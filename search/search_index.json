{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"\u9996\u9875"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"GLES/Framebuffer%20Object/","text":"GLES Framebuffers learnopengl \u66f4\u591a\u7528\u4f8b: \u6cdb\u5149 \u591a\u6e32\u67d3\u76ee\u6807(Multiple Render Targets) \u4e0e \u5ef6\u8fdf\u7740\u8272\u6cd5 \u5b9a\u4e49 \u901a\u5e38\u6211\u4eec\u7684\u64cd\u4f5c\u90fd\u662f\u5728 \u9ed8\u8ba4 \u5e27\u7f13\u51b2 (Default Framebuffer ) \u7684\u6e32\u67d3\u7f13\u51b2\u4e0a\u8fdb\u884c\u7684\u3002\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u662f\u5728\u4f60\u521b\u5efa\u7a97\u53e3\u7684\u65f6\u5019\u751f\u6210\u548c\u914d\u7f6e\u7684\uff08EGL\uff09\u3002 \u5728GL\u4e2d\u4f1a\u4f7f\u7528\u51e0\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u5c4f\u5e55\u7f13\u51b2\uff1a\u7528\u4e8e\u5199\u5165\u989c\u8272\u503c\u7684 \u989c\u8272\u7f13\u51b2 \uff0c\u7528\u4e8e\u5199\u5165\u6df1\u5ea6\u4fe1\u606f\u7684 \u6df1\u5ea6\u7f13\u51b2 \uff0c\u4ee5\u53ca\u5141\u8bb8\u6211\u4eec\u57fa\u4e8e\u4e00\u4e9b\u6761\u4ef6\u4e22\u5f03\u6307\u5b9a\u7247\u6bb5\u7684 \u6a21\u677f\u7f13\u51b2 \u3002\u628a\u8fd9\u51e0\u79cd\u7f13\u51b2\u7ed3\u5408\u8d77\u6765\u53eb\u505a\u5e27\u7f13\u51b2(Framebuffer)\u3002 \u800c\u4f7f\u7528 \u5e27\u7f13\u51b2\u5bf9\u8c61 (Framebuffer Object) \u5141\u8bb8\u7528\u6237 \u81ea\u5b9a\u4e49\u5e27\u7f13\u51b2 \uff0cFramebuffer \u5b9e\u9645\u662f\u4e00\u4e2a\u53ef\u6dfb\u52a0 \u7f13\u51b2\u7684\u5bb9\u5668 . \u7528\u6237\u53ef\u4ee5\u4e3a\u5176\u6dfb\u52a0 \u7eb9\u7406 (Textures ) \u6216 \u6e32\u67d3\u7f13\u51b2\u533a \u5bf9\u8c61\uff08Renderbuffer), \u6765\u5b9a\u4e49\u81ea\u5df1\u7684\u989c\u8272\u7f13\u51b2\uff0c\u6df1\u5ea6\u7f13\u51b2, \u548c\u6a21\u677f\u7f13\u51b2\u3002 \u5e94\u7528 \u6e32\u67d3\u5230\u4e00\u4e2a\u975e\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u88ab\u53eb\u505a \u79bb\u5c4f\u6e32\u67d3 (Off-screen Rendering) \u6216 \u6e32\u67d3\u5230\u7eb9\u7406 (Render to Texture)\u3002 \u901a\u8fc7\u81ea\u5b9a\u4e49\u5e27\u7f13\u51b2\u53ef\u4ee5\u5c06\u4f60\u7684\u573a\u666f\u6e32\u67d3\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u4e2d, \u53ef\u4ee5\u4f7f\u6211\u4eec\u80fd\u591f\u5728\u5f53\u524d\u573a\u666f\u4e2d\u521b\u5efa \u955c\u5b50, \u5012\u5f71 \u8fd9\u6837\u7684\u6548\u679c. \u8fd8\u6709\u5f88\u591a\u5e38\u89c1\u7279\u6548\u9700\u8981\u7528\u5230\u5e27\u7f13\u51b2, \u4f8b\u5982: \u9634\u5f71\u8d34\u56fe, \u52a8\u6001\u53cd\u5c04\u548c\u73af\u5883\u8d34\u56fe, \u591a\u9053\u666f\u6df1\u6280\u672f, \u52a8\u6001\u6a21\u7cca, \u548c\u540e\u671f\u5904\u7406\u7279\u6548\u7b49. \u76f8\u5173\u5b9a\u4e49 \u9ed8\u8ba4\u5e27\u7f13\u51b2 Default Framebuffers \u5728\u8fdb\u884cGLES\u6307\u4ee4\u64cd\u4f5c\u524d, \u9700\u8981\u521b\u5efa\u4e00\u4e2a Context \u548c \u7ed8\u56fe\u8868\u9762 (\u9ed8\u8ba4 Framebuffer), \u8fd9\u901a\u5e38\u7531\u539f\u751f\u7a97\u53e3\u7cfb\u7edf\u901a\u8fc7 EGL \u7b49\u5b8c\u6210. \u521b\u5efa EGL \u7ed8\u5236\u8868\u9762\u7684\u8c03\u7528\u65f6, \u4ee5\u50cf\u7d20\u5f62\u5f0f\u6307\u5b9a \u5bbd\u5ea6,\u9ad8\u5ea6, \u662f\u5426\u4f7f\u7528 \u989c\u8272\u7f13\u51b2, \u6df1\u5ea6\u7f13\u51b2, \u6a21\u677f\u7f13\u51b2, \u53ca\u8fd9\u4e9b\u7f13\u51b2\u533a\u7684\u4f4d\u6df1. \u4e0d\u80fd\u5bf9\u5176\u8fdb\u884c\u4fee\u6539\u6216\u67e5\u8be2\u72b6\u6001\u64cd\u4f5c glViewport \u63a7\u5236\u5e27\u7f13\u51b2\u7684\u5927\u5c0f, \u4ee5\u53ca\u63a7\u5236\u9634\u5f71\u6df1\u5ea6\u8d34\u56fe\u5927\u5c0f\u7b49\u7b49 \u5e27\u7f13\u51b2\u5bf9\u8c61 Framebuffers Objects (FBOs) \u9644\u7740 Attachment FBO \u4ec5\u88ab\u89c6\u4e3a\u7f13\u5b58\u7684\u5bb9\u5668, \u56e0\u6b64\u4f7f\u7528 FBO \u4f5c\u4e3a\u6e32\u67d3\u76ee\u6807\u65f6\uff0c\u9996\u5148\u9700\u8981\u4e3a FBO \u7684\u9644\u7740\u8fde\u63a5\u5bf9\u8c61\uff0c \u9644\u7740\u662f\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\uff0c\u5b83\u80fd\u591f\u4f5c\u4e3a\u5e27\u7f13\u51b2\u7684\u4e00\u4e2a\u7f13\u51b2\uff0c\u53ef\u4ee5\u5c06\u5b83\u60f3\u8c61\u4e3a\u4e00\u4e2a\u56fe\u50cf\u3002 \u521b\u5efa\u4e00\u4e2a\u9644\u4ef6\u65b9\u5f0f\u6709\u4e24\u79cd\uff1a \u7eb9\u7406 \u6216 \u6e32\u67d3\u7f13\u51b2 \u5bf9\u8c61(Renderbuffer)\u3002 \u5e27\u7f13\u51b2\u76843\u4e2a\u9644\u7740 \u989c\u8272\u9644\u7740 Color Attachment \u6df1\u5ea6\u9644\u7740 Depth Attachment \u6a21\u677f\u9644\u7740 Stencil Attachment \u7eb9\u7406\u9644\u4ef6 Textures \u5373\u666e\u901a\u7684 Texture, \u6839\u636e Format\u7684\u4e0d\u540c, \u53ef\u4ee5\u5206\u522b\u7528\u4f5c FBO \u4e2d\u7684\u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u9644\u7740\u3002 \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 Renderbuffer Objects \u662f\u4e00\u4e2a\u7531\u5e94\u7528\u7a0b\u5e8f\u5206\u914d\u7684 2D \u56fe\u50cf\u7f13\u51b2\u533a\u3002 \u6e32\u67d3\u7f13\u51b2\u533a\u53ef\u4ee5\u7528\u4e8e\u5206\u914d\u548c\u5b58\u50a8 \u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u503c\uff0c\u53ef\u4ee5\u7528\u4f5c FBO \u4e2d\u7684\u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u9644\u7740\u3002 \u4f7f\u7528 \u7eb9\u7406 \u548c Renderbuffer \u5bf9\u8c61, \u90fd\u652f\u6301\u4e3a FBO \u5206\u522b\u6dfb\u52a0\u4e09\u79cd\u9644\u7740. \u4f46\u901a\u5e38\u4f7f\u7528 Texture \u6dfb\u52a0\u989c\u8272\u9644\u7740, \u7528 Renderbuffer \u6765\u6dfb\u52a0\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740. \u539f\u56e0\u5728\u540e\u9762\u8ba8\u8bba. (OpenGL ES 3.0 \u7f16\u7a0b\u6307\u5357) \u4f7f\u7528\u6d41\u7a0b APP --> GLES : glGenFramebuffers(1, &fbo); glBindFramebuffer(GL_FRAMEBUFFER, fbo); glBindFramebuffer(GL_FRAMEBUFFER, 0); \u521b\u5efa\u5e27\u7f13\u51b2 \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61 glGenFramebuffers(1, &fbo); \u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684(Active)\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, fbo); \u5728\u7ed1\u5b9a\u5230GL_FRAMEBUFFER\u76ee\u6807\u4e4b\u540e\uff0c\u6240\u6709\u7684 \u8bfb\u53d6 \u548c \u5199\u5165 \u5e27\u7f13\u51b2\u7684\u64cd\u4f5c\u5c06\u4f1a\u5f71\u54cd\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u3002 \u6211\u4eec\u4e5f\u53ef\u4ee5\u4f7f\u7528 GL_READ_FRAMEBUFFER \u6216 GL_DRAW_FRAMEBUFFER \uff0c\u5c06\u4e00\u4e2a\u5e27\u7f13\u51b2\u5206\u522b\u7ed1\u5b9a\u5230\u8bfb\u53d6\u76ee\u6807\u6216\u5199\u5165\u76ee\u6807\u3002 \u7ed1\u5b9a\u5230 GL_READ_FRAMEBUFFER \u7684\u5e27\u7f13\u51b2\u5c06\u4f1a\u4f7f\u7528\u5728\u6240\u6709\u50cf\u662f glReadPixels \u7684\u8bfb\u53d6\u64cd\u4f5c\u4e2d\uff0c \u7ed1\u5b9a\u5230 GL_DRAW_FRAMEBUFFER \u7684\u5e27\u7f13\u51b2\u5c06\u4f1a\u88ab\u7528\u4f5c\u6e32\u67d3\u3001\u6e05\u9664\u7b49\u5199\u5165\u64cd\u4f5c\u7684\u76ee\u6807\u3002 \u901a\u5e38\u90fd \u4e0d\u9700\u8981\u533a\u5206 \u5b83\u4eec\uff0c\u4f7f\u7528 GL_FRAMEBUFFER \uff0c\u7ed1\u5b9a\u5230\u4e24\u4e2a\u4e0a\u3002 \u6dfb\u52a0\u9644\u7740: \u5728\u8fd9\u4e00\u9636\u6bb5, \u4f7f\u7528Texture\u6216Renderbuffer\u5bf9FBO\u6dfb\u52a0\u9644\u7740, \u4ee3\u7801\u5728\u4e0b\u4e24\u8282\u79cd\u5c55\u793a. \u6dfb\u52a0\u9644\u7740\u540e, \u68c0\u67e5\u5e27\u7f13\u51b2\u7684\u5b8c\u6574\u6027 if( glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE) \u4e00\u4e2a\u5b8c\u6574\u7684\u5e27\u7f13\u51b2\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u7684\u6761\u4ef6\uff1a \u9644\u52a0\u81f3\u5c11\u4e00\u4e2a\u9644\u7740\uff08\u989c\u8272\u3001\u6df1\u5ea6\u6216\u6a21\u677f\u9644\u7740\uff09\u3002 \u81f3\u5c11\u6709\u4e00\u4e2a\u989c\u8272\u9644\u4ef6(Attachment)\u3002TODO: check angle \u6240\u6709\u7684\u9644\u4ef6\u90fd\u5fc5\u987b\u662f\u5b8c\u6574\u7684\uff08\u4fdd\u7559\u4e86\u5185\u5b58\uff09\u3002 \u6bcf\u4e2a\u7f13\u51b2\u90fd\u5e94\u8be5\u6709\u76f8\u540c\u7684\u9ad8\u5ea6\u548c\u5bbd\u5ea6\u3002 \u5982\u679c\u5b58\u5728\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740, \u5b83\u4eec\u5fc5\u987b\u662f\u76f8\u540c\u7684\u56fe\u50cf. \u6240\u6709\u9644\u7740\u7684 GL_RENDERBUFFER_SAMPLES \u6837\u672c\u503c\u76f8\u540c. \u82e5\u9644\u7740\u5bf9\u8c61\u662f\u7eb9\u7406, \u5219\u6b64\u503c\u4e3a0. \u89e3\u7ed1FBO / \u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u6e32\u67d3\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u88ab\u53eb\u505a \u79bb\u5c4f\u6e32\u67d3 (Off-screen Rendering)\u3002\u8981\u4fdd\u8bc1\u6240\u6709\u7684\u6e32\u67d3\u64cd\u4f5c\u5728\u4e3b\u7a97\u53e3\u4e2d\u6709\u89c6\u89c9\u6548\u679c\uff0c\u6211\u4eec\u9700\u8981\u518d\u6b21\u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2\uff0c\u5c06\u5b83\u7ed1\u5b9a\u5230 0 \u3002 \u7eb9\u7406\u9644\u7740 \u666e\u901a\u7684\u521b\u5efa\u7eb9\u7406\u7684\u65b9\u5f0f unsigned int texture; glGenTextures(1, &texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); \u5982\u679c\u4f60\u60f3\u5c06\u4f60\u7684\u5c4f\u5e55\u6e32\u67d3\u5230\u4e00\u4e2a\u66f4\u5c0f\u6216\u66f4\u5927\u7684\u7eb9\u7406\u4e0a\uff0c\u4f60\u9700\u8981\uff08\u5728\u6e32\u67d3\u5230\u4f60\u7684\u5e27\u7f13\u51b2\u4e4b\u524d\uff09\u518d\u6b21\u8c03\u7528glViewport\uff0c\u4f7f\u7528\u7eb9\u7406\u7684\u65b0\u7ef4\u5ea6\u4f5c\u4e3a\u53c2\u6570\uff0c\u5426\u5219\u53ea\u6709\u4e00\u5c0f\u90e8\u5206\u7684\u7eb9\u7406\u6216\u5c4f\u5e55\u4f1a\u88ab\u6e32\u67d3\u5230\u8fd9\u4e2a\u7eb9\u7406\u4e0a\u3002 TODO: \u4ec0\u4e48\u610f\u601d? \u5c06\u7eb9\u7406\u9644\u52a0\u5728\u5e27\u7f13\u51b2\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); target \uff1a\u5e27\u7f13\u51b2\u7684\u76ee\u6807\uff08\u7ed8\u5236\u3001\u8bfb\u53d6\u6216\u8005\u4e24\u8005\u7686\u6709\uff09 attachment \uff1a\u6211\u4eec\u60f3\u8981\u9644\u52a0\u7684\u9644\u4ef6\u7c7b\u578b\u3002\u5f53\u524d\u6211\u4eec\u6b63\u5728\u9644\u52a0\u4e00\u4e2a \u989c\u8272\u9644\u4ef6 \u3002\u6ce8\u610f\u6700\u540e\u7684 0 \u610f\u5473\u7740\u53ef\u4ee5\u9644\u52a0\u591a\u4e2a\u989c\u8272\u9644\u4ef6\u3002 GL_COLOR_ATTACHMENT i , GL_DEPTH_ATTACHMENT , GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMENT . textarget \uff1a\u4f60\u5e0c\u671b\u9644\u52a0\u7684\u7eb9\u7406\u7c7b\u578b texture \uff1a\u8981\u9644\u52a0\u7684\u7eb9\u7406\u672c\u8eab level \uff1a\u591a\u7ea7\u6e10\u8fdc\u7eb9\u7406\u7684\u7ea7\u522b\u3002\u6211\u4eec\u5c06\u5b83\u4fdd\u7559\u4e3a0 \u7eb9\u7406\u5bf9\u8c61\u5141\u8bb8\u9644\u52a0\u4e00\u4e2a\u6df1\u5ea6\u6216\u6a21\u677f\u7f13\u51b2\u7eb9\u7406\u5230\u5e27\u7f13\u51b2\u5bf9\u8c61\u4e2d\u3002 \u8981\u9644\u52a0\u6df1\u5ea6\u7f13\u51b2\u7684\u8bdd\uff0c\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e\u4e3a GL_DEPTH_ATTACHMENT \u3002\u5e76\u5c06\u7eb9\u7406\u7684\u683c\u5f0f(Format)\u548c\u5185\u90e8\u683c\u5f0f(Internalformat)\u7c7b\u578b\u53d8\u4e3a GL_DEPTH_COMPONENT \uff0c\u6765\u53cd\u6620\u6df1\u5ea6\u7f13\u51b2\u7684\u50a8\u5b58\u683c\u5f0f\u3002 \u8981\u9644\u52a0\u6a21\u677f\u7f13\u51b2\u7684\u8bdd\uff0c\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e\u4e3a GL_STENCIL_ATTACHMENT \uff0c\u5e76\u5c06\u7eb9\u7406\u7684\u683c\u5f0f\u8bbe\u5b9a\u4e3a GL_STENCIL_INDEX \u3002 \u4e5f\u53ef\u4ee5\u5c06\u6df1\u5ea6\u7f13\u51b2\u548c\u6a21\u677f\u7f13\u51b2\u5408\u5e76\u9644\u52a0\u4e3a\u4e00\u4e2a\u7eb9\u7406\u3002\u7eb9\u7406\u7684\u6bcf32\u4f4d\u6570\u503c\u5c06\u5305\u542b24\u4f4d\u7684\u6df1\u5ea6\u4fe1\u606f\u548c8\u4f4d\u7684\u6a21\u677f\u4fe1\u606f\u3002\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e GL_DEPTH_STENCIL_ATTACHMENT \u7c7b\u578b\uff0c\u5e76\u914d\u7f6e\u7eb9\u7406\u7684\u683c\u5f0f\uff0c\u8ba9\u5b83\u5305\u542b\u5408\u5e76\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u503c\u3002 ``` glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL ); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0); ``` Renderbuffer \u9644\u7740 \u521b\u5efa\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u7684\u4ee3\u7801 glGenRenderbuffers(1, &rbo); \u7ed1\u5b9a\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\uff0c\u8ba9\u4e4b\u540e\u6240\u6709\u7684\u6e32\u67d3\u7f13\u51b2\u64cd\u4f5c\u5f71\u54cd\u5f53\u524d\u7684 RBO\uff1a glBindRenderbuffer(GL_RENDERBUFFER, rbo); \u521b\u5efa\u4e00\u4e2a\u6df1\u5ea6\u548c\u6a21\u677f\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); \u521b\u5efa\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u548c\u7eb9\u7406\u5bf9\u8c61\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u662f\u8fd9\u4e2a\u5bf9\u8c61\u662f\u4e13\u95e8\u88ab\u8bbe\u8ba1\u4f5c\u4e3a\u56fe\u50cf\u4f7f\u7528\u7684\uff0c\u800c\u4e0d\u662f\u7eb9\u7406\u90a3\u6837\u7684\u901a\u7528\u6570\u636e\u7f13\u51b2(General Purpose Data Buffer)\u3002 \u8fd9\u91cc\u6211\u4eec\u9009\u62e9 GL_DEPTH24_STENCIL8 \u4f5c\u4e3a\u5185\u90e8\u683c\u5f0f\uff0c\u5b83\u5c01\u88c5\u4e8624\u4f4d\u7684\u6df1\u5ea6\u548c8\u4f4d\u7684\u6a21\u677f\u7f13\u51b2\u3002 \u9644\u52a0\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5230 FBO\uff1a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); \u4f7f\u7528 GL_DEPTH_STENCIL_ATTACHMENT \u8868\u793a\u540c\u65f6\u5305\u542b\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740 Texture VS. Renderbuffer \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61(Renderbuffer Object) \u662f\u5728\u7eb9\u7406\u4e4b\u540e\u5f15\u5165\u5230OpenGL\u4e2d\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u53ef\u7528\u7684\u5e27\u7f13\u51b2\u9644\u4ef6\u7c7b\u578b\u7684\uff0c\u6240\u4ee5\u5728\u8fc7\u53bb\u7eb9\u7406\u662f\u552f\u4e00\u53ef\u7528\u7684\u9644\u4ef6\u3002 Renderbuffer : \u548c\u7eb9\u7406\u56fe\u50cf\u4e00\u6837\uff0c\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u662f\u4e00\u4e2a\u771f\u6b63\u7684\u7f13\u51b2\uff0c\u5373\u4e00\u7cfb\u5217\u7684\u5b57\u8282\u3001\u6574\u6570\u3001\u50cf\u7d20\u7b49\u3002 \u4f18\u70b9: Renderbuffer \u4f1a\u5c06\u6570\u636e\u50a8\u5b58\u4e3aOpenGL\u539f\u751f\u7684\u6e32\u67d3\u683c\u5f0f\uff0c\u5b83\u662f\u4e3a\u79bb\u5c4f\u6e32\u67d3\u5230\u5e27\u7f13\u51b2\u4f18\u5316\u8fc7\u7684\u3002 Renderbuffer \u76f4\u63a5\u5c06\u6240\u6709\u7684\u6e32\u67d3\u6570\u636e\u50a8\u5b58\u5230\u5b83\u7684\u7f13\u51b2\u4e2d\uff0c\u4e0d\u4f1a\u505a\u4efb\u4f55\u9488\u5bf9\u7eb9\u7406\u683c\u5f0f\u7684\u8f6c\u6362\uff0c\u8ba9\u5b83\u53d8\u4e3a\u4e00\u4e2a\u66f4\u5feb\u7684\u53ef\u5199\u50a8\u5b58\u4ecb\u8d28\u3002 \u7f3a\u70b9: Renderbuffer \u4e0d\u80fd\u505a\u7eb9\u7406: \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u901a\u5e38\u90fd\u662f \u53ea\u5199 \u7684\uff0c\u6240\u4ee5\u4f60\u4e0d\u80fd\u8bfb\u53d6\u5b83\u4eec, \u6bd4\u5982\u4f7f\u7528\u7eb9\u7406\u8bbf\u95ee\u3002 \u5f53\u7136\u4f60\u4ecd\u7136\u8fd8\u662f\u80fd\u591f\u4f7f\u7528 glReadPixels \u6765\u8bfb\u53d6\u5b83\uff0c\u8fd9\u4f1a\u4ece\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2(\u800c\u4e0d\u662f\u9644\u4ef6\u672c\u8eab)\u4e2d\u8fd4\u56de\u7279\u5b9a\u533a\u57df\u7684\u50cf\u7d20\u3002 \u56e0\u6b64\u901a\u5e38\u7684\u89c4\u5219\u662f: \u5982\u679c\u4f60 \u4e0d\u9700\u8981\u4ece\u4e00\u4e2a\u7f13\u51b2\u4e2d\u91c7\u6837 \u6570\u636e\uff0c\u90a3\u4e48\u5bf9\u8fd9\u4e2a\u7f13\u51b2\u4f7f\u7528 \u6e32\u67d3\u7f13\u51b2 \u5bf9\u8c61\u4f1a\u662f\u660e\u667a\u7684\u9009\u62e9\u3002 \u800c\u5982\u679c\u4f60 \u9700\u8981\u4ece\u7f13\u51b2\u4e2d\u91c7\u6837\u989c\u8272\u6216\u6df1\u5ea6 \u503c\u7b49\u6570\u636e\uff0c\u90a3\u4e48\u4f60\u5e94\u8be5\u9009\u62e9 \u7eb9\u7406 \u9644\u4ef6\u3002\u6027\u80fd\u65b9\u9762\u5b83\u4e0d\u4f1a\u4ea7\u751f\u975e\u5e38\u5927\u7684\u5f71\u54cd\u7684\u3002 \u56e0\u6b64 Renderbuffer \u5bf9\u8c61\u901a\u5e38\u7528\u4e8e \u6df1\u5ea6\u548c\u6a21\u677f \u9644\u4ef6\uff0c\u56e0\u4e3a\u5927\u90e8\u5206\u65f6\u95f4\u6211\u4eec\u90fd\u4e0d\u9700\u8981\u4ece\u6df1\u5ea6\u548c\u6a21\u677f\u7f13\u51b2\u4e2d\u8bfb\u53d6\u503c\uff0c\u53ea\u5173\u5fc3\u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5, \u4f46\u4e0d\u9700\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u91c7\u6837. \u5bf9\u5e94\u5230\u573a\u666f\u4e2d: \u9009\u62e9 Texture \u6e32\u67d3\u5230\u4e00\u4e2a\u7528\u4f5c\u989c\u8272\u7eb9\u7406\u7684\u989c\u8272\u7f13\u51b2\u533a \u6e32\u67d3\u5230\u4e00\u4e2a\u7528\u4f5c\u9634\u5f71\u7684\u6df1\u5ea6\u7eb9\u7406\u7684\u6df1\u5ea6\u7f13\u51b2\u533a \u9009\u62e9 Renderbuffer \u591a\u91cd\u91c7\u6837 \u5982\u679c\u56fe\u50cf\u4e0d\u88ab\u4f5c\u4e3a\u7eb9\u7406, \u5219 Renderbuffer \u53ef\u80fd\u5e26\u6765\u6027\u80fd\u4f18\u52bf: GLES \u53ef\u80fd\u4ee5\u66f4\u9ad8\u6548\u7684\u683c\u5f0f\u5b58\u50a8 Renderbuffer, \u6bd4\u7eb9\u7406\u66f4\u9002\u5408\u6e32\u67d3 \u4f8b\u5982: \u5229\u7528\u5176\u5199\u5165\u6216\u8005\u590d\u5236\u5230\u5176\u5b83\u7f13\u51b2\u5feb\u7684\u7279\u70b9\u3002 \u4ea4\u6362\u7f13\u51b2 \u8fd9\u6837\u7684\u64cd\u4f5c\u5728\u4f7f\u7528\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u65f6\u4f1a\u975e\u5e38\u5feb\u3002 \u5728\u6bcf\u4e2a\u6e32\u67d3\u8fed\u4ee3\u6700\u540e\u4f7f\u7528\u7684 glfwSwapBuffers \uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5b9e\u73b0\uff1a\u53ea\u9700\u8981\u5199\u5165\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u56fe\u50cf\uff0c\u5e76\u5728\u6700\u540e\u4ea4\u6362\u5230\u53e6\u5916\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5c31\u53ef\u4ee5\u4e86\u3002 \u793a\u4f8b: \u573a\u666f\u6ee4\u955c \u521b\u5efa\u9636\u6bb5 // \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61\uff0c\u5e76\u7ed1\u5b9a unsigned int framebuffer; glGenFramebuffers(1, &framebuffer); glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); // \u4f7f\u7528 Texture \u6dfb\u52a0\u989c\u8272\u9644\u7740 // \u751f\u6210\u7eb9\u7406 unsigned int texColorBuffer; glGenTextures(1, &texColorBuffer); glBindTexture(GL_TEXTURE_2D, texColorBuffer); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glBindTexture(GL_TEXTURE_2D, 0); // \u5c06\u7eb9\u7406\u5bf9\u8c61, \u9644\u52a0\u5230\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u5bf9\u8c61\u989c\u8272(color)\u9644\u4ef6\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, 0); // \u4f7f\u7528 Renderbuffer \u6dfb\u52a0\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740 // \u6df1\u5ea6\uff08\u548c\u6a21\u677f\uff09\u6d4b\u8bd5 // \u6dfb\u52a0\u4e00\u4e2a\u6df1\u5ea6\uff08\u548c\u6a21\u677f\uff09\u9644\u4ef6\u5230\u5e27\u7f13\u51b2\u4e2d unsigned int rbo; glGenRenderbuffers(1, &rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); // GL_DEPTH24_STENCIL8 glBindRenderbuffer(GL_RENDERBUFFER, 0); // \u5c06\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61, \u9644\u52a0\u5230\u5230\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u7684 depth \u548c stencil \u9644\u4ef6\u4e0a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); // \u68c0\u67e5\u5e27\u7f13\u51b2\u662f\u5426\u662f\u5b8c\u6574\u7684 if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) std::cout << \"ERROR::FRAMEBUFFER:: Framebuffer is not complete!\" << std::endl; // \u89e3\u7ed1\u5e27\u7f13\u51b2/\u7ed1\u5b9a\u56de\u9ed8\u8ba4 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u7ed8\u5236\u9636\u6bb5 \u8981\u60f3\u7ed8\u5236\u573a\u666f\u5230\u4e00\u4e2a\u7eb9\u7406\u4e0a\uff0c\u6211\u4eec\u9700\u8981\u91c7\u53d6\u4ee5\u4e0b\u7684\u6b65\u9aa4\uff1a \u5c06\u65b0\u7684\u5e27\u7f13\u51b2\u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684\u5e27\u7f13\u51b2 \u548c\u5f80\u5e38\u4e00\u6837\u6e32\u67d3\u573a\u666f \u6b64\u65f6\u573a\u666f\u4f1a\u6e32\u67d3\u5230\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2, \u800c\u4e0d\u662f\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u3002 \u6240\u6709\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u64cd\u4f5c\u90fd\u4f1a\u4ece\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u4ef6\u4e2d\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u8bfb\u53d6\u3002 \u7ed1\u5b9a\u56de\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2 \u7ed8\u5236\u4e00\u4e2a\u6574\u5c4f\u5e55\u7684\u56db\u8fb9\u5f62\uff0c\u7136\u540e\u5c06\u5e27\u7f13\u51b2\u7684\u989c\u8272\u7f13\u51b2\u4f5c\u4e3a\u56db\u8fb9\u5f62\u7684\u7eb9\u7406\u3002 // \u7b2c\u4e00\u5904\u7406\u9636\u6bb5: \u7ed8\u5236\u5230FBO glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // \u6211\u4eec\u73b0\u5728\u4e0d\u4f7f\u7528\u6a21\u677f\u7f13\u51b2 glEnable(GL_DEPTH_TEST); DrawScene(); // \u7ed8\u5236\u539f\u59cb 3D \u573a\u666f // Load VAO, bind Textures, uniform data, call glDrawArrays or glDrawElements // \u7b2c\u4e8c\u5904\u7406\u9636\u6bb5: \u7ed8\u5236\u5230\u5c4f\u5e55 glBindFramebuffer(GL_FRAMEBUFFER, 0); // \u8fd4\u56de\u9ed8\u8ba4 glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); screenShader.use(); // \u4f7f\u7528\u53e6\u4e00\u5957 shader glBindVertexArray(quadVAO); // \u7ed8\u5236\u4e00\u4e2a\u56db\u8fb9\u5f62 glDisable(GL_DEPTH_TEST); glBindTexture(GL_TEXTURE_2D, textureColorbuffer); // \u5c06 Color Buffer \u4f5c\u4e3a\u7eb9\u7406\u7ed8\u5236\u5230\u56db\u8fb9\u5f62\u4e0a glDrawArrays(GL_TRIANGLES, 0, 6); \u5982\u679c screenShader \u4e0d\u505a\u7279\u6b8a\u5904\u7406, \u6b64\u65f6\u753b\u9762\u4f1a\u548c DrawScene \u7ed8\u5236\u7684\u539f\u59cb3D\u573a\u666f\u4e00\u81f4. \u6b64\u65f6\u7ed8\u5236\u7684\u56db\u8fb9\u5f62\u7c7b\u4f3c\u4e00\u4e2a\u663e\u793a\u5c4f\u5e55, \u5229\u7528\u8d34\u56fe\u663e\u793a\u539f\u59cb\u573a\u666f. \u4f46\u5982\u679c\u5bf9 screenShader \u4e2d\u7eb9\u7406\u7684color\u8fdb\u884c\u4fee\u6539, \u5c31\u53ef\u7528\u5b9e\u73b0\u6ee4\u955c\u6548\u679c. void main() { // \u53cd\u767d\u7279\u6548 FragColor = vec4(vec3(1.0 - texture(screenTexture, TexCoords)), 1.0); } \u753b\u9762\u6548\u679c\u548c\u66f4\u591a\u7279\u6548\u5904\u7406, \u53c2\u89c1 LearnOpenGL (English version: LearnOpenGL ) \u79bb\u5c4fMSAA \u79bb\u5c4fMSAA \u5728\u9ed8\u8ba4\u5e27\u7f13\u51b2\u4e2d\u542f\u7528MASS, \u53ea\u9700\u8981 glEnable(GL_MULTISAMPLE); \u542f\u7528\u5373\u53ef. \u4f46\u5bf9\u4e8e\u79bb\u5c4f\u6e32\u67d3, \u9700\u8981\u624b\u52a8\u521b\u5efa\u591a\u91cd\u91c7\u6837\u7684\u9644\u7740. Texture: \u521b\u5efaMS Texture: \u4f7f\u7528 glTexImage2DMultisample \u6765\u66ff\u4ee3 glTexImage2D glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex); glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE); glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0); \u9644\u52a0\u5230\u5e27\u7f13\u51b2: \u4f7f\u7528 glFramebufferTexture2D \u5c06\u591a\u91cd\u91c7\u6837\u7eb9\u7406\u4e0a\uff0c\u4f46\u8fd9\u91cc\u7eb9\u7406\u7c7b\u578b\u4f7f\u7528\u7684\u662f GL_TEXTURE_2D_MULTISAMPLE \u3002 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0); Renderbuffer : \u521b\u5efa\u8fc7\u7a0b\u4e0d\u53d8 \u9644\u52a0\u5230\u5e27\u7f13\u51b2: \u5c06 glRenderbufferStorage \u7684\u8c03\u7528\u6539\u4e3a glRenderbufferStorageMultisample \u5c31\u53ef\u4ee5\u4e86 glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, width, height); \u7b2c\u4e8c\u53c2\u6570 4 \u4e3a\u91c7\u6837\u6b21\u6570 \u7ed8\u5236: void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); \u5c06\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u7684\u50cf\u7d20\u503c, \u4ece\u4e00\u4e2a\u5e27\u7f13\u51b2\u590d\u5236\u5230\u53e6\u4e00\u4e2a\u5e27\u7f13\u51b2. \u901a\u8fc7 glBlitFramebuffer \u5c06\u591a\u91cd\u91c7\u6837\u7684\u5e27\u7f13\u51b2, \u590d\u5236\u5230\u4e00\u4e2a\u4e2d\u4ecb\u5e27\u7f13\u51b2\u7684\u989c\u8272\u9644\u7740\u7684\u7eb9\u7406, \u5b9e\u73b0\u591a\u91cd\u91c7\u6837. glBindFramebuffer(multisampledFBO); ClearFrameBuffer(); DrawScene(); // \u5c06\u591a\u91cd\u91c7\u6837\u7f13\u51b2\u8fd8\u539f\u5230\u4e2d\u4ecbFBO\u4e0a glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO); glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO); glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST); // \u73b0\u5728\u573a\u666f\u662f\u4e00\u4e2a2D\u7eb9\u7406\u7f13\u51b2\uff0c\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u56fe\u50cf\u7528\u6765\u540e\u671f\u5904\u7406 glBindFramebuffer(GL_FRAMEBUFFER, 0); ClearFramebuffer(); glBindTexture(GL_TEXTURE_2D, screenTexture); DrawPostProcessingQuad(); Framebuffer \u76f8\u5173 API \u6c47\u603b API ES Ver. Notes void glGenFramebuffers ( sizei n, uint *framebuffers ); 2 void glBindFramebuffer ( enum target, uint framebuffer ); 2 void glGenRenderbuffers ( sizei n, uint *renderbuffers ); 2 void glBindRenderbuffer ( enum target, uint renderbuffer ); 2 void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); 2 \u521b\u5efa\u4e00\u4e2a Renderbuffer internalformat : \u6307\u5b9a\u7f13\u51b2\u683c\u5f0f: depth \u548c stencil GL_DEPTH24_STENCIL8; GL_DEPTH32F_STENCIL8 GL_DEPTH_COMPONENT16 GL_DEPTH_COMPONENT24 GL_DEPTH_COMPONENT32F GL_STENCIL_INDEX8 void glRenderbufferStorageMultisample ( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); 3.0 \u521b\u5efa\u4e00\u4e2a\u591a\u91cd\u91c7\u6837 Renderbuffer, \u4e0eglRenderbufferStorage\u7684\u533a\u522b\u4ec5\u4e3a\u540e\u8005samples=0 GLenum glCheckFramebufferStatus (GLenum target); \u68c0\u67e5fbo\u5b8c\u6574\u6027 void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); \u5c06\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u7684\u50cf\u7d20\u503c, \u4ece\u4e00\u4e2afb\u590d\u5236\u5230\u53e6\u4e00\u4e2afb. \u5e94\u7528\u4e3e\u4f8b: 1. \u590d\u5236\u591a\u4e2a\u7eb9\u7406\u5230\u5c4f\u5e55 2. \u5c06\u591a\u91cd\u91c7\u6837\u6e32\u67d3\u89e3\u6790\u4e3a\u4e00\u4e2a\u7eb9\u7406 \u7ed1\u5b9a void glFramebufferRenderbuffer ( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); 2 void glFramebufferTexture ( GLenum target, GLenum attachment, GLuint texture, GLint level); 3.2 void glFramebufferTexture2D ( enum target, enum attachment, enum textarget, uint texture, int level ); 2.0 void glFramebufferTextureLayer ( enum target, enum attachment, uint texture, int level, int layer ); 3.0 \u7ed1\u5b9a 3D Texture \u65e0\u6548\u5316/\u5220\u9664 void glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments); 3.0 \u901a\u77e5\u9a71\u52a8\u4e0d\u518d\u9700\u8981fb\u5185\u5bb9. \u4f7f\u9a71\u52a8\u53ef\u7528\u8fdb\u884c\u4f18\u5316: \u5982\u8df3\u8fc7TBR\u67b6\u6784\u4e2d\u4e0d\u5fc5\u8981\u7684\u56fe\u5757\u5185\u5bb9\u6062\u590d \u8df3\u8fc7\u5b9e\u73b0\u4e2d\u4e3a\u6539\u8fdb\u6027\u80fd\u800c\u505a\u7684\u7f13\u5b58\u5237\u65b0 void glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height); 3.0 void glDeleteRenderbuffers (GLsizei n, const GLuint *renderbuffers); 2 void glDeleteFramebuffers (GLsizei n, const GLuint *framebuffers); 2 \u5176\u4ed6 void glFramebufferParameteri (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params); boolean IsRenderbuffer ( uint renderbuffer ); boolean IsFramebuffer ( uint framebuffer ); \u5176\u4ed6\u9488\u5bf9\u8bfb\u5e27\u7f13\u51b2\u7684\u547d\u4ee4: ReadPixels, CopyTexImage , and CopyTexSubImage , gl2 void glBindFramebuffer (GLenum target, GLuint framebuffer); GLenum glCheckFramebufferStatus (GLenum target); void glDeleteFramebuffers (GLsizei n, const GLuint framebuffers); void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); void glFramebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); void glGenFramebuffers (GLsizei n, GLuint framebuffers); void glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, GLint *params); GLboolean glIsFramebuffer (GLuint framebuffer); void glBindRenderbuffer (GLenum target, GLuint renderbuffer); void glDeleteRenderbuffers (GLsizei n, const GLuint renderbuffers); void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); void glGenRenderbuffers (GLsizei n, GLuint renderbuffers); void glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint *params); GLboolean glIsRenderbuffer (GLuint renderbuffer); void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); gl3 void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); void glFramebufferTextureLayer (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); void glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum attachments); void glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum attachments, GLint x, GLint y, GLsizei width, GLsizei height); void glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); gl31 void glFramebufferParameteri (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params); gl32 void glFramebufferTexture (GLenum target, GLenum attachment, GLuint texture, GLint level); EXT glext.h void glResolveMultisampleFramebufferAPPLE (void); void glDiscardFramebufferEXT (GLenum target, GLsizei numAttachments, const GLenum attachments); void glFramebufferTexture2DMultisampleEXT (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glFramebufferTexture2DMultisampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glExtGetFramebuffersQCOM (GLuint framebuffers, GLint maxFramebuffers, GLint *numFramebuffers); Renderbuffer void glEGLImageTargetRenderbufferStorageOES (GLenum target, GLeglImageOES image); void glRenderbufferStorageMultisampleAPPLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleEXT (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleIMG (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glExtGetRenderbuffersQCOM (GLuint renderbuffers, GLint maxRenderbuffers, GLint numRenderbuffers); gl2Ext void glFramebufferTextureOES (GLenum target, GLenum attachment, GLuint texture, GLint level); void glFramebufferTexture3DOES (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); void glResolveMultisampleFramebufferAPPLE (void); void glDiscardFramebufferEXT (GLenum target, GLsizei numAttachments, const GLenum attachments); void glFramebufferTextureEXT (GLenum target, GLenum attachment, GLuint texture, GLint level); void glFramebufferTexture2DMultisampleEXT (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glFramebufferFetchBarrierEXT (void); void glFramebufferPixelLocalStorageSizeEXT (GLuint target, GLsizei size); GLsizei glGetFramebufferPixelLocalStorageSizeEXT (GLuint target); void glFramebufferTexture2DDownsampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint xscale, GLint yscale); void glFramebufferTextureLayerDownsampleIMG (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale); void glFramebufferTexture2DMultisampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glApplyFramebufferAttachmentCMAAINTEL (void); void glFramebufferParameteriMESA (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameterivMESA (GLenum target, GLenum pname, GLint params); void glBlitFramebufferNV (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); void glFramebufferSampleLocationsfvNV (GLenum target, GLuint start, GLsizei count, const GLfloat v); void glNamedFramebufferSampleLocationsfvNV (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat v); void glFramebufferTextureMultiviewOVR (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews); void glFramebufferTextureMultisampleMultiviewOVR (GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews); void glFramebufferFoveationConfigQCOM (GLuint framebuffer, GLuint numLayers, GLuint focalPointsPerLayer, GLuint requestedFeatures, GLuint *providedFeatures); void glFramebufferFoveationParametersQCOM (GLuint framebuffer, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea); void glFramebufferFetchBarrierQCOM (void); Renderbuffer void glEGLImageTargetRenderbufferStorageOES (GLenum target, GLeglImageOES image); void glRenderbufferStorageMultisampleAdvancedAMD (GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height); void glNamedRenderbufferStorageMultisampleAdvancedAMD (GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleANGLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleAPPLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleEXT (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleIMG (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleNV (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glExtGetRenderbuffersQCOM (GLuint renderbuffers, GLint maxRenderbuffers, GLint numRenderbuffers); gl2ext_angle.h void glGetRenderbufferParameterivRobustANGLE (GLenum target, GLenum pname, GLsizei bufSize, GLsizei length, GLint params); void glGetRenderbufferImageANGLE (GLenum target, GLenum format, GLenum type, void *pixels); gl2Ext_ANGLE void glGetFramebufferAttachmentParameterivRobustANGLE (GLenum target, GLenum attachment, GLenum pname, GLsizei bufSize, GLsizei length, GLint params); void glGetFramebufferParameterivRobustANGLE (GLenum target, GLenum pname, GLsizei bufSize, GLsizei length, GLint params); Summary Framebuffer \u5206\u9ed8\u8ba4 fb \u548c \u7528\u6237\u5b9a\u4e49 fb, \u540e\u8005\u88ab\u79f0\u4e3a Framebuffer Objects (FBOs) OpenGL \u4f1a\u5728 Context\u4e2d\u521b\u5efa Default Framebuffer \u7528\u6765\u8868\u793a\u4e00\u4e2a \u7a97\u53e3 \u6216 \u663e\u793a\u8bbe\u5907. \u4e0d\u80fd\u4fee\u6539\u5176 attachments FBOs \u5173\u8054 Textures \u6216 Renderbuffers, \u4e0d\u4f1a\u76f4\u63a5\u53ef\u89c1 FBOs\u4e2d\u7f13\u5b58(Buffers)\u53c8\u79f0\u4f5c \"attachment points\" Bind points void glBindFramebuffer(GL_FRAMEBUFFER, mFramebuffer) bind framebuffers to the context \u4e24\u79cd\u7c7b\u578b: GL_DRAW_FRAMEBUFFER \u548c GL_READ_FRAMEBUFFER , \u800c GL_FRAMEBUFFER \u8868\u793a\u4e8c\u8005\u90fd\u6709. Colorspace: \u4e24\u79cd: linear RGB \u548c sRGB \u542f\u7528 / \u7981\u7528 GL_FRAMEBUFFER_SRGB \u6765\u63a7\u5236\u662f\u5426\u8fdb\u884c\u8f6c\u6362 ### Blending blending \u4f5c\u7528\u4e8e\u76ee\u6807\u56fe\u50cf\u7684 sRGB colorspace, \u56e0\u6b64\u82e5 GL_FRAMEBUFFER_SRGB \u672a\u542f\u7528, \u65e0\u6cd5\u6b63\u5e38\u5de5\u4f5c. Read void glReadBuffer (GLenum mode ); Draw void glDrawBuffersEXT(attachmentCount, drawBuffers[GL_COLOR_ATTACHMENT0_EXT, ...]); attachmentCount can only be as large as GL_MAX_DRAW_BUFFERS ( Windows ANGLE\u4e0a\u7ea6\u4e3a 34852) Draw \u64cd\u4f5c\u4f1a\u5bf9 fb \u8bbe\u7f6e\u4e00\u79cd state, \u56e0\u6b64\u53ef\u7528\u53ea draw \u4e00\u6b21. Framebuffer Jump to navigation Jump to search A Framebuffer is a collection of buffers that can be used as the destination for rendering. OpenGL has two kinds of framebuffers: the Default Framebuffer , which is provided by the OpenGL Context ; and user-created framebuffers called Framebuffer Objects (FBOs). The buffers for default framebuffers are part of the context and usually represent a window or display device. The buffers for FBOs reference images from either Textures or Renderbuffers ; they are never directly visible. Note that the term \"buffer\" here refers to a specific location in the framebuffer. An image may or may not be associated with a particular buffer in a framebuffer. Buffers in FBOs are also called \"attachment points\"; they're the locations where images can be attached. Default framebuffers cannot change their buffer attachments, but a particular default framebuffer may not have images associated with certain buffers. For example the GL_BACK_RIGHT buffer will only have an image if the default framebuffer is double-buffered and uses stereoscopic 3D. The default framebuffer's buffer names are separate from framebuffer object buffer names . Bind points glBindFramebuffer is used to bind framebuffers to the context. They can be bound to one of two targets: GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER. The draw framebuffer is used as the destination for rendering, clearing , and other writing operations. The read framebuffer is used as the source for reading operations. Binding to the GL_FRAMEBUFFER target is equivalent to binding that framebuffer to both GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER. Note that most other uses of GL_FRAMEBUFFER mean the draw framebuffer; this is the case when it means both. Colorspace Color Image Formats can be in a linear or sRGB colorspace . Normally, sRGB images perform color correction, such that texture reads from them will always convert them to linear RGB. However, when writing values from a Fragment Shader to the image, a question arises: in what colorspace are the values written by the shader? When the output buffer is linear RGB, the answer is assumed to be linear. But if we are writing to an sRGB image, it is entirely reasonable for a shader to want to write linear values which will be automatically converted to sRGB for storage. However, at other times, it is entirely reasonable for a shader to want to write sRGB values directly, and therefore want to store the written provided without any conversion. The fragment shader is not given the power to control this, as the controls for it depend partially on state external to the fragment shader (namely, the colorspace of the image buffer being written to). Instead, this is made a global state value. When GL_FRAMEBUFFER_SRGB is disabled , the system assumes that the color written by the fragment shader is in whatever colorspace the image it is being written to is. Therefore, no colorspace correction is performed. If GL_FRAMEBUFFER_SRGB is enabled however, then if the destination image is in the sRGB colorspace (as queried through glGetFramebufferAttachmentParameter(GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING) ), then it will assume the shader's output is in the linear RGB colorspace. It will therefore convert the output from linear RGB to sRGB. Note that Logical Operations are disabled for any sRGB buffer when GL_FRAMEBUFFER_SRGB is enabled. Blending Blending interacts with sRGB colorspace in destination images. The sRGB colorspace is non-linear, and thus linearly interpolating between non-linear colorspaces generally leads to colors that are not accurate. The correct operation is to linearize the destination color, do the blending in linear RGB space, and then convert back to sRGB. If GL_FRAMEBUFFER_SRGB is enabled , then the appropriate correction will be done for sRGB destination images. That is, if a particular destination image is sRGB, the destination value will be converted to linear RGB, blended with the linear source value via the current blend functions, and the result will be converted back to sRGB for writing to the destination image. If GL_FRAMEBUFFER_SRGB is not enabled, then it is assumed that the user knows what they are doing. Therefore, blending against an sRGB image when GL_FRAMEBUFFER_SRGB is not enabled will not perform any of the above correction. This is generally not a good idea, even if you are writing sRGB color values from the Fragment Shader . Read color buffer Certain OpenGL operations can read pixel data from the color buffer. These operations are: Direct pixel reads . Framebuffer blits . Copies from the framebuffer to textures , which could also be during mutable storage specification . All of these operations read from the framebuffer bound to GL_READ_FRAMEBUFFER. However, because framebuffers often have multiple color images that could be read from, there is a selector in the framebuffer object that defines which color buffer these operations read from. The framebuffer's read buffer is specified by: void glReadBuffer (GLenum mode ); Warning: This sets the read buffer for the framebuffer currently bound to GL_READ_FRAMEBUFFER. So make sure that the framebuffer you want is bound to that buffer. The read buffer is part of the framebuffer's state, so each framebuffer will remember its previously set read buffer. If the GL_READ_FRAMEBUFFER is the default framebuffer, then mode must be the name of a color buffer name . It may be one of the multiple buffer aliases , which degrades as specified. If the read framebuffer is an FBO, then mode must be GL_COLOR_ATTACHMENT i , for one of the legal values of i . mode may also be GL_NONE, which indicates that no reading can be performed from color buffers on this framebuffer. Any attempt to perform read operations will fail with an error (GL_INVALID_OPERATION). Draw color buffers Much as with the read buffer, framebuffers have a set of draw buffers where writing operations write to. Unlike the read buffer, there are multiple draw buffers, which allow writing operations to write values to different buffers in the framebuffer at the same time. Fragment shader color outputs allow a fragment shader to define fragment color outputs, for example. The framebuffer therefore has a table of draw buffers, which are indexed on the half-open range [0, GL_MAX_DRAW_BUFFERS). The framebuffer's table maps from these indices to named color buffers in the framebuffer. To set this mapping table (on the framebuffer bound to GL_DRAW_FRAMEBUFFER), use this function: void glDrawBuffers( GLsizei n, const GLenum *bufs ); This function sets the first n entries of the mapping table. The indices of the enumerators correspond to the output fragment colors from the fragment shader. Thus, n can only be as large as GL_MAX_DRAW_BUFFERS. The entries in the bufs array are enumerators referring to buffer names in the framebuffer. All entries after n are set to GL_NONE. The values in bufs must name specific color buffers in the framebuffer. For the default framebuffer, buffer names cannot be the one of the multiple buffer aliases ; you must use GL_BACK_LEFT rather than GL_BACK. Framebuffer Objects use GL_COLOR_ATTACHMENT i buffer names. An entry in the list can be GL_NONE, which means that the output (if the shader outputs a value for it at all) is discarded. If you are only setting up one draw buffer, you may use glDrawBuffer . It takes one enumeration value and sets the fragment color 0 to draw to that buffer. All other draw buffer indices are set to GL_NONE. For the default framebuffer, the multiple buffer aliases can be used (though it is not advised to do so). They will cause drawing operations to write to all of the specified buffers. The state set by glDrawBuffers is part of the state of the framebuffer. So you can generally set this up once and leave it set. Buffer clearing Images in a framebuffer may be cleared to a particular value. Clearing is affected by the following state: The Write Mask . Only unmasked components will be changed by a clear call. The Pixel Ownership Test , which matters only for the Default Framebuffer . Pixels that are not owned will have undefined values. The Scissor Test . If the scissor test is enabled, then the clear region is bounded by the scissor rectangle. The Rasterizer Discard state. If discarding is enabled, all clearing commands are ignored. Framebuffer image clearing commands are Rendering Commands . Therefore, they are affected by Conditional Rendering . Clearing can be done in one of two ways. The old way can clear multiple buffers in a single call: void glClear (GLbitfield mask ); This will clear the current GL_DRAW_FRAMEBUFFER. The mask field is a bitmask that defines which kinds of buffers to clear. It can be a combination of GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT. When GL_COLOR_BUFFER_BIT is cleared, all of the active draw buffers are cleared. The values that the given buffers are cleared to are set beforehand via OpenGL state functions: void glClearColor (GLfloat red , GLfloat green , GLfloat blue , GLfloat alpha ); void glClearDepth (GLdouble depth ); void glClearStencil (GLint s ); These functions set the values that will be used to clear the appropriate buffers. Note that you must call these before calling glClear . depth will be clamped to the range [0, 1]. s , the stencil index, will be clamped to the valid integer range for the stencil buffer's image format. Note that glClearColor takes floating-point values. Yet it is perfectly legal to use integer Image Formats for images in framebuffers. Attempting to clear integer buffers with floating-point data will not work. Instead, you must clear each buffer individually with this suite of functions: void glClearBufferiv (GLenum buffer , GLint drawBuffer , const GLint * value ); void glClearBufferuiv (GLenum buffer , GLint drawBuffer , const GLuint * value ); void glClearBufferfv (GLenum buffer , GLint drawBuffer , const GLfloat * value ); void glClearBufferfi (GLenum buffer , GLint drawBuffer , GLfloat depth , GLint stencil ); This will clear a buffer in the current GL_DRAW_FRAMEBUFFER. buffer is either GL_COLOR, GL_DEPTH, GL_DEPTH_STENCIL, or GL_STENCIL. When clearing the GL_DEPTH buffer, you must use glClearBufferfv , and the depth value (a single float) will be clamped to [0, 1]. When using GL_STENCIL, you must use glClearBufferiv , and the stencil value (a single integer) will be clamped to the range of the stencil image format's precision. When using GL_DEPTH_STENCIL, you must use glClearBufferfi , and depth and stencil will each be clamped as appropriate for their value. The drawbuffer specifies the draw buffer index for the buffer to clear. This is only relevant if the buffer is GL_COLOR; in all other cases it must be 0. Note that this is the draw buffer index , not one of the GL_COLOR_ATTACHMENT i values. So 0 represents whatever the first buffer named by glDrawBuffers is. Note: Confusingly, buffer may also be one of the default framebuffer's multiple buffer aliases . In this case, drawbuffer specifies an additional draw buffer to clear, and all of the buffers will be cleared. You should probably avoid using them. Warning: Buffer clearing, of all forms , will respect the current state of the Scissor Test . If you wish to clear the entire buffer, you must make sure the scissor test is disabled. Buffer reading Pixel data can be read from a framebuffer and stored into CPU memory (or a buffer object ). The framebuffer being read from is the framebuffer bound to GL_READ_FRAMEBUFFER; remember that binding to GL_FRAMEBUFFER binds to both the read and the draw. To begin reading pixels, use this command: void glReadPixels (GLint x , GLint y , GLsizei width , GLsizei height , GLenum format , GLenum type , GLvoid * data ) This performs a Pixel Transfer read operation; as such, the destination data can be an offset into a Pixel Buffer Object if you so desire. Framebuffers have many buffers to read from. Which buffer is read from depends in part on the format parameter. If format is GL_DEPTH_COMPONENT, then the depth buffer is read from. If it is GL_STENCIL_INDEX, then the stencil buffer is read from. If it is GL_DEPTH_STENCIL then both the depth and stencil buffers are read from. If format is a color format, then the current read color buffer is used. If the current read buffer is GL_NONE, then a GL_INVALID_OPERATION error will occur. Read color clamping The color values read via glReadPixels may be clamped to the [0, 1] range. This is controlled via this function: void glClampColor (GLenum target , GLenum clamp ); The target must be GL_CLAMP_READ_COLOR. The clamp can be set to one of the following: GL_TRUE: Clamping is always on, no matter what the format or type parameters of the read pixels call. GL_FALSE: Clamping is always off, no matter what the format or type parameters of the read pixels call. GL_FIXED_ONLY: Clamping is only on if the type of the image being read is a normalized signed or unsigned value. Note that the clamping behavior is not framebuffer object state. It will not be stored with the current framebuffer. Invalidation The contents of a framebuffer can be invalidated. This means that the application is no longer interested in whatever pixel data happens to be stored in any images in that part of the framebuffer. Invalidation is useful, as it allows the implementation to allocate new memory if asynchronous commands are working with the previously invalidated framebuffer images. In particular, invalidation after asynchronous pixel reads are quite useful. To invalidate the framebuffer as a whole, the following function is used: glInvalidateFramebuffer (GLenum target , GLsizei numAttachments , const GLenum * attachments ) The framebuffer bound to target will be invalidated. The specific images in the framebuffer to be invalidated are specified by the array attachments , which must have numAttachments entries in it. The entries in the array must be names of specific images in the framebuffer. For user-created Framebuffer Objects, these must be the names of one of the available attachment points. For the default framebuffer, the names can be one of the images in the default framebuffer ; none of the color buffer's aliases work here. The default framebuffer can also use the names GL_COLOR (which means GL_BACK_LEFT if double-buffered and GL_FRONT_LEFT if single-bufferred. Instead of invalidating whole sets of images in the framebuffer, a portion of the framebuffer can be invalidated instead: glInvalidateSubFramebuffer (GLenum target , GLsizei numAttachments , const GLenum * attachments , GLint x , GLint y , GLint width , GLint height ) The x , y , width , and height parameters specify a rectangular region of the specified images to invalidate. After invalidation, the contents of pixels stored in those areas are undefined. You can clear them to a set value after invalidation. Blitting Framebuffers can be bound to two separate targets with glBindFramebuffer : GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER. Binding to GL_FRAMEBUFFER is equivalent to binding the framebuffer to both. The reason for the separation of these targets is to allow data in one framebuffer to be blitted to another framebuffer. A blit operation is a special form of copy operation; it copies a rectangular area of pixels from one framebuffer to another. This function also has some very specific properties with regard to multisampling . Framebuffer blitting commands are considered Rendering Commands . Therefore, they are affected by Conditional Rendering . However, they do not invoke most parts of the Rendering Pipeline . Blits are affected by the Scissor Test (they always use viewport index 0) as well as the Pixel Ownership Test , but are not affected by the Write Mask , Depth Test or any other parts of the rendering pipeline. You bind the source framebuffer to GL_READ_FRAMEBUFFER, then bind the destination framebuffer to GL_DRAW_FRAMEBUFFER. The read framebuffer is the source of the blit, and the draw framebuffer is the destination. The read and draw framebuffers can be the same. After binding the framebuffers, you call this function: void glBlitFramebuffer( GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); The pixels in the rectangular area specified by the src values are copied to the rectangular area specified by the dst values. The mask parameter is a bitfield that specifies which kinds of buffers you want copied: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT, or some combination. The filter parameter specifies how you want filtering performed if the two rectangles are not the same size. One thing to keep in mind is this: when using GL_COLOR_BUFFER_BIT, the only colors read will come from the read color buffer in the read FBO, specified by glReadBuffer . The colors written will only go to the draw color buffers in the write FBO, specified by glDrawBuffers . If multiple draw buffers are specified, then multiple color buffers are updated with the same data. The depth and stencil buffers of the source framebuffers are blitted to the depth and stencil buffers of the destination if the mask specifies them. Note that it is perfectly valid to blit from or to the Default Framebuffer . If one (or both) of the framebuffers is a layered framebuffer (blitting fails if the framebuffers are incomplete. So they will be either all layered or all not layered), then blitting happens rather oddly. Only layer 0 will be read and only layer 0 will be written . This is true even if both the read and draw FBOs are layered and have the same number of layers. If you want to blit other layers, you will have to bind those layers to some other FBO and blit from/to that new FBO. Format Considerations Blitting is not the same as performing a pixel transfer or a texture copy . The conversion between source and destination format is more limited. Blitting depth and stencil buffers works as expected: values are converted from one bitdepth to the other as needed. Conversion between color formats is different. A blit operation can only convert between formats within 3 groups. Signed integral and unsigned integral formats make up two groups, with all normalized and floating-point formats making up the third. Thus, it is legal to blit from an GL_RGB8 buffer to a GL_RGB32F and vice versa. But it is not legal to blit a GL_RGB8 from or to a GL_RGBI8 format image. The data during blitting is converted according to simple rules. Blitting from a floating-point format to a normalized integer format will cause clamping, either to [0, 1] for unsigned normalized or [-1, 1] for signed normalized. Multisampling Considerations Multisampling is supported with the Default Framebuffer (through WGL/GLX_multisample) and/or Framebuffer Objects (through multisampled renderbuffers or textures , where supported). As explained in the article on Multisampling , a multisampled buffer must be resolved into a single sample before it can be displayed. When the default framebuffer uses multisampling, this resolving operation is automatic, occurring during framebuffer swapping (though reading from the framebuffer can cause it to happen anyway). Each framebuffer has a specific number of samples; for Framebuffer Objects , they cannot be framebuffer-complete if all of the attached images do not have the same number of samples. A sample count of zero represents a framebuffer that is not multisampled. If you perform a blit operation and and at least one of the framebuffers is multisampled, then the source and destination sizes must be the same. That is, you cannot do multisampled blits and rescaling at the same time. If you blit between two framebuffers with the same number of samples, the copy is done directly; the destination buffer gets the same information the source had. It is an error to blit between framebuffers with different numbers of samples, unless one of the framebuffers has zero samples. Blitting from a non-multisampled framebuffer to a multisampled framebuffer causes all of samples in a pixel of the draw framebuffer to get the same value from the corresponding pixel in the read framebuffer. Blitting from a multisampled framebuffer to a non-multisampled framebuffer performs a multisample resolve operation, computing the value of a draw framebuffer's pixel from all of the samples in the corresponding pixel of the read framebuffer. This explicit resolve operation is very useful when wanting to display multisampled buffers. As with all multisample behavior, none of this works at all unless glEnable(GL_MULTISAMPLE) is in effect (which is the default).","title":"OpenGL(ES)"},{"location":"GLES/Framebuffer%20Object/#gles-framebuffers","text":"learnopengl \u66f4\u591a\u7528\u4f8b: \u6cdb\u5149 \u591a\u6e32\u67d3\u76ee\u6807(Multiple Render Targets) \u4e0e \u5ef6\u8fdf\u7740\u8272\u6cd5","title":"GLES Framebuffers"},{"location":"GLES/Framebuffer%20Object/#_1","text":"\u901a\u5e38\u6211\u4eec\u7684\u64cd\u4f5c\u90fd\u662f\u5728 \u9ed8\u8ba4 \u5e27\u7f13\u51b2 (Default Framebuffer ) \u7684\u6e32\u67d3\u7f13\u51b2\u4e0a\u8fdb\u884c\u7684\u3002\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u662f\u5728\u4f60\u521b\u5efa\u7a97\u53e3\u7684\u65f6\u5019\u751f\u6210\u548c\u914d\u7f6e\u7684\uff08EGL\uff09\u3002 \u5728GL\u4e2d\u4f1a\u4f7f\u7528\u51e0\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u5c4f\u5e55\u7f13\u51b2\uff1a\u7528\u4e8e\u5199\u5165\u989c\u8272\u503c\u7684 \u989c\u8272\u7f13\u51b2 \uff0c\u7528\u4e8e\u5199\u5165\u6df1\u5ea6\u4fe1\u606f\u7684 \u6df1\u5ea6\u7f13\u51b2 \uff0c\u4ee5\u53ca\u5141\u8bb8\u6211\u4eec\u57fa\u4e8e\u4e00\u4e9b\u6761\u4ef6\u4e22\u5f03\u6307\u5b9a\u7247\u6bb5\u7684 \u6a21\u677f\u7f13\u51b2 \u3002\u628a\u8fd9\u51e0\u79cd\u7f13\u51b2\u7ed3\u5408\u8d77\u6765\u53eb\u505a\u5e27\u7f13\u51b2(Framebuffer)\u3002 \u800c\u4f7f\u7528 \u5e27\u7f13\u51b2\u5bf9\u8c61 (Framebuffer Object) \u5141\u8bb8\u7528\u6237 \u81ea\u5b9a\u4e49\u5e27\u7f13\u51b2 \uff0cFramebuffer \u5b9e\u9645\u662f\u4e00\u4e2a\u53ef\u6dfb\u52a0 \u7f13\u51b2\u7684\u5bb9\u5668 . \u7528\u6237\u53ef\u4ee5\u4e3a\u5176\u6dfb\u52a0 \u7eb9\u7406 (Textures ) \u6216 \u6e32\u67d3\u7f13\u51b2\u533a \u5bf9\u8c61\uff08Renderbuffer), \u6765\u5b9a\u4e49\u81ea\u5df1\u7684\u989c\u8272\u7f13\u51b2\uff0c\u6df1\u5ea6\u7f13\u51b2, \u548c\u6a21\u677f\u7f13\u51b2\u3002","title":"\u5b9a\u4e49"},{"location":"GLES/Framebuffer%20Object/#_2","text":"\u6e32\u67d3\u5230\u4e00\u4e2a\u975e\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u88ab\u53eb\u505a \u79bb\u5c4f\u6e32\u67d3 (Off-screen Rendering) \u6216 \u6e32\u67d3\u5230\u7eb9\u7406 (Render to Texture)\u3002 \u901a\u8fc7\u81ea\u5b9a\u4e49\u5e27\u7f13\u51b2\u53ef\u4ee5\u5c06\u4f60\u7684\u573a\u666f\u6e32\u67d3\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u4e2d, \u53ef\u4ee5\u4f7f\u6211\u4eec\u80fd\u591f\u5728\u5f53\u524d\u573a\u666f\u4e2d\u521b\u5efa \u955c\u5b50, \u5012\u5f71 \u8fd9\u6837\u7684\u6548\u679c. \u8fd8\u6709\u5f88\u591a\u5e38\u89c1\u7279\u6548\u9700\u8981\u7528\u5230\u5e27\u7f13\u51b2, \u4f8b\u5982: \u9634\u5f71\u8d34\u56fe, \u52a8\u6001\u53cd\u5c04\u548c\u73af\u5883\u8d34\u56fe, \u591a\u9053\u666f\u6df1\u6280\u672f, \u52a8\u6001\u6a21\u7cca, \u548c\u540e\u671f\u5904\u7406\u7279\u6548\u7b49.","title":"\u5e94\u7528"},{"location":"GLES/Framebuffer%20Object/#_3","text":"\u9ed8\u8ba4\u5e27\u7f13\u51b2 Default Framebuffers \u5728\u8fdb\u884cGLES\u6307\u4ee4\u64cd\u4f5c\u524d, \u9700\u8981\u521b\u5efa\u4e00\u4e2a Context \u548c \u7ed8\u56fe\u8868\u9762 (\u9ed8\u8ba4 Framebuffer), \u8fd9\u901a\u5e38\u7531\u539f\u751f\u7a97\u53e3\u7cfb\u7edf\u901a\u8fc7 EGL \u7b49\u5b8c\u6210. \u521b\u5efa EGL \u7ed8\u5236\u8868\u9762\u7684\u8c03\u7528\u65f6, \u4ee5\u50cf\u7d20\u5f62\u5f0f\u6307\u5b9a \u5bbd\u5ea6,\u9ad8\u5ea6, \u662f\u5426\u4f7f\u7528 \u989c\u8272\u7f13\u51b2, \u6df1\u5ea6\u7f13\u51b2, \u6a21\u677f\u7f13\u51b2, \u53ca\u8fd9\u4e9b\u7f13\u51b2\u533a\u7684\u4f4d\u6df1. \u4e0d\u80fd\u5bf9\u5176\u8fdb\u884c\u4fee\u6539\u6216\u67e5\u8be2\u72b6\u6001\u64cd\u4f5c glViewport \u63a7\u5236\u5e27\u7f13\u51b2\u7684\u5927\u5c0f, \u4ee5\u53ca\u63a7\u5236\u9634\u5f71\u6df1\u5ea6\u8d34\u56fe\u5927\u5c0f\u7b49\u7b49 \u5e27\u7f13\u51b2\u5bf9\u8c61 Framebuffers Objects (FBOs) \u9644\u7740 Attachment FBO \u4ec5\u88ab\u89c6\u4e3a\u7f13\u5b58\u7684\u5bb9\u5668, \u56e0\u6b64\u4f7f\u7528 FBO \u4f5c\u4e3a\u6e32\u67d3\u76ee\u6807\u65f6\uff0c\u9996\u5148\u9700\u8981\u4e3a FBO \u7684\u9644\u7740\u8fde\u63a5\u5bf9\u8c61\uff0c \u9644\u7740\u662f\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\uff0c\u5b83\u80fd\u591f\u4f5c\u4e3a\u5e27\u7f13\u51b2\u7684\u4e00\u4e2a\u7f13\u51b2\uff0c\u53ef\u4ee5\u5c06\u5b83\u60f3\u8c61\u4e3a\u4e00\u4e2a\u56fe\u50cf\u3002 \u521b\u5efa\u4e00\u4e2a\u9644\u4ef6\u65b9\u5f0f\u6709\u4e24\u79cd\uff1a \u7eb9\u7406 \u6216 \u6e32\u67d3\u7f13\u51b2 \u5bf9\u8c61(Renderbuffer)\u3002 \u5e27\u7f13\u51b2\u76843\u4e2a\u9644\u7740 \u989c\u8272\u9644\u7740 Color Attachment \u6df1\u5ea6\u9644\u7740 Depth Attachment \u6a21\u677f\u9644\u7740 Stencil Attachment \u7eb9\u7406\u9644\u4ef6 Textures \u5373\u666e\u901a\u7684 Texture, \u6839\u636e Format\u7684\u4e0d\u540c, \u53ef\u4ee5\u5206\u522b\u7528\u4f5c FBO \u4e2d\u7684\u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u9644\u7740\u3002 \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 Renderbuffer Objects \u662f\u4e00\u4e2a\u7531\u5e94\u7528\u7a0b\u5e8f\u5206\u914d\u7684 2D \u56fe\u50cf\u7f13\u51b2\u533a\u3002 \u6e32\u67d3\u7f13\u51b2\u533a\u53ef\u4ee5\u7528\u4e8e\u5206\u914d\u548c\u5b58\u50a8 \u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u503c\uff0c\u53ef\u4ee5\u7528\u4f5c FBO \u4e2d\u7684\u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u9644\u7740\u3002 \u4f7f\u7528 \u7eb9\u7406 \u548c Renderbuffer \u5bf9\u8c61, \u90fd\u652f\u6301\u4e3a FBO \u5206\u522b\u6dfb\u52a0\u4e09\u79cd\u9644\u7740. \u4f46\u901a\u5e38\u4f7f\u7528 Texture \u6dfb\u52a0\u989c\u8272\u9644\u7740, \u7528 Renderbuffer \u6765\u6dfb\u52a0\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740. \u539f\u56e0\u5728\u540e\u9762\u8ba8\u8bba. (OpenGL ES 3.0 \u7f16\u7a0b\u6307\u5357)","title":"\u76f8\u5173\u5b9a\u4e49"},{"location":"GLES/Framebuffer%20Object/#_4","text":"APP --> GLES : glGenFramebuffers(1, &fbo); glBindFramebuffer(GL_FRAMEBUFFER, fbo); glBindFramebuffer(GL_FRAMEBUFFER, 0);","title":"\u4f7f\u7528\u6d41\u7a0b"},{"location":"GLES/Framebuffer%20Object/#_5","text":"\u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61 glGenFramebuffers(1, &fbo); \u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684(Active)\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, fbo); \u5728\u7ed1\u5b9a\u5230GL_FRAMEBUFFER\u76ee\u6807\u4e4b\u540e\uff0c\u6240\u6709\u7684 \u8bfb\u53d6 \u548c \u5199\u5165 \u5e27\u7f13\u51b2\u7684\u64cd\u4f5c\u5c06\u4f1a\u5f71\u54cd\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u3002 \u6211\u4eec\u4e5f\u53ef\u4ee5\u4f7f\u7528 GL_READ_FRAMEBUFFER \u6216 GL_DRAW_FRAMEBUFFER \uff0c\u5c06\u4e00\u4e2a\u5e27\u7f13\u51b2\u5206\u522b\u7ed1\u5b9a\u5230\u8bfb\u53d6\u76ee\u6807\u6216\u5199\u5165\u76ee\u6807\u3002 \u7ed1\u5b9a\u5230 GL_READ_FRAMEBUFFER \u7684\u5e27\u7f13\u51b2\u5c06\u4f1a\u4f7f\u7528\u5728\u6240\u6709\u50cf\u662f glReadPixels \u7684\u8bfb\u53d6\u64cd\u4f5c\u4e2d\uff0c \u7ed1\u5b9a\u5230 GL_DRAW_FRAMEBUFFER \u7684\u5e27\u7f13\u51b2\u5c06\u4f1a\u88ab\u7528\u4f5c\u6e32\u67d3\u3001\u6e05\u9664\u7b49\u5199\u5165\u64cd\u4f5c\u7684\u76ee\u6807\u3002 \u901a\u5e38\u90fd \u4e0d\u9700\u8981\u533a\u5206 \u5b83\u4eec\uff0c\u4f7f\u7528 GL_FRAMEBUFFER \uff0c\u7ed1\u5b9a\u5230\u4e24\u4e2a\u4e0a\u3002 \u6dfb\u52a0\u9644\u7740: \u5728\u8fd9\u4e00\u9636\u6bb5, \u4f7f\u7528Texture\u6216Renderbuffer\u5bf9FBO\u6dfb\u52a0\u9644\u7740, \u4ee3\u7801\u5728\u4e0b\u4e24\u8282\u79cd\u5c55\u793a. \u6dfb\u52a0\u9644\u7740\u540e, \u68c0\u67e5\u5e27\u7f13\u51b2\u7684\u5b8c\u6574\u6027 if( glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE) \u4e00\u4e2a\u5b8c\u6574\u7684\u5e27\u7f13\u51b2\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u7684\u6761\u4ef6\uff1a \u9644\u52a0\u81f3\u5c11\u4e00\u4e2a\u9644\u7740\uff08\u989c\u8272\u3001\u6df1\u5ea6\u6216\u6a21\u677f\u9644\u7740\uff09\u3002 \u81f3\u5c11\u6709\u4e00\u4e2a\u989c\u8272\u9644\u4ef6(Attachment)\u3002TODO: check angle \u6240\u6709\u7684\u9644\u4ef6\u90fd\u5fc5\u987b\u662f\u5b8c\u6574\u7684\uff08\u4fdd\u7559\u4e86\u5185\u5b58\uff09\u3002 \u6bcf\u4e2a\u7f13\u51b2\u90fd\u5e94\u8be5\u6709\u76f8\u540c\u7684\u9ad8\u5ea6\u548c\u5bbd\u5ea6\u3002 \u5982\u679c\u5b58\u5728\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740, \u5b83\u4eec\u5fc5\u987b\u662f\u76f8\u540c\u7684\u56fe\u50cf. \u6240\u6709\u9644\u7740\u7684 GL_RENDERBUFFER_SAMPLES \u6837\u672c\u503c\u76f8\u540c. \u82e5\u9644\u7740\u5bf9\u8c61\u662f\u7eb9\u7406, \u5219\u6b64\u503c\u4e3a0. \u89e3\u7ed1FBO / \u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u6e32\u67d3\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u88ab\u53eb\u505a \u79bb\u5c4f\u6e32\u67d3 (Off-screen Rendering)\u3002\u8981\u4fdd\u8bc1\u6240\u6709\u7684\u6e32\u67d3\u64cd\u4f5c\u5728\u4e3b\u7a97\u53e3\u4e2d\u6709\u89c6\u89c9\u6548\u679c\uff0c\u6211\u4eec\u9700\u8981\u518d\u6b21\u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2\uff0c\u5c06\u5b83\u7ed1\u5b9a\u5230 0 \u3002","title":"\u521b\u5efa\u5e27\u7f13\u51b2"},{"location":"GLES/Framebuffer%20Object/#_6","text":"\u666e\u901a\u7684\u521b\u5efa\u7eb9\u7406\u7684\u65b9\u5f0f unsigned int texture; glGenTextures(1, &texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); \u5982\u679c\u4f60\u60f3\u5c06\u4f60\u7684\u5c4f\u5e55\u6e32\u67d3\u5230\u4e00\u4e2a\u66f4\u5c0f\u6216\u66f4\u5927\u7684\u7eb9\u7406\u4e0a\uff0c\u4f60\u9700\u8981\uff08\u5728\u6e32\u67d3\u5230\u4f60\u7684\u5e27\u7f13\u51b2\u4e4b\u524d\uff09\u518d\u6b21\u8c03\u7528glViewport\uff0c\u4f7f\u7528\u7eb9\u7406\u7684\u65b0\u7ef4\u5ea6\u4f5c\u4e3a\u53c2\u6570\uff0c\u5426\u5219\u53ea\u6709\u4e00\u5c0f\u90e8\u5206\u7684\u7eb9\u7406\u6216\u5c4f\u5e55\u4f1a\u88ab\u6e32\u67d3\u5230\u8fd9\u4e2a\u7eb9\u7406\u4e0a\u3002 TODO: \u4ec0\u4e48\u610f\u601d? \u5c06\u7eb9\u7406\u9644\u52a0\u5728\u5e27\u7f13\u51b2\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); target \uff1a\u5e27\u7f13\u51b2\u7684\u76ee\u6807\uff08\u7ed8\u5236\u3001\u8bfb\u53d6\u6216\u8005\u4e24\u8005\u7686\u6709\uff09 attachment \uff1a\u6211\u4eec\u60f3\u8981\u9644\u52a0\u7684\u9644\u4ef6\u7c7b\u578b\u3002\u5f53\u524d\u6211\u4eec\u6b63\u5728\u9644\u52a0\u4e00\u4e2a \u989c\u8272\u9644\u4ef6 \u3002\u6ce8\u610f\u6700\u540e\u7684 0 \u610f\u5473\u7740\u53ef\u4ee5\u9644\u52a0\u591a\u4e2a\u989c\u8272\u9644\u4ef6\u3002 GL_COLOR_ATTACHMENT i , GL_DEPTH_ATTACHMENT , GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMENT . textarget \uff1a\u4f60\u5e0c\u671b\u9644\u52a0\u7684\u7eb9\u7406\u7c7b\u578b texture \uff1a\u8981\u9644\u52a0\u7684\u7eb9\u7406\u672c\u8eab level \uff1a\u591a\u7ea7\u6e10\u8fdc\u7eb9\u7406\u7684\u7ea7\u522b\u3002\u6211\u4eec\u5c06\u5b83\u4fdd\u7559\u4e3a0 \u7eb9\u7406\u5bf9\u8c61\u5141\u8bb8\u9644\u52a0\u4e00\u4e2a\u6df1\u5ea6\u6216\u6a21\u677f\u7f13\u51b2\u7eb9\u7406\u5230\u5e27\u7f13\u51b2\u5bf9\u8c61\u4e2d\u3002 \u8981\u9644\u52a0\u6df1\u5ea6\u7f13\u51b2\u7684\u8bdd\uff0c\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e\u4e3a GL_DEPTH_ATTACHMENT \u3002\u5e76\u5c06\u7eb9\u7406\u7684\u683c\u5f0f(Format)\u548c\u5185\u90e8\u683c\u5f0f(Internalformat)\u7c7b\u578b\u53d8\u4e3a GL_DEPTH_COMPONENT \uff0c\u6765\u53cd\u6620\u6df1\u5ea6\u7f13\u51b2\u7684\u50a8\u5b58\u683c\u5f0f\u3002 \u8981\u9644\u52a0\u6a21\u677f\u7f13\u51b2\u7684\u8bdd\uff0c\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e\u4e3a GL_STENCIL_ATTACHMENT \uff0c\u5e76\u5c06\u7eb9\u7406\u7684\u683c\u5f0f\u8bbe\u5b9a\u4e3a GL_STENCIL_INDEX \u3002 \u4e5f\u53ef\u4ee5\u5c06\u6df1\u5ea6\u7f13\u51b2\u548c\u6a21\u677f\u7f13\u51b2\u5408\u5e76\u9644\u52a0\u4e3a\u4e00\u4e2a\u7eb9\u7406\u3002\u7eb9\u7406\u7684\u6bcf32\u4f4d\u6570\u503c\u5c06\u5305\u542b24\u4f4d\u7684\u6df1\u5ea6\u4fe1\u606f\u548c8\u4f4d\u7684\u6a21\u677f\u4fe1\u606f\u3002\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e GL_DEPTH_STENCIL_ATTACHMENT \u7c7b\u578b\uff0c\u5e76\u914d\u7f6e\u7eb9\u7406\u7684\u683c\u5f0f\uff0c\u8ba9\u5b83\u5305\u542b\u5408\u5e76\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u503c\u3002 ``` glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL ); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0); ```","title":"\u7eb9\u7406\u9644\u7740"},{"location":"GLES/Framebuffer%20Object/#renderbuffer","text":"\u521b\u5efa\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u7684\u4ee3\u7801 glGenRenderbuffers(1, &rbo); \u7ed1\u5b9a\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\uff0c\u8ba9\u4e4b\u540e\u6240\u6709\u7684\u6e32\u67d3\u7f13\u51b2\u64cd\u4f5c\u5f71\u54cd\u5f53\u524d\u7684 RBO\uff1a glBindRenderbuffer(GL_RENDERBUFFER, rbo); \u521b\u5efa\u4e00\u4e2a\u6df1\u5ea6\u548c\u6a21\u677f\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); \u521b\u5efa\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u548c\u7eb9\u7406\u5bf9\u8c61\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u662f\u8fd9\u4e2a\u5bf9\u8c61\u662f\u4e13\u95e8\u88ab\u8bbe\u8ba1\u4f5c\u4e3a\u56fe\u50cf\u4f7f\u7528\u7684\uff0c\u800c\u4e0d\u662f\u7eb9\u7406\u90a3\u6837\u7684\u901a\u7528\u6570\u636e\u7f13\u51b2(General Purpose Data Buffer)\u3002 \u8fd9\u91cc\u6211\u4eec\u9009\u62e9 GL_DEPTH24_STENCIL8 \u4f5c\u4e3a\u5185\u90e8\u683c\u5f0f\uff0c\u5b83\u5c01\u88c5\u4e8624\u4f4d\u7684\u6df1\u5ea6\u548c8\u4f4d\u7684\u6a21\u677f\u7f13\u51b2\u3002 \u9644\u52a0\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5230 FBO\uff1a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); \u4f7f\u7528 GL_DEPTH_STENCIL_ATTACHMENT \u8868\u793a\u540c\u65f6\u5305\u542b\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740","title":"Renderbuffer \u9644\u7740"},{"location":"GLES/Framebuffer%20Object/#texture-vs-renderbuffer","text":"\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61(Renderbuffer Object) \u662f\u5728\u7eb9\u7406\u4e4b\u540e\u5f15\u5165\u5230OpenGL\u4e2d\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u53ef\u7528\u7684\u5e27\u7f13\u51b2\u9644\u4ef6\u7c7b\u578b\u7684\uff0c\u6240\u4ee5\u5728\u8fc7\u53bb\u7eb9\u7406\u662f\u552f\u4e00\u53ef\u7528\u7684\u9644\u4ef6\u3002 Renderbuffer : \u548c\u7eb9\u7406\u56fe\u50cf\u4e00\u6837\uff0c\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u662f\u4e00\u4e2a\u771f\u6b63\u7684\u7f13\u51b2\uff0c\u5373\u4e00\u7cfb\u5217\u7684\u5b57\u8282\u3001\u6574\u6570\u3001\u50cf\u7d20\u7b49\u3002 \u4f18\u70b9: Renderbuffer \u4f1a\u5c06\u6570\u636e\u50a8\u5b58\u4e3aOpenGL\u539f\u751f\u7684\u6e32\u67d3\u683c\u5f0f\uff0c\u5b83\u662f\u4e3a\u79bb\u5c4f\u6e32\u67d3\u5230\u5e27\u7f13\u51b2\u4f18\u5316\u8fc7\u7684\u3002 Renderbuffer \u76f4\u63a5\u5c06\u6240\u6709\u7684\u6e32\u67d3\u6570\u636e\u50a8\u5b58\u5230\u5b83\u7684\u7f13\u51b2\u4e2d\uff0c\u4e0d\u4f1a\u505a\u4efb\u4f55\u9488\u5bf9\u7eb9\u7406\u683c\u5f0f\u7684\u8f6c\u6362\uff0c\u8ba9\u5b83\u53d8\u4e3a\u4e00\u4e2a\u66f4\u5feb\u7684\u53ef\u5199\u50a8\u5b58\u4ecb\u8d28\u3002 \u7f3a\u70b9: Renderbuffer \u4e0d\u80fd\u505a\u7eb9\u7406: \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u901a\u5e38\u90fd\u662f \u53ea\u5199 \u7684\uff0c\u6240\u4ee5\u4f60\u4e0d\u80fd\u8bfb\u53d6\u5b83\u4eec, \u6bd4\u5982\u4f7f\u7528\u7eb9\u7406\u8bbf\u95ee\u3002 \u5f53\u7136\u4f60\u4ecd\u7136\u8fd8\u662f\u80fd\u591f\u4f7f\u7528 glReadPixels \u6765\u8bfb\u53d6\u5b83\uff0c\u8fd9\u4f1a\u4ece\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2(\u800c\u4e0d\u662f\u9644\u4ef6\u672c\u8eab)\u4e2d\u8fd4\u56de\u7279\u5b9a\u533a\u57df\u7684\u50cf\u7d20\u3002 \u56e0\u6b64\u901a\u5e38\u7684\u89c4\u5219\u662f: \u5982\u679c\u4f60 \u4e0d\u9700\u8981\u4ece\u4e00\u4e2a\u7f13\u51b2\u4e2d\u91c7\u6837 \u6570\u636e\uff0c\u90a3\u4e48\u5bf9\u8fd9\u4e2a\u7f13\u51b2\u4f7f\u7528 \u6e32\u67d3\u7f13\u51b2 \u5bf9\u8c61\u4f1a\u662f\u660e\u667a\u7684\u9009\u62e9\u3002 \u800c\u5982\u679c\u4f60 \u9700\u8981\u4ece\u7f13\u51b2\u4e2d\u91c7\u6837\u989c\u8272\u6216\u6df1\u5ea6 \u503c\u7b49\u6570\u636e\uff0c\u90a3\u4e48\u4f60\u5e94\u8be5\u9009\u62e9 \u7eb9\u7406 \u9644\u4ef6\u3002\u6027\u80fd\u65b9\u9762\u5b83\u4e0d\u4f1a\u4ea7\u751f\u975e\u5e38\u5927\u7684\u5f71\u54cd\u7684\u3002 \u56e0\u6b64 Renderbuffer \u5bf9\u8c61\u901a\u5e38\u7528\u4e8e \u6df1\u5ea6\u548c\u6a21\u677f \u9644\u4ef6\uff0c\u56e0\u4e3a\u5927\u90e8\u5206\u65f6\u95f4\u6211\u4eec\u90fd\u4e0d\u9700\u8981\u4ece\u6df1\u5ea6\u548c\u6a21\u677f\u7f13\u51b2\u4e2d\u8bfb\u53d6\u503c\uff0c\u53ea\u5173\u5fc3\u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5, \u4f46\u4e0d\u9700\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u91c7\u6837. \u5bf9\u5e94\u5230\u573a\u666f\u4e2d: \u9009\u62e9 Texture \u6e32\u67d3\u5230\u4e00\u4e2a\u7528\u4f5c\u989c\u8272\u7eb9\u7406\u7684\u989c\u8272\u7f13\u51b2\u533a \u6e32\u67d3\u5230\u4e00\u4e2a\u7528\u4f5c\u9634\u5f71\u7684\u6df1\u5ea6\u7eb9\u7406\u7684\u6df1\u5ea6\u7f13\u51b2\u533a \u9009\u62e9 Renderbuffer \u591a\u91cd\u91c7\u6837 \u5982\u679c\u56fe\u50cf\u4e0d\u88ab\u4f5c\u4e3a\u7eb9\u7406, \u5219 Renderbuffer \u53ef\u80fd\u5e26\u6765\u6027\u80fd\u4f18\u52bf: GLES \u53ef\u80fd\u4ee5\u66f4\u9ad8\u6548\u7684\u683c\u5f0f\u5b58\u50a8 Renderbuffer, \u6bd4\u7eb9\u7406\u66f4\u9002\u5408\u6e32\u67d3 \u4f8b\u5982: \u5229\u7528\u5176\u5199\u5165\u6216\u8005\u590d\u5236\u5230\u5176\u5b83\u7f13\u51b2\u5feb\u7684\u7279\u70b9\u3002 \u4ea4\u6362\u7f13\u51b2 \u8fd9\u6837\u7684\u64cd\u4f5c\u5728\u4f7f\u7528\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u65f6\u4f1a\u975e\u5e38\u5feb\u3002 \u5728\u6bcf\u4e2a\u6e32\u67d3\u8fed\u4ee3\u6700\u540e\u4f7f\u7528\u7684 glfwSwapBuffers \uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5b9e\u73b0\uff1a\u53ea\u9700\u8981\u5199\u5165\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u56fe\u50cf\uff0c\u5e76\u5728\u6700\u540e\u4ea4\u6362\u5230\u53e6\u5916\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5c31\u53ef\u4ee5\u4e86\u3002","title":"Texture VS. Renderbuffer"},{"location":"GLES/Framebuffer%20Object/#_7","text":"","title":"\u793a\u4f8b: \u573a\u666f\u6ee4\u955c"},{"location":"GLES/Framebuffer%20Object/#_8","text":"// \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61\uff0c\u5e76\u7ed1\u5b9a unsigned int framebuffer; glGenFramebuffers(1, &framebuffer); glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); // \u4f7f\u7528 Texture \u6dfb\u52a0\u989c\u8272\u9644\u7740 // \u751f\u6210\u7eb9\u7406 unsigned int texColorBuffer; glGenTextures(1, &texColorBuffer); glBindTexture(GL_TEXTURE_2D, texColorBuffer); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glBindTexture(GL_TEXTURE_2D, 0); // \u5c06\u7eb9\u7406\u5bf9\u8c61, \u9644\u52a0\u5230\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u5bf9\u8c61\u989c\u8272(color)\u9644\u4ef6\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, 0); // \u4f7f\u7528 Renderbuffer \u6dfb\u52a0\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740 // \u6df1\u5ea6\uff08\u548c\u6a21\u677f\uff09\u6d4b\u8bd5 // \u6dfb\u52a0\u4e00\u4e2a\u6df1\u5ea6\uff08\u548c\u6a21\u677f\uff09\u9644\u4ef6\u5230\u5e27\u7f13\u51b2\u4e2d unsigned int rbo; glGenRenderbuffers(1, &rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); // GL_DEPTH24_STENCIL8 glBindRenderbuffer(GL_RENDERBUFFER, 0); // \u5c06\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61, \u9644\u52a0\u5230\u5230\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u7684 depth \u548c stencil \u9644\u4ef6\u4e0a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); // \u68c0\u67e5\u5e27\u7f13\u51b2\u662f\u5426\u662f\u5b8c\u6574\u7684 if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) std::cout << \"ERROR::FRAMEBUFFER:: Framebuffer is not complete!\" << std::endl; // \u89e3\u7ed1\u5e27\u7f13\u51b2/\u7ed1\u5b9a\u56de\u9ed8\u8ba4 glBindFramebuffer(GL_FRAMEBUFFER, 0);","title":"\u521b\u5efa\u9636\u6bb5"},{"location":"GLES/Framebuffer%20Object/#_9","text":"\u8981\u60f3\u7ed8\u5236\u573a\u666f\u5230\u4e00\u4e2a\u7eb9\u7406\u4e0a\uff0c\u6211\u4eec\u9700\u8981\u91c7\u53d6\u4ee5\u4e0b\u7684\u6b65\u9aa4\uff1a \u5c06\u65b0\u7684\u5e27\u7f13\u51b2\u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684\u5e27\u7f13\u51b2 \u548c\u5f80\u5e38\u4e00\u6837\u6e32\u67d3\u573a\u666f \u6b64\u65f6\u573a\u666f\u4f1a\u6e32\u67d3\u5230\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2, \u800c\u4e0d\u662f\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u3002 \u6240\u6709\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u64cd\u4f5c\u90fd\u4f1a\u4ece\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u4ef6\u4e2d\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u8bfb\u53d6\u3002 \u7ed1\u5b9a\u56de\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2 \u7ed8\u5236\u4e00\u4e2a\u6574\u5c4f\u5e55\u7684\u56db\u8fb9\u5f62\uff0c\u7136\u540e\u5c06\u5e27\u7f13\u51b2\u7684\u989c\u8272\u7f13\u51b2\u4f5c\u4e3a\u56db\u8fb9\u5f62\u7684\u7eb9\u7406\u3002 // \u7b2c\u4e00\u5904\u7406\u9636\u6bb5: \u7ed8\u5236\u5230FBO glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // \u6211\u4eec\u73b0\u5728\u4e0d\u4f7f\u7528\u6a21\u677f\u7f13\u51b2 glEnable(GL_DEPTH_TEST); DrawScene(); // \u7ed8\u5236\u539f\u59cb 3D \u573a\u666f // Load VAO, bind Textures, uniform data, call glDrawArrays or glDrawElements // \u7b2c\u4e8c\u5904\u7406\u9636\u6bb5: \u7ed8\u5236\u5230\u5c4f\u5e55 glBindFramebuffer(GL_FRAMEBUFFER, 0); // \u8fd4\u56de\u9ed8\u8ba4 glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); screenShader.use(); // \u4f7f\u7528\u53e6\u4e00\u5957 shader glBindVertexArray(quadVAO); // \u7ed8\u5236\u4e00\u4e2a\u56db\u8fb9\u5f62 glDisable(GL_DEPTH_TEST); glBindTexture(GL_TEXTURE_2D, textureColorbuffer); // \u5c06 Color Buffer \u4f5c\u4e3a\u7eb9\u7406\u7ed8\u5236\u5230\u56db\u8fb9\u5f62\u4e0a glDrawArrays(GL_TRIANGLES, 0, 6); \u5982\u679c screenShader \u4e0d\u505a\u7279\u6b8a\u5904\u7406, \u6b64\u65f6\u753b\u9762\u4f1a\u548c DrawScene \u7ed8\u5236\u7684\u539f\u59cb3D\u573a\u666f\u4e00\u81f4. \u6b64\u65f6\u7ed8\u5236\u7684\u56db\u8fb9\u5f62\u7c7b\u4f3c\u4e00\u4e2a\u663e\u793a\u5c4f\u5e55, \u5229\u7528\u8d34\u56fe\u663e\u793a\u539f\u59cb\u573a\u666f. \u4f46\u5982\u679c\u5bf9 screenShader \u4e2d\u7eb9\u7406\u7684color\u8fdb\u884c\u4fee\u6539, \u5c31\u53ef\u7528\u5b9e\u73b0\u6ee4\u955c\u6548\u679c. void main() { // \u53cd\u767d\u7279\u6548 FragColor = vec4(vec3(1.0 - texture(screenTexture, TexCoords)), 1.0); } \u753b\u9762\u6548\u679c\u548c\u66f4\u591a\u7279\u6548\u5904\u7406, \u53c2\u89c1 LearnOpenGL (English version: LearnOpenGL )","title":"\u7ed8\u5236\u9636\u6bb5"},{"location":"GLES/Framebuffer%20Object/#msaa","text":"\u79bb\u5c4fMSAA \u5728\u9ed8\u8ba4\u5e27\u7f13\u51b2\u4e2d\u542f\u7528MASS, \u53ea\u9700\u8981 glEnable(GL_MULTISAMPLE); \u542f\u7528\u5373\u53ef. \u4f46\u5bf9\u4e8e\u79bb\u5c4f\u6e32\u67d3, \u9700\u8981\u624b\u52a8\u521b\u5efa\u591a\u91cd\u91c7\u6837\u7684\u9644\u7740. Texture: \u521b\u5efaMS Texture: \u4f7f\u7528 glTexImage2DMultisample \u6765\u66ff\u4ee3 glTexImage2D glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex); glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE); glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0); \u9644\u52a0\u5230\u5e27\u7f13\u51b2: \u4f7f\u7528 glFramebufferTexture2D \u5c06\u591a\u91cd\u91c7\u6837\u7eb9\u7406\u4e0a\uff0c\u4f46\u8fd9\u91cc\u7eb9\u7406\u7c7b\u578b\u4f7f\u7528\u7684\u662f GL_TEXTURE_2D_MULTISAMPLE \u3002 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0); Renderbuffer : \u521b\u5efa\u8fc7\u7a0b\u4e0d\u53d8 \u9644\u52a0\u5230\u5e27\u7f13\u51b2: \u5c06 glRenderbufferStorage \u7684\u8c03\u7528\u6539\u4e3a glRenderbufferStorageMultisample \u5c31\u53ef\u4ee5\u4e86 glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, width, height); \u7b2c\u4e8c\u53c2\u6570 4 \u4e3a\u91c7\u6837\u6b21\u6570 \u7ed8\u5236: void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); \u5c06\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u7684\u50cf\u7d20\u503c, \u4ece\u4e00\u4e2a\u5e27\u7f13\u51b2\u590d\u5236\u5230\u53e6\u4e00\u4e2a\u5e27\u7f13\u51b2. \u901a\u8fc7 glBlitFramebuffer \u5c06\u591a\u91cd\u91c7\u6837\u7684\u5e27\u7f13\u51b2, \u590d\u5236\u5230\u4e00\u4e2a\u4e2d\u4ecb\u5e27\u7f13\u51b2\u7684\u989c\u8272\u9644\u7740\u7684\u7eb9\u7406, \u5b9e\u73b0\u591a\u91cd\u91c7\u6837. glBindFramebuffer(multisampledFBO); ClearFrameBuffer(); DrawScene(); // \u5c06\u591a\u91cd\u91c7\u6837\u7f13\u51b2\u8fd8\u539f\u5230\u4e2d\u4ecbFBO\u4e0a glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO); glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO); glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST); // \u73b0\u5728\u573a\u666f\u662f\u4e00\u4e2a2D\u7eb9\u7406\u7f13\u51b2\uff0c\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u56fe\u50cf\u7528\u6765\u540e\u671f\u5904\u7406 glBindFramebuffer(GL_FRAMEBUFFER, 0); ClearFramebuffer(); glBindTexture(GL_TEXTURE_2D, screenTexture); DrawPostProcessingQuad();","title":"\u79bb\u5c4fMSAA"},{"location":"GLES/Framebuffer%20Object/#framebuffer-api","text":"API ES Ver. Notes void glGenFramebuffers ( sizei n, uint *framebuffers ); 2 void glBindFramebuffer ( enum target, uint framebuffer ); 2 void glGenRenderbuffers ( sizei n, uint *renderbuffers ); 2 void glBindRenderbuffer ( enum target, uint renderbuffer ); 2 void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); 2 \u521b\u5efa\u4e00\u4e2a Renderbuffer internalformat : \u6307\u5b9a\u7f13\u51b2\u683c\u5f0f: depth \u548c stencil GL_DEPTH24_STENCIL8; GL_DEPTH32F_STENCIL8 GL_DEPTH_COMPONENT16 GL_DEPTH_COMPONENT24 GL_DEPTH_COMPONENT32F GL_STENCIL_INDEX8 void glRenderbufferStorageMultisample ( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); 3.0 \u521b\u5efa\u4e00\u4e2a\u591a\u91cd\u91c7\u6837 Renderbuffer, \u4e0eglRenderbufferStorage\u7684\u533a\u522b\u4ec5\u4e3a\u540e\u8005samples=0 GLenum glCheckFramebufferStatus (GLenum target); \u68c0\u67e5fbo\u5b8c\u6574\u6027 void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); \u5c06\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u7684\u50cf\u7d20\u503c, \u4ece\u4e00\u4e2afb\u590d\u5236\u5230\u53e6\u4e00\u4e2afb. \u5e94\u7528\u4e3e\u4f8b: 1. \u590d\u5236\u591a\u4e2a\u7eb9\u7406\u5230\u5c4f\u5e55 2. \u5c06\u591a\u91cd\u91c7\u6837\u6e32\u67d3\u89e3\u6790\u4e3a\u4e00\u4e2a\u7eb9\u7406 \u7ed1\u5b9a void glFramebufferRenderbuffer ( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); 2 void glFramebufferTexture ( GLenum target, GLenum attachment, GLuint texture, GLint level); 3.2 void glFramebufferTexture2D ( enum target, enum attachment, enum textarget, uint texture, int level ); 2.0 void glFramebufferTextureLayer ( enum target, enum attachment, uint texture, int level, int layer ); 3.0 \u7ed1\u5b9a 3D Texture \u65e0\u6548\u5316/\u5220\u9664 void glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments); 3.0 \u901a\u77e5\u9a71\u52a8\u4e0d\u518d\u9700\u8981fb\u5185\u5bb9. \u4f7f\u9a71\u52a8\u53ef\u7528\u8fdb\u884c\u4f18\u5316: \u5982\u8df3\u8fc7TBR\u67b6\u6784\u4e2d\u4e0d\u5fc5\u8981\u7684\u56fe\u5757\u5185\u5bb9\u6062\u590d \u8df3\u8fc7\u5b9e\u73b0\u4e2d\u4e3a\u6539\u8fdb\u6027\u80fd\u800c\u505a\u7684\u7f13\u5b58\u5237\u65b0 void glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height); 3.0 void glDeleteRenderbuffers (GLsizei n, const GLuint *renderbuffers); 2 void glDeleteFramebuffers (GLsizei n, const GLuint *framebuffers); 2 \u5176\u4ed6 void glFramebufferParameteri (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params); boolean IsRenderbuffer ( uint renderbuffer ); boolean IsFramebuffer ( uint framebuffer ); \u5176\u4ed6\u9488\u5bf9\u8bfb\u5e27\u7f13\u51b2\u7684\u547d\u4ee4: ReadPixels, CopyTexImage , and CopyTexSubImage ,","title":"Framebuffer \u76f8\u5173 API \u6c47\u603b"},{"location":"GLES/Framebuffer%20Object/#gl2","text":"void glBindFramebuffer (GLenum target, GLuint framebuffer); GLenum glCheckFramebufferStatus (GLenum target); void glDeleteFramebuffers (GLsizei n, const GLuint framebuffers); void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); void glFramebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); void glGenFramebuffers (GLsizei n, GLuint framebuffers); void glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, GLint *params); GLboolean glIsFramebuffer (GLuint framebuffer); void glBindRenderbuffer (GLenum target, GLuint renderbuffer); void glDeleteRenderbuffers (GLsizei n, const GLuint renderbuffers); void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); void glGenRenderbuffers (GLsizei n, GLuint renderbuffers); void glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint *params); GLboolean glIsRenderbuffer (GLuint renderbuffer); void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);","title":"gl2"},{"location":"GLES/Framebuffer%20Object/#gl3","text":"void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); void glFramebufferTextureLayer (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); void glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum attachments); void glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum attachments, GLint x, GLint y, GLsizei width, GLsizei height); void glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);","title":"gl3"},{"location":"GLES/Framebuffer%20Object/#gl31","text":"void glFramebufferParameteri (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params);","title":"gl31"},{"location":"GLES/Framebuffer%20Object/#gl32","text":"void glFramebufferTexture (GLenum target, GLenum attachment, GLuint texture, GLint level);","title":"gl32"},{"location":"GLES/Framebuffer%20Object/#ext","text":"","title":"EXT"},{"location":"GLES/Framebuffer%20Object/#glexth","text":"void glResolveMultisampleFramebufferAPPLE (void); void glDiscardFramebufferEXT (GLenum target, GLsizei numAttachments, const GLenum attachments); void glFramebufferTexture2DMultisampleEXT (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glFramebufferTexture2DMultisampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glExtGetFramebuffersQCOM (GLuint framebuffers, GLint maxFramebuffers, GLint *numFramebuffers);","title":"glext.h"},{"location":"GLES/Framebuffer%20Object/#renderbuffer_1","text":"void glEGLImageTargetRenderbufferStorageOES (GLenum target, GLeglImageOES image); void glRenderbufferStorageMultisampleAPPLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleEXT (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleIMG (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glExtGetRenderbuffersQCOM (GLuint renderbuffers, GLint maxRenderbuffers, GLint numRenderbuffers);","title":"Renderbuffer"},{"location":"GLES/Framebuffer%20Object/#gl2ext","text":"void glFramebufferTextureOES (GLenum target, GLenum attachment, GLuint texture, GLint level); void glFramebufferTexture3DOES (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); void glResolveMultisampleFramebufferAPPLE (void); void glDiscardFramebufferEXT (GLenum target, GLsizei numAttachments, const GLenum attachments); void glFramebufferTextureEXT (GLenum target, GLenum attachment, GLuint texture, GLint level); void glFramebufferTexture2DMultisampleEXT (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glFramebufferFetchBarrierEXT (void); void glFramebufferPixelLocalStorageSizeEXT (GLuint target, GLsizei size); GLsizei glGetFramebufferPixelLocalStorageSizeEXT (GLuint target); void glFramebufferTexture2DDownsampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint xscale, GLint yscale); void glFramebufferTextureLayerDownsampleIMG (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale); void glFramebufferTexture2DMultisampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glApplyFramebufferAttachmentCMAAINTEL (void); void glFramebufferParameteriMESA (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameterivMESA (GLenum target, GLenum pname, GLint params); void glBlitFramebufferNV (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); void glFramebufferSampleLocationsfvNV (GLenum target, GLuint start, GLsizei count, const GLfloat v); void glNamedFramebufferSampleLocationsfvNV (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat v); void glFramebufferTextureMultiviewOVR (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews); void glFramebufferTextureMultisampleMultiviewOVR (GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews); void glFramebufferFoveationConfigQCOM (GLuint framebuffer, GLuint numLayers, GLuint focalPointsPerLayer, GLuint requestedFeatures, GLuint *providedFeatures); void glFramebufferFoveationParametersQCOM (GLuint framebuffer, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea); void glFramebufferFetchBarrierQCOM (void);","title":"gl2Ext"},{"location":"GLES/Framebuffer%20Object/#renderbuffer_2","text":"void glEGLImageTargetRenderbufferStorageOES (GLenum target, GLeglImageOES image); void glRenderbufferStorageMultisampleAdvancedAMD (GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height); void glNamedRenderbufferStorageMultisampleAdvancedAMD (GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleANGLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleAPPLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleEXT (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleIMG (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleNV (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glExtGetRenderbuffersQCOM (GLuint renderbuffers, GLint maxRenderbuffers, GLint numRenderbuffers); gl2ext_angle.h void glGetRenderbufferParameterivRobustANGLE (GLenum target, GLenum pname, GLsizei bufSize, GLsizei length, GLint params); void glGetRenderbufferImageANGLE (GLenum target, GLenum format, GLenum type, void *pixels);","title":"Renderbuffer"},{"location":"GLES/Framebuffer%20Object/#gl2ext_angle","text":"void glGetFramebufferAttachmentParameterivRobustANGLE (GLenum target, GLenum attachment, GLenum pname, GLsizei bufSize, GLsizei length, GLint params); void glGetFramebufferParameterivRobustANGLE (GLenum target, GLenum pname, GLsizei bufSize, GLsizei length, GLint params);","title":"gl2Ext_ANGLE"},{"location":"GLES/Framebuffer%20Object/#summary","text":"Framebuffer \u5206\u9ed8\u8ba4 fb \u548c \u7528\u6237\u5b9a\u4e49 fb, \u540e\u8005\u88ab\u79f0\u4e3a Framebuffer Objects (FBOs) OpenGL \u4f1a\u5728 Context\u4e2d\u521b\u5efa Default Framebuffer \u7528\u6765\u8868\u793a\u4e00\u4e2a \u7a97\u53e3 \u6216 \u663e\u793a\u8bbe\u5907. \u4e0d\u80fd\u4fee\u6539\u5176 attachments FBOs \u5173\u8054 Textures \u6216 Renderbuffers, \u4e0d\u4f1a\u76f4\u63a5\u53ef\u89c1 FBOs\u4e2d\u7f13\u5b58(Buffers)\u53c8\u79f0\u4f5c \"attachment points\"","title":"Summary"},{"location":"GLES/Framebuffer%20Object/#bind-points","text":"void glBindFramebuffer(GL_FRAMEBUFFER, mFramebuffer) bind framebuffers to the context \u4e24\u79cd\u7c7b\u578b: GL_DRAW_FRAMEBUFFER \u548c GL_READ_FRAMEBUFFER , \u800c GL_FRAMEBUFFER \u8868\u793a\u4e8c\u8005\u90fd\u6709.","title":"Bind points"},{"location":"GLES/Framebuffer%20Object/#colorspace","text":"\u4e24\u79cd: linear RGB \u548c sRGB \u542f\u7528 / \u7981\u7528 GL_FRAMEBUFFER_SRGB \u6765\u63a7\u5236\u662f\u5426\u8fdb\u884c\u8f6c\u6362 ### Blending blending \u4f5c\u7528\u4e8e\u76ee\u6807\u56fe\u50cf\u7684 sRGB colorspace, \u56e0\u6b64\u82e5 GL_FRAMEBUFFER_SRGB \u672a\u542f\u7528, \u65e0\u6cd5\u6b63\u5e38\u5de5\u4f5c.","title":"Colorspace:"},{"location":"GLES/Framebuffer%20Object/#read","text":"void glReadBuffer (GLenum mode );","title":"Read"},{"location":"GLES/Framebuffer%20Object/#draw","text":"void glDrawBuffersEXT(attachmentCount, drawBuffers[GL_COLOR_ATTACHMENT0_EXT, ...]); attachmentCount can only be as large as GL_MAX_DRAW_BUFFERS ( Windows ANGLE\u4e0a\u7ea6\u4e3a 34852) Draw \u64cd\u4f5c\u4f1a\u5bf9 fb \u8bbe\u7f6e\u4e00\u79cd state, \u56e0\u6b64\u53ef\u7528\u53ea draw \u4e00\u6b21.","title":"Draw"},{"location":"GLES/Framebuffer%20Object/#framebuffer","text":"Jump to navigation Jump to search A Framebuffer is a collection of buffers that can be used as the destination for rendering. OpenGL has two kinds of framebuffers: the Default Framebuffer , which is provided by the OpenGL Context ; and user-created framebuffers called Framebuffer Objects (FBOs). The buffers for default framebuffers are part of the context and usually represent a window or display device. The buffers for FBOs reference images from either Textures or Renderbuffers ; they are never directly visible. Note that the term \"buffer\" here refers to a specific location in the framebuffer. An image may or may not be associated with a particular buffer in a framebuffer. Buffers in FBOs are also called \"attachment points\"; they're the locations where images can be attached. Default framebuffers cannot change their buffer attachments, but a particular default framebuffer may not have images associated with certain buffers. For example the GL_BACK_RIGHT buffer will only have an image if the default framebuffer is double-buffered and uses stereoscopic 3D. The default framebuffer's buffer names are separate from framebuffer object buffer names .","title":"Framebuffer"},{"location":"GLES/Framebuffer%20Object/#bind-points_1","text":"glBindFramebuffer is used to bind framebuffers to the context. They can be bound to one of two targets: GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER. The draw framebuffer is used as the destination for rendering, clearing , and other writing operations. The read framebuffer is used as the source for reading operations. Binding to the GL_FRAMEBUFFER target is equivalent to binding that framebuffer to both GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER. Note that most other uses of GL_FRAMEBUFFER mean the draw framebuffer; this is the case when it means both.","title":"Bind points"},{"location":"GLES/Framebuffer%20Object/#colorspace_1","text":"Color Image Formats can be in a linear or sRGB colorspace . Normally, sRGB images perform color correction, such that texture reads from them will always convert them to linear RGB. However, when writing values from a Fragment Shader to the image, a question arises: in what colorspace are the values written by the shader? When the output buffer is linear RGB, the answer is assumed to be linear. But if we are writing to an sRGB image, it is entirely reasonable for a shader to want to write linear values which will be automatically converted to sRGB for storage. However, at other times, it is entirely reasonable for a shader to want to write sRGB values directly, and therefore want to store the written provided without any conversion. The fragment shader is not given the power to control this, as the controls for it depend partially on state external to the fragment shader (namely, the colorspace of the image buffer being written to). Instead, this is made a global state value. When GL_FRAMEBUFFER_SRGB is disabled , the system assumes that the color written by the fragment shader is in whatever colorspace the image it is being written to is. Therefore, no colorspace correction is performed. If GL_FRAMEBUFFER_SRGB is enabled however, then if the destination image is in the sRGB colorspace (as queried through glGetFramebufferAttachmentParameter(GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING) ), then it will assume the shader's output is in the linear RGB colorspace. It will therefore convert the output from linear RGB to sRGB. Note that Logical Operations are disabled for any sRGB buffer when GL_FRAMEBUFFER_SRGB is enabled.","title":"Colorspace"},{"location":"GLES/Framebuffer%20Object/#blending","text":"Blending interacts with sRGB colorspace in destination images. The sRGB colorspace is non-linear, and thus linearly interpolating between non-linear colorspaces generally leads to colors that are not accurate. The correct operation is to linearize the destination color, do the blending in linear RGB space, and then convert back to sRGB. If GL_FRAMEBUFFER_SRGB is enabled , then the appropriate correction will be done for sRGB destination images. That is, if a particular destination image is sRGB, the destination value will be converted to linear RGB, blended with the linear source value via the current blend functions, and the result will be converted back to sRGB for writing to the destination image. If GL_FRAMEBUFFER_SRGB is not enabled, then it is assumed that the user knows what they are doing. Therefore, blending against an sRGB image when GL_FRAMEBUFFER_SRGB is not enabled will not perform any of the above correction. This is generally not a good idea, even if you are writing sRGB color values from the Fragment Shader .","title":"Blending"},{"location":"GLES/Framebuffer%20Object/#read-color-buffer","text":"Certain OpenGL operations can read pixel data from the color buffer. These operations are: Direct pixel reads . Framebuffer blits . Copies from the framebuffer to textures , which could also be during mutable storage specification . All of these operations read from the framebuffer bound to GL_READ_FRAMEBUFFER. However, because framebuffers often have multiple color images that could be read from, there is a selector in the framebuffer object that defines which color buffer these operations read from. The framebuffer's read buffer is specified by: void glReadBuffer (GLenum mode ); Warning: This sets the read buffer for the framebuffer currently bound to GL_READ_FRAMEBUFFER. So make sure that the framebuffer you want is bound to that buffer. The read buffer is part of the framebuffer's state, so each framebuffer will remember its previously set read buffer. If the GL_READ_FRAMEBUFFER is the default framebuffer, then mode must be the name of a color buffer name . It may be one of the multiple buffer aliases , which degrades as specified. If the read framebuffer is an FBO, then mode must be GL_COLOR_ATTACHMENT i , for one of the legal values of i . mode may also be GL_NONE, which indicates that no reading can be performed from color buffers on this framebuffer. Any attempt to perform read operations will fail with an error (GL_INVALID_OPERATION).","title":"Read color buffer"},{"location":"GLES/Framebuffer%20Object/#draw-color-buffers","text":"Much as with the read buffer, framebuffers have a set of draw buffers where writing operations write to. Unlike the read buffer, there are multiple draw buffers, which allow writing operations to write values to different buffers in the framebuffer at the same time. Fragment shader color outputs allow a fragment shader to define fragment color outputs, for example. The framebuffer therefore has a table of draw buffers, which are indexed on the half-open range [0, GL_MAX_DRAW_BUFFERS). The framebuffer's table maps from these indices to named color buffers in the framebuffer. To set this mapping table (on the framebuffer bound to GL_DRAW_FRAMEBUFFER), use this function: void glDrawBuffers( GLsizei n, const GLenum *bufs ); This function sets the first n entries of the mapping table. The indices of the enumerators correspond to the output fragment colors from the fragment shader. Thus, n can only be as large as GL_MAX_DRAW_BUFFERS. The entries in the bufs array are enumerators referring to buffer names in the framebuffer. All entries after n are set to GL_NONE. The values in bufs must name specific color buffers in the framebuffer. For the default framebuffer, buffer names cannot be the one of the multiple buffer aliases ; you must use GL_BACK_LEFT rather than GL_BACK. Framebuffer Objects use GL_COLOR_ATTACHMENT i buffer names. An entry in the list can be GL_NONE, which means that the output (if the shader outputs a value for it at all) is discarded. If you are only setting up one draw buffer, you may use glDrawBuffer . It takes one enumeration value and sets the fragment color 0 to draw to that buffer. All other draw buffer indices are set to GL_NONE. For the default framebuffer, the multiple buffer aliases can be used (though it is not advised to do so). They will cause drawing operations to write to all of the specified buffers. The state set by glDrawBuffers is part of the state of the framebuffer. So you can generally set this up once and leave it set.","title":"Draw color buffers"},{"location":"GLES/Framebuffer%20Object/#buffer-clearing","text":"Images in a framebuffer may be cleared to a particular value. Clearing is affected by the following state: The Write Mask . Only unmasked components will be changed by a clear call. The Pixel Ownership Test , which matters only for the Default Framebuffer . Pixels that are not owned will have undefined values. The Scissor Test . If the scissor test is enabled, then the clear region is bounded by the scissor rectangle. The Rasterizer Discard state. If discarding is enabled, all clearing commands are ignored. Framebuffer image clearing commands are Rendering Commands . Therefore, they are affected by Conditional Rendering . Clearing can be done in one of two ways. The old way can clear multiple buffers in a single call: void glClear (GLbitfield mask ); This will clear the current GL_DRAW_FRAMEBUFFER. The mask field is a bitmask that defines which kinds of buffers to clear. It can be a combination of GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT. When GL_COLOR_BUFFER_BIT is cleared, all of the active draw buffers are cleared. The values that the given buffers are cleared to are set beforehand via OpenGL state functions: void glClearColor (GLfloat red , GLfloat green , GLfloat blue , GLfloat alpha ); void glClearDepth (GLdouble depth ); void glClearStencil (GLint s ); These functions set the values that will be used to clear the appropriate buffers. Note that you must call these before calling glClear . depth will be clamped to the range [0, 1]. s , the stencil index, will be clamped to the valid integer range for the stencil buffer's image format. Note that glClearColor takes floating-point values. Yet it is perfectly legal to use integer Image Formats for images in framebuffers. Attempting to clear integer buffers with floating-point data will not work. Instead, you must clear each buffer individually with this suite of functions: void glClearBufferiv (GLenum buffer , GLint drawBuffer , const GLint * value ); void glClearBufferuiv (GLenum buffer , GLint drawBuffer , const GLuint * value ); void glClearBufferfv (GLenum buffer , GLint drawBuffer , const GLfloat * value ); void glClearBufferfi (GLenum buffer , GLint drawBuffer , GLfloat depth , GLint stencil ); This will clear a buffer in the current GL_DRAW_FRAMEBUFFER. buffer is either GL_COLOR, GL_DEPTH, GL_DEPTH_STENCIL, or GL_STENCIL. When clearing the GL_DEPTH buffer, you must use glClearBufferfv , and the depth value (a single float) will be clamped to [0, 1]. When using GL_STENCIL, you must use glClearBufferiv , and the stencil value (a single integer) will be clamped to the range of the stencil image format's precision. When using GL_DEPTH_STENCIL, you must use glClearBufferfi , and depth and stencil will each be clamped as appropriate for their value. The drawbuffer specifies the draw buffer index for the buffer to clear. This is only relevant if the buffer is GL_COLOR; in all other cases it must be 0. Note that this is the draw buffer index , not one of the GL_COLOR_ATTACHMENT i values. So 0 represents whatever the first buffer named by glDrawBuffers is. Note: Confusingly, buffer may also be one of the default framebuffer's multiple buffer aliases . In this case, drawbuffer specifies an additional draw buffer to clear, and all of the buffers will be cleared. You should probably avoid using them. Warning: Buffer clearing, of all forms , will respect the current state of the Scissor Test . If you wish to clear the entire buffer, you must make sure the scissor test is disabled.","title":"Buffer clearing"},{"location":"GLES/Framebuffer%20Object/#buffer-reading","text":"Pixel data can be read from a framebuffer and stored into CPU memory (or a buffer object ). The framebuffer being read from is the framebuffer bound to GL_READ_FRAMEBUFFER; remember that binding to GL_FRAMEBUFFER binds to both the read and the draw. To begin reading pixels, use this command: void glReadPixels (GLint x , GLint y , GLsizei width , GLsizei height , GLenum format , GLenum type , GLvoid * data ) This performs a Pixel Transfer read operation; as such, the destination data can be an offset into a Pixel Buffer Object if you so desire. Framebuffers have many buffers to read from. Which buffer is read from depends in part on the format parameter. If format is GL_DEPTH_COMPONENT, then the depth buffer is read from. If it is GL_STENCIL_INDEX, then the stencil buffer is read from. If it is GL_DEPTH_STENCIL then both the depth and stencil buffers are read from. If format is a color format, then the current read color buffer is used. If the current read buffer is GL_NONE, then a GL_INVALID_OPERATION error will occur.","title":"Buffer reading"},{"location":"GLES/Framebuffer%20Object/#read-color-clamping","text":"The color values read via glReadPixels may be clamped to the [0, 1] range. This is controlled via this function: void glClampColor (GLenum target , GLenum clamp ); The target must be GL_CLAMP_READ_COLOR. The clamp can be set to one of the following: GL_TRUE: Clamping is always on, no matter what the format or type parameters of the read pixels call. GL_FALSE: Clamping is always off, no matter what the format or type parameters of the read pixels call. GL_FIXED_ONLY: Clamping is only on if the type of the image being read is a normalized signed or unsigned value. Note that the clamping behavior is not framebuffer object state. It will not be stored with the current framebuffer.","title":"Read color clamping"},{"location":"GLES/Framebuffer%20Object/#invalidation","text":"The contents of a framebuffer can be invalidated. This means that the application is no longer interested in whatever pixel data happens to be stored in any images in that part of the framebuffer. Invalidation is useful, as it allows the implementation to allocate new memory if asynchronous commands are working with the previously invalidated framebuffer images. In particular, invalidation after asynchronous pixel reads are quite useful. To invalidate the framebuffer as a whole, the following function is used: glInvalidateFramebuffer (GLenum target , GLsizei numAttachments , const GLenum * attachments ) The framebuffer bound to target will be invalidated. The specific images in the framebuffer to be invalidated are specified by the array attachments , which must have numAttachments entries in it. The entries in the array must be names of specific images in the framebuffer. For user-created Framebuffer Objects, these must be the names of one of the available attachment points. For the default framebuffer, the names can be one of the images in the default framebuffer ; none of the color buffer's aliases work here. The default framebuffer can also use the names GL_COLOR (which means GL_BACK_LEFT if double-buffered and GL_FRONT_LEFT if single-bufferred. Instead of invalidating whole sets of images in the framebuffer, a portion of the framebuffer can be invalidated instead: glInvalidateSubFramebuffer (GLenum target , GLsizei numAttachments , const GLenum * attachments , GLint x , GLint y , GLint width , GLint height ) The x , y , width , and height parameters specify a rectangular region of the specified images to invalidate. After invalidation, the contents of pixels stored in those areas are undefined. You can clear them to a set value after invalidation.","title":"Invalidation"},{"location":"GLES/Framebuffer%20Object/#blitting","text":"Framebuffers can be bound to two separate targets with glBindFramebuffer : GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER. Binding to GL_FRAMEBUFFER is equivalent to binding the framebuffer to both. The reason for the separation of these targets is to allow data in one framebuffer to be blitted to another framebuffer. A blit operation is a special form of copy operation; it copies a rectangular area of pixels from one framebuffer to another. This function also has some very specific properties with regard to multisampling . Framebuffer blitting commands are considered Rendering Commands . Therefore, they are affected by Conditional Rendering . However, they do not invoke most parts of the Rendering Pipeline . Blits are affected by the Scissor Test (they always use viewport index 0) as well as the Pixel Ownership Test , but are not affected by the Write Mask , Depth Test or any other parts of the rendering pipeline. You bind the source framebuffer to GL_READ_FRAMEBUFFER, then bind the destination framebuffer to GL_DRAW_FRAMEBUFFER. The read framebuffer is the source of the blit, and the draw framebuffer is the destination. The read and draw framebuffers can be the same. After binding the framebuffers, you call this function: void glBlitFramebuffer( GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); The pixels in the rectangular area specified by the src values are copied to the rectangular area specified by the dst values. The mask parameter is a bitfield that specifies which kinds of buffers you want copied: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT, or some combination. The filter parameter specifies how you want filtering performed if the two rectangles are not the same size. One thing to keep in mind is this: when using GL_COLOR_BUFFER_BIT, the only colors read will come from the read color buffer in the read FBO, specified by glReadBuffer . The colors written will only go to the draw color buffers in the write FBO, specified by glDrawBuffers . If multiple draw buffers are specified, then multiple color buffers are updated with the same data. The depth and stencil buffers of the source framebuffers are blitted to the depth and stencil buffers of the destination if the mask specifies them. Note that it is perfectly valid to blit from or to the Default Framebuffer . If one (or both) of the framebuffers is a layered framebuffer (blitting fails if the framebuffers are incomplete. So they will be either all layered or all not layered), then blitting happens rather oddly. Only layer 0 will be read and only layer 0 will be written . This is true even if both the read and draw FBOs are layered and have the same number of layers. If you want to blit other layers, you will have to bind those layers to some other FBO and blit from/to that new FBO.","title":"Blitting"},{"location":"GLES/Framebuffer%20Object/#format-considerations","text":"Blitting is not the same as performing a pixel transfer or a texture copy . The conversion between source and destination format is more limited. Blitting depth and stencil buffers works as expected: values are converted from one bitdepth to the other as needed. Conversion between color formats is different. A blit operation can only convert between formats within 3 groups. Signed integral and unsigned integral formats make up two groups, with all normalized and floating-point formats making up the third. Thus, it is legal to blit from an GL_RGB8 buffer to a GL_RGB32F and vice versa. But it is not legal to blit a GL_RGB8 from or to a GL_RGBI8 format image. The data during blitting is converted according to simple rules. Blitting from a floating-point format to a normalized integer format will cause clamping, either to [0, 1] for unsigned normalized or [-1, 1] for signed normalized.","title":"Format Considerations"},{"location":"GLES/Framebuffer%20Object/#multisampling-considerations","text":"Multisampling is supported with the Default Framebuffer (through WGL/GLX_multisample) and/or Framebuffer Objects (through multisampled renderbuffers or textures , where supported). As explained in the article on Multisampling , a multisampled buffer must be resolved into a single sample before it can be displayed. When the default framebuffer uses multisampling, this resolving operation is automatic, occurring during framebuffer swapping (though reading from the framebuffer can cause it to happen anyway). Each framebuffer has a specific number of samples; for Framebuffer Objects , they cannot be framebuffer-complete if all of the attached images do not have the same number of samples. A sample count of zero represents a framebuffer that is not multisampled. If you perform a blit operation and and at least one of the framebuffers is multisampled, then the source and destination sizes must be the same. That is, you cannot do multisampled blits and rescaling at the same time. If you blit between two framebuffers with the same number of samples, the copy is done directly; the destination buffer gets the same information the source had. It is an error to blit between framebuffers with different numbers of samples, unless one of the framebuffers has zero samples. Blitting from a non-multisampled framebuffer to a multisampled framebuffer causes all of samples in a pixel of the draw framebuffer to get the same value from the corresponding pixel in the read framebuffer. Blitting from a multisampled framebuffer to a non-multisampled framebuffer performs a multisample resolve operation, computing the value of a draw framebuffer's pixel from all of the samples in the corresponding pixel of the read framebuffer. This explicit resolve operation is very useful when wanting to display multisampled buffers. As with all multisample behavior, none of this works at all unless glEnable(GL_MULTISAMPLE) is in effect (which is the default).","title":"Multisampling Considerations"},{"location":"GLES/GLES%20Draw%20APIs/","text":"Drawing Commands For all the functions in this section: mode: GL_POINTS GL_LINE_STRIP GL_LINE_LOOP GL_LINES GL_TRIANGLE_STRIP GL_TRIANGLE_FAN GL_TRIANGLES 3.2 \u65b0\u589e\u56db\u4e2a\u90bb\u63a5\u6a21\u5f0f (Adjacency mode) GL_LINE_STRIP_ADJACENCY GL_LINES_ADJACENCY GL_TRIANGLE_STRIP_ADJACENCY GL_TRIANGLES_ADJACENCY type: UNSIGNED_{BYTE, SHORT, INT} void DrawArrays (enum mode, int first, sizei count); void DrawElements (enum mode, sizei count, enum type, const void *indices); void DrawRangeElements (enum mode, uint start, uint end, sizei count, enum type, const void *indices); void DrawArraysInstanced (enum mode, int first, sizei count, sizei instancecount); void DrawElementsInstanced (enum mode, sizei count, enum type, const void *indices, sizei instancecount); void DrawArraysIndirect (enum mode, const void *indirect); void DrawElementsIndirect (enum mode, enum type, const void *indirect); void DrawElementsBaseVertex (enum mode, sizei count, enum type, const void *indices, int basevertex); void DrawRangeElementsBaseVertex (enum mode, uint start, uint end, sizei count, enum type, const void *indices, int basevertex); void DrawElementsInstancedBaseVertex (enum mode, sizei count,enum type, const void *indices, sizei instancecount, int basevertex); Drawing Commands 2.0 3.0 3.1 3.2 Note glDrawArrays \u221a glDrawElements \u221a glDrawRangeElements \u221a glDrawArraysInstanced \u221a glDrawElementsInstanced \u221a glDrawArraysIndirect \u221a glDrawElementsIndirect \u221a glDrawElementsBaseVertex \u221a glDrawRangeElementsBaseVertex \u221a glDrawElementsInstancedBaseVertex \u221a Mode \u7ed8\u5236mode\u5373\u901a\u8fc7\u7ed8\u5236\u6a21\u5f0f\u6765\u6307\u5b9a \u56fe\u5143 \u7684\u7ed8\u5236\u6a21\u5f0f. \u6e32\u67d3\u7684\u65f6\u5019\u9700\u8981\u6307\u5b9a\u4e00\u4e2a\u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\u3002 TODO \u4f7f\u7528\u573a\u666f\u53ca\u5bf9\u6bd4. 1. \u70b9 \u5bf9\u5e94\u7684\u6a21\u5f0f\u4e3a GL_POINTS \uff0c\u5373\u5728\u6bcf\u4e2a\u9876\u70b9\u4f4d\u7f6e\u7ed8\u5236\u4e00\u4e2a\u70b9\u3002OpenGL ES \u4e2d\u7ed8\u5236\u7684\u70b9\u5b9e\u5219\u662f\u4e00\u4e2a\u65b9\u5757\uff0c\u9876\u70b9\u4f4d\u7f6e\u662f\u65b9\u5757\u7684\u4e2d\u5fc3\u70b9\uff0c\u8fb9\u957f\u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7531\u5185\u5efa\u53d8\u91cf gl_PointSize \u6307\u5b9a\u3002 \u70b9\u7684\u5c3a\u5bf8\u5927\u5c0f\u8303\u56f4\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u65b9\u5f0f\u83b7\u53d6\uff1a GLfloat pointSizeRange[2]; glGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, pointSizeRange); 12 \u5982\u679c\u6211\u4eec\u60f3\u81ea\u5b9a\u4e49\u70b9\u7684\u5916\u5f62\uff0c\u901a\u5e38\u53ef\u4ee5\u4f7f\u7528\u7eb9\u7406\u3002\u4e00\u4e2a\u4f7f\u7528\u7eb9\u7406\u7684\u7247\u6bb5\u7740\u8272\u5668\u793a\u4f8b\u5982\u4e0b\uff1a #version 300 es precision mediump float; uniform sampler2D u_TextureUnit; layout(location = 0) out vec4 outColor; void main() { outColor = texture2D(u_TextureUnit, gl_PointCoord); } 123456789 \u8fd9\u6837\u6211\u4eec\u5728\u5916\u9762\u7ed9 u_TextureUnit \u6307\u5b9a\u7eb9\u7406\u7684 id \u5373\u53ef\uff0c\u5173\u4e8e\u7eb9\u7406\u7684\u76f8\u5173\u4f7f\u7528\u540e\u7eed\u6587\u7ae0\u518d\u4ecb\u7ecd\u3002 \u8fd8\u6709\u4e0a\u4f8b\u4e2d\u6211\u4eec\u4f7f\u7528\u5230\u4e86\u4e00\u4e2a\u5185\u5efa\u53d8\u91cf gl_PointCoord \uff0c\u5b83\u53ea\u5728\u7ed8\u5236\u70b9\u7cbe\u7075\u65f6\u53ef\u4ee5\u4f7f\u7528\uff0c\u63cf\u8ff0\u4e86\u8fd9\u4e2a\u70b9\u5185\u90e8\u7684\u5750\u6807\u7a7a\u95f4\uff0c\u5176\u5de6\u4e0a\u89d2\u4e3a (0, 0)\uff0c\u53f3\u4e0b\u89d2\u4e3a (1, 1)\u3002 2. \u76f4\u7ebf \u5bf9\u5e94\u7684\u6a21\u5f0f\u4e3a GL_LINES \u3001 GL_LINE_LOOP \u3001 GL_LINE_STRIP \uff0c\u7528\u6307\u5b9a\u7684\u9876\u70b9\u7ed8\u5236\u76f8\u5e94\u7684\u7ebf\u6bb5\u3002 \u5982\u56fe\uff0c\u5047\u8bbe\u6307\u5b9a\u7684\u9876\u70b9\u5750\u6807\u4e3a (v0, v1, v2, v3)\uff0c\u90a3\u4e48 GL_LINES \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1) \u548c (v2, v3) \u8fd9\u4e24\u6761\u7ebf\u6bb5 GL_LINE_STRIP \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1)\u3001(v1, v2) \u548c (v2, v3) \u4e09\u6761\u7ebf\u6bb5 GL_LINE_LOOP \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1)\u3001(v1, v2)\u3001(v2, v3) \u548c (v3, v0) \u56db\u6761\u7ebf\u6bb5 \u7ebf\u6bb5\u7684\u5bbd\u5ea6\u4f7f\u7528\u5982\u4e0b API \u6307\u5b9a\uff1a /** * @param width \u7ebf\u5bbd\uff0c\u4ee5\u50cf\u7d20\u6570\u8868\u793a\uff0c\u9ed8\u8ba4\u7684\u5bbd\u5ea6\u4e3a 1.0 */ void glLineWidth(GLFloat width); 1234 \u6307\u5b9a\u7684\u7ebf\u5bbd\u5c06\u88ab OpenGL \u8bb0\u4f4f\uff0c\u76f4\u5230\u7531\u5e94\u7528\u7a0b\u5e8f\u66f4\u65b0\u3002 \u652f\u6301\u7684\u7ebf\u5bbd\u8303\u56f4\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u65b9\u5f0f\u83b7\u53d6\uff1a GLfloat lineWidthRange[2]; glGetFloatv(GL_ALIASED_LINE_WIDTH_RANGE, lineWidthRange); 12 3. \u4e09\u89d2\u5f62 \u5bf9\u5e94\u7684\u6a21\u5f0f\u4e3a GL_TRIANGLES \u3001 GL_TRIANGLE_STRIP \u3001 GL_TRIANGLE_FAN \u3002\u4e09\u89d2\u5f62\u56fe\u5143\u53ef\u8c13\u662f\u6700\u5e38\u4f7f\u7528\u7684\u4e86\u3002 \u5982\u56fe\uff0c\u5047\u8bbe\u6307\u5b9a\u7684\u9876\u70b9\u5750\u6807\u4e3a\u4e0a\u56fe\u6240\u793a\uff0c\u90a3\u4e48 GL_TRIANGLES \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1, v2) \u548c (v3, v4, v5) \u8fd9\u4e24\u4e2a\u4e09\u89d2\u5f62\u3002 GL_TRIANGLE_STRIP \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1, v2)\u3001(v2, v1, v3) \uff08\u6ce8\u610f\u987a\u5e8f\uff09\u548c (v2, v3, v4) \u4e09\u4e2a\u4e09\u89d2\u5f62\u3002 GL_TRIANGLE_FAN \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1, v2)\u3001(v0, v2, v3) \u548c (v0, v3, v4) \u4e09\u4e2a\u4e09\u89d2\u5f62\u3002 4. 3.2 \u65b0\u589e Adjacent Mode IndexType type: UNSIGNED_BYTE, UNSIGNED_SHORT, UNSIGNED_INT 2.0 \u57fa\u7840\u7ed8\u5236 /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param first \u8d77\u59cb\u4f4d\u7f6e * @param count \u9876\u70b9\u6570\u91cf */ void glDrawArrays(GLenum mode, GLint first, GLsizei count); /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param count \u9876\u70b9\u6570\u91cf * @param type \u5143\u7d20\u7c7b\u578b\uff0c\u6709\uff1aGL_UNSIGNED_BYTE\u3001GL_UNSIGNED_SHORT\u3001GL_UNSIGNED_INT * @param indices \u5143\u7d20\u7d22\u5f15\u6570\u7ec4 */ void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void *indices); \u533a\u522b \u9996\u5148\uff0c\u8fd9\u4e24\u4e2a\u51fd\u6570\u7684\u4f5c\u7528\u90fd\u662f\u4ece\u4e00\u4e2a\u6570\u636e\u6570\u7ec4\u4e2d\u63d0\u53d6\u6570\u636e\uff0c\u7136\u540e\u6e32\u67d3\u56fe\u5143\u3002 \u533a\u522b\u5728\u4e8e\uff1a glDrawArrays \u662f\u76f4\u63a5\u7ed8\u5236\u771f\u5b9e\u7684\u9876\u70b9\u6570\u636e\uff0c\u800c glDrawElements \u662f\u6309\u7167\u6307\u5b9a\u7684\u7d22\u5f15\u987a\u5e8f\u53d6\u51fa\u771f\u5b9e\u6570\u636e\u518d\u7ed8\u5236\u3002 \u4e8e\u662f\u5bf9\u4e8e\u9876\u70b9\u5b58\u5728\u5171\u4eab\u7684\u573a\u666f\u65f6\uff0c\u4f7f\u7528 glDrawElements \u5bf9\u4e8e\u91cd\u590d\u7684\u9876\u70b9\u6570\u636e\u53ea\u9700\u8981\u4f20\u8f93\u4e00\u4efd\u6570\u636e\uff0c\u7ed8\u5236\u65f6\u901a\u8fc7\u7d22\u5f15\u53cd\u590d\u7684\u83b7\u53d6\u5176\u503c\uff0c\u6700\u7ec8\u964d\u4f4e\u5185\u5b58\u5360\u7528\u548c\u5185\u5b58\u5e26\u5bbd\u9700\u6c42\u3002 3.0 \u65b0\u589e\u7684\u7ed8\u5236\u63a5\u53e3: Instanced \u591a\u5b9e\u4f8b\u6e32\u67d3 \u5728 OpenGL ES 3.0 \u4e2d\u65b0\u589e\u4e86\u51e0\u4e2a\u7ed8\u5236\u56fe\u5143\u7684\u63a5\u53e3\u3002 1. glDrawRangeElements /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param start \u8d77\u59cb\u7d22\u5f15\u4f4d\u7f6e * @param end \u7ed3\u675f\u7d22\u5f15\u4f4d\u7f6e * @param count \u9876\u70b9\u6570\u91cf * @param type \u5143\u7d20\u7c7b\u578b\uff0c\u6709\uff1aGL_UNSIGNED_BYTE\u3001GL_UNSIGNED_SHORT\u3001GL_UNSIGNED_INT * @param indices \u5143\u7d20\u7d22\u5f15\u6570\u7ec4 */ void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices); \u76f8\u6bd4\u4e8e glDrawElements \u63a5\u53e3\uff0c\u5b83\u65b0\u589e\u4e86 start \uff0c end \u4e24\u4e2a\u53c2\u6570\uff0c\u7528\u6765\u6307\u5b9a\u4f7f\u7528\u7684\u6570\u636e\u6570\u7ec4\u7684\u8d77\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e\u3002\u5176\u4f59\u533a\u522b\u4e0d\u5927\u3002 glDrawElementsInstanced \u548c glDrawArraysInstanced \u591a\u5b9e\u4f8b\u6e32\u67d3 Learn GL: \u591a\u5b9e\u4f8b\u6e32\u67d3 \u573a\u666f \u5047\u8bbe\u4f60\u6709\u4e00\u4e2a\u7ed8\u5236\u4e86\u5f88\u591a\u6a21\u578b\u7684\u573a\u666f\uff0c\u800c\u5927\u90e8\u5206\u7684\u6a21\u578b\u5305\u542b\u7684\u662f\u540c\u4e00\u7ec4\u9876\u70b9\u6570\u636e\uff0c\u53ea\u4e0d\u8fc7\u8fdb\u884c\u7684\u662f\u4e0d\u540c\u7684\u4e16\u754c\u7a7a\u95f4\u53d8\u6362\u3002\u60f3\u8c61\u4e00\u4e2a\u5145\u6ee1\u8349\u7684\u573a\u666f\uff1a\u6bcf\u6839\u8349\u90fd\u662f\u4e00\u4e2a\u5305\u542b\u51e0\u4e2a\u4e09\u89d2\u5f62\u7684\u5c0f\u6a21\u578b\u3002\u4f60\u53ef\u80fd\u4f1a\u9700\u8981\u7ed8\u5236\u5f88\u591a\u6839\u8349\uff0c\u6700\u7ec8\u5728\u6bcf\u5e27\u4e2d\u4f60\u53ef\u80fd\u4f1a\u9700\u8981\u6e32\u67d3\u4e0a\u5343\u6216\u8005\u4e0a\u4e07\u6839\u8349\u3002\u56e0\u4e3a\u6bcf\u4e00\u6839\u8349\u4ec5\u4ec5\u662f\u7531\u51e0\u4e2a\u4e09\u89d2\u5f62\u6784\u6210\uff0c\u6e32\u67d3\u51e0\u4e4e\u662f\u77ac\u95f4\u5b8c\u6210\u7684\uff0c\u4f46\u4e0a\u5343\u4e2a\u6e32\u67d3\u51fd\u6570\u8c03\u7528\u5374\u4f1a\u6781\u5927\u5730\u5f71\u54cd\u6027\u80fd\u3002 \u5982\u679c\u6211\u4eec\u80fd\u591f\u5c06\u6570\u636e\u4e00\u6b21\u6027\u53d1\u9001\u7ed9GPU\uff0c\u7136\u540e\u4f7f\u7528\u4e00\u4e2a\u7ed8\u5236\u51fd\u6570\u8ba9OpenGL\u5229\u7528\u8fd9\u4e9b\u6570\u636e\u7ed8\u5236\u591a\u4e2a\u7269\u4f53\uff0c\u5c31\u4f1a\u66f4\u65b9\u4fbf\u4e86\u3002\u8fd9\u5c31\u662f\u5b9e\u4f8b\u5316(Instancing)\u3002 \u5b9e\u4f8b\u5316\uff08instancing) \u5b9e\u4f8b\u5316\u8fd9\u9879\u6280\u672f\u80fd\u591f\u8ba9\u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u6e32\u67d3\u8c03\u7528\u6765\u7ed8\u5236\u591a\u4e2a\u7269\u4f53\uff0c\u6765\u8282\u7701\u6bcf\u6b21\u7ed8\u5236\u7269\u4f53\u65f6CPU -> GPU\u7684\u901a\u4fe1\uff0c\u5b83\u53ea\u9700\u8981\u4e00\u6b21\u5373\u53ef\u3002 \u5982\u679c\u60f3\u4f7f\u7528\u5b9e\u4f8b\u5316\u6e32\u67d3\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5c06glDrawArrays\u548cglDrawElements\u7684\u6e32\u67d3\u8c03\u7528\u5206\u522b\u6539\u4e3aglDrawArraysInstanced\u548cglDrawElementsInstanced\u5c31\u53ef\u4ee5\u4e86\u3002\u8fd9\u4e9b\u6e32\u67d3\u51fd\u6570\u7684 \u5b9e\u4f8b\u5316 \u7248\u672c\u9700\u8981\u4e00\u4e2a\u989d\u5916\u7684\u53c2\u6570\uff0c\u53eb\u505a\u5b9e\u4f8b\u6570\u91cf(Instance Count)\uff0c\u5b83\u80fd\u591f\u8bbe\u7f6e\u6211\u4eec\u9700\u8981\u6e32\u67d3\u7684\u5b9e\u4f8b\u4e2a\u6570\u3002\u8fd9\u6837\u6211\u4eec\u53ea\u9700\u8981\u5c06\u5fc5\u987b\u7684\u6570\u636e\u53d1\u9001\u5230GPU\u4e00\u6b21\uff0c\u7136\u540e\u4f7f\u7528\u4e00\u6b21\u51fd\u6570\u8c03\u7528\u544a\u8bc9GPU\u5b83\u5e94\u8be5\u5982\u4f55\u7ed8\u5236\u8fd9\u4e9b\u5b9e\u4f8b\u3002GPU\u5c06\u4f1a\u76f4\u63a5\u6e32\u67d3\u8fd9\u4e9b\u5b9e\u4f8b\uff0c\u800c\u4e0d\u7528\u4e0d\u65ad\u5730\u4e0eCPU\u8fdb\u884c\u901a\u4fe1\u3002 glDrawElementsInstanced \u548c glDrawArraysInstanced glDrawArraysInstanced \u51fd\u6570\u662f glDrawArrays \u7684\u591a\u5b9e\u4f8b\u7248\u672c\uff0c\u53c2\u6570\u5b8c\u5168\u7b49\u4ef7\uff0c\u53ea\u662f\u591a\u4e86\u4e2ainstance count\uff0c\u8be5\u53c2\u6570\u7528\u4e8e\u8bbe\u7f6e\u6e32\u67d3\u5b9e\u4f8b\u4e2a\u6570\u3002\u4f8b\u5982\u6211\u4eec\u60f3\u8981\u4e00\u6b21\u6279\u91cf\u7ed8\u5236 100 \u4e2a\u76f8\u4f3c\u7684\u56fe\u5143\uff0c\u8fd9\u4e2a\u503c\u5bf9\u5e94\u5c31\u4f20 100\u3002 /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param first \u8d77\u59cb\u4f4d\u7f6e: \u4ece\u6570\u7ec4\u7f13\u5b58\u4e2d\u7684\u54ea\u4e00\u4f4d\u5f00\u59cb\u7ed8\u5236\uff0c\u4e00\u822c\u4e3a0\u3002 * @param count \u9876\u70b9\u6570\u91cf * @param instancecount \u7ed8\u5236\u7684\u5b9e\u4f8b\u6570\u91cf */ void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount); glDrawElementsInstanced \u662f glDrawElements \u7684\u591a\u5b9e\u4f8b\u7248\u672c\uff0c\u540c\u6837\u53ea\u662f\u591a\u4e86\u4e2ainstance count\u53c2\u6570\u800c\u5df2\uff0c\u540c\u6837\u662f\u7528\u4e8e\u8bbe\u7f6e\u6e32\u67d3\u5b9e\u4f8b\u4e2a\u6570\u3002 /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param count \u9876\u70b9\u6570\u91cf * @param type \u5143\u7d20\u7c7b\u578b\uff0c\u6709\uff1aGL_UNSIGNED_BYTE\u3001GL_UNSIGNED_SHORT\u3001GL_UNSIGNED_INT * @param indices \u5143\u7d20\u7d22\u5f15\u7684\u6307\u9488 * @param instancecount \u7ed8\u5236\u7684\u56fe\u5143\u5b9e\u4f8b\u6570\u91cf */ void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount); \u53d8\u91cf\u63a7\u5236 gl_InstanceID \u8fd9\u4e2a\u51fd\u6570\u672c\u8eab\u5e76\u6ca1\u6709\u4ec0\u4e48\u7528\u3002\u6e32\u67d3\u540c\u4e00\u4e2a\u7269\u4f53\u4e00\u5343\u6b21\u5bf9\u6211\u4eec\u5e76\u6ca1\u6709\u4ec0\u4e48\u7528\u5904\uff0c\u6bcf\u4e2a\u7269\u4f53\u90fd\u662f\u5b8c\u5168\u76f8\u540c\u7684\uff0c\u800c\u4e14\u8fd8\u5728\u540c\u4e00\u4e2a\u4f4d\u7f6e\u3002\u6211\u4eec\u53ea\u80fd\u770b\u89c1\u4e00\u4e2a\u7269\u4f53\uff01\u5904\u4e8e\u8fd9\u4e2a\u539f\u56e0\uff0cGLSL\u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u5d4c\u5165\u4e86\u53e6\u4e00\u4e2a\u5185\u5efa\u53d8\u91cf\uff0cgl_InstanceID\u3002 \u53d8\u91cf\u6570\u7ec4\u9700\u8981\u4f7f\u7528 uniform \u6570\u7ec4\u8f6c\u5165GLSL. \u4f8b\u5982\u4e0b\u4f8b\u4e2d \u4f7f\u7528\u4e86\u5927\u5c0f100\u7684 uniform\u6570\u7ec4\u8f6c\u5165 offset: gl_InstanceID \u5f88\u65b9\u4fbf, \u4f46\u4f1a\u5f88\u5feb\u8fbe\u5230uniform\u6570\u636e\u5927\u5c0f \u4e0a\u9650 , \u9700\u8981\u6ce8\u610f\u6570\u91cf. #version 330 core layout (location = 0) in vec2 aPos; layout (location = 1) in vec3 aColor; out vec3 fColor; uniform vec2 offsets[100]; void main() { vec2 offset = offsets[gl_InstanceID]; gl_Position = vec4(aPos + offset, 0.0, 1.0); fColor = aColor; } Instanced Array \u7531\u4e8e\u5b9e\u4f8b\u592a\u591a\u65f6, \u4f7f\u7528 gl_InstanceID \u5bb9\u6613\u4f7funiform \u8d85\u9650, \u5b83\u7684\u4e00\u4e2a\u4ee3\u66ff\u65b9\u6848\u662f\u5b9e\u4f8b\u5316\u6570\u7ec4(Instanced Array)\uff0c\u5b83\u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u9876\u70b9\u5c5e\u6027\uff08\u80fd\u591f\u8ba9\u6211\u4eec\u50a8\u5b58\u66f4\u591a\u7684\u6570\u636e\uff09\uff0c\u4ec5\u5728\u9876\u70b9\u7740\u8272\u5668\u6e32\u67d3\u4e00\u4e2a\u65b0\u7684\u5b9e\u4f8b\u65f6\u624d\u4f1a\u66f4\u65b0\u3002 #version 330 core layout (location = 0) in vec2 aPos; layout (location = 1) in vec3 aColor; layout (location = 2) in vec2 aOffset; out vec3 fColor; void main() { gl_Position = vec4(aPos + aOffset, 0.0, 1.0); fColor = aColor; } 3. \u591a\u5b9e\u4f8b\u6e32\u67d3\u9876\u70b9\u5c5e\u6027\u63a7\u5236 \u591a\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027, \u591a\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027\uff0c\u4e0e\u5176\u4ed6\u7684\u9876\u70b9\u5c5e\u6027\u662f\u7c7b\u4f3c\u7684\u3002\u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684\u58f0\u660e\u548c\u6570\u636e\u914d\u7f6e\u65b9\u6cd5\u5b8c\u5168\u4e00\u81f4. \u5b83\u4eec\u53ef\u4ee5\u4f7f\u7528 APIs: glGetAttribLocation \u67e5\u8be2 glVertexAttribPointer \u8bbe\u7f6e glEnableVertexAttribArray \u542f\u7528 glDisableVertexAttribArray \u7981\u7528 \u591a\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027\u7684\u552f\u4e00\u7684\u533a\u522b\u5c31\u662f \u6b63\u5e38\u7684\u9876\u70b9\u5c5e\u6027: \u9488\u5bf9\u7684\u662f\u5355\u4e00\u9876\u70b9 \u591a\u5b9e\u4f8b\u9876\u70b9\u5c5e\u6027: \u9488\u5bf9\u7684\u662f\u4e00\u4e2a\u56fe\u5143\u5b9e\u4f8b\u3002 \u7b80\u5355\u7684\u7406\u89e3\u5c31\u662f\u9876\u70b9\u7740\u8272\u5668\u7684\u8f93\u5165\u6b63\u5e38\u60c5\u51b5\u662f\u4e00\u4e2a\u9876\u70b9\u5c5e\u6027\u5bf9\u5e94\u4e00\u4e2a\u9876\u70b9\uff0c\u800c\u6240\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027\u662f\u4e00\u4e2a\u5c5e\u6027\u5bf9\u4ee5\u4e00\u4e2a\u56fe\u5143\uff08\u56fe\u5143\u4e2d\u6240\u6709\u7684\u9876\u70b9\u7684\u8fd9\u4e00\u6761\u5c5e\u6027\u5171\u7528\u540c\u4e00\u4e2a\u6570\u636e\uff09\uff0c\u5373\u6bcf\u4e2a\u5b9e\u4f8b\u66f4\u65b0\u4e00\u6b21\u8fd9\u4e2a\u5c5e\u6027\u7684\u6570\u636e\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e2a\u529f\u80fd\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u51fd\u6570\uff1a /** * @param index \u5bf9\u5e94\u7740\u8272\u5668\u4e2d\u7684\u5b9e\u4f8b\u53d8\u91cf\u7684\u7d22\u5f15, \u4f8b\u5982 offset \u3002 * @param divisor \u8868\u793a\u9876\u70b9\u5c5e\u6027\u7684\u66f4\u65b0\u9891\u7387\uff0c\u6bcf\u9694\u591a\u5c11\u4e2a\u5b9e\u4f8b\u5c06\u91cd\u65b0\u8bbe\u7f6e\u5b9e\u4f8b\u7684\u8be5\u5c5e\u6027\uff0c * \u4f8b\u5982\u8bbe\u7f6e\u4e3a 1 \u90a3\u4e48\u6bcf\u4e2a\u5b9e\u4f8b\u7684\u5c5e\u6027\u90fd\u4e0d\u4e00\u6837\uff0c \u8bbe\u7f6e\u4e3a2\u5219\u6bcf\u4e24\u4e2a\u5b9e\u4f8b\u76f8\u540c\u3002 * \u5982\u679cdivisor\u7684\u503c\u662f0\uff0c\u8868\u793a\u591a\u5b9e\u4f8b\u7279\u6027\u88ab\u7981\u7528 */ void glVertexAttribDivisor (GLuint index, GLuint divisor) 4. \u4ee3\u7801\u5b9e\u4f8b \u521b\u5efa\u7740\u8272\u5668: \u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u6211\u4eec\u589e\u52a0\u4e00\u4e2a\u504f\u79fb\u91cf\u7684\u5c5e\u6027\uff08attribute vec3 offset\uff09 \u5728\u6bcf\u6b21\u7ed8\u5236\u4e4b\u540e\u5b83\u7684\u503c\u4f1a\u53d1\u751f\u504f\u79fb\u3002\u901a\u8fc7 glVertexAttribDivisor \u6765\u8bbe\u7f6e\u5982\u4f55\u504f\u79fb\u3002 fragment shader precision mediump float; uniform sampler2D image; varying vec2 vTexcoord; void main() { gl_FragColor = texture2D(image, vTexcoord); } vertex shader attribute vec3 position; attribute vec3 offset; //\u504f\u79fb\u91cf attribute vec2 texcoord; varying vec2 vTexcoord; void main() { gl_Position = vec4(position + offset, 1.0); vTexcoord = texcoord; } \u8bbe\u7f6e\u9876\u70b9\u5c5e\u6027\u3002\u8bbe\u7f6e\u9876\u70b9\u5c5e\u6027\u65b9\u4fbf\u6211\u4eec\u8fdb\u884c\u7eb9\u7406\u8d34\u56fe\u3002 - (void)setupVBO { _vertCount = 6; GLfloat vertices[] = { -0.5f, 1.0f, 0.0f, 1.0f, 0.0f, // \u53f3\u4e0a -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, // \u53f3\u4e0b -1.0f, 0.5f, 0.0f, 0.0f, 1.0f, // \u5de6\u4e0b -1.0f, 0.5f, 0.0f, 0.0f, 1.0f, // \u5de6\u4e0b -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, // \u5de6\u4e0a -0.5f, 1.0f, 0.0f, 1.0f, 0.0f, // \u53f3\u4e0a }; // \u521b\u5efaVBO _vbo = createVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW, sizeof(vertices), vertices); // Vertex Attrib: position glEnableVertexAttribArray(glGetAttribLocation(_program, \"position\")); glVertexAttribPointer(glGetAttribLocation(_program, \"position\"), 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, NULL); // Vertex Attrib: texcoord glEnableVertexAttribArray(glGetAttribLocation(_program, \"texcoord\")); glVertexAttribPointer(glGetAttribLocation(_program, \"texcoord\"), 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, NULL+sizeof(GL_FLOAT)*3); } \u8bbe\u7f6e\u7eb9\u7406 \u901a\u8fc7\u8bfb\u53d6\u7eb9\u7406\u56fe\u7247\uff0c\u751f\u6210\u7eb9\u7406\u7f13\u5b58\u5bf9\u8c61\u3002 \u8bbe\u7f6e\u504f\u79fb\u91cf \u504f\u79fb\u91cf\u548c\u666e\u901a\u7684\u9876\u70b9\u6570\u636e\u4e00\u6837\u53ef\u4ee5\u4f7f\u7528VBO\u6765\u5b58\u50a8\u3002 \u6211\u4eec\u5e0c\u671b\u6bcf\u6b21\u7ed8\u5236\u9876\u70b9\u6570\u7ec4\u90fd\u53d1\u751f\u4e00\u5b9a\u7684\u504f\u79fb\uff0c\u603b\u5171\u53d1\u751f\u4e09\u6b21\u504f\u79fb\uff08gl_Position = vec4(position+offset, 1.0)\uff09\u3002\u8fd9\u6837\u6211\u4eec\u603b\u5171\u9700\u89819\u4e2aGLfloat\u7684\u7a7a\u95f4\u6765\u5b58\u50a8\u504f\u79fb\u6570\u636e\u3002 - (void)setupOffset { GLfloat vertices[] = { 0.1f, -0.1f, 0.0f, 0.7f, -0.7f, 0.0f, 1.3f, -1.3f, 0.0f, }; // \u521b\u5efaVBO _offsetVBO = createVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW, sizeof(vertices), vertices); glEnableVertexAttribArray(glGetAttribLocation(_program, \"offset\")); glVertexAttribPointer(glGetAttribLocation(_program, \"offset\"), 3, GL_FLOAT, GL_FALSE, 0, NULL); } \u7ed8\u5236 - (void)render { glClearColor(1.0, 1.0, 1.0, 1.0); glClear(GL_COLOR_BUFFER_BIT); glLineWidth(2.0); glViewport(0, 0, self.frame.size.width, self.frame.size.height); // \u6fc0\u6d3b\u7eb9\u7406 glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, _texture); glUniform1i(glGetUniformLocation(_program, \"image\"), 0); // \u6bcf\u6b21\u7ed8\u5236\u4e4b\u540e\uff0c\u5bf9offset\u8fdb\u884c1\u4e2a\u504f\u79fb glVertexAttribDivisor(glGetAttribLocation(_program, \"offset\"), 1); // \u7ed8\u5236 3 \u4e2a\u5b9e\u4f8b, \u6bcf\u4e2a\u5b9e\u4f8b\u5bf9\u5e94\u4e00\u4e2a offset vector glDrawArraysInstanced(GL_TRIANGLES, 0, _vertCount, 3); //\u5c06\u6307\u5b9a renderbuffer \u5448\u73b0\u5728\u5c4f\u5e55\u4e0a\uff0c\u5728\u8fd9\u91cc\u6211\u4eec\u6307\u5b9a\u7684\u662f\u524d\u9762\u5df2\u7ecf\u7ed1\u5b9a\u4e3a\u5f53\u524d renderbuffer \u7684\u90a3\u4e2a\uff0c\u5728 renderbuffer \u53ef\u4ee5\u88ab\u5448\u73b0\u4e4b\u524d\uff0c\u5fc5\u987b\u8c03\u7528renderbufferStorage:fromDrawable: \u4e3a\u4e4b\u5206\u914d\u5b58\u50a8\u7a7a\u95f4\u3002 [_context presentRenderbuffer:GL_RENDERBUFFER]; } \u590d\u6742\u70b9\u7684\u4f8b\u5b50 #version 330 core layout (location = 0) in vec3 aPos; layout (location = 2) in vec2 aTexCoords; layout (location = 3) in mat4 instanceMatrix; out vec2 TexCoords; uniform mat4 projection; uniform mat4 view; void main() { gl_Position = projection * view * instanceMatrix * vec4(aPos, 1.0); TexCoords = aTexCoords; } \u6211\u4eec\u4e0d\u518d\u4f7f\u7528\u6a21\u578buniform\u53d8\u91cf\uff0c\u6539\u4e3a\u4e00\u4e2amat4\u7684\u9876\u70b9\u5c5e\u6027\uff0c\u8ba9\u6211\u4eec\u80fd\u591f\u5b58\u50a8\u4e00\u4e2a\u5b9e\u4f8b\u5316\u6570\u7ec4\u7684\u53d8\u6362\u77e9\u9635\u3002\u7136\u800c\uff0c\u5f53\u6211\u4eec\u9876\u70b9\u5c5e\u6027\u7684\u7c7b\u578b\u5927\u4e8evec4\u65f6\uff0c\u5c31\u8981\u591a\u8fdb\u884c\u4e00\u6b65\u5904\u7406\u4e86\u3002\u9876\u70b9\u5c5e\u6027\u6700\u5927\u5141\u8bb8\u7684\u6570\u636e\u5927\u5c0f\u7b49\u4e8e\u4e00\u4e2avec4\u3002\u56e0\u4e3a\u4e00\u4e2amat4\u672c\u8d28\u4e0a\u662f4\u4e2avec4\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u8fd9\u4e2a\u77e9\u9635\u9884\u75594\u4e2a\u9876\u70b9\u5c5e\u6027\u3002\u56e0\u4e3a\u6211\u4eec\u5c06\u5b83\u7684\u4f4d\u7f6e\u503c\u8bbe\u7f6e\u4e3a3\uff0c\u77e9\u9635\u6bcf\u4e00\u5217\u7684\u9876\u70b9\u5c5e\u6027\u4f4d\u7f6e\u503c\u5c31\u662f3\u30014\u30015\u548c6\u3002 \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u8fd94\u4e2a\u9876\u70b9\u5c5e\u6027\u8bbe\u7f6e\u5c5e\u6027\u6307\u9488\uff0c\u5e76\u5c06\u5b83\u4eec\u8bbe\u7f6e\u4e3a\u5b9e\u4f8b\u5316\u6570\u7ec4\uff1a // \u9876\u70b9\u7f13\u51b2\u5bf9\u8c61 unsigned int buffer; glGenBuffers(1, &buffer); glBindBuffer(GL_ARRAY_BUFFER, buffer); glBufferData(GL_ARRAY_BUFFER, amount * sizeof(glm::mat4), &modelMatrices[0], GL_STATIC_DRAW); for(unsigned int i = 0; i < rock.meshes.size(); i++) { unsigned int VAO = rock.meshes[i].VAO; glBindVertexArray(VAO); // \u9876\u70b9\u5c5e\u6027 GLsizei vec4Size = sizeof(glm::vec4); glEnableVertexAttribArray(3); glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)0); glEnableVertexAttribArray(4); glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(vec4Size)); glEnableVertexAttribArray(5); glVertexAttribPointer(5, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(2 * vec4Size)); glEnableVertexAttribArray(6); glVertexAttribPointer(6, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(3 * vec4Size)); glVertexAttribDivisor(3, 1); glVertexAttribDivisor(4, 1); glVertexAttribDivisor(5, 1); glVertexAttribDivisor(6, 1); glBindVertexArray(0); } \u6ce8\u610f\u8fd9\u91cc\u6211\u4eec\u5c06Mesh\u7684VAO\u4ece\u79c1\u6709\u53d8\u91cf\u6539\u4e3a\u4e86\u516c\u6709\u53d8\u91cf\uff0c\u8ba9\u6211\u4eec\u80fd\u591f\u8bbf\u95ee\u5b83\u7684\u9876\u70b9\u6570\u7ec4\u5bf9\u8c61\u3002\u8fd9\u5e76\u4e0d\u662f\u6700\u597d\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u53ea\u662f\u4e3a\u4e86\u914d\u5408\u672c\u5c0f\u8282\u7684\u4e00\u4e2a\u7b80\u5355\u7684\u6539\u52a8\u3002\u9664\u6b64\u4e4b\u5916\u4ee3\u7801\u5c31\u5e94\u8be5\u5f88\u6e05\u695a\u4e86\u3002\u6211\u4eec\u544a\u8bc9\u4e86OpenGL\u5e94\u8be5\u5982\u4f55\u89e3\u91ca\u6bcf\u4e2a\u7f13\u51b2\u9876\u70b9\u5c5e\u6027\u7684\u7f13\u51b2\uff0c\u5e76\u4e14\u544a\u8bc9\u5b83\u8fd9\u4e9b\u9876\u70b9\u5c5e\u6027\u662f\u5b9e\u4f8b\u5316\u6570\u7ec4\u3002 \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u518d\u6b21\u4f7f\u7528\u7f51\u683c\u7684VAO\uff0c\u8fd9\u4e00\u6b21\u4f7f\u7528glDrawElementsInstanced\u8fdb\u884c\u7ed8\u5236\uff1a // \u7ed8\u5236\u5c0f\u884c\u661f instanceShader.use(); for(unsigned int i = 0; i < rock.meshes.size(); i++) { glBindVertexArray(rock.meshes[i].VAO); glDrawElementsInstanced( GL_TRIANGLES, rock.meshes[i].indices.size(), GL_UNSIGNED_INT, 0, amount ); } 3.1 \u65b0\u589e\u7684\u7ed8\u5236\u63a5\u53e3: Indirect DrawArraysIndirect \u548c DrawElementsIndirect void DrawArraysIndirect (enum mode, const void *indirect); void DrawElementsIndirect (enum mode, enum type, const void *indirect); 3.2 \u65b0\u589e\u7684\u7ed8\u5236\u63a5\u53e3: BaseVertex void DrawElementsBaseVertex (enum mode, sizei count, enum type, const void *indices, int basevertex); void DrawRangeElementsBaseVertex (enum mode, uint start, uint end, sizei count, enum type, const void *indices, int basevertex); void DrawElementsInstancedBaseVertex (enum mode, sizei count,enum type, const void *indices, sizei instancecount, int basevertex);","title":"Drawing Commands"},{"location":"GLES/GLES%20Draw%20APIs/#drawing-commands","text":"For all the functions in this section: mode: GL_POINTS GL_LINE_STRIP GL_LINE_LOOP GL_LINES GL_TRIANGLE_STRIP GL_TRIANGLE_FAN GL_TRIANGLES 3.2 \u65b0\u589e\u56db\u4e2a\u90bb\u63a5\u6a21\u5f0f (Adjacency mode) GL_LINE_STRIP_ADJACENCY GL_LINES_ADJACENCY GL_TRIANGLE_STRIP_ADJACENCY GL_TRIANGLES_ADJACENCY type: UNSIGNED_{BYTE, SHORT, INT} void DrawArrays (enum mode, int first, sizei count); void DrawElements (enum mode, sizei count, enum type, const void *indices); void DrawRangeElements (enum mode, uint start, uint end, sizei count, enum type, const void *indices); void DrawArraysInstanced (enum mode, int first, sizei count, sizei instancecount); void DrawElementsInstanced (enum mode, sizei count, enum type, const void *indices, sizei instancecount); void DrawArraysIndirect (enum mode, const void *indirect); void DrawElementsIndirect (enum mode, enum type, const void *indirect); void DrawElementsBaseVertex (enum mode, sizei count, enum type, const void *indices, int basevertex); void DrawRangeElementsBaseVertex (enum mode, uint start, uint end, sizei count, enum type, const void *indices, int basevertex); void DrawElementsInstancedBaseVertex (enum mode, sizei count,enum type, const void *indices, sizei instancecount, int basevertex); Drawing Commands 2.0 3.0 3.1 3.2 Note glDrawArrays \u221a glDrawElements \u221a glDrawRangeElements \u221a glDrawArraysInstanced \u221a glDrawElementsInstanced \u221a glDrawArraysIndirect \u221a glDrawElementsIndirect \u221a glDrawElementsBaseVertex \u221a glDrawRangeElementsBaseVertex \u221a glDrawElementsInstancedBaseVertex \u221a","title":"Drawing Commands"},{"location":"GLES/GLES%20Draw%20APIs/#mode","text":"\u7ed8\u5236mode\u5373\u901a\u8fc7\u7ed8\u5236\u6a21\u5f0f\u6765\u6307\u5b9a \u56fe\u5143 \u7684\u7ed8\u5236\u6a21\u5f0f. \u6e32\u67d3\u7684\u65f6\u5019\u9700\u8981\u6307\u5b9a\u4e00\u4e2a\u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\u3002 TODO \u4f7f\u7528\u573a\u666f\u53ca\u5bf9\u6bd4.","title":"Mode"},{"location":"GLES/GLES%20Draw%20APIs/#1","text":"\u5bf9\u5e94\u7684\u6a21\u5f0f\u4e3a GL_POINTS \uff0c\u5373\u5728\u6bcf\u4e2a\u9876\u70b9\u4f4d\u7f6e\u7ed8\u5236\u4e00\u4e2a\u70b9\u3002OpenGL ES \u4e2d\u7ed8\u5236\u7684\u70b9\u5b9e\u5219\u662f\u4e00\u4e2a\u65b9\u5757\uff0c\u9876\u70b9\u4f4d\u7f6e\u662f\u65b9\u5757\u7684\u4e2d\u5fc3\u70b9\uff0c\u8fb9\u957f\u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7531\u5185\u5efa\u53d8\u91cf gl_PointSize \u6307\u5b9a\u3002 \u70b9\u7684\u5c3a\u5bf8\u5927\u5c0f\u8303\u56f4\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u65b9\u5f0f\u83b7\u53d6\uff1a GLfloat pointSizeRange[2]; glGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, pointSizeRange); 12 \u5982\u679c\u6211\u4eec\u60f3\u81ea\u5b9a\u4e49\u70b9\u7684\u5916\u5f62\uff0c\u901a\u5e38\u53ef\u4ee5\u4f7f\u7528\u7eb9\u7406\u3002\u4e00\u4e2a\u4f7f\u7528\u7eb9\u7406\u7684\u7247\u6bb5\u7740\u8272\u5668\u793a\u4f8b\u5982\u4e0b\uff1a #version 300 es precision mediump float; uniform sampler2D u_TextureUnit; layout(location = 0) out vec4 outColor; void main() { outColor = texture2D(u_TextureUnit, gl_PointCoord); } 123456789 \u8fd9\u6837\u6211\u4eec\u5728\u5916\u9762\u7ed9 u_TextureUnit \u6307\u5b9a\u7eb9\u7406\u7684 id \u5373\u53ef\uff0c\u5173\u4e8e\u7eb9\u7406\u7684\u76f8\u5173\u4f7f\u7528\u540e\u7eed\u6587\u7ae0\u518d\u4ecb\u7ecd\u3002 \u8fd8\u6709\u4e0a\u4f8b\u4e2d\u6211\u4eec\u4f7f\u7528\u5230\u4e86\u4e00\u4e2a\u5185\u5efa\u53d8\u91cf gl_PointCoord \uff0c\u5b83\u53ea\u5728\u7ed8\u5236\u70b9\u7cbe\u7075\u65f6\u53ef\u4ee5\u4f7f\u7528\uff0c\u63cf\u8ff0\u4e86\u8fd9\u4e2a\u70b9\u5185\u90e8\u7684\u5750\u6807\u7a7a\u95f4\uff0c\u5176\u5de6\u4e0a\u89d2\u4e3a (0, 0)\uff0c\u53f3\u4e0b\u89d2\u4e3a (1, 1)\u3002","title":"1. \u70b9"},{"location":"GLES/GLES%20Draw%20APIs/#2","text":"\u5bf9\u5e94\u7684\u6a21\u5f0f\u4e3a GL_LINES \u3001 GL_LINE_LOOP \u3001 GL_LINE_STRIP \uff0c\u7528\u6307\u5b9a\u7684\u9876\u70b9\u7ed8\u5236\u76f8\u5e94\u7684\u7ebf\u6bb5\u3002 \u5982\u56fe\uff0c\u5047\u8bbe\u6307\u5b9a\u7684\u9876\u70b9\u5750\u6807\u4e3a (v0, v1, v2, v3)\uff0c\u90a3\u4e48 GL_LINES \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1) \u548c (v2, v3) \u8fd9\u4e24\u6761\u7ebf\u6bb5 GL_LINE_STRIP \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1)\u3001(v1, v2) \u548c (v2, v3) \u4e09\u6761\u7ebf\u6bb5 GL_LINE_LOOP \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1)\u3001(v1, v2)\u3001(v2, v3) \u548c (v3, v0) \u56db\u6761\u7ebf\u6bb5 \u7ebf\u6bb5\u7684\u5bbd\u5ea6\u4f7f\u7528\u5982\u4e0b API \u6307\u5b9a\uff1a /** * @param width \u7ebf\u5bbd\uff0c\u4ee5\u50cf\u7d20\u6570\u8868\u793a\uff0c\u9ed8\u8ba4\u7684\u5bbd\u5ea6\u4e3a 1.0 */ void glLineWidth(GLFloat width); 1234 \u6307\u5b9a\u7684\u7ebf\u5bbd\u5c06\u88ab OpenGL \u8bb0\u4f4f\uff0c\u76f4\u5230\u7531\u5e94\u7528\u7a0b\u5e8f\u66f4\u65b0\u3002 \u652f\u6301\u7684\u7ebf\u5bbd\u8303\u56f4\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u65b9\u5f0f\u83b7\u53d6\uff1a GLfloat lineWidthRange[2]; glGetFloatv(GL_ALIASED_LINE_WIDTH_RANGE, lineWidthRange); 12","title":"2. \u76f4\u7ebf"},{"location":"GLES/GLES%20Draw%20APIs/#3","text":"\u5bf9\u5e94\u7684\u6a21\u5f0f\u4e3a GL_TRIANGLES \u3001 GL_TRIANGLE_STRIP \u3001 GL_TRIANGLE_FAN \u3002\u4e09\u89d2\u5f62\u56fe\u5143\u53ef\u8c13\u662f\u6700\u5e38\u4f7f\u7528\u7684\u4e86\u3002 \u5982\u56fe\uff0c\u5047\u8bbe\u6307\u5b9a\u7684\u9876\u70b9\u5750\u6807\u4e3a\u4e0a\u56fe\u6240\u793a\uff0c\u90a3\u4e48 GL_TRIANGLES \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1, v2) \u548c (v3, v4, v5) \u8fd9\u4e24\u4e2a\u4e09\u89d2\u5f62\u3002 GL_TRIANGLE_STRIP \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1, v2)\u3001(v2, v1, v3) \uff08\u6ce8\u610f\u987a\u5e8f\uff09\u548c (v2, v3, v4) \u4e09\u4e2a\u4e09\u89d2\u5f62\u3002 GL_TRIANGLE_FAN \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1, v2)\u3001(v0, v2, v3) \u548c (v0, v3, v4) \u4e09\u4e2a\u4e09\u89d2\u5f62\u3002","title":"3. \u4e09\u89d2\u5f62"},{"location":"GLES/GLES%20Draw%20APIs/#4-32-adjacent-mode","text":"","title":"4. 3.2 \u65b0\u589e Adjacent Mode"},{"location":"GLES/GLES%20Draw%20APIs/#indextype","text":"type: UNSIGNED_BYTE, UNSIGNED_SHORT, UNSIGNED_INT","title":"IndexType"},{"location":"GLES/GLES%20Draw%20APIs/#20","text":"/** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param first \u8d77\u59cb\u4f4d\u7f6e * @param count \u9876\u70b9\u6570\u91cf */ void glDrawArrays(GLenum mode, GLint first, GLsizei count); /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param count \u9876\u70b9\u6570\u91cf * @param type \u5143\u7d20\u7c7b\u578b\uff0c\u6709\uff1aGL_UNSIGNED_BYTE\u3001GL_UNSIGNED_SHORT\u3001GL_UNSIGNED_INT * @param indices \u5143\u7d20\u7d22\u5f15\u6570\u7ec4 */ void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void *indices); \u533a\u522b \u9996\u5148\uff0c\u8fd9\u4e24\u4e2a\u51fd\u6570\u7684\u4f5c\u7528\u90fd\u662f\u4ece\u4e00\u4e2a\u6570\u636e\u6570\u7ec4\u4e2d\u63d0\u53d6\u6570\u636e\uff0c\u7136\u540e\u6e32\u67d3\u56fe\u5143\u3002 \u533a\u522b\u5728\u4e8e\uff1a glDrawArrays \u662f\u76f4\u63a5\u7ed8\u5236\u771f\u5b9e\u7684\u9876\u70b9\u6570\u636e\uff0c\u800c glDrawElements \u662f\u6309\u7167\u6307\u5b9a\u7684\u7d22\u5f15\u987a\u5e8f\u53d6\u51fa\u771f\u5b9e\u6570\u636e\u518d\u7ed8\u5236\u3002 \u4e8e\u662f\u5bf9\u4e8e\u9876\u70b9\u5b58\u5728\u5171\u4eab\u7684\u573a\u666f\u65f6\uff0c\u4f7f\u7528 glDrawElements \u5bf9\u4e8e\u91cd\u590d\u7684\u9876\u70b9\u6570\u636e\u53ea\u9700\u8981\u4f20\u8f93\u4e00\u4efd\u6570\u636e\uff0c\u7ed8\u5236\u65f6\u901a\u8fc7\u7d22\u5f15\u53cd\u590d\u7684\u83b7\u53d6\u5176\u503c\uff0c\u6700\u7ec8\u964d\u4f4e\u5185\u5b58\u5360\u7528\u548c\u5185\u5b58\u5e26\u5bbd\u9700\u6c42\u3002","title":"2.0 \u57fa\u7840\u7ed8\u5236"},{"location":"GLES/GLES%20Draw%20APIs/#30-instanced","text":"\u5728 OpenGL ES 3.0 \u4e2d\u65b0\u589e\u4e86\u51e0\u4e2a\u7ed8\u5236\u56fe\u5143\u7684\u63a5\u53e3\u3002","title":"3.0 \u65b0\u589e\u7684\u7ed8\u5236\u63a5\u53e3: Instanced \u591a\u5b9e\u4f8b\u6e32\u67d3"},{"location":"GLES/GLES%20Draw%20APIs/#1-gldrawrangeelements","text":"/** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param start \u8d77\u59cb\u7d22\u5f15\u4f4d\u7f6e * @param end \u7ed3\u675f\u7d22\u5f15\u4f4d\u7f6e * @param count \u9876\u70b9\u6570\u91cf * @param type \u5143\u7d20\u7c7b\u578b\uff0c\u6709\uff1aGL_UNSIGNED_BYTE\u3001GL_UNSIGNED_SHORT\u3001GL_UNSIGNED_INT * @param indices \u5143\u7d20\u7d22\u5f15\u6570\u7ec4 */ void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices); \u76f8\u6bd4\u4e8e glDrawElements \u63a5\u53e3\uff0c\u5b83\u65b0\u589e\u4e86 start \uff0c end \u4e24\u4e2a\u53c2\u6570\uff0c\u7528\u6765\u6307\u5b9a\u4f7f\u7528\u7684\u6570\u636e\u6570\u7ec4\u7684\u8d77\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e\u3002\u5176\u4f59\u533a\u522b\u4e0d\u5927\u3002","title":"1. glDrawRangeElements"},{"location":"GLES/GLES%20Draw%20APIs/#gldrawelementsinstanced-gldrawarraysinstanced","text":"","title":"glDrawElementsInstanced \u548c glDrawArraysInstanced"},{"location":"GLES/GLES%20Draw%20APIs/#_1","text":"Learn GL: \u591a\u5b9e\u4f8b\u6e32\u67d3","title":"\u591a\u5b9e\u4f8b\u6e32\u67d3"},{"location":"GLES/GLES%20Draw%20APIs/#_2","text":"\u5047\u8bbe\u4f60\u6709\u4e00\u4e2a\u7ed8\u5236\u4e86\u5f88\u591a\u6a21\u578b\u7684\u573a\u666f\uff0c\u800c\u5927\u90e8\u5206\u7684\u6a21\u578b\u5305\u542b\u7684\u662f\u540c\u4e00\u7ec4\u9876\u70b9\u6570\u636e\uff0c\u53ea\u4e0d\u8fc7\u8fdb\u884c\u7684\u662f\u4e0d\u540c\u7684\u4e16\u754c\u7a7a\u95f4\u53d8\u6362\u3002\u60f3\u8c61\u4e00\u4e2a\u5145\u6ee1\u8349\u7684\u573a\u666f\uff1a\u6bcf\u6839\u8349\u90fd\u662f\u4e00\u4e2a\u5305\u542b\u51e0\u4e2a\u4e09\u89d2\u5f62\u7684\u5c0f\u6a21\u578b\u3002\u4f60\u53ef\u80fd\u4f1a\u9700\u8981\u7ed8\u5236\u5f88\u591a\u6839\u8349\uff0c\u6700\u7ec8\u5728\u6bcf\u5e27\u4e2d\u4f60\u53ef\u80fd\u4f1a\u9700\u8981\u6e32\u67d3\u4e0a\u5343\u6216\u8005\u4e0a\u4e07\u6839\u8349\u3002\u56e0\u4e3a\u6bcf\u4e00\u6839\u8349\u4ec5\u4ec5\u662f\u7531\u51e0\u4e2a\u4e09\u89d2\u5f62\u6784\u6210\uff0c\u6e32\u67d3\u51e0\u4e4e\u662f\u77ac\u95f4\u5b8c\u6210\u7684\uff0c\u4f46\u4e0a\u5343\u4e2a\u6e32\u67d3\u51fd\u6570\u8c03\u7528\u5374\u4f1a\u6781\u5927\u5730\u5f71\u54cd\u6027\u80fd\u3002 \u5982\u679c\u6211\u4eec\u80fd\u591f\u5c06\u6570\u636e\u4e00\u6b21\u6027\u53d1\u9001\u7ed9GPU\uff0c\u7136\u540e\u4f7f\u7528\u4e00\u4e2a\u7ed8\u5236\u51fd\u6570\u8ba9OpenGL\u5229\u7528\u8fd9\u4e9b\u6570\u636e\u7ed8\u5236\u591a\u4e2a\u7269\u4f53\uff0c\u5c31\u4f1a\u66f4\u65b9\u4fbf\u4e86\u3002\u8fd9\u5c31\u662f\u5b9e\u4f8b\u5316(Instancing)\u3002","title":"\u573a\u666f"},{"location":"GLES/GLES%20Draw%20APIs/#instancing","text":"\u5b9e\u4f8b\u5316\u8fd9\u9879\u6280\u672f\u80fd\u591f\u8ba9\u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u6e32\u67d3\u8c03\u7528\u6765\u7ed8\u5236\u591a\u4e2a\u7269\u4f53\uff0c\u6765\u8282\u7701\u6bcf\u6b21\u7ed8\u5236\u7269\u4f53\u65f6CPU -> GPU\u7684\u901a\u4fe1\uff0c\u5b83\u53ea\u9700\u8981\u4e00\u6b21\u5373\u53ef\u3002 \u5982\u679c\u60f3\u4f7f\u7528\u5b9e\u4f8b\u5316\u6e32\u67d3\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5c06glDrawArrays\u548cglDrawElements\u7684\u6e32\u67d3\u8c03\u7528\u5206\u522b\u6539\u4e3aglDrawArraysInstanced\u548cglDrawElementsInstanced\u5c31\u53ef\u4ee5\u4e86\u3002\u8fd9\u4e9b\u6e32\u67d3\u51fd\u6570\u7684 \u5b9e\u4f8b\u5316 \u7248\u672c\u9700\u8981\u4e00\u4e2a\u989d\u5916\u7684\u53c2\u6570\uff0c\u53eb\u505a\u5b9e\u4f8b\u6570\u91cf(Instance Count)\uff0c\u5b83\u80fd\u591f\u8bbe\u7f6e\u6211\u4eec\u9700\u8981\u6e32\u67d3\u7684\u5b9e\u4f8b\u4e2a\u6570\u3002\u8fd9\u6837\u6211\u4eec\u53ea\u9700\u8981\u5c06\u5fc5\u987b\u7684\u6570\u636e\u53d1\u9001\u5230GPU\u4e00\u6b21\uff0c\u7136\u540e\u4f7f\u7528\u4e00\u6b21\u51fd\u6570\u8c03\u7528\u544a\u8bc9GPU\u5b83\u5e94\u8be5\u5982\u4f55\u7ed8\u5236\u8fd9\u4e9b\u5b9e\u4f8b\u3002GPU\u5c06\u4f1a\u76f4\u63a5\u6e32\u67d3\u8fd9\u4e9b\u5b9e\u4f8b\uff0c\u800c\u4e0d\u7528\u4e0d\u65ad\u5730\u4e0eCPU\u8fdb\u884c\u901a\u4fe1\u3002 glDrawElementsInstanced \u548c glDrawArraysInstanced glDrawArraysInstanced \u51fd\u6570\u662f glDrawArrays \u7684\u591a\u5b9e\u4f8b\u7248\u672c\uff0c\u53c2\u6570\u5b8c\u5168\u7b49\u4ef7\uff0c\u53ea\u662f\u591a\u4e86\u4e2ainstance count\uff0c\u8be5\u53c2\u6570\u7528\u4e8e\u8bbe\u7f6e\u6e32\u67d3\u5b9e\u4f8b\u4e2a\u6570\u3002\u4f8b\u5982\u6211\u4eec\u60f3\u8981\u4e00\u6b21\u6279\u91cf\u7ed8\u5236 100 \u4e2a\u76f8\u4f3c\u7684\u56fe\u5143\uff0c\u8fd9\u4e2a\u503c\u5bf9\u5e94\u5c31\u4f20 100\u3002 /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param first \u8d77\u59cb\u4f4d\u7f6e: \u4ece\u6570\u7ec4\u7f13\u5b58\u4e2d\u7684\u54ea\u4e00\u4f4d\u5f00\u59cb\u7ed8\u5236\uff0c\u4e00\u822c\u4e3a0\u3002 * @param count \u9876\u70b9\u6570\u91cf * @param instancecount \u7ed8\u5236\u7684\u5b9e\u4f8b\u6570\u91cf */ void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount); glDrawElementsInstanced \u662f glDrawElements \u7684\u591a\u5b9e\u4f8b\u7248\u672c\uff0c\u540c\u6837\u53ea\u662f\u591a\u4e86\u4e2ainstance count\u53c2\u6570\u800c\u5df2\uff0c\u540c\u6837\u662f\u7528\u4e8e\u8bbe\u7f6e\u6e32\u67d3\u5b9e\u4f8b\u4e2a\u6570\u3002 /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param count \u9876\u70b9\u6570\u91cf * @param type \u5143\u7d20\u7c7b\u578b\uff0c\u6709\uff1aGL_UNSIGNED_BYTE\u3001GL_UNSIGNED_SHORT\u3001GL_UNSIGNED_INT * @param indices \u5143\u7d20\u7d22\u5f15\u7684\u6307\u9488 * @param instancecount \u7ed8\u5236\u7684\u56fe\u5143\u5b9e\u4f8b\u6570\u91cf */ void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);","title":"\u5b9e\u4f8b\u5316\uff08instancing)"},{"location":"GLES/GLES%20Draw%20APIs/#_3","text":"","title":"\u53d8\u91cf\u63a7\u5236"},{"location":"GLES/GLES%20Draw%20APIs/#gl_instanceid","text":"\u8fd9\u4e2a\u51fd\u6570\u672c\u8eab\u5e76\u6ca1\u6709\u4ec0\u4e48\u7528\u3002\u6e32\u67d3\u540c\u4e00\u4e2a\u7269\u4f53\u4e00\u5343\u6b21\u5bf9\u6211\u4eec\u5e76\u6ca1\u6709\u4ec0\u4e48\u7528\u5904\uff0c\u6bcf\u4e2a\u7269\u4f53\u90fd\u662f\u5b8c\u5168\u76f8\u540c\u7684\uff0c\u800c\u4e14\u8fd8\u5728\u540c\u4e00\u4e2a\u4f4d\u7f6e\u3002\u6211\u4eec\u53ea\u80fd\u770b\u89c1\u4e00\u4e2a\u7269\u4f53\uff01\u5904\u4e8e\u8fd9\u4e2a\u539f\u56e0\uff0cGLSL\u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u5d4c\u5165\u4e86\u53e6\u4e00\u4e2a\u5185\u5efa\u53d8\u91cf\uff0cgl_InstanceID\u3002 \u53d8\u91cf\u6570\u7ec4\u9700\u8981\u4f7f\u7528 uniform \u6570\u7ec4\u8f6c\u5165GLSL. \u4f8b\u5982\u4e0b\u4f8b\u4e2d \u4f7f\u7528\u4e86\u5927\u5c0f100\u7684 uniform\u6570\u7ec4\u8f6c\u5165 offset: gl_InstanceID \u5f88\u65b9\u4fbf, \u4f46\u4f1a\u5f88\u5feb\u8fbe\u5230uniform\u6570\u636e\u5927\u5c0f \u4e0a\u9650 , \u9700\u8981\u6ce8\u610f\u6570\u91cf. #version 330 core layout (location = 0) in vec2 aPos; layout (location = 1) in vec3 aColor; out vec3 fColor; uniform vec2 offsets[100]; void main() { vec2 offset = offsets[gl_InstanceID]; gl_Position = vec4(aPos + offset, 0.0, 1.0); fColor = aColor; }","title":"gl_InstanceID"},{"location":"GLES/GLES%20Draw%20APIs/#instanced-array","text":"\u7531\u4e8e\u5b9e\u4f8b\u592a\u591a\u65f6, \u4f7f\u7528 gl_InstanceID \u5bb9\u6613\u4f7funiform \u8d85\u9650, \u5b83\u7684\u4e00\u4e2a\u4ee3\u66ff\u65b9\u6848\u662f\u5b9e\u4f8b\u5316\u6570\u7ec4(Instanced Array)\uff0c\u5b83\u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u9876\u70b9\u5c5e\u6027\uff08\u80fd\u591f\u8ba9\u6211\u4eec\u50a8\u5b58\u66f4\u591a\u7684\u6570\u636e\uff09\uff0c\u4ec5\u5728\u9876\u70b9\u7740\u8272\u5668\u6e32\u67d3\u4e00\u4e2a\u65b0\u7684\u5b9e\u4f8b\u65f6\u624d\u4f1a\u66f4\u65b0\u3002 #version 330 core layout (location = 0) in vec2 aPos; layout (location = 1) in vec3 aColor; layout (location = 2) in vec2 aOffset; out vec3 fColor; void main() { gl_Position = vec4(aPos + aOffset, 0.0, 1.0); fColor = aColor; }","title":"Instanced Array"},{"location":"GLES/GLES%20Draw%20APIs/#3_1","text":"\u591a\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027, \u591a\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027\uff0c\u4e0e\u5176\u4ed6\u7684\u9876\u70b9\u5c5e\u6027\u662f\u7c7b\u4f3c\u7684\u3002\u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684\u58f0\u660e\u548c\u6570\u636e\u914d\u7f6e\u65b9\u6cd5\u5b8c\u5168\u4e00\u81f4. \u5b83\u4eec\u53ef\u4ee5\u4f7f\u7528 APIs: glGetAttribLocation \u67e5\u8be2 glVertexAttribPointer \u8bbe\u7f6e glEnableVertexAttribArray \u542f\u7528 glDisableVertexAttribArray \u7981\u7528 \u591a\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027\u7684\u552f\u4e00\u7684\u533a\u522b\u5c31\u662f \u6b63\u5e38\u7684\u9876\u70b9\u5c5e\u6027: \u9488\u5bf9\u7684\u662f\u5355\u4e00\u9876\u70b9 \u591a\u5b9e\u4f8b\u9876\u70b9\u5c5e\u6027: \u9488\u5bf9\u7684\u662f\u4e00\u4e2a\u56fe\u5143\u5b9e\u4f8b\u3002 \u7b80\u5355\u7684\u7406\u89e3\u5c31\u662f\u9876\u70b9\u7740\u8272\u5668\u7684\u8f93\u5165\u6b63\u5e38\u60c5\u51b5\u662f\u4e00\u4e2a\u9876\u70b9\u5c5e\u6027\u5bf9\u5e94\u4e00\u4e2a\u9876\u70b9\uff0c\u800c\u6240\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027\u662f\u4e00\u4e2a\u5c5e\u6027\u5bf9\u4ee5\u4e00\u4e2a\u56fe\u5143\uff08\u56fe\u5143\u4e2d\u6240\u6709\u7684\u9876\u70b9\u7684\u8fd9\u4e00\u6761\u5c5e\u6027\u5171\u7528\u540c\u4e00\u4e2a\u6570\u636e\uff09\uff0c\u5373\u6bcf\u4e2a\u5b9e\u4f8b\u66f4\u65b0\u4e00\u6b21\u8fd9\u4e2a\u5c5e\u6027\u7684\u6570\u636e\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e2a\u529f\u80fd\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u51fd\u6570\uff1a /** * @param index \u5bf9\u5e94\u7740\u8272\u5668\u4e2d\u7684\u5b9e\u4f8b\u53d8\u91cf\u7684\u7d22\u5f15, \u4f8b\u5982 offset \u3002 * @param divisor \u8868\u793a\u9876\u70b9\u5c5e\u6027\u7684\u66f4\u65b0\u9891\u7387\uff0c\u6bcf\u9694\u591a\u5c11\u4e2a\u5b9e\u4f8b\u5c06\u91cd\u65b0\u8bbe\u7f6e\u5b9e\u4f8b\u7684\u8be5\u5c5e\u6027\uff0c * \u4f8b\u5982\u8bbe\u7f6e\u4e3a 1 \u90a3\u4e48\u6bcf\u4e2a\u5b9e\u4f8b\u7684\u5c5e\u6027\u90fd\u4e0d\u4e00\u6837\uff0c \u8bbe\u7f6e\u4e3a2\u5219\u6bcf\u4e24\u4e2a\u5b9e\u4f8b\u76f8\u540c\u3002 * \u5982\u679cdivisor\u7684\u503c\u662f0\uff0c\u8868\u793a\u591a\u5b9e\u4f8b\u7279\u6027\u88ab\u7981\u7528 */ void glVertexAttribDivisor (GLuint index, GLuint divisor)","title":"3. \u591a\u5b9e\u4f8b\u6e32\u67d3\u9876\u70b9\u5c5e\u6027\u63a7\u5236"},{"location":"GLES/GLES%20Draw%20APIs/#4","text":"\u521b\u5efa\u7740\u8272\u5668: \u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u6211\u4eec\u589e\u52a0\u4e00\u4e2a\u504f\u79fb\u91cf\u7684\u5c5e\u6027\uff08attribute vec3 offset\uff09 \u5728\u6bcf\u6b21\u7ed8\u5236\u4e4b\u540e\u5b83\u7684\u503c\u4f1a\u53d1\u751f\u504f\u79fb\u3002\u901a\u8fc7 glVertexAttribDivisor \u6765\u8bbe\u7f6e\u5982\u4f55\u504f\u79fb\u3002 fragment shader precision mediump float; uniform sampler2D image; varying vec2 vTexcoord; void main() { gl_FragColor = texture2D(image, vTexcoord); } vertex shader attribute vec3 position; attribute vec3 offset; //\u504f\u79fb\u91cf attribute vec2 texcoord; varying vec2 vTexcoord; void main() { gl_Position = vec4(position + offset, 1.0); vTexcoord = texcoord; } \u8bbe\u7f6e\u9876\u70b9\u5c5e\u6027\u3002\u8bbe\u7f6e\u9876\u70b9\u5c5e\u6027\u65b9\u4fbf\u6211\u4eec\u8fdb\u884c\u7eb9\u7406\u8d34\u56fe\u3002 - (void)setupVBO { _vertCount = 6; GLfloat vertices[] = { -0.5f, 1.0f, 0.0f, 1.0f, 0.0f, // \u53f3\u4e0a -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, // \u53f3\u4e0b -1.0f, 0.5f, 0.0f, 0.0f, 1.0f, // \u5de6\u4e0b -1.0f, 0.5f, 0.0f, 0.0f, 1.0f, // \u5de6\u4e0b -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, // \u5de6\u4e0a -0.5f, 1.0f, 0.0f, 1.0f, 0.0f, // \u53f3\u4e0a }; // \u521b\u5efaVBO _vbo = createVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW, sizeof(vertices), vertices); // Vertex Attrib: position glEnableVertexAttribArray(glGetAttribLocation(_program, \"position\")); glVertexAttribPointer(glGetAttribLocation(_program, \"position\"), 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, NULL); // Vertex Attrib: texcoord glEnableVertexAttribArray(glGetAttribLocation(_program, \"texcoord\")); glVertexAttribPointer(glGetAttribLocation(_program, \"texcoord\"), 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, NULL+sizeof(GL_FLOAT)*3); } \u8bbe\u7f6e\u7eb9\u7406 \u901a\u8fc7\u8bfb\u53d6\u7eb9\u7406\u56fe\u7247\uff0c\u751f\u6210\u7eb9\u7406\u7f13\u5b58\u5bf9\u8c61\u3002 \u8bbe\u7f6e\u504f\u79fb\u91cf \u504f\u79fb\u91cf\u548c\u666e\u901a\u7684\u9876\u70b9\u6570\u636e\u4e00\u6837\u53ef\u4ee5\u4f7f\u7528VBO\u6765\u5b58\u50a8\u3002 \u6211\u4eec\u5e0c\u671b\u6bcf\u6b21\u7ed8\u5236\u9876\u70b9\u6570\u7ec4\u90fd\u53d1\u751f\u4e00\u5b9a\u7684\u504f\u79fb\uff0c\u603b\u5171\u53d1\u751f\u4e09\u6b21\u504f\u79fb\uff08gl_Position = vec4(position+offset, 1.0)\uff09\u3002\u8fd9\u6837\u6211\u4eec\u603b\u5171\u9700\u89819\u4e2aGLfloat\u7684\u7a7a\u95f4\u6765\u5b58\u50a8\u504f\u79fb\u6570\u636e\u3002 - (void)setupOffset { GLfloat vertices[] = { 0.1f, -0.1f, 0.0f, 0.7f, -0.7f, 0.0f, 1.3f, -1.3f, 0.0f, }; // \u521b\u5efaVBO _offsetVBO = createVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW, sizeof(vertices), vertices); glEnableVertexAttribArray(glGetAttribLocation(_program, \"offset\")); glVertexAttribPointer(glGetAttribLocation(_program, \"offset\"), 3, GL_FLOAT, GL_FALSE, 0, NULL); } \u7ed8\u5236 - (void)render { glClearColor(1.0, 1.0, 1.0, 1.0); glClear(GL_COLOR_BUFFER_BIT); glLineWidth(2.0); glViewport(0, 0, self.frame.size.width, self.frame.size.height); // \u6fc0\u6d3b\u7eb9\u7406 glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, _texture); glUniform1i(glGetUniformLocation(_program, \"image\"), 0); // \u6bcf\u6b21\u7ed8\u5236\u4e4b\u540e\uff0c\u5bf9offset\u8fdb\u884c1\u4e2a\u504f\u79fb glVertexAttribDivisor(glGetAttribLocation(_program, \"offset\"), 1); // \u7ed8\u5236 3 \u4e2a\u5b9e\u4f8b, \u6bcf\u4e2a\u5b9e\u4f8b\u5bf9\u5e94\u4e00\u4e2a offset vector glDrawArraysInstanced(GL_TRIANGLES, 0, _vertCount, 3); //\u5c06\u6307\u5b9a renderbuffer \u5448\u73b0\u5728\u5c4f\u5e55\u4e0a\uff0c\u5728\u8fd9\u91cc\u6211\u4eec\u6307\u5b9a\u7684\u662f\u524d\u9762\u5df2\u7ecf\u7ed1\u5b9a\u4e3a\u5f53\u524d renderbuffer \u7684\u90a3\u4e2a\uff0c\u5728 renderbuffer \u53ef\u4ee5\u88ab\u5448\u73b0\u4e4b\u524d\uff0c\u5fc5\u987b\u8c03\u7528renderbufferStorage:fromDrawable: \u4e3a\u4e4b\u5206\u914d\u5b58\u50a8\u7a7a\u95f4\u3002 [_context presentRenderbuffer:GL_RENDERBUFFER]; }","title":"4. \u4ee3\u7801\u5b9e\u4f8b"},{"location":"GLES/GLES%20Draw%20APIs/#_4","text":"#version 330 core layout (location = 0) in vec3 aPos; layout (location = 2) in vec2 aTexCoords; layout (location = 3) in mat4 instanceMatrix; out vec2 TexCoords; uniform mat4 projection; uniform mat4 view; void main() { gl_Position = projection * view * instanceMatrix * vec4(aPos, 1.0); TexCoords = aTexCoords; } \u6211\u4eec\u4e0d\u518d\u4f7f\u7528\u6a21\u578buniform\u53d8\u91cf\uff0c\u6539\u4e3a\u4e00\u4e2amat4\u7684\u9876\u70b9\u5c5e\u6027\uff0c\u8ba9\u6211\u4eec\u80fd\u591f\u5b58\u50a8\u4e00\u4e2a\u5b9e\u4f8b\u5316\u6570\u7ec4\u7684\u53d8\u6362\u77e9\u9635\u3002\u7136\u800c\uff0c\u5f53\u6211\u4eec\u9876\u70b9\u5c5e\u6027\u7684\u7c7b\u578b\u5927\u4e8evec4\u65f6\uff0c\u5c31\u8981\u591a\u8fdb\u884c\u4e00\u6b65\u5904\u7406\u4e86\u3002\u9876\u70b9\u5c5e\u6027\u6700\u5927\u5141\u8bb8\u7684\u6570\u636e\u5927\u5c0f\u7b49\u4e8e\u4e00\u4e2avec4\u3002\u56e0\u4e3a\u4e00\u4e2amat4\u672c\u8d28\u4e0a\u662f4\u4e2avec4\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u8fd9\u4e2a\u77e9\u9635\u9884\u75594\u4e2a\u9876\u70b9\u5c5e\u6027\u3002\u56e0\u4e3a\u6211\u4eec\u5c06\u5b83\u7684\u4f4d\u7f6e\u503c\u8bbe\u7f6e\u4e3a3\uff0c\u77e9\u9635\u6bcf\u4e00\u5217\u7684\u9876\u70b9\u5c5e\u6027\u4f4d\u7f6e\u503c\u5c31\u662f3\u30014\u30015\u548c6\u3002 \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u8fd94\u4e2a\u9876\u70b9\u5c5e\u6027\u8bbe\u7f6e\u5c5e\u6027\u6307\u9488\uff0c\u5e76\u5c06\u5b83\u4eec\u8bbe\u7f6e\u4e3a\u5b9e\u4f8b\u5316\u6570\u7ec4\uff1a // \u9876\u70b9\u7f13\u51b2\u5bf9\u8c61 unsigned int buffer; glGenBuffers(1, &buffer); glBindBuffer(GL_ARRAY_BUFFER, buffer); glBufferData(GL_ARRAY_BUFFER, amount * sizeof(glm::mat4), &modelMatrices[0], GL_STATIC_DRAW); for(unsigned int i = 0; i < rock.meshes.size(); i++) { unsigned int VAO = rock.meshes[i].VAO; glBindVertexArray(VAO); // \u9876\u70b9\u5c5e\u6027 GLsizei vec4Size = sizeof(glm::vec4); glEnableVertexAttribArray(3); glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)0); glEnableVertexAttribArray(4); glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(vec4Size)); glEnableVertexAttribArray(5); glVertexAttribPointer(5, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(2 * vec4Size)); glEnableVertexAttribArray(6); glVertexAttribPointer(6, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(3 * vec4Size)); glVertexAttribDivisor(3, 1); glVertexAttribDivisor(4, 1); glVertexAttribDivisor(5, 1); glVertexAttribDivisor(6, 1); glBindVertexArray(0); } \u6ce8\u610f\u8fd9\u91cc\u6211\u4eec\u5c06Mesh\u7684VAO\u4ece\u79c1\u6709\u53d8\u91cf\u6539\u4e3a\u4e86\u516c\u6709\u53d8\u91cf\uff0c\u8ba9\u6211\u4eec\u80fd\u591f\u8bbf\u95ee\u5b83\u7684\u9876\u70b9\u6570\u7ec4\u5bf9\u8c61\u3002\u8fd9\u5e76\u4e0d\u662f\u6700\u597d\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u53ea\u662f\u4e3a\u4e86\u914d\u5408\u672c\u5c0f\u8282\u7684\u4e00\u4e2a\u7b80\u5355\u7684\u6539\u52a8\u3002\u9664\u6b64\u4e4b\u5916\u4ee3\u7801\u5c31\u5e94\u8be5\u5f88\u6e05\u695a\u4e86\u3002\u6211\u4eec\u544a\u8bc9\u4e86OpenGL\u5e94\u8be5\u5982\u4f55\u89e3\u91ca\u6bcf\u4e2a\u7f13\u51b2\u9876\u70b9\u5c5e\u6027\u7684\u7f13\u51b2\uff0c\u5e76\u4e14\u544a\u8bc9\u5b83\u8fd9\u4e9b\u9876\u70b9\u5c5e\u6027\u662f\u5b9e\u4f8b\u5316\u6570\u7ec4\u3002 \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u518d\u6b21\u4f7f\u7528\u7f51\u683c\u7684VAO\uff0c\u8fd9\u4e00\u6b21\u4f7f\u7528glDrawElementsInstanced\u8fdb\u884c\u7ed8\u5236\uff1a // \u7ed8\u5236\u5c0f\u884c\u661f instanceShader.use(); for(unsigned int i = 0; i < rock.meshes.size(); i++) { glBindVertexArray(rock.meshes[i].VAO); glDrawElementsInstanced( GL_TRIANGLES, rock.meshes[i].indices.size(), GL_UNSIGNED_INT, 0, amount ); }","title":"\u590d\u6742\u70b9\u7684\u4f8b\u5b50"},{"location":"GLES/GLES%20Draw%20APIs/#31-indirect","text":"","title":"3.1 \u65b0\u589e\u7684\u7ed8\u5236\u63a5\u53e3: Indirect"},{"location":"GLES/GLES%20Draw%20APIs/#drawarraysindirect-drawelementsindirect","text":"","title":"DrawArraysIndirect   \u548c DrawElementsIndirect"},{"location":"GLES/GLES%20Draw%20APIs/#_5","text":"void DrawArraysIndirect (enum mode, const void *indirect); void DrawElementsIndirect (enum mode, enum type, const void *indirect);","title":""},{"location":"GLES/GLES%20Draw%20APIs/#32-basevertex","text":"void DrawElementsBaseVertex (enum mode, sizei count, enum type, const void *indices, int basevertex); void DrawRangeElementsBaseVertex (enum mode, uint start, uint end, sizei count, enum type, const void *indices, int basevertex); void DrawElementsInstancedBaseVertex (enum mode, sizei count,enum type, const void *indices, sizei instancecount, int basevertex);","title":"3.2 \u65b0\u589e\u7684\u7ed8\u5236\u63a5\u53e3: BaseVertex"},{"location":"GLES/GLES%20Object%20Model.mm/","text":"\u540d\u8bcd\u89e3\u91ca FBOs Fence Semephere Sampler Vertex Attribute Divisors 1. Objects \u5bf9\u8c61 1.1. Buffer void GenBuffers (sizei n, uint buffers); void DeleteBuffers (sizei n,const uint buffers); boolean IsBuffer (uint buffer); 1.1.1. Create and Bind Buffer Objects [6.1] void BindBuffer void BindBufferRange void BindBufferBase 1.1.2. Buffer Object Data Stores [6.2] void BufferData void BufferSubData 1.1.3. Map/Unmap Buffer Data [6.3] void *MapBufferRange void FlushMappedBufferRange 1.1.4. Copy Between Buffers [6.5] void CopyBufferSubData 1.1.5. Buffer Object Queries [6.6] void GetBufferParameteri void GetBufferPointerv 1.2. Shader uint CreateShader void ShaderSource void CompileShader void ReleaseShaderCompiler void DeleteShader boolean IsShader void ShaderBinary 1.2.1. Shader Memory Access 1.3. Program 1.3.1. Program Interfaces 1.3.2. Program Binaries 1.4. Program Pipeline 1.5. Uniform Variables 1.6. Texture & Sampler 1.6.1. Texture 1.6.2. Sampler 1.6.3. Pixel Storage Modes and Pixel Buffer Objects 1.6.4. Texture Image TexImage3D TexImage2D 1.6.5. Alternate Texture Image CopyTexImage2D TexSubImage3D TexSubImage2D CopyTexSubImage3D CopyTexSubImage2D 1.6.6. Compressed Texture Images 1.6.7. Multisample Textures TexStorage2DMultisample TexStorage3DMultisample 1.6.8. Buffer Textures void TexBufferRange void TexBuffer 1.6.9. Manual Mipmap Generation void GenerateMipmap 1.6.10. Immutable-Format Tex. Images void TexStorage2D void TexStorage3D 1.6.11. Texture Image Loads/Stores void BindImageTexture 1.7. Renderbuffer 1.8. Framebuffer 1.9. Vertex Array 1.9.1. Generic Vertex Attributes 1.9.2. Vertex Attribute Divisors 1.9.3. Drawing Commands For all the functions in this section: mode: LINE_LOOP, LINE_[STRIP_]ADJACENCY, LINES, LINES_ADJACENCY, PATCHES TRIANGLE_FAN, POINTS[ TRIANGLES_ADJACENCY], TRIANGLES, TRIANGLE_STRIP[ ADJACENCY] type: UNSIGNED_{BYTE, SHORT, INT} void DrawArrays (enum mode, int first, sizei count); void DrawArraysInstanced (enum mode, int first, sizei count, sizei instancecount); void DrawArraysIndirect (enum mode, const void *indirect); void DrawElements (enum mode, sizei count, enum type, const void *indices); void DrawElementsInstanced (enum mode, sizei count, enum type, const void *indices, sizei instancecount); void DrawRangeElements (enum mode, uint start, uint end, sizei count, enum type, const void *indices); void DrawElementsBaseVertex (enum mode, sizei count, enum type, const void *indices, int basevertex); void DrawRangeElementsBaseVertex (enum mode, uint start, uint end, sizei count, enum type, const void *indices, int basevertex); void DrawElementsInstancedBaseVertex(enum mode, sizei count,enum type, const void *indices, sizei instancecount, int basevertex); void DrawElementsIndirect (enum mode,enum type, const void *indirect); 1.9.4. Vertex Attributes 1.10. Transform Feedback 1.11. Query 1.12. Sync 2. Operation \u64cd\u4f5c 2.1. Vertex Post-Processing 2.1.1. Transform Feedback [12.1] void GenTransformFeedbacks void DeleteTransformFeedbacks boolean IsTransformFeedback void BindTransformFeedback void BeginTransformFeedback void EndTransformFeedback void PauseTransformFeedback void ResumeTransformFeedback 2.1.2. Controlling Viewport [12.5.1] void DepthRangef(float n, float f); void Viewport(int x, int y, sizei w, sizei h); 2.2. Rasterization 2.2.1. Primitive Bounding Box [13.2] void PrimitiveBoundingBox(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW); 2.2.2. Multisampling [13.4] Use to antialias points and lines. void GetMultisamplefv(enum pname, uint index, float *val); pname: SAMPLE_POSITION 2.2.3. Sample Shading [13.4.1] void MinSampleShading(float value); 2.2.4. Points [13.5] Point size is taken from the shader built-in gl_PointSize and clamped to the implementation-dependent point size range. 2.2.5. Line Segments [13.6] void LineWidth(float width); 2.2.6. Polygons [13.7] void FrontFace(enum dir); Enable(CULL_FACE) Disable(CULL_FACE) IsEnabled(CULL_FACE) void CullFace(enum mode); Enable(POLYGON_OFFSET_FILL) Disable(POLYGON_OFFSET_FILL) IsEnabled(POLYGON_OFFSET_FILL) void PolygonOffset(float factor, float units); 2.3. Whole Framebuffer Operations Whole Framebuffer Operations Selecting Buffers for Writing [15.2.1] void DrawBuffers(sizei n, const enum *bufs); Fine Control of Buffer Updates [15.2.2] void ColorMask(boolean r, boolean g, boolean b, boolean a); void ColorMaski(uint buf, boolean r, boolean g, boolean b, boolean a); void DepthMask(boolean mask); void StencilMask(uint mask); void StencilMaskSeparate(enum face, uint mask); face: FRONT, BACK, FRONT_AND_BACK Clearing the Buffers [15.2.3] void Clear(bitfield buf); buf: Zero or Bitwise OR of {COLOR, DEPTH, STENCIL}_BUFFER_BIT void ClearColor(float r, float g, float b, float a); void ClearDepthf(float d); void ClearStencil(int s); void ClearBuffer{i f ui}v(enum buffer, int drawbuffer, const T *value); buffer: COLOR, DEPTH, STENCIL void ClearBufferfi(enum buffer, int drawbuffer, float depth, int stencil); buffer: DEPTH_STENCIL drawbuffer: 0 Invalidating Framebuffer Contents [15.2.4] void InvalidateSubFramebuffer(enum target, sizei numAttachments, const enum *attachments, int x, int y, sizei width, sizei height); target: [DRAW_, READ_]FRAMEBUFFER attachments: points to an array of COLOR, STENCIL, {COLOR, DEPTH, STENCIL}_ATTACHMENT void InvalidateFramebuffer( 2.4. Per-Fragment Operations Scissor Test [13.8.2] Enable/Disable(SCISSOR_TEST); void Scissor(int left, int bottom, sizei width, sizei height); Multisample Fragment Ops. [13.8.3] Enable/Disable(cap); cap: SAMPLE_ALPHA_TO_COVERAGE, SAMPLE_COVERAGE void SampleCoverage(float value, boolean invert); void SampleMaski(uint maskNumber, bitfield mask); Stencil Test [15.1.2] Enable/Disable(STENCIL_TEST); void StencilFunc (enum func, int ref, uint mask); func: ALWAYS, EQUAL, GEQUAL, GREATER, LEQUAL, LESS, NEVER, NOTEQUAL void StencilFuncSeparate (enum face, enum func, int ref, uint mask); func: See StencilFunc face: BACK, FRONT, FRONT_AND_BACK void StencilOp (enum sfail, enum dpfail, enum dppass); void StencilOpSeparate (enum face, enum sfail, enum dpfail, enum dppass); face: BACK, FRONT, FRONT_AND_BACK sfail, dpfail, dppass: DECR, DECR_WRAP, INCR, INCR_WRAP, INVERT, KEEP, REPLACE, ZERO Depth Buffer Test [15.1.3] Enable/Disable(DEPTH_TEST); void DepthFunc (enum func); func: See StencilFunc Blending [15.1.5] void Enablei (enum target, uint index); void Disablei (enum target, uint index); target: must be BLEND Enable/Disable/IsEnabled(BLEND); void BlendColor (float red, float green, float blue, float alpha); void BlendEquation (enum mode); void BlendEquationSeparate (enum modeRGB, enum modeAlpha); mode, modeRGB, modeAlpha: FUNC_{ADD, SUBTRACT, REVERSE_SUBTRACT}, MAX, MIN void BlendEquationi (uint buf, enum mode); void BlendEquationSeparatei (uint buf, enum modeRGB, enum modeAlpha ); modeRGB, modeAlpha: See BlendEquationSeparate void BlendFunc(enum src, enum dst); src, dst: See BlendFuncSeparate void BlendFuncSeparate (enum srcRGB, enum dstRGB, enum srcAlpha, enum dstAlpha); src, dst, srcRGB, dstRGB, srcAlpha, dstAlpha: {CONSTANT, DST, SRC} COLOR, {CONSTANT, DST, SRC}_ALPHA, ONE, ONE_MINUS_SRC {ALPHA, COLOR}, ONE_MINUS_{CONSTANT, DST} ALPHA , ONE_MINUS {CONSTANT, DST}_COLOR, SRC_ALPHA_SATURATE, ZERO void BlendFunci (uint buf, enum src, enum dst); void BlendFuncSeparatei (uint buf, enum srcRGB, enum dstRGB, enum srcAlpha, enum dstAlpha); modeRGB, modeAlpha: See BlendFuncSeparate void BlendBarrier(void); Dithering [15.1.7] Enable/Disable/IsEnabled(DITHER); 2.5. Reading and Copying Pixels and Images","title":"\u540d\u8bcd\u89e3\u91ca"},{"location":"GLES/GLES%20Object%20Model.mm/#_1","text":"FBOs Fence Semephere Sampler Vertex Attribute Divisors","title":"\u540d\u8bcd\u89e3\u91ca"},{"location":"GLES/GLES%20Object%20Model.mm/#1-objects","text":"","title":"1. Objects \u5bf9\u8c61"},{"location":"GLES/GLES%20Object%20Model.mm/#11-buffer","text":"void GenBuffers (sizei n, uint buffers); void DeleteBuffers (sizei n,const uint buffers); boolean IsBuffer (uint buffer);","title":"1.1. Buffer"},{"location":"GLES/GLES%20Object%20Model.mm/#111-create-and-bind-buffer-objects-61","text":"void BindBuffer void BindBufferRange void BindBufferBase","title":"1.1.1. Create and Bind Buffer Objects [6.1]"},{"location":"GLES/GLES%20Object%20Model.mm/#112-buffer-object-data-stores-62","text":"void BufferData void BufferSubData","title":"1.1.2. Buffer Object Data Stores [6.2]"},{"location":"GLES/GLES%20Object%20Model.mm/#113-mapunmap-buffer-data-63","text":"void *MapBufferRange void FlushMappedBufferRange","title":"1.1.3. Map/Unmap Buffer Data [6.3]"},{"location":"GLES/GLES%20Object%20Model.mm/#114-copy-between-buffers-65","text":"void CopyBufferSubData","title":"1.1.4. Copy Between Buffers [6.5]"},{"location":"GLES/GLES%20Object%20Model.mm/#115-buffer-object-queries-66","text":"void GetBufferParameteri void GetBufferPointerv","title":"1.1.5. Buffer Object Queries [6.6]"},{"location":"GLES/GLES%20Object%20Model.mm/#12-shader","text":"uint CreateShader void ShaderSource void CompileShader void ReleaseShaderCompiler void DeleteShader boolean IsShader void ShaderBinary","title":"1.2. Shader"},{"location":"GLES/GLES%20Object%20Model.mm/#121-shader-memory-access","text":"","title":"1.2.1. Shader Memory Access"},{"location":"GLES/GLES%20Object%20Model.mm/#13-program","text":"","title":"1.3. Program"},{"location":"GLES/GLES%20Object%20Model.mm/#131-program-interfaces","text":"","title":"1.3.1. Program Interfaces"},{"location":"GLES/GLES%20Object%20Model.mm/#132-program-binaries","text":"","title":"1.3.2. Program Binaries"},{"location":"GLES/GLES%20Object%20Model.mm/#14-program-pipeline","text":"","title":"1.4. Program Pipeline"},{"location":"GLES/GLES%20Object%20Model.mm/#15-uniform-variables","text":"","title":"1.5. Uniform Variables"},{"location":"GLES/GLES%20Object%20Model.mm/#16-texture-sampler","text":"","title":"1.6. Texture &amp; Sampler"},{"location":"GLES/GLES%20Object%20Model.mm/#161-texture","text":"","title":"1.6.1. Texture"},{"location":"GLES/GLES%20Object%20Model.mm/#162-sampler","text":"","title":"1.6.2. Sampler"},{"location":"GLES/GLES%20Object%20Model.mm/#163-pixel-storage-modes-and-pixel-buffer-objects","text":"","title":"1.6.3. Pixel Storage Modes and Pixel Buffer Objects"},{"location":"GLES/GLES%20Object%20Model.mm/#164-texture-image","text":"TexImage3D TexImage2D","title":"1.6.4. Texture Image"},{"location":"GLES/GLES%20Object%20Model.mm/#165-alternate-texture-image","text":"CopyTexImage2D TexSubImage3D TexSubImage2D CopyTexSubImage3D CopyTexSubImage2D","title":"1.6.5. Alternate Texture Image"},{"location":"GLES/GLES%20Object%20Model.mm/#166-compressed-texture-images","text":"","title":"1.6.6. Compressed Texture Images"},{"location":"GLES/GLES%20Object%20Model.mm/#167-multisample-textures","text":"TexStorage2DMultisample TexStorage3DMultisample","title":"1.6.7. Multisample Textures"},{"location":"GLES/GLES%20Object%20Model.mm/#168-buffer-textures","text":"void TexBufferRange void TexBuffer","title":"1.6.8. Buffer Textures"},{"location":"GLES/GLES%20Object%20Model.mm/#169-manual-mipmap-generation","text":"void GenerateMipmap","title":"1.6.9. Manual Mipmap Generation"},{"location":"GLES/GLES%20Object%20Model.mm/#1610-immutable-format-tex-images","text":"void TexStorage2D void TexStorage3D","title":"1.6.10. Immutable-Format Tex. Images"},{"location":"GLES/GLES%20Object%20Model.mm/#1611-texture-image-loadsstores","text":"void BindImageTexture","title":"1.6.11. Texture Image Loads/Stores"},{"location":"GLES/GLES%20Object%20Model.mm/#17-renderbuffer","text":"","title":"1.7. Renderbuffer"},{"location":"GLES/GLES%20Object%20Model.mm/#18-framebuffer","text":"","title":"1.8. Framebuffer"},{"location":"GLES/GLES%20Object%20Model.mm/#19-vertex-array","text":"","title":"1.9. Vertex Array"},{"location":"GLES/GLES%20Object%20Model.mm/#191-generic-vertex-attributes","text":"","title":"1.9.1. Generic Vertex Attributes"},{"location":"GLES/GLES%20Object%20Model.mm/#192-vertex-attribute-divisors","text":"","title":"1.9.2. Vertex Attribute Divisors"},{"location":"GLES/GLES%20Object%20Model.mm/#193-drawing-commands","text":"For all the functions in this section: mode: LINE_LOOP, LINE_[STRIP_]ADJACENCY, LINES, LINES_ADJACENCY, PATCHES TRIANGLE_FAN, POINTS[ TRIANGLES_ADJACENCY], TRIANGLES, TRIANGLE_STRIP[ ADJACENCY] type: UNSIGNED_{BYTE, SHORT, INT} void DrawArrays (enum mode, int first, sizei count); void DrawArraysInstanced (enum mode, int first, sizei count, sizei instancecount); void DrawArraysIndirect (enum mode, const void *indirect); void DrawElements (enum mode, sizei count, enum type, const void *indices); void DrawElementsInstanced (enum mode, sizei count, enum type, const void *indices, sizei instancecount); void DrawRangeElements (enum mode, uint start, uint end, sizei count, enum type, const void *indices); void DrawElementsBaseVertex (enum mode, sizei count, enum type, const void *indices, int basevertex); void DrawRangeElementsBaseVertex (enum mode, uint start, uint end, sizei count, enum type, const void *indices, int basevertex); void DrawElementsInstancedBaseVertex(enum mode, sizei count,enum type, const void *indices, sizei instancecount, int basevertex); void DrawElementsIndirect (enum mode,enum type, const void *indirect);","title":"1.9.3. Drawing Commands"},{"location":"GLES/GLES%20Object%20Model.mm/#194-vertex-attributes","text":"","title":"1.9.4. Vertex Attributes"},{"location":"GLES/GLES%20Object%20Model.mm/#110-transform-feedback","text":"","title":"1.10. Transform Feedback"},{"location":"GLES/GLES%20Object%20Model.mm/#111-query","text":"","title":"1.11. Query"},{"location":"GLES/GLES%20Object%20Model.mm/#112-sync","text":"","title":"1.12. Sync"},{"location":"GLES/GLES%20Object%20Model.mm/#2-operation","text":"","title":"2. Operation \u64cd\u4f5c"},{"location":"GLES/GLES%20Object%20Model.mm/#21-vertex-post-processing","text":"","title":"2.1. Vertex Post-Processing"},{"location":"GLES/GLES%20Object%20Model.mm/#211-transform-feedback-121","text":"void GenTransformFeedbacks void DeleteTransformFeedbacks boolean IsTransformFeedback void BindTransformFeedback void BeginTransformFeedback void EndTransformFeedback void PauseTransformFeedback void ResumeTransformFeedback","title":"2.1.1. Transform Feedback [12.1]"},{"location":"GLES/GLES%20Object%20Model.mm/#212-controlling-viewport-1251","text":"void DepthRangef(float n, float f); void Viewport(int x, int y, sizei w, sizei h);","title":"2.1.2. Controlling Viewport [12.5.1]"},{"location":"GLES/GLES%20Object%20Model.mm/#22-rasterization","text":"","title":"2.2. Rasterization"},{"location":"GLES/GLES%20Object%20Model.mm/#221-primitive-bounding-box-132","text":"void PrimitiveBoundingBox(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW);","title":"2.2.1. Primitive Bounding Box [13.2]"},{"location":"GLES/GLES%20Object%20Model.mm/#222-multisampling-134","text":"Use to antialias points and lines. void GetMultisamplefv(enum pname, uint index, float *val); pname: SAMPLE_POSITION","title":"2.2.2. Multisampling [13.4]"},{"location":"GLES/GLES%20Object%20Model.mm/#223-sample-shading-1341","text":"void MinSampleShading(float value);","title":"2.2.3. Sample Shading [13.4.1]"},{"location":"GLES/GLES%20Object%20Model.mm/#224-points-135","text":"Point size is taken from the shader built-in gl_PointSize and clamped to the implementation-dependent point size range.","title":"2.2.4. Points [13.5]"},{"location":"GLES/GLES%20Object%20Model.mm/#225-line-segments-136","text":"void LineWidth(float width);","title":"2.2.5. Line Segments [13.6]"},{"location":"GLES/GLES%20Object%20Model.mm/#226-polygons-137","text":"void FrontFace(enum dir); Enable(CULL_FACE) Disable(CULL_FACE) IsEnabled(CULL_FACE) void CullFace(enum mode); Enable(POLYGON_OFFSET_FILL) Disable(POLYGON_OFFSET_FILL) IsEnabled(POLYGON_OFFSET_FILL) void PolygonOffset(float factor, float units);","title":"2.2.6. Polygons [13.7]"},{"location":"GLES/GLES%20Object%20Model.mm/#23-whole-framebuffer-operations","text":"Whole Framebuffer Operations","title":"2.3. Whole Framebuffer Operations"},{"location":"GLES/GLES%20Object%20Model.mm/#selecting-buffers-for-writing-1521","text":"void DrawBuffers(sizei n, const enum *bufs);","title":"Selecting Buffers for Writing [15.2.1]"},{"location":"GLES/GLES%20Object%20Model.mm/#fine-control-of-buffer-updates-1522","text":"void ColorMask(boolean r, boolean g, boolean b, boolean a); void ColorMaski(uint buf, boolean r, boolean g, boolean b, boolean a); void DepthMask(boolean mask); void StencilMask(uint mask); void StencilMaskSeparate(enum face, uint mask); face: FRONT, BACK, FRONT_AND_BACK","title":"Fine Control of Buffer Updates [15.2.2]"},{"location":"GLES/GLES%20Object%20Model.mm/#clearing-the-buffers-1523","text":"void Clear(bitfield buf); buf: Zero or Bitwise OR of {COLOR, DEPTH, STENCIL}_BUFFER_BIT void ClearColor(float r, float g, float b, float a); void ClearDepthf(float d); void ClearStencil(int s); void ClearBuffer{i f ui}v(enum buffer, int drawbuffer, const T *value); buffer: COLOR, DEPTH, STENCIL void ClearBufferfi(enum buffer, int drawbuffer, float depth, int stencil); buffer: DEPTH_STENCIL drawbuffer: 0","title":"Clearing the Buffers [15.2.3]"},{"location":"GLES/GLES%20Object%20Model.mm/#invalidating-framebuffer-contents-1524","text":"void InvalidateSubFramebuffer(enum target, sizei numAttachments, const enum *attachments, int x, int y, sizei width, sizei height); target: [DRAW_, READ_]FRAMEBUFFER attachments: points to an array of COLOR, STENCIL, {COLOR, DEPTH, STENCIL}_ATTACHMENT void InvalidateFramebuffer(","title":"Invalidating Framebuffer Contents [15.2.4]"},{"location":"GLES/GLES%20Object%20Model.mm/#24-per-fragment-operations","text":"","title":"2.4. Per-Fragment Operations"},{"location":"GLES/GLES%20Object%20Model.mm/#scissor-test-1382","text":"Enable/Disable(SCISSOR_TEST); void Scissor(int left, int bottom, sizei width, sizei height);","title":"Scissor Test [13.8.2]"},{"location":"GLES/GLES%20Object%20Model.mm/#multisample-fragment-ops-1383","text":"Enable/Disable(cap); cap: SAMPLE_ALPHA_TO_COVERAGE, SAMPLE_COVERAGE void SampleCoverage(float value, boolean invert); void SampleMaski(uint maskNumber, bitfield mask);","title":"Multisample Fragment Ops. [13.8.3]"},{"location":"GLES/GLES%20Object%20Model.mm/#stencil-test-1512","text":"Enable/Disable(STENCIL_TEST); void StencilFunc (enum func, int ref, uint mask); func: ALWAYS, EQUAL, GEQUAL, GREATER, LEQUAL, LESS, NEVER, NOTEQUAL void StencilFuncSeparate (enum face, enum func, int ref, uint mask); func: See StencilFunc face: BACK, FRONT, FRONT_AND_BACK void StencilOp (enum sfail, enum dpfail, enum dppass); void StencilOpSeparate (enum face, enum sfail, enum dpfail, enum dppass); face: BACK, FRONT, FRONT_AND_BACK sfail, dpfail, dppass: DECR, DECR_WRAP, INCR, INCR_WRAP, INVERT, KEEP, REPLACE, ZERO","title":"Stencil Test [15.1.2]"},{"location":"GLES/GLES%20Object%20Model.mm/#depth-buffer-test-1513","text":"Enable/Disable(DEPTH_TEST); void DepthFunc (enum func); func: See StencilFunc","title":"Depth Buffer Test [15.1.3]"},{"location":"GLES/GLES%20Object%20Model.mm/#blending-1515","text":"void Enablei (enum target, uint index); void Disablei (enum target, uint index); target: must be BLEND Enable/Disable/IsEnabled(BLEND); void BlendColor (float red, float green, float blue, float alpha); void BlendEquation (enum mode); void BlendEquationSeparate (enum modeRGB, enum modeAlpha); mode, modeRGB, modeAlpha: FUNC_{ADD, SUBTRACT, REVERSE_SUBTRACT}, MAX, MIN void BlendEquationi (uint buf, enum mode); void BlendEquationSeparatei (uint buf, enum modeRGB, enum modeAlpha ); modeRGB, modeAlpha: See BlendEquationSeparate void BlendFunc(enum src, enum dst); src, dst: See BlendFuncSeparate void BlendFuncSeparate (enum srcRGB, enum dstRGB, enum srcAlpha, enum dstAlpha); src, dst, srcRGB, dstRGB, srcAlpha, dstAlpha: {CONSTANT, DST, SRC} COLOR, {CONSTANT, DST, SRC}_ALPHA, ONE, ONE_MINUS_SRC {ALPHA, COLOR}, ONE_MINUS_{CONSTANT, DST} ALPHA , ONE_MINUS {CONSTANT, DST}_COLOR, SRC_ALPHA_SATURATE, ZERO void BlendFunci (uint buf, enum src, enum dst); void BlendFuncSeparatei (uint buf, enum srcRGB, enum dstRGB, enum srcAlpha, enum dstAlpha); modeRGB, modeAlpha: See BlendFuncSeparate void BlendBarrier(void);","title":"Blending [15.1.5]"},{"location":"GLES/GLES%20Object%20Model.mm/#dithering-1517","text":"Enable/Disable/IsEnabled(DITHER);","title":"Dithering [15.1.7]"},{"location":"GLES/GLES%20Object%20Model.mm/#25-reading-and-copying-pixels-and-images","text":"","title":"2.5. Reading and Copying Pixels and Images"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/","text":"Vulkan \u6269\u5c55 (\u672c\u7ae0\u6587\u672c\u5185\u5bb9\u7684\u66f4\u591a\u7ec6\u8282, \u53c2\u89c1 Vulkan Specification 1.1 , \u4ee3\u7801\u4e3a\u793a\u4f8b\u7528\u4f2a\u7801) \u5bf9\u4e8e\u4e0d\u540c\u7684\u5e73\u53f0, \u9a71\u52a8, \u64cd\u4f5c\u7cfb\u7edf\u7b49, \u5f53Vulkan\u7684\u5e95\u5c42\u5b9e\u73b0\u4e0d\u540c\u65f6, Vulkan \u53ef\u7528\u7684\u529f\u80fd\u96c6\u4e5f\u6709\u5f88\u591a\u533a\u522b. \u672c\u7ae0\u63cf\u8ff0\u4e86 Vulkan \u5982\u4f55\u5b9a\u4e49\u548c\u6269\u5c55\u529f\u80fd\u96c6, \u4e3b\u8981\u4ecb\u7ecd\u4e86\u56db\u4e2a\u6982\u5ff5: Extension, Feature, Limitation, \u548c Format. Vulkan \u521d\u59cb\u5316\u6d41\u7a0b \u5728\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u65f6, \u9700\u8981\u542f\u7528\u7684 Vulkan \u529f\u80fd\u96c6\u9700\u8981\u5728\u521d\u59cb\u5316 Device \u524d\u786e\u5b9a\u4e0b\u6765. \u5bf9\u5e94 vk \u521d\u59cb\u5316\u7684\u524d\u4e09\u6b65: Instance --> Physical Device --> Device \u4ee5\u4e0b\u662f\u521d\u59cb\u5316\u8fc7\u7a0b\u4e2d\u4e0e\u529f\u80fd\u76f8\u5173\u7684\u8fc7\u7a0b: \u679a\u4e3e vk \u652f\u6301\u7684 Instance-level Extensions \u521b\u5efa Instance \u679a\u4e3e \u7269\u7406\u8bbe\u5907, \u9009\u62e9 GPU, \u679a\u4e3e GPU \u652f\u6301\u7684 Device Extensions, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u200b \u67e5\u8be2\u652f\u6301\u7684 Extensions \u7684 Features \u7ed3\u6784\u4f53, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u200b \u67e5\u8be2\u652f\u6301\u7684 Extensions \u7684 Properties \u7ed3\u6784\u4f53 \u67e5\u8be2 GPU \u652f\u6301\u7684 Feature, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u67e5\u8be2 GPU \u7684 Properties \u5c06\u542f\u7528\u7684 Extensions \u548c Features \u5217\u8868\u653e\u5165 CreateInfo \u7ed3\u6784\u4f53, \u521b\u5efa\u903b\u8f91\u8bbe\u5907 Device, Extension: \u529f\u80fd\u96c6\u7684\u62bd\u8c61\u6982\u5ff5, \u7528\u6765\u4e3a Vulkan \u6dfb\u52a0\u65b0\u7684 Commands\uff0cStructures \u548c Enumerants. \u540c\u65f6\u53ef\u80fd\u65b0\u589e Features, Limitations, \u548c Format. Feature: bool \u503c\u96c6\u5408, \u53ef\u9009\u529f\u80fd\u7684\u5f00\u5173. \u53ef\u4ee5\u7528\u6765\u67e5\u8be2\u8bbe\u5907\u652f\u6301\u7684\u529f\u80fd, Limitation \u548c Format \u662f\u4e24\u4e2a\u53ea\u8bfb\u53c2\u6570\u96c6, Limitation \u53c8\u79f0\u505a Properties, \u8868\u793a\u8bbe\u5907\u7279\u5f81\u503c; Format \u8868\u793a\u652f\u6301\u7684\u683c\u5f0f. \u672c\u7ae0\u540e\u9762\u5404\u7ae0\u8282\u5bf9\u6b64\u6d41\u7a0b\u5404\u6b65\u9aa4\u8fdb\u884c\u89e3\u91ca, \u5e76\u5305\u542b\u793a\u4f8b\u4ee3\u7801. Extensions: \u6269\u5c55 \u6269\u5c55 (Extensions) \u53ef\u7528\u6765\u4e3a Vk \u6dfb\u52a0\u65b0\u529f\u80fd. Vk \u6838\u5fc3\u7684\u65b0\u7248\u672c (\u5982: VK_VERSION_1_1) \u4e5f\u53ef\u4ee5\u89c6\u4e3a\u4e00\u4e2a\u6269\u5c55. \u6269\u5c55\u53ef\u4ee5\u5b9a\u4e49\u65b0\u7684 \u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784. ( Commands\uff0cStructures \u548c Enumerants) \u6269\u5c55\u5206\u4e3a\u5b9e\u4f8b\u7ea7\u548c\u8bbe\u5907\u7ea7 (Instance-level \u548c Device-level) \u5f53 Commands \u7528\u6765\u679a\u4e3e\u5b9e\u4f8b\u5c5e\u6027 (instance properties), \u6216\u63a5\u53d7 VkInstance \u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570, \u5219\u88ab\u89c6\u4e3a\u5b9e\u4f8b\u7ea7\u529f\u80fd\u3002 \u5f53 Commands \u7528\u6765\u679a\u4e3e\u7269\u7406\u8bbe\u5907\u5c5e\u6027 (physical device properties), \u6216\u63a5\u53d7 VkDevice \u53ca\u5176\u5b50\u7c7b\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\uff0c\u5219\u88ab\u89c6\u4e3a\u8bbe\u5907\u7ea7\u529f\u80fd\u3002 \u4e3a\u4e86\u65b9\u4fbf\u7f16\u8bd1\uff0c\u5728 Khronos \u63d0\u4f9b\u7684 vulkan_core.h \u4e2d\u9664\u4e86\u6838\u5fc3API, \u8fd8\u5b9a\u4e49\u4e86\u5df2\u6ce8\u518c Extensions \u5b9a\u4e49\u7684\u63a5\u53e3\uff0c\u5305\u62ec\u65b0 \u7ed3\u6784, \u679a\u4e3e, \u548c\u547d\u4ee4\u7684\u51fd\u6570\u6307\u9488\u7c7b\u578b\u3002\u6269\u5c55\u7684\u5b9e\u73b0\u901a\u8fc7 Layers \u548c Vulkan\u5b9e\u73b0\u6765\u63d0\u4f9b\u3002 \u542f\u7528 Vk Extensions Vk Extensions \u9700\u8981\u5728\u521d\u59cb\u5316\u9636\u6bb5\u663e\u5f0f\u542f\u7528. \u542f\u7528 instance extension, \u8981\u5728\u521b\u5efa VKInstance \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkInstanceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. \u542f\u7528 device extension, \u8981\u5728 \u521b\u5efa VkDevice \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkDeviceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. Physical-Device-Level \u529f\u80fd\u6ca1\u6709\u542f\u7528\u673a\u5236\uff0c\u53ea\u8981 VkPhysicalDevice \u7684\u529f\u80fd\u5bf9\u5e94\u7684 Extensions \u5728\u679a\u4e3e\u51fd\u6570 vkEnumerateDeviceExtensionProperties \u4e2d\u88ab\u5217\u51fa. \u4ec5 \u542f\u7528 \u6269\u5c55\u64cd\u4f5c\u800c\u8a00, \u9664\u4e86 \u542f\u7528 \u8be5\u6269\u5c55\u81ea\u8eab\u5b9a\u4e49\u7684\u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784\u5916, \u4e0d\u4f1a\u66f4\u6539\u6838\u5fc3Vulkan API \u6216\u5176\u4ed6\u6269\u5c55\u7684\u529f\u80fd\u3002 \u793a\u4f8b: \u521b\u5efa VkInstance \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> extensions(); extensions.push_back(VK_KHR_WIN32_SURFACE_EXTENSION_NAME); VkInstanceCreateInfo inst_info = {}; inst_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; ... // Enable Instance Extensions inst_info.enabledExtensionCount = extensions.size(); inst_info.ppEnabledExtensionNames = extensions.data(); VkInstance instance; VkResult res = vkCreateInstance(&inst_info, NULL, &instance); \u5bf9 VkPhysicalDevice, \u679a\u4e3e\u5176\u652f\u6301\u7684 Extensions: // \u679a\u4e3e\u8bbe\u5907 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); // \u9009\u62e9\u8bbe\u5907 VkPhysicalDevice physicalDevice = devices[0]; // \u4ec5\u793a\u4f8b,\u6b63\u786e\u4ee3\u7801\u5e94\u9009\u62e9\u5bf9\u5e94 GPU \u8bbe\u5907 // \u679a\u4e3e Extensions uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, availableExtensions.data()); \u521b\u5efa VkDevice \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> device_extension_names(); // check if physicalDevice support extension: for (const auto& extension : availableExtensions) { if(strcmp(extension.extensionName, VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0) device_extension_names.push_back(extension.extensionName); } } VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; device_info.pNext = NULL; ... // Enable Device Extensions device_info.enabledExtensionCount = device_extension_names.size(); device_info.ppEnabledExtensionNames = enabledExtensionCount ? device_extension_names.data() : NULL; VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device); Features: \u529f\u80fd Features \u7528\u6765\u8bbe\u7f6e\u6216\u67e5\u8be2 \u975e\u6240\u6709\u5b9e\u73b0\u90fd\u652f\u6301 \u7684\u529f\u80fd\u3002 Feature \u5747\u4e3a bool \u503c. Features \u662f\u7269\u7406\u8bbe\u5907\u7684\u5c5e\u6027\u3002(physical device properties) \u8fd9\u4e9b\u529f\u80fd\u662f\u201c\u53ef\u9009\u201d\u7684\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u4f7f\u7528\u524d\u660e\u786e\u542f\u7528\u3002 \u6838\u5fc3 Features Vk \u6838\u5fc3\u4e2d\u5b9a\u4e49\u7684 Features, \u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceFeatures \u67e5\u8be2. VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); \u67e5\u8be2\u7ed3\u679c VkPhysicalDeviceFeatures \u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceFeatures { VkBool32 robustBufferAccess; VkBool32 fullDrawIndexUint32; VkBool32 imageCubeArray; VkBool32 independentBlend; VkBool32 geometryShader; VkBool32 tessellationShader; VkBool32 sampleRateShading; .... // \u603b\u8ba150+\u4e2a Bool \u503c } VkPhysicalDeviceFeatures \u5176\u4e2d\u6bcf\u4e2a Feature \u7684\u542b\u4e49 \u5728 Vulkan Specification 1.1/Features \u4e2d\u90fd\u6709\u89e3\u91ca. \u4f8b\u5982: IndependentBlend \u6307\u5b9a: \u662f\u5426\u6bcf\u4e2a attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u4e92\u76f8\u72ec\u7acb\u3002 \u672a\u542f\u7528\u6b64 Feature\uff0c\u5219\u6240\u6709 color attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u5fc5\u987b\u76f8\u540c\u3002 \u82e5\u542f\u7528\u6b64 Feature\uff0c\u5219\u53ef\u4ee5\u4e3a\u6bcf\u4e2a\u7ed1\u5b9a\u7684 color attachment \u63d0\u4f9b\u4e0d\u540c\u7684 VkPipelineColorBlendAttachmentState \u3002 \u6269\u5c55\u63d0\u4f9b\u7684Features \u67e5\u8be2\u51fd\u6570: vkGetPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 physicalDeviceFeatures2; vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &physicalDeviceFeatures2); \u67e5\u8be2\u7ed3\u679c: VkPhysicalDeviceFeatures2 \u7ed3\u6784: // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; sType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 pNext: \u6307\u9488\u94fe. VkPhysicalDeviceFeatures: Vulkan 1.0 \u63d0\u4f9b\u7684\u6838\u5fc3 Features \u6ce8: VkPhysicalDeviceFeatures2 \u7b49\u4ef7 VkPhysicalDeviceFeatures2KHR, vkGetPhysicalDeviceFeatures2 \u7b49\u4ef7 vkGetPhysicalDeviceFeatures2KHR \u901a\u8fc7 pNext , \u53ef\u4ee5\u83b7\u5f97\u6269\u5c55\u6240\u5b9a\u4e49\u7684 Features \u7ed3\u6784\u4f53, \u6709\u7684\u7531 Vulkan \u6838\u5fc3\u65b0\u7248\u672c\u63d0\u4f9b, \u6709\u7684\u7531\u5176\u4ed6 Extension\u63d0\u4f9b. \u4f8b\u5982: Vulkan 1.1 \u63d0\u4f9b\u7684 samplerYcbcrConversion. // Provided by VK_VERSION_1_1: VK_KHR_sampler_ycbcr_conversion typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures { VkStructureType sType; void* pNext; VkBool32 samplerYcbcrConversion; } VkPhysicalDeviceSamplerYcbcrConversionFeatures; VK_EXT_transform_feedback \u63d0\u4f9b\u7684 transformFeedback \u548c geometryStreams. // Provided by VK_EXT_transform_feedback typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 transformFeedback; VkBool32 geometryStreams; } VkPhysicalDeviceTransformFeedbackFeaturesEXT; \u67e5\u8be2\u793a\u4f8b: // \u6269\u5c55\u7684 Feature \u7ed3\u6784\u4f53 VkPhysicalDeviceSamplerYcbcrConversionFeatures mSamplerYcbcrConversionFeatures = {}; mSamplerYcbcrConversionFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; // vk1.1 \u7684 VkPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 deviceFeatures = {}; deviceFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; deviceFeatures.pNext = mVertexAttributeDivisorFeatures // \u67e5\u8be2 vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &deviceFeatures); // \u4f7f\u7528 if (mVertexAttributeDivisorFeatures.vertexAttributeInstanceRateDivisor) { ... } \u542f\u7528 Features Features \u9ed8\u8ba4\u7686\u4e3a\u4e0d\u542f\u7528\u72b6\u6001. \u5fc5\u987b\u5728 VkDevice \u521b\u5efa\u65f6\u663e\u5f0f\u542f\u7528\u3002\u5982\u679c\u542f\u7528\u4e86\u7269\u7406\u8bbe\u5907\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5219 VkDevice \u521b\u5efa\u5c06\u5931\u8d25\uff0c\u5e76\u8fd4\u56deVK_ERROR_FEATURE_NOT_PRESENT\u3002 \u542f\u7528\u65b9\u6cd5: \u521b\u5efa VkPhysicalDeviceFeatures \u7ed3\u6784\u7684\u6307\u9488 (\u62161.1\u7684 VkPhysicalDeviceFeatures2\u7ed3\u6784) \u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \u6216 VK_FALSE, eg: physicalDeviceFeatures.independentBlend = VK_TRUE \u901a\u8fc7\u4f20\u9012\u7ed9 vkCreateDevice \u7528\u7684 VkDeviceCreateInfo\u7ed3\u6784\u7684 pEnabledFeatures \u6210\u5458. \u8981\u542f\u52a8\u6240\u6709\u8bbe\u5907\u7684\u529f\u80fd (\u614e\u7528)\uff0c\u5219\u53ea\u9700\u4f20\u5165\u67e5\u8be2\u51fd\u6570 vkGetPhysicalDeviceFeatures \u8fd4\u56de\u7684 VkPhysicalDeviceFeatures \u7ed3\u6784\u5373\u53ef\u3002\u8981\u7981\u7528\u5355\u4e2a\u529f\u80fd\uff0c\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728\u76f8\u540c\u7ed3\u6784\u4e2d\u5c06\u6240\u9700\u6210\u5458\u8bbe\u7f6e\u4e3aVK_FALSE\u3002 \u7528\u8fc7\u7ed9 pNext\u94fe\u6dfb\u52a0 Extensions \u63d0\u4f9b\u7684 Features \u7ed3\u6784\u4f53, \u6765\u542f\u7528\u6269\u5c55\u7684 Features. // \u67e5\u8be2\u6838\u5fc3 Features \u662f\u5426\u652f\u6301 VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); // \u8bbe\u7f6e\u542f\u7528 Features VkPhysicalDeviceFeatures2KHR enabledFeatures = {}; enabledFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; enabledFeatures.features.imageCubeArray = mPhysicalDeviceFeatures.imageCubeArray; enabledFeatures.features.independentBlend = mPhysicalDeviceFeatures.independentBlend; // Create Device VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; // \u6307\u5411 Features \u7ed3\u6784\u4f53\u4ee5\u8bbe\u7f6e Extensions \u63d0\u4f9b\u7684 Features // mSamplerYcbcrConversionFeatures : \u524d\u9762\u67e5\u8be2\u793a\u4f8b\u4e2d\u7684\u7ed3\u6784\u4f53. device_info.pNext = mSamplerYcbcrConversionFeatures; // Enable Physical Device Features device_info.pEnabledFeatures = &enabledFeatures.features; ... VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device); Limitations Limits \u63d0\u4f9b\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u53ef\u80fd\u9700\u8981\u660e\u786e\u7684\u4e00\u4e9b\u8bbe\u5907\u7279\u5f81\u503c, \u8fd9\u4e9b\u7279\u5f81\u7684\u6700\u5c0f\u503c\uff0c\u6700\u5927\u503c\u7b49\u4f1a\u968f\u5e95\u5c42\u5b9e\u73b0\u7684\u4e0d\u540c\u800c\u5f02. \u901a\u8fc7 VkPhysicalDeviceLimits \u7ed3\u6784\u4f53\u83b7\u53d6\u6838\u5fc31.0\u7684 Limits, \u6216\u5229\u7528 vk1.1 \u4e2d\u52a0\u5165\u7684 VkPhysicalDeviceProperties2 \u7684 pNext \u94fe \u83b7\u53d6\u5404 Extension \u65b0\u589e\u7684 Limits . \u7ed3\u6784\u4f53 VkPhysicalDeviceLimits \u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7701\u7565\u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd: \u4f8b\u5982: maxUniformBufferRange : \u5f53\u5c06\u7ed3\u6784\u4f53 VkDescriptorBufferInfo \u4f5c\u4e3a\u53c2\u6570\u8c03\u7528 vkUpdateDescriptorSets , \u5e76\u4e14 descriptors \u7c7b\u578b\u4e3a VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER \u6216 VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC \u65f6, \u5176\u7ed3\u6784\u4f53\u6210\u5458 range \u53ef\u8bbe\u7684\u6700\u5927\u503c. \u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684Limits \u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684\u7ed3\u6784\u4f53\u5747\u4ee5 Properties \u800c\u975e Limits \u7ed3\u5c3e, \u5176\u67e5\u8be2\u65b9\u6cd5\u4e0e\u67e5\u8be2 \u6269\u5c55\u63d0\u4f9b\u7684 Feature \u4e00\u6837. \u67e5\u8be2\u51fd\u6570\u548c\u7ed3\u679c\u7ed3\u6784\u4f53\u5982\u4e0b: VkPhysicalDeviceProperties2 deviceProperties; vkGetPhysicalDeviceProperties2KHR(mPhysicalDevice, &deviceProperties); \u67e5\u8be2\u7ed3\u679c\u793a\u4f8b: \u7ed3\u6784\u4f53 VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT \u5305\u542b\u4e86\u6269\u5c55 VK_EXT_vertex_attribute_divisor \u63d0\u4f9b\u7684 limits \u503c maxVertexAttribDivisor : // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT; Formats \u5bf9\u4e8e\u4e0d\u540c\u7684 vk \u5b9e\u73b0, \u5176\u652f\u6301\u7684\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u683c\u5f0f\u53ef\u80fd\u4f1a\u4e0d\u540c\u3002\u867d\u7136 Vulkan \u89c4\u5b9a\u4e86\u4e00\u7ec4\u5fc5\u987b\u652f\u6301\u7684 Format \u7684\u6700\u5c0f\u96c6\uff0c\u4f46\u5728\u4f7f\u7528\u9664\u6b64\u4ee5\u5916\u7684 Format\u529f\u80fd\u4e4b\u524d, \u5fc5\u987b\u663e\u5f0f\u7684\u67e5\u8be2\uff0c\u4ee5\u786e\u4fdd\u5b9e\u73b0\u652f\u6301\u8fd9\u4e9b\u683c\u5f0f\u3002 \u67e5\u8be2\u547d\u4ee4: vkGetPhysicalDeviceFormatProperties , \u67e5\u8be2\u8fd4\u56de\u7684 VkFormat \u7ed3\u6784\u4f53\u7684\u5305\u542b\u4e86\u5f53\u524d\u5b9e\u73b0\u6240\u652f\u6301\u7684\u683c\u5f0f\u529f\u80fd\u3002 VkFormat \u7ed3\u6784\u4f53\u793a\u4f8b: // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d \u5173\u4e8e Format \u76f8\u5173\u7684\u5185\u5bb9\u6bd4\u8f83\u590d\u6742, \u672c\u7ae0\u8282\u4ee5\u53ca\u540e\u7eed\u7ae0\u8282\u90fd\u4e0d\u8fdb\u884c\u6df1\u5165. \u5982\u679c\u9700\u8981\u8003\u8651\u518d\u5355\u72ec\u8fdb\u884c\u7814\u7a76. 39. Extending Vulkan New functionality may be added to Vulkan via either new extensions or new versions of the core, or new versions of an extension in some cases. This chapter describes how Vulkan is versioned, how compatibility is affected between different versions, and compatibility rules that are followed by the Vulkan Working Group. 39.1. Instance and Device Functionality Commands that enumerate instance properties, or that accept a VkInstance object as a parameter, are considered instance-level functionality. Commands that enumerate physical device properties, or that accept a VkDevice object or any of a device\u2019s child objects as a parameter, are considered device-level functionality. 39.4. Extensions Extensions may define new Vulkan commands, structures, and enumerants. For compilation purposes, the interfaces defined by registered extensions, including new structures and enumerants as well as function pointer types for new commands, are defined in the Khronos-supplied vulkan_core.h together with the core API. However, commands defined by extensions may not be available for static linking - in which case function pointers to these commands should be queried at runtime as described in Command Function Pointers . Extensions may be provided by layers as well as by a Vulkan implementation. Because extensions may extend or change the behavior of the Vulkan API, extension authors should add support for their extensions to the Khronos validation layers. This is especially important for new commands whose parameters have been wrapped by the validation layers. See the \u201cVulkan Loader Specification and Architecture Overview\u201d document for additional information. 39.4.1. Instance Extensions Instance extensions add new instance-level functionality to the API, outside of the core specification. To query the available instance extensions, call: // Provided by VK_VERSION_1_0 VkResult vkEnumerateInstanceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties); pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, as described below. pProperties is either NULL or a pointer to an array of VkExtensionProperties structures. When pLayerName parameter is NULL , only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the instance extensions provided by that layer are returned. If pProperties is NULL , then the number of extensions properties available is returned in pPropertyCount . Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties . If pPropertyCount is less than the number of extension properties available, at most pPropertyCount structures will be written. If pPropertyCount is smaller than the number of extensions available, VK_INCOMPLETE will be returned instead of VK_SUCCESS , to indicate that not all the available properties were returned. Because the list of available layers may change externally between calls to vkEnumerateInstanceExtensionProperties , two calls may retrieve different results if a pLayerName is available in one call but not in another. The extensions supported by a layer may also change between two calls, e.g. if the layer implementation is replaced by a different version between those calls. Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version. 39.4.2. Device Extensions Device extensions add new device-level functionality to the API, outside of the core specification. To query the extensions available to a given physical device, call: // Provided by VK_VERSION_1_0 VkResult vkEnumerateDeviceExtensionProperties( VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties); physicalDevice is the physical device that will be queried. pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, and is treated in the same fashion as the vkEnumerateInstanceExtensionProperties :: pPropertyCount parameter. pProperties is either NULL or a pointer to an array of VkExtensionProperties structures. When pLayerName parameter is NULL , only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the device extensions provided by that layer are returned. Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version. 40. Features Features describe functionality which is not supported on all implementations. Features are properties of the physical device. Features are optional , and must be explicitly enabled before use. Support for features is reported and enabled on a per-feature basis. NoteFeatures are reported via the basic VkPhysicalDeviceFeatures structure, as well as the extensible structure VkPhysicalDeviceFeatures2 , which was added in the VK_KHR_get_physical_device_properties2 extension and included in Vulkan 1.1. When new features are added in future Vulkan versions or extensions, each extension should introduce one new feature structure, if needed. This structure can be added to the pNext chain of the VkPhysicalDeviceFeatures2 structure. For convenience, new core versions of Vulkan may introduce new unified features structures for features promoted from extensions. At the same time, the extension\u2019s original features structure (if any) is also promoted to the core API, and is an alias of the extension\u2019s structure. This results in multiple names for the same feature: in the original extension\u2019s feature structure and the promoted structure alias, in the unified feature structure. When a feature was implicitly supported and enabled in the extension, but an explicit name was added during promotion, then the extension itself acts as an alias for the feature as listed in the table below. All aliases of the same feature in the core API must be reported consistently: either all must be reported as supported, or none of them. When a promoted extension is available, any corresponding feature aliases must be supported. // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; The pNext chain of this structure is used to extend the structure with features defined by extensions. Fine-grained features used by a logical device must be enabled at VkDevice creation time. If a feature is enabled that the physical device does not support, VkDevice creation will fail and return VK_ERROR_FEATURE_NOT_PRESENT . The fine-grained features are enabled by passing a pointer to the VkPhysicalDeviceFeatures structure via the pEnabledFeatures member of the VkDeviceCreateInfo structure that is passed into the vkCreateDevice call. If a member of pEnabledFeatures is set to VK_TRUE or VK_FALSE , then the device will be created with the indicated feature enabled or disabled, respectively. Features can also be enabled by using the VkPhysicalDeviceFeatures2 structure. If an application wishes to enable all features supported by a device, it can simply pass in the VkPhysicalDeviceFeatures structure that was previously returned by vkGetPhysicalDeviceFeatures . To disable an individual feature, the application can set the desired member to VK_FALSE in the same structure. Setting pEnabledFeatures to NULL and not including a VkPhysicalDeviceFeatures2 in the pNext chain of VkDeviceCreateInfo is equivalent to setting all members of the structure to VK_FALSE . To query support for atomic operations on floating-point numbers, call vkGetPhysicalDeviceFeatures2 with a VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure included in the pNext chain of its pFeatures parameter. The VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure is defined as: // Provided by VK_EXT_shader_atomic_float typedef struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 shaderBufferFloat32Atomics; VkBool32 shaderBufferFloat32AtomicAdd; VkBool32 shaderBufferFloat64Atomics; VkBool32 shaderBufferFloat64AtomicAdd; VkBool32 shaderSharedFloat32Atomics; VkBool32 shaderSharedFloat32AtomicAdd; VkBool32 shaderSharedFloat64Atomics; VkBool32 shaderSharedFloat64AtomicAdd; VkBool32 shaderImageFloat32Atomics; VkBool32 shaderImageFloat32AtomicAdd; VkBool32 sparseImageFloat32Atomics; VkBool32 sparseImageFloat32AtomicAdd; } VkPhysicalDeviceShaderAtomicFloatFeaturesEXT; 41. Limits Limits are implementation-dependent minimums, maximums, and other device characteristics that an application may need to be aware of. NoteLimits are reported via the basic VkPhysicalDeviceLimits structure, as well as the extensible structure VkPhysicalDeviceProperties2 , which was added in VK_KHR_get_physical_device_properties2 and included in Vulkan 1.1. When limits are added in future Vulkan versions or extensions, each extension should introduce one new limit structure, if needed. This structure can be added to the pNext chain of the VkPhysicalDeviceProperties2 structure. The VkPhysicalDeviceLimits structure is defined as: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd The VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure is defined as: // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT; 42. Formats Supported buffer and image formats may vary across implementations. A minimum set of format features are guaranteed, but others must be explicitly queried before use to ensure they are supported by the implementation. The features for the set of formats ( VkFormat ) supported by the implementation are queried individually using the vkGetPhysicalDeviceFormatProperties command. 42.1. Format Definition The following image formats can be passed to, and may be returned from Vulkan commands. The memory required to store each format is discussed with that format, and also summarized in the Representation and Texel Block Size section and the Compatible formats table. // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d 43. Additional Capabilities This chapter describes additional capabilities beyond the minimum capabilities described in the ( Limits and Formats chapters, including: Additional Image Capabilities Additional Buffer Capabilities Optional Semaphore Capabilities Optional Fence Capabilities Timestamp Calibration Capabilities","title":"0.1. Vulkan \u6269\u5c55"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#vulkan","text":"(\u672c\u7ae0\u6587\u672c\u5185\u5bb9\u7684\u66f4\u591a\u7ec6\u8282, \u53c2\u89c1 Vulkan Specification 1.1 , \u4ee3\u7801\u4e3a\u793a\u4f8b\u7528\u4f2a\u7801) \u5bf9\u4e8e\u4e0d\u540c\u7684\u5e73\u53f0, \u9a71\u52a8, \u64cd\u4f5c\u7cfb\u7edf\u7b49, \u5f53Vulkan\u7684\u5e95\u5c42\u5b9e\u73b0\u4e0d\u540c\u65f6, Vulkan \u53ef\u7528\u7684\u529f\u80fd\u96c6\u4e5f\u6709\u5f88\u591a\u533a\u522b. \u672c\u7ae0\u63cf\u8ff0\u4e86 Vulkan \u5982\u4f55\u5b9a\u4e49\u548c\u6269\u5c55\u529f\u80fd\u96c6, \u4e3b\u8981\u4ecb\u7ecd\u4e86\u56db\u4e2a\u6982\u5ff5: Extension, Feature, Limitation, \u548c Format.","title":"Vulkan \u6269\u5c55"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#vulkan_1","text":"\u5728\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u65f6, \u9700\u8981\u542f\u7528\u7684 Vulkan \u529f\u80fd\u96c6\u9700\u8981\u5728\u521d\u59cb\u5316 Device \u524d\u786e\u5b9a\u4e0b\u6765. \u5bf9\u5e94 vk \u521d\u59cb\u5316\u7684\u524d\u4e09\u6b65: Instance --> Physical Device --> Device \u4ee5\u4e0b\u662f\u521d\u59cb\u5316\u8fc7\u7a0b\u4e2d\u4e0e\u529f\u80fd\u76f8\u5173\u7684\u8fc7\u7a0b: \u679a\u4e3e vk \u652f\u6301\u7684 Instance-level Extensions \u521b\u5efa Instance \u679a\u4e3e \u7269\u7406\u8bbe\u5907, \u9009\u62e9 GPU, \u679a\u4e3e GPU \u652f\u6301\u7684 Device Extensions, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u200b \u67e5\u8be2\u652f\u6301\u7684 Extensions \u7684 Features \u7ed3\u6784\u4f53, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u200b \u67e5\u8be2\u652f\u6301\u7684 Extensions \u7684 Properties \u7ed3\u6784\u4f53 \u67e5\u8be2 GPU \u652f\u6301\u7684 Feature, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u67e5\u8be2 GPU \u7684 Properties \u5c06\u542f\u7528\u7684 Extensions \u548c Features \u5217\u8868\u653e\u5165 CreateInfo \u7ed3\u6784\u4f53, \u521b\u5efa\u903b\u8f91\u8bbe\u5907 Device, Extension: \u529f\u80fd\u96c6\u7684\u62bd\u8c61\u6982\u5ff5, \u7528\u6765\u4e3a Vulkan \u6dfb\u52a0\u65b0\u7684 Commands\uff0cStructures \u548c Enumerants. \u540c\u65f6\u53ef\u80fd\u65b0\u589e Features, Limitations, \u548c Format. Feature: bool \u503c\u96c6\u5408, \u53ef\u9009\u529f\u80fd\u7684\u5f00\u5173. \u53ef\u4ee5\u7528\u6765\u67e5\u8be2\u8bbe\u5907\u652f\u6301\u7684\u529f\u80fd, Limitation \u548c Format \u662f\u4e24\u4e2a\u53ea\u8bfb\u53c2\u6570\u96c6, Limitation \u53c8\u79f0\u505a Properties, \u8868\u793a\u8bbe\u5907\u7279\u5f81\u503c; Format \u8868\u793a\u652f\u6301\u7684\u683c\u5f0f. \u672c\u7ae0\u540e\u9762\u5404\u7ae0\u8282\u5bf9\u6b64\u6d41\u7a0b\u5404\u6b65\u9aa4\u8fdb\u884c\u89e3\u91ca, \u5e76\u5305\u542b\u793a\u4f8b\u4ee3\u7801.","title":"Vulkan \u521d\u59cb\u5316\u6d41\u7a0b"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#extensions","text":"\u6269\u5c55 (Extensions) \u53ef\u7528\u6765\u4e3a Vk \u6dfb\u52a0\u65b0\u529f\u80fd. Vk \u6838\u5fc3\u7684\u65b0\u7248\u672c (\u5982: VK_VERSION_1_1) \u4e5f\u53ef\u4ee5\u89c6\u4e3a\u4e00\u4e2a\u6269\u5c55. \u6269\u5c55\u53ef\u4ee5\u5b9a\u4e49\u65b0\u7684 \u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784. ( Commands\uff0cStructures \u548c Enumerants) \u6269\u5c55\u5206\u4e3a\u5b9e\u4f8b\u7ea7\u548c\u8bbe\u5907\u7ea7 (Instance-level \u548c Device-level) \u5f53 Commands \u7528\u6765\u679a\u4e3e\u5b9e\u4f8b\u5c5e\u6027 (instance properties), \u6216\u63a5\u53d7 VkInstance \u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570, \u5219\u88ab\u89c6\u4e3a\u5b9e\u4f8b\u7ea7\u529f\u80fd\u3002 \u5f53 Commands \u7528\u6765\u679a\u4e3e\u7269\u7406\u8bbe\u5907\u5c5e\u6027 (physical device properties), \u6216\u63a5\u53d7 VkDevice \u53ca\u5176\u5b50\u7c7b\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\uff0c\u5219\u88ab\u89c6\u4e3a\u8bbe\u5907\u7ea7\u529f\u80fd\u3002 \u4e3a\u4e86\u65b9\u4fbf\u7f16\u8bd1\uff0c\u5728 Khronos \u63d0\u4f9b\u7684 vulkan_core.h \u4e2d\u9664\u4e86\u6838\u5fc3API, \u8fd8\u5b9a\u4e49\u4e86\u5df2\u6ce8\u518c Extensions \u5b9a\u4e49\u7684\u63a5\u53e3\uff0c\u5305\u62ec\u65b0 \u7ed3\u6784, \u679a\u4e3e, \u548c\u547d\u4ee4\u7684\u51fd\u6570\u6307\u9488\u7c7b\u578b\u3002\u6269\u5c55\u7684\u5b9e\u73b0\u901a\u8fc7 Layers \u548c Vulkan\u5b9e\u73b0\u6765\u63d0\u4f9b\u3002","title":"Extensions: \u6269\u5c55"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#vk-extensions","text":"Vk Extensions \u9700\u8981\u5728\u521d\u59cb\u5316\u9636\u6bb5\u663e\u5f0f\u542f\u7528. \u542f\u7528 instance extension, \u8981\u5728\u521b\u5efa VKInstance \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkInstanceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. \u542f\u7528 device extension, \u8981\u5728 \u521b\u5efa VkDevice \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkDeviceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. Physical-Device-Level \u529f\u80fd\u6ca1\u6709\u542f\u7528\u673a\u5236\uff0c\u53ea\u8981 VkPhysicalDevice \u7684\u529f\u80fd\u5bf9\u5e94\u7684 Extensions \u5728\u679a\u4e3e\u51fd\u6570 vkEnumerateDeviceExtensionProperties \u4e2d\u88ab\u5217\u51fa. \u4ec5 \u542f\u7528 \u6269\u5c55\u64cd\u4f5c\u800c\u8a00, \u9664\u4e86 \u542f\u7528 \u8be5\u6269\u5c55\u81ea\u8eab\u5b9a\u4e49\u7684\u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784\u5916, \u4e0d\u4f1a\u66f4\u6539\u6838\u5fc3Vulkan API \u6216\u5176\u4ed6\u6269\u5c55\u7684\u529f\u80fd\u3002 \u793a\u4f8b: \u521b\u5efa VkInstance \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> extensions(); extensions.push_back(VK_KHR_WIN32_SURFACE_EXTENSION_NAME); VkInstanceCreateInfo inst_info = {}; inst_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; ... // Enable Instance Extensions inst_info.enabledExtensionCount = extensions.size(); inst_info.ppEnabledExtensionNames = extensions.data(); VkInstance instance; VkResult res = vkCreateInstance(&inst_info, NULL, &instance); \u5bf9 VkPhysicalDevice, \u679a\u4e3e\u5176\u652f\u6301\u7684 Extensions: // \u679a\u4e3e\u8bbe\u5907 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); // \u9009\u62e9\u8bbe\u5907 VkPhysicalDevice physicalDevice = devices[0]; // \u4ec5\u793a\u4f8b,\u6b63\u786e\u4ee3\u7801\u5e94\u9009\u62e9\u5bf9\u5e94 GPU \u8bbe\u5907 // \u679a\u4e3e Extensions uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, availableExtensions.data()); \u521b\u5efa VkDevice \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> device_extension_names(); // check if physicalDevice support extension: for (const auto& extension : availableExtensions) { if(strcmp(extension.extensionName, VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0) device_extension_names.push_back(extension.extensionName); } } VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; device_info.pNext = NULL; ... // Enable Device Extensions device_info.enabledExtensionCount = device_extension_names.size(); device_info.ppEnabledExtensionNames = enabledExtensionCount ? device_extension_names.data() : NULL; VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device);","title":"\u542f\u7528 Vk Extensions"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#features","text":"Features \u7528\u6765\u8bbe\u7f6e\u6216\u67e5\u8be2 \u975e\u6240\u6709\u5b9e\u73b0\u90fd\u652f\u6301 \u7684\u529f\u80fd\u3002 Feature \u5747\u4e3a bool \u503c. Features \u662f\u7269\u7406\u8bbe\u5907\u7684\u5c5e\u6027\u3002(physical device properties) \u8fd9\u4e9b\u529f\u80fd\u662f\u201c\u53ef\u9009\u201d\u7684\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u4f7f\u7528\u524d\u660e\u786e\u542f\u7528\u3002","title":"Features: \u529f\u80fd"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#features_1","text":"Vk \u6838\u5fc3\u4e2d\u5b9a\u4e49\u7684 Features, \u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceFeatures \u67e5\u8be2. VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); \u67e5\u8be2\u7ed3\u679c VkPhysicalDeviceFeatures \u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceFeatures { VkBool32 robustBufferAccess; VkBool32 fullDrawIndexUint32; VkBool32 imageCubeArray; VkBool32 independentBlend; VkBool32 geometryShader; VkBool32 tessellationShader; VkBool32 sampleRateShading; .... // \u603b\u8ba150+\u4e2a Bool \u503c } VkPhysicalDeviceFeatures \u5176\u4e2d\u6bcf\u4e2a Feature \u7684\u542b\u4e49 \u5728 Vulkan Specification 1.1/Features \u4e2d\u90fd\u6709\u89e3\u91ca. \u4f8b\u5982: IndependentBlend \u6307\u5b9a: \u662f\u5426\u6bcf\u4e2a attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u4e92\u76f8\u72ec\u7acb\u3002 \u672a\u542f\u7528\u6b64 Feature\uff0c\u5219\u6240\u6709 color attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u5fc5\u987b\u76f8\u540c\u3002 \u82e5\u542f\u7528\u6b64 Feature\uff0c\u5219\u53ef\u4ee5\u4e3a\u6bcf\u4e2a\u7ed1\u5b9a\u7684 color attachment \u63d0\u4f9b\u4e0d\u540c\u7684 VkPipelineColorBlendAttachmentState \u3002","title":"\u6838\u5fc3 Features"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#features_2","text":"\u67e5\u8be2\u51fd\u6570: vkGetPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 physicalDeviceFeatures2; vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &physicalDeviceFeatures2); \u67e5\u8be2\u7ed3\u679c: VkPhysicalDeviceFeatures2 \u7ed3\u6784: // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; sType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 pNext: \u6307\u9488\u94fe. VkPhysicalDeviceFeatures: Vulkan 1.0 \u63d0\u4f9b\u7684\u6838\u5fc3 Features \u6ce8: VkPhysicalDeviceFeatures2 \u7b49\u4ef7 VkPhysicalDeviceFeatures2KHR, vkGetPhysicalDeviceFeatures2 \u7b49\u4ef7 vkGetPhysicalDeviceFeatures2KHR \u901a\u8fc7 pNext , \u53ef\u4ee5\u83b7\u5f97\u6269\u5c55\u6240\u5b9a\u4e49\u7684 Features \u7ed3\u6784\u4f53, \u6709\u7684\u7531 Vulkan \u6838\u5fc3\u65b0\u7248\u672c\u63d0\u4f9b, \u6709\u7684\u7531\u5176\u4ed6 Extension\u63d0\u4f9b. \u4f8b\u5982: Vulkan 1.1 \u63d0\u4f9b\u7684 samplerYcbcrConversion. // Provided by VK_VERSION_1_1: VK_KHR_sampler_ycbcr_conversion typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures { VkStructureType sType; void* pNext; VkBool32 samplerYcbcrConversion; } VkPhysicalDeviceSamplerYcbcrConversionFeatures; VK_EXT_transform_feedback \u63d0\u4f9b\u7684 transformFeedback \u548c geometryStreams. // Provided by VK_EXT_transform_feedback typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 transformFeedback; VkBool32 geometryStreams; } VkPhysicalDeviceTransformFeedbackFeaturesEXT; \u67e5\u8be2\u793a\u4f8b: // \u6269\u5c55\u7684 Feature \u7ed3\u6784\u4f53 VkPhysicalDeviceSamplerYcbcrConversionFeatures mSamplerYcbcrConversionFeatures = {}; mSamplerYcbcrConversionFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; // vk1.1 \u7684 VkPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 deviceFeatures = {}; deviceFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; deviceFeatures.pNext = mVertexAttributeDivisorFeatures // \u67e5\u8be2 vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &deviceFeatures); // \u4f7f\u7528 if (mVertexAttributeDivisorFeatures.vertexAttributeInstanceRateDivisor) { ... }","title":"\u6269\u5c55\u63d0\u4f9b\u7684Features"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#features_3","text":"Features \u9ed8\u8ba4\u7686\u4e3a\u4e0d\u542f\u7528\u72b6\u6001. \u5fc5\u987b\u5728 VkDevice \u521b\u5efa\u65f6\u663e\u5f0f\u542f\u7528\u3002\u5982\u679c\u542f\u7528\u4e86\u7269\u7406\u8bbe\u5907\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5219 VkDevice \u521b\u5efa\u5c06\u5931\u8d25\uff0c\u5e76\u8fd4\u56deVK_ERROR_FEATURE_NOT_PRESENT\u3002 \u542f\u7528\u65b9\u6cd5: \u521b\u5efa VkPhysicalDeviceFeatures \u7ed3\u6784\u7684\u6307\u9488 (\u62161.1\u7684 VkPhysicalDeviceFeatures2\u7ed3\u6784) \u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \u6216 VK_FALSE, eg: physicalDeviceFeatures.independentBlend = VK_TRUE \u901a\u8fc7\u4f20\u9012\u7ed9 vkCreateDevice \u7528\u7684 VkDeviceCreateInfo\u7ed3\u6784\u7684 pEnabledFeatures \u6210\u5458. \u8981\u542f\u52a8\u6240\u6709\u8bbe\u5907\u7684\u529f\u80fd (\u614e\u7528)\uff0c\u5219\u53ea\u9700\u4f20\u5165\u67e5\u8be2\u51fd\u6570 vkGetPhysicalDeviceFeatures \u8fd4\u56de\u7684 VkPhysicalDeviceFeatures \u7ed3\u6784\u5373\u53ef\u3002\u8981\u7981\u7528\u5355\u4e2a\u529f\u80fd\uff0c\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728\u76f8\u540c\u7ed3\u6784\u4e2d\u5c06\u6240\u9700\u6210\u5458\u8bbe\u7f6e\u4e3aVK_FALSE\u3002 \u7528\u8fc7\u7ed9 pNext\u94fe\u6dfb\u52a0 Extensions \u63d0\u4f9b\u7684 Features \u7ed3\u6784\u4f53, \u6765\u542f\u7528\u6269\u5c55\u7684 Features. // \u67e5\u8be2\u6838\u5fc3 Features \u662f\u5426\u652f\u6301 VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); // \u8bbe\u7f6e\u542f\u7528 Features VkPhysicalDeviceFeatures2KHR enabledFeatures = {}; enabledFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; enabledFeatures.features.imageCubeArray = mPhysicalDeviceFeatures.imageCubeArray; enabledFeatures.features.independentBlend = mPhysicalDeviceFeatures.independentBlend; // Create Device VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; // \u6307\u5411 Features \u7ed3\u6784\u4f53\u4ee5\u8bbe\u7f6e Extensions \u63d0\u4f9b\u7684 Features // mSamplerYcbcrConversionFeatures : \u524d\u9762\u67e5\u8be2\u793a\u4f8b\u4e2d\u7684\u7ed3\u6784\u4f53. device_info.pNext = mSamplerYcbcrConversionFeatures; // Enable Physical Device Features device_info.pEnabledFeatures = &enabledFeatures.features; ... VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device);","title":"\u542f\u7528 Features"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#limitations","text":"Limits \u63d0\u4f9b\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u53ef\u80fd\u9700\u8981\u660e\u786e\u7684\u4e00\u4e9b\u8bbe\u5907\u7279\u5f81\u503c, \u8fd9\u4e9b\u7279\u5f81\u7684\u6700\u5c0f\u503c\uff0c\u6700\u5927\u503c\u7b49\u4f1a\u968f\u5e95\u5c42\u5b9e\u73b0\u7684\u4e0d\u540c\u800c\u5f02. \u901a\u8fc7 VkPhysicalDeviceLimits \u7ed3\u6784\u4f53\u83b7\u53d6\u6838\u5fc31.0\u7684 Limits, \u6216\u5229\u7528 vk1.1 \u4e2d\u52a0\u5165\u7684 VkPhysicalDeviceProperties2 \u7684 pNext \u94fe \u83b7\u53d6\u5404 Extension \u65b0\u589e\u7684 Limits . \u7ed3\u6784\u4f53 VkPhysicalDeviceLimits \u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7701\u7565\u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd: \u4f8b\u5982: maxUniformBufferRange : \u5f53\u5c06\u7ed3\u6784\u4f53 VkDescriptorBufferInfo \u4f5c\u4e3a\u53c2\u6570\u8c03\u7528 vkUpdateDescriptorSets , \u5e76\u4e14 descriptors \u7c7b\u578b\u4e3a VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER \u6216 VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC \u65f6, \u5176\u7ed3\u6784\u4f53\u6210\u5458 range \u53ef\u8bbe\u7684\u6700\u5927\u503c.","title":"Limitations"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#limits","text":"\u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684\u7ed3\u6784\u4f53\u5747\u4ee5 Properties \u800c\u975e Limits \u7ed3\u5c3e, \u5176\u67e5\u8be2\u65b9\u6cd5\u4e0e\u67e5\u8be2 \u6269\u5c55\u63d0\u4f9b\u7684 Feature \u4e00\u6837. \u67e5\u8be2\u51fd\u6570\u548c\u7ed3\u679c\u7ed3\u6784\u4f53\u5982\u4e0b: VkPhysicalDeviceProperties2 deviceProperties; vkGetPhysicalDeviceProperties2KHR(mPhysicalDevice, &deviceProperties); \u67e5\u8be2\u7ed3\u679c\u793a\u4f8b: \u7ed3\u6784\u4f53 VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT \u5305\u542b\u4e86\u6269\u5c55 VK_EXT_vertex_attribute_divisor \u63d0\u4f9b\u7684 limits \u503c maxVertexAttribDivisor : // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;","title":"\u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684Limits"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#formats","text":"\u5bf9\u4e8e\u4e0d\u540c\u7684 vk \u5b9e\u73b0, \u5176\u652f\u6301\u7684\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u683c\u5f0f\u53ef\u80fd\u4f1a\u4e0d\u540c\u3002\u867d\u7136 Vulkan \u89c4\u5b9a\u4e86\u4e00\u7ec4\u5fc5\u987b\u652f\u6301\u7684 Format \u7684\u6700\u5c0f\u96c6\uff0c\u4f46\u5728\u4f7f\u7528\u9664\u6b64\u4ee5\u5916\u7684 Format\u529f\u80fd\u4e4b\u524d, \u5fc5\u987b\u663e\u5f0f\u7684\u67e5\u8be2\uff0c\u4ee5\u786e\u4fdd\u5b9e\u73b0\u652f\u6301\u8fd9\u4e9b\u683c\u5f0f\u3002 \u67e5\u8be2\u547d\u4ee4: vkGetPhysicalDeviceFormatProperties , \u67e5\u8be2\u8fd4\u56de\u7684 VkFormat \u7ed3\u6784\u4f53\u7684\u5305\u542b\u4e86\u5f53\u524d\u5b9e\u73b0\u6240\u652f\u6301\u7684\u683c\u5f0f\u529f\u80fd\u3002 VkFormat \u7ed3\u6784\u4f53\u793a\u4f8b: // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d \u5173\u4e8e Format \u76f8\u5173\u7684\u5185\u5bb9\u6bd4\u8f83\u590d\u6742, \u672c\u7ae0\u8282\u4ee5\u53ca\u540e\u7eed\u7ae0\u8282\u90fd\u4e0d\u8fdb\u884c\u6df1\u5165. \u5982\u679c\u9700\u8981\u8003\u8651\u518d\u5355\u72ec\u8fdb\u884c\u7814\u7a76.","title":"Formats"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#39-extending-vulkan","text":"New functionality may be added to Vulkan via either new extensions or new versions of the core, or new versions of an extension in some cases. This chapter describes how Vulkan is versioned, how compatibility is affected between different versions, and compatibility rules that are followed by the Vulkan Working Group.","title":"39. Extending Vulkan"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#391-instance-and-device-functionality","text":"Commands that enumerate instance properties, or that accept a VkInstance object as a parameter, are considered instance-level functionality. Commands that enumerate physical device properties, or that accept a VkDevice object or any of a device\u2019s child objects as a parameter, are considered device-level functionality.","title":"39.1. Instance and Device Functionality"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#394-extensions","text":"Extensions may define new Vulkan commands, structures, and enumerants. For compilation purposes, the interfaces defined by registered extensions, including new structures and enumerants as well as function pointer types for new commands, are defined in the Khronos-supplied vulkan_core.h together with the core API. However, commands defined by extensions may not be available for static linking - in which case function pointers to these commands should be queried at runtime as described in Command Function Pointers . Extensions may be provided by layers as well as by a Vulkan implementation. Because extensions may extend or change the behavior of the Vulkan API, extension authors should add support for their extensions to the Khronos validation layers. This is especially important for new commands whose parameters have been wrapped by the validation layers. See the \u201cVulkan Loader Specification and Architecture Overview\u201d document for additional information.","title":"39.4. Extensions"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#3941-instance-extensions","text":"Instance extensions add new instance-level functionality to the API, outside of the core specification. To query the available instance extensions, call: // Provided by VK_VERSION_1_0 VkResult vkEnumerateInstanceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties); pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, as described below. pProperties is either NULL or a pointer to an array of VkExtensionProperties structures. When pLayerName parameter is NULL , only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the instance extensions provided by that layer are returned. If pProperties is NULL , then the number of extensions properties available is returned in pPropertyCount . Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties . If pPropertyCount is less than the number of extension properties available, at most pPropertyCount structures will be written. If pPropertyCount is smaller than the number of extensions available, VK_INCOMPLETE will be returned instead of VK_SUCCESS , to indicate that not all the available properties were returned. Because the list of available layers may change externally between calls to vkEnumerateInstanceExtensionProperties , two calls may retrieve different results if a pLayerName is available in one call but not in another. The extensions supported by a layer may also change between two calls, e.g. if the layer implementation is replaced by a different version between those calls. Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version.","title":"39.4.1. Instance Extensions"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#3942-device-extensions","text":"Device extensions add new device-level functionality to the API, outside of the core specification. To query the extensions available to a given physical device, call: // Provided by VK_VERSION_1_0 VkResult vkEnumerateDeviceExtensionProperties( VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties); physicalDevice is the physical device that will be queried. pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, and is treated in the same fashion as the vkEnumerateInstanceExtensionProperties :: pPropertyCount parameter. pProperties is either NULL or a pointer to an array of VkExtensionProperties structures. When pLayerName parameter is NULL , only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the device extensions provided by that layer are returned. Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version.","title":"39.4.2. Device Extensions"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#40-features","text":"Features describe functionality which is not supported on all implementations. Features are properties of the physical device. Features are optional , and must be explicitly enabled before use. Support for features is reported and enabled on a per-feature basis. NoteFeatures are reported via the basic VkPhysicalDeviceFeatures structure, as well as the extensible structure VkPhysicalDeviceFeatures2 , which was added in the VK_KHR_get_physical_device_properties2 extension and included in Vulkan 1.1. When new features are added in future Vulkan versions or extensions, each extension should introduce one new feature structure, if needed. This structure can be added to the pNext chain of the VkPhysicalDeviceFeatures2 structure. For convenience, new core versions of Vulkan may introduce new unified features structures for features promoted from extensions. At the same time, the extension\u2019s original features structure (if any) is also promoted to the core API, and is an alias of the extension\u2019s structure. This results in multiple names for the same feature: in the original extension\u2019s feature structure and the promoted structure alias, in the unified feature structure. When a feature was implicitly supported and enabled in the extension, but an explicit name was added during promotion, then the extension itself acts as an alias for the feature as listed in the table below. All aliases of the same feature in the core API must be reported consistently: either all must be reported as supported, or none of them. When a promoted extension is available, any corresponding feature aliases must be supported. // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; The pNext chain of this structure is used to extend the structure with features defined by extensions. Fine-grained features used by a logical device must be enabled at VkDevice creation time. If a feature is enabled that the physical device does not support, VkDevice creation will fail and return VK_ERROR_FEATURE_NOT_PRESENT . The fine-grained features are enabled by passing a pointer to the VkPhysicalDeviceFeatures structure via the pEnabledFeatures member of the VkDeviceCreateInfo structure that is passed into the vkCreateDevice call. If a member of pEnabledFeatures is set to VK_TRUE or VK_FALSE , then the device will be created with the indicated feature enabled or disabled, respectively. Features can also be enabled by using the VkPhysicalDeviceFeatures2 structure. If an application wishes to enable all features supported by a device, it can simply pass in the VkPhysicalDeviceFeatures structure that was previously returned by vkGetPhysicalDeviceFeatures . To disable an individual feature, the application can set the desired member to VK_FALSE in the same structure. Setting pEnabledFeatures to NULL and not including a VkPhysicalDeviceFeatures2 in the pNext chain of VkDeviceCreateInfo is equivalent to setting all members of the structure to VK_FALSE . To query support for atomic operations on floating-point numbers, call vkGetPhysicalDeviceFeatures2 with a VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure included in the pNext chain of its pFeatures parameter. The VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure is defined as: // Provided by VK_EXT_shader_atomic_float typedef struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 shaderBufferFloat32Atomics; VkBool32 shaderBufferFloat32AtomicAdd; VkBool32 shaderBufferFloat64Atomics; VkBool32 shaderBufferFloat64AtomicAdd; VkBool32 shaderSharedFloat32Atomics; VkBool32 shaderSharedFloat32AtomicAdd; VkBool32 shaderSharedFloat64Atomics; VkBool32 shaderSharedFloat64AtomicAdd; VkBool32 shaderImageFloat32Atomics; VkBool32 shaderImageFloat32AtomicAdd; VkBool32 sparseImageFloat32Atomics; VkBool32 sparseImageFloat32AtomicAdd; } VkPhysicalDeviceShaderAtomicFloatFeaturesEXT;","title":"40. Features"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#41-limits","text":"Limits are implementation-dependent minimums, maximums, and other device characteristics that an application may need to be aware of. NoteLimits are reported via the basic VkPhysicalDeviceLimits structure, as well as the extensible structure VkPhysicalDeviceProperties2 , which was added in VK_KHR_get_physical_device_properties2 and included in Vulkan 1.1. When limits are added in future Vulkan versions or extensions, each extension should introduce one new limit structure, if needed. This structure can be added to the pNext chain of the VkPhysicalDeviceProperties2 structure. The VkPhysicalDeviceLimits structure is defined as: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd The VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure is defined as: // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;","title":"41. Limits"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#42-formats","text":"Supported buffer and image formats may vary across implementations. A minimum set of format features are guaranteed, but others must be explicitly queried before use to ensure they are supported by the implementation. The features for the set of formats ( VkFormat ) supported by the implementation are queried individually using the vkGetPhysicalDeviceFormatProperties command.","title":"42. Formats"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#421-format-definition","text":"The following image formats can be passed to, and may be returned from Vulkan commands. The memory required to store each format is discussed with that format, and also summarized in the Representation and Texel Block Size section and the Compatible formats table. // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d","title":"42.1. Format Definition"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#43-additional-capabilities","text":"This chapter describes additional capabilities beyond the minimum capabilities described in the ( Limits and Formats chapters, including: Additional Image Capabilities Additional Buffer Capabilities Optional Semaphore Capabilities Optional Fence Capabilities Timestamp Calibration Capabilities","title":"43. Additional Capabilities"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/","text":"1. \u6d41\u7a0b\u603b\u89c8 2. \u521d\u59cb\u5316\u65f6, \u6d89\u53ca\u7684 API 2. \u7406\u89e3 Vulkan\u00ae Objects 1. Instance 2. PhysicalDevice 3. Device 4. Queue 5. CommandPool 6. CommandBuffer 7. Sampler 8. Image & Buffer TODO 9. DeviceMemory \u5bf9\u8c61\u7ec4 \u8bbe\u5907 \u56fe\u50cf \u7ba1\u9053 3. Pipeline 4. \u8be6\u7ec6 1. \u6d41\u7a0b\u603b\u89c8 \u521d\u59cb\u8bbe\u7f6e Instance \u5b9e\u4f8b [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 \u5448\u73b0 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b \u7ed8\u5236 Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe \u6ce8: []: \u975e Vulkan \u6838\u5fc3 init_global_layer_properties(info); init_instance_extension_names(info); init_device_extension_names(info); init_instance(info, sample_title); init_enumerate_device(info); init_window_size(info, 500, 500); init_connection(info); init_window(info); init_swapchain_extension(info); init_device(info); init_command_pool(info); init_command_buffer(info); execute_begin_command_buffer(info); init_device_queue(info); init_swap_chain(info); init_depth_buffer(info); init_uniform_buffer(info); init_descriptor_and_pipeline_layouts(info, false); init_renderpass(info, depthPresent); #include \"15-draw_cube.vert.h\" #include \"15-draw_cube.frag.h\" VkShaderModuleCreateInfo vert_info = {}; VkShaderModuleCreateInfo frag_info = {}; vert_info.sType = frag_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; vert_info.codeSize = sizeof(__draw_cube_vert); vert_info.pCode = __draw_cube_vert; frag_info.codeSize = sizeof(__draw_cube_frag); frag_info.pCode = __draw_cube_frag; init_shaders(info, &vert_info, &frag_info); init_framebuffers(info, depthPresent); init_vertex_buffer(info, g_vb_solid_face_colors_Data, sizeof(g_vb_solid_face_colors_Data), sizeof(g_vb_solid_face_colors_Data[0]), false); init_descriptor_pool(info, false); init_descriptor_set(info, false); init_pipeline_cache(info); init_pipeline(info, depthPresent); 2. \u521d\u59cb\u5316\u65f6, \u6d89\u53ca\u7684 API \u521d\u59cb\u8bbe\u7f6e Instance \u5b9e\u4f8b vkCreateInstance [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf vkEnumeratePhysicalDevices vkGetPhysicalDeviceQueueFamilyProperties Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 \u5448\u73b0 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b \u7ed8\u5236 Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe 2. \u7406\u89e3 Vulkan\u00ae Objects \u7eff\u8272\u6846: \u65e0\u7c7b\u578b, \u4ee5 uint32_t \u8868\u793a \u5b9e\u7ebf+\u7bad\u5934: \u521b\u5efa\u987a\u5e8f \u5b9e\u7ebf+\u83f1\u5f62: \u7ec4\u5408 (\u88ab\u5305\u542b) \u865a\u7ebf: \u901a\u4fe1 \u4e09\u4e2a\u533a\u57df\u4e2d, \u7ea2\u8272\u4e3a\u4e3b Object, \u5176\u4ed6\u5bf9\u8c61\u90fd\u76f4\u63a5\u6216\u95f4\u63a5\u7684\u7531\u6b64\u5bf9\u8c61\u521b\u5efa. \u8868\u73b0\u4e3a vkCreateSwapchainKHR \u9700\u8981 Device \u4e3a\u53c2\u6570. 1. Instance Instance \u662f\u521b\u5efa\u7684\u7b2c\u4e00\u4e2a\u5bf9\u8c61\u3002 \u5b83\u8868\u793a\u4ece\u5e94\u7528\u7a0b\u5e8f\u5230 Vulkan \u8fd0\u884c\u65f6\u7684 \u8fde\u63a5 \uff0c\u56e0\u6b64\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u4ec5\u5e94 \u5b58\u5728\u4e00\u6b21 \u3002 \u5b83\u8fd8\u5b58\u50a8\u4f7f\u7528 Vulkan \u6240\u9700\u7684\u6240\u6709\u7279\u5b9a\u4e8e \u5e94\u7528\u7a0b\u5e8f \u7684\u72b6\u6001\u3002 \u56e0\u6b64\uff0c\u60a8\u5fc5\u987b\u6307\u5b9a\u521b\u5efa\u5b9e\u4f8b\u65f6\u8981\u542f\u7528\u7684\u6240\u6709\u5c42 Layers \uff08\u4f8b\u5982\u9a8c\u8bc1\u5c42\uff09\u548c\u6240\u6709\u6269\u5c55 Extensions\u3002 2. PhysicalDevice \u8868\u793a\u7279\u5b9a\u7684 Vulkan \u517c\u5bb9\u8bbe\u5907\uff0c\u4f8b\u5982\u56fe\u5f62\u5361\u3002 vkEnumeratePhysicalDevices \u60a8\u53ef\u4ee5\u4ece Instance \u4e2d \u679a\u4e3e \u5b83\u4eec\uff0c\u7136\u540e\u53ef\u4ee5\u67e5\u8be2\u5b83\u4eec\u7684 vendorID\uff0cdeviceID \u548c\u652f\u6301\u7684\u529f\u80fd\u4ee5\u53ca\u5176\u4ed6\u5c5e\u6027\u548c\u9650\u5236\u3002 vkGetPhysicalDeviceQueueFamilyProperties PhysicalDevice \u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u53ef\u7528\u7684 Queue Families \u7c7b\u578b\u3002 \u56fe\u5f62\u961f\u5217 Graphics Queue \u662f\u6700\u4e3b\u8981\u7684\u961f\u5217\uff0c\u4f46\u662f\u60a8\u53ef\u80fd\u8fd8\u6709\u5176\u4ed6\u4ec5\u652f\u6301\u8ba1\u7b97Compute \u6216\u4f20\u8f93 Transfer\u7684\u961f\u5217\u3002 PhysicalDevice\u8fd8\u53ef\u4ee5\u679a\u4e3e\u5176\u5185\u90e8\u7684\u5185\u5b58\u5806 Memory Heaps \u548c\u5185\u5b58\u7c7b\u578b Memory Types \u3002 Memory Heaps \u4ee3\u8868\u7279\u5b9a\u7684RAM\u6c60\u3002 \u5b83\u53ef\u80fd\u4f1a\u63d0\u53d6 \u4e3b\u677f\u4e0a\u7684\u7cfb\u7edfRAM, \u6216\u4e13\u7528\u56fe\u5f62\u5361\u4e0a\u7684\u89c6\u9891RAM\u4e2d\u7684\u7279\u5b9a\u5185\u5b58\u7a7a\u95f4\uff0c\u6216\u8005\u5b9e\u73b0\u8981\u516c\u5f00\u7684\u4efb\u4f55\u5176\u4ed6\u7279\u5b9a\u4e8e\u4e3b\u673a\u6216\u8bbe\u5907\u7684\u5185\u5b58\u3002 \u5206\u914d\u5185\u5b58 Allocate Memory \u65f6\u5fc5\u987b\u6307\u5b9a Memory Types \u3002 \u5b83\u5177\u6709\u5bf9 Memory Blob \u7684\u7279\u5b9a\u8981\u6c42\uff0c\u4f8b\u5982\u5bf9 host \u53ef\u89c1\uff0c\u4e00\u81f4\u6027 coherent\uff08\u5728CPU\u548cGPU\u4e4b\u95f4\uff09\u548c\u5df2\u7f13\u5b58 cached\u3002\u8fd9\u4e9b\u53ef\u80fd\u4f1a\u4efb\u610f\u7ec4\u5408\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f\u3002 3. Device \u53c8\u88ab\u89c6\u4e3a \u903b\u8f91\u8bbe\u5907 Logical Device \u6216 Opened Device. \u5b83\u4ee3\u8868\u4e86\u4e00\u4e2a\u5df2\u7ecf\u521d\u59cb\u5316\u7684 Vulkan \u8bbe\u5907, \u51c6\u5907\u597d\u521b\u5efa\u5176\u4ed6\u5bf9\u8c61 \u521b\u5efa\u8bbe\u5907\u65f6, \u9700\u6307\u5b9a\u542f\u7528\u54ea\u4e9b Features , \u5e76\u58f0\u660e\u6240\u6709\u4f7f\u7528\u7684 Queue , \u5176\u7f16\u53f7 \u548c\u5176 Queue Family 4. Queue Device \u4e0a\u6267\u884c\u7684\u547d\u4ee4\u961f\u5217 Queue of Commands\u3002 \u901a\u8fc7\u4f7f\u7528 vkQueueSubmit \u586b\u5145 CommandBuffer \u5e76\u5c06\u5176\u63d0\u4ea4\u5230 Queue\uff0c\u6765\u8bf7\u6c42 GPU \u5b8c\u6210\u7684\u6240\u6709\u5b9e\u9645\u5de5\u4f5c\u3002 \u5982\u679c\u6709\u591a\u4e2a\u961f\u5217\uff0c\u4f8b\u5982 Graphic Queue \u548c Compute Queue\uff0c\u5219\u53ef\u4ee5\u5411\u6bcf\u4e2a\u961f\u5217\u63d0\u4ea4\u4e0d\u540c\u7684CommandBuffer\u3002\u8fd9\u6837\uff0c\u60a8\u5c31\u53ef\u4ee5\u542f\u7528\u5f02\u6b65\u8ba1\u7b97\uff0c\u5982\u679c\u6267\u884c\u6b63\u786e\u7684\u8bdd\uff0c\u53ef\u4ee5\u5927\u5927\u63d0\u9ad8\u901f\u5ea6\u3002 5. CommandPool \u7528\u4e8e\u5206\u914d CommandBuffer \u3002\u5b83\u5df2\u8fde\u63a5\u5230\u7279\u5b9a\u7684 Queue Family \u3002 6. CommandBuffer \u4ece\u6307\u5b9a\u7684 CommandPool \u5206\u914d\u3002\u5b83\u4ee3\u8868 Device \u8981\u6267\u884c\u7684\u5404\u79cd\u547d\u4ee4\u7684\u7f13\u51b2\u533a\u3002 \u53ef\u4ee5\u5728 Command Buffer \u4e0a\u8c03\u7528\u5404 vkCmd \u5f00\u5934\u7684\u51fd\u6570\uff0c\u7528\u4e8e\u6307\u5b9a \u6267\u884c\u7684\u4efb\u52a1\u7684\u987a\u5e8f\uff0c\u7c7b\u578b\u548c\u53c2\u6570\u3002 \u4e4b\u540e CommandBuffer \u63d0\u4ea4\u5230 Queue \u5e76\u6700\u7ec8\u7531 Device \u6267\u884c 7. Sampler \u91c7\u6837\u5668 Sampler \u672a\u7ed1\u5b9a\u5230\u4efb\u4f55\u7279\u5b9a\u56fe\u50cf Image\u3002\u5b83\u53ea\u662f\u4e00\u7ec4\u72b6\u6001\u53c2\u6570 state parameters \uff0c \u4f8b\u5982\u8fc7\u6ee4\u6a21\u5f0f (filtering mode)\uff08\u6700\u8fd1\u6216\u7ebf\u6027 nearest or linear\uff09,\u6216\u5bfb\u5740\u6a21\u5f0f (addressing mode)\uff08\u91cd\u590d\uff0c\u94b3\u4f4d\u5230\u8fb9\u7f18\uff0c\u94b3\u4f4d\u5230\u8fb9\u754c\u7b49 repeat, clamp-to-edge, clamp-to-border\uff09\u3002 8. Image & Buffer TODO \u7f13\u51b2\u533a\u548c\u56fe\u50cf\u662f\u5360\u7528\u8bbe\u5907\u5185\u5b58\u7684\u4e24\u79cd\u8d44\u6e90\u3002 \u7f13\u51b2\u533a\u6bd4\u8f83\u7b80\u5355\u3002 \u5b83\u662f\u4efb\u4f55\u5177\u6709\u957f\u5ea6\u7684\u4e8c\u8fdb\u5236\u6570\u636e\u7684\u5bb9\u5668, \u4ee5\u5b57\u8282\u8868\u793a\u3002 \u53e6\u4e00\u65b9\u9762\uff0c\u56fe\u50cf\u4ee3\u8868\u4e00\u7ec4\u50cf\u7d20\u3002 \u8fd9\u662f\u5176\u4ed6\u56fe\u5f62API\u4e2d\u79f0\u4e3a\u7eb9\u7406\u7684\u5bf9\u8c61\u3002 \u9700\u8981\u66f4\u591a\u53c2\u6570\u6765\u6307\u5b9a\u56fe\u50cf\u7684\u521b\u5efa\u3002 \u5b83\u53ef\u4ee5\u662f1D\uff0c2D\u62163D\uff0c\u5177\u6709\u5404\u79cd\u50cf\u7d20\u683c\u5f0f\uff08\u5982R8G8B8A8_UNORM\u6216R32_SFLOAT\uff09\uff0c \u5e76\u4e14\u8fd8\u53ef\u4ee5\u5305\u542b\u8bb8\u591a\u79bb\u6563\u56fe\u50cf\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u5177\u6709\u591a\u4e2a\u9635\u5217\u5c42\u6216MIP\u7ea7\u522b\uff08\u6216\u4e24\u8005\uff09\u3002 \u56fe\u7247\u662f\u4e00\u79cd\u72ec\u7acb\u7684\u5bf9\u8c61\u7c7b\u578b\uff0c\u56e0\u4e3a\u5b83\u4e0d\u4e00\u5b9a\u53ea\u5305\u542b\u53ef\u4ee5\u76f4\u63a5\u8bbf\u95ee\u7684\u7ebf\u6027\u50cf\u7d20\u96c6\u3002 \u56fe\u50cf\u53ef\u4ee5\u5177\u6709\u7531\u56fe\u5f62\u9a71\u52a8\u7a0b\u5e8f\u7ba1\u7406\u7684\u4e0d\u540c\u7684\u7279\u5b9a\u4e8e\u5b9e\u73b0\u7684\u5185\u90e8\u683c\u5f0f\uff08\u5e73\u94fa\u548c\u5e03\u5c40\uff09\u3002 9. DeviceMemory \u521b\u5efa\u4e00\u5b9a\u957f\u5ea6\u7684\u7f13\u51b2\u533a\u6216\u5177\u6709\u7279\u5b9a\u5c3a\u5bf8\u7684\u56fe\u50cf\u4e0d\u4f1a\u81ea\u52a8\u4e3a\u5176\u5206\u914d\u5185\u5b58\u3002 \u8fd9\u662f\u4e00\u4e2a\u4e09\u6b65\u8fc7\u7a0b\uff0c\u5fc5\u987b\u7531\u60a8\u624b\u52a8\u6267\u884c\u3002 \u60a8\u4e5f\u53ef\u4ee5\u9009\u62e9\u4f7f\u7528\u6211\u4eec\u7684Vulkan\u5185\u5b58\u5206\u914d\u5668\u5e93\uff0c\u8be5\u5e93\u5c06\u4e3a\u60a8\u5206\u914d\u8d44\u6e90\u3002 1.\u5206\u914dDeviceMemory\uff0c 2.\u521b\u5efa\u7f13\u51b2\u533a\u6216\u56fe\u50cf\uff0c 3.\u4f7f\u7528\u529f\u80fdvkBindBufferMemory\u6216vkBindImageMemory\u5c06\u5b83\u4eec\u7ed1\u5b9a\u5728\u4e00\u8d77\u3002 \u56e0\u6b64\uff0c\u60a8\u8fd8\u5fc5\u987b\u521b\u5efa\u4e00\u4e2aDeviceMemory\u5bf9\u8c61\u3002 \u5b83\u4ee3\u8868\u4ece\u7279\u5b9a\u5185\u5b58\u7c7b\u578b\uff08\u7531PhysicalDevice\u652f\u6301\uff09\u5206\u914d\u7684\u5185\u5b58\u5757\uff0c\u5177\u6709\u7279\u5b9a\u7684\u5b57\u8282\u957f\u5ea6\u3002 \u60a8\u4e0d\u5e94\u8be5\u4e3a\u6bcf\u4e2a\u7f13\u51b2\u533a\u6216\u6620\u50cf\u5206\u914d\u5355\u72ec\u7684DeviceMemory\u3002 \u76f8\u53cd\uff0c\u60a8\u5e94\u8be5\u5206\u914d\u66f4\u5927\u7684\u5185\u5b58\u5757\uff0c\u5e76\u5c06\u5176\u4e2d\u7684\u4e00\u90e8\u5206\u5206\u914d\u7ed9\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u3002 \u5206\u914d\u662f\u4e00\u9879\u6602\u8d35\u7684\u64cd\u4f5c\uff0c\u5e76\u4e14\u6700\u5927\u5206\u914d\u6570\u91cf\u4e5f\u53d7\u5230\u9650\u5236\uff0c\u6240\u6709\u8fd9\u4e9b\u90fd\u53ef\u4ee5\u4ecePhysicalDevice\u4e2d\u67e5\u8be2\u3002 \u5bf9\u8c61\u7ec4 \u8bbe\u5907 Instance PhysicalDevice Queue Family Memory Heap Memory Type --> Device Memory Device Queue <-- Queue Family \u56fe\u50cf Surface Swapchain Image ImageView Framebuffer <--RenderPass \u7ba1\u9053 DescriptorSetLayout PipelineLayout ShaderModule Pipeline Cache PipeLine DescriptorSet <-- DescriptorSetLayout, DescriptorPool 3. Pipeline 4. \u8be6\u7ec6 Instance \u5b9e\u4f8b [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe","title":"1. Vulkan \u521d\u59cb\u5316 \u4e09\u89d2"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#1","text":"\u521d\u59cb\u8bbe\u7f6e Instance \u5b9e\u4f8b [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 \u5448\u73b0 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b \u7ed8\u5236 Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe \u6ce8: []: \u975e Vulkan \u6838\u5fc3 init_global_layer_properties(info); init_instance_extension_names(info); init_device_extension_names(info); init_instance(info, sample_title); init_enumerate_device(info); init_window_size(info, 500, 500); init_connection(info); init_window(info); init_swapchain_extension(info); init_device(info); init_command_pool(info); init_command_buffer(info); execute_begin_command_buffer(info); init_device_queue(info); init_swap_chain(info); init_depth_buffer(info); init_uniform_buffer(info); init_descriptor_and_pipeline_layouts(info, false); init_renderpass(info, depthPresent); #include \"15-draw_cube.vert.h\" #include \"15-draw_cube.frag.h\" VkShaderModuleCreateInfo vert_info = {}; VkShaderModuleCreateInfo frag_info = {}; vert_info.sType = frag_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; vert_info.codeSize = sizeof(__draw_cube_vert); vert_info.pCode = __draw_cube_vert; frag_info.codeSize = sizeof(__draw_cube_frag); frag_info.pCode = __draw_cube_frag; init_shaders(info, &vert_info, &frag_info); init_framebuffers(info, depthPresent); init_vertex_buffer(info, g_vb_solid_face_colors_Data, sizeof(g_vb_solid_face_colors_Data), sizeof(g_vb_solid_face_colors_Data[0]), false); init_descriptor_pool(info, false); init_descriptor_set(info, false); init_pipeline_cache(info); init_pipeline(info, depthPresent);","title":"1. \u6d41\u7a0b\u603b\u89c8"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#2-api","text":"\u521d\u59cb\u8bbe\u7f6e Instance \u5b9e\u4f8b vkCreateInstance [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf vkEnumeratePhysicalDevices vkGetPhysicalDeviceQueueFamilyProperties Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 \u5448\u73b0 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b \u7ed8\u5236 Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe","title":"2. \u521d\u59cb\u5316\u65f6, \u6d89\u53ca\u7684 API"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#2-vulkan-objects","text":"\u7eff\u8272\u6846: \u65e0\u7c7b\u578b, \u4ee5 uint32_t \u8868\u793a \u5b9e\u7ebf+\u7bad\u5934: \u521b\u5efa\u987a\u5e8f \u5b9e\u7ebf+\u83f1\u5f62: \u7ec4\u5408 (\u88ab\u5305\u542b) \u865a\u7ebf: \u901a\u4fe1 \u4e09\u4e2a\u533a\u57df\u4e2d, \u7ea2\u8272\u4e3a\u4e3b Object, \u5176\u4ed6\u5bf9\u8c61\u90fd\u76f4\u63a5\u6216\u95f4\u63a5\u7684\u7531\u6b64\u5bf9\u8c61\u521b\u5efa. \u8868\u73b0\u4e3a vkCreateSwapchainKHR \u9700\u8981 Device \u4e3a\u53c2\u6570.","title":"2. \u7406\u89e3 Vulkan\u00ae Objects"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#1-instance","text":"Instance \u662f\u521b\u5efa\u7684\u7b2c\u4e00\u4e2a\u5bf9\u8c61\u3002 \u5b83\u8868\u793a\u4ece\u5e94\u7528\u7a0b\u5e8f\u5230 Vulkan \u8fd0\u884c\u65f6\u7684 \u8fde\u63a5 \uff0c\u56e0\u6b64\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u4ec5\u5e94 \u5b58\u5728\u4e00\u6b21 \u3002 \u5b83\u8fd8\u5b58\u50a8\u4f7f\u7528 Vulkan \u6240\u9700\u7684\u6240\u6709\u7279\u5b9a\u4e8e \u5e94\u7528\u7a0b\u5e8f \u7684\u72b6\u6001\u3002 \u56e0\u6b64\uff0c\u60a8\u5fc5\u987b\u6307\u5b9a\u521b\u5efa\u5b9e\u4f8b\u65f6\u8981\u542f\u7528\u7684\u6240\u6709\u5c42 Layers \uff08\u4f8b\u5982\u9a8c\u8bc1\u5c42\uff09\u548c\u6240\u6709\u6269\u5c55 Extensions\u3002","title":"1. Instance"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#2-physicaldevice","text":"\u8868\u793a\u7279\u5b9a\u7684 Vulkan \u517c\u5bb9\u8bbe\u5907\uff0c\u4f8b\u5982\u56fe\u5f62\u5361\u3002 vkEnumeratePhysicalDevices \u60a8\u53ef\u4ee5\u4ece Instance \u4e2d \u679a\u4e3e \u5b83\u4eec\uff0c\u7136\u540e\u53ef\u4ee5\u67e5\u8be2\u5b83\u4eec\u7684 vendorID\uff0cdeviceID \u548c\u652f\u6301\u7684\u529f\u80fd\u4ee5\u53ca\u5176\u4ed6\u5c5e\u6027\u548c\u9650\u5236\u3002 vkGetPhysicalDeviceQueueFamilyProperties PhysicalDevice \u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u53ef\u7528\u7684 Queue Families \u7c7b\u578b\u3002 \u56fe\u5f62\u961f\u5217 Graphics Queue \u662f\u6700\u4e3b\u8981\u7684\u961f\u5217\uff0c\u4f46\u662f\u60a8\u53ef\u80fd\u8fd8\u6709\u5176\u4ed6\u4ec5\u652f\u6301\u8ba1\u7b97Compute \u6216\u4f20\u8f93 Transfer\u7684\u961f\u5217\u3002 PhysicalDevice\u8fd8\u53ef\u4ee5\u679a\u4e3e\u5176\u5185\u90e8\u7684\u5185\u5b58\u5806 Memory Heaps \u548c\u5185\u5b58\u7c7b\u578b Memory Types \u3002 Memory Heaps \u4ee3\u8868\u7279\u5b9a\u7684RAM\u6c60\u3002 \u5b83\u53ef\u80fd\u4f1a\u63d0\u53d6 \u4e3b\u677f\u4e0a\u7684\u7cfb\u7edfRAM, \u6216\u4e13\u7528\u56fe\u5f62\u5361\u4e0a\u7684\u89c6\u9891RAM\u4e2d\u7684\u7279\u5b9a\u5185\u5b58\u7a7a\u95f4\uff0c\u6216\u8005\u5b9e\u73b0\u8981\u516c\u5f00\u7684\u4efb\u4f55\u5176\u4ed6\u7279\u5b9a\u4e8e\u4e3b\u673a\u6216\u8bbe\u5907\u7684\u5185\u5b58\u3002 \u5206\u914d\u5185\u5b58 Allocate Memory \u65f6\u5fc5\u987b\u6307\u5b9a Memory Types \u3002 \u5b83\u5177\u6709\u5bf9 Memory Blob \u7684\u7279\u5b9a\u8981\u6c42\uff0c\u4f8b\u5982\u5bf9 host \u53ef\u89c1\uff0c\u4e00\u81f4\u6027 coherent\uff08\u5728CPU\u548cGPU\u4e4b\u95f4\uff09\u548c\u5df2\u7f13\u5b58 cached\u3002\u8fd9\u4e9b\u53ef\u80fd\u4f1a\u4efb\u610f\u7ec4\u5408\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f\u3002","title":"2. PhysicalDevice"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#3-device","text":"\u53c8\u88ab\u89c6\u4e3a \u903b\u8f91\u8bbe\u5907 Logical Device \u6216 Opened Device. \u5b83\u4ee3\u8868\u4e86\u4e00\u4e2a\u5df2\u7ecf\u521d\u59cb\u5316\u7684 Vulkan \u8bbe\u5907, \u51c6\u5907\u597d\u521b\u5efa\u5176\u4ed6\u5bf9\u8c61 \u521b\u5efa\u8bbe\u5907\u65f6, \u9700\u6307\u5b9a\u542f\u7528\u54ea\u4e9b Features , \u5e76\u58f0\u660e\u6240\u6709\u4f7f\u7528\u7684 Queue , \u5176\u7f16\u53f7 \u548c\u5176 Queue Family","title":"3. Device"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#4-queue","text":"Device \u4e0a\u6267\u884c\u7684\u547d\u4ee4\u961f\u5217 Queue of Commands\u3002 \u901a\u8fc7\u4f7f\u7528 vkQueueSubmit \u586b\u5145 CommandBuffer \u5e76\u5c06\u5176\u63d0\u4ea4\u5230 Queue\uff0c\u6765\u8bf7\u6c42 GPU \u5b8c\u6210\u7684\u6240\u6709\u5b9e\u9645\u5de5\u4f5c\u3002 \u5982\u679c\u6709\u591a\u4e2a\u961f\u5217\uff0c\u4f8b\u5982 Graphic Queue \u548c Compute Queue\uff0c\u5219\u53ef\u4ee5\u5411\u6bcf\u4e2a\u961f\u5217\u63d0\u4ea4\u4e0d\u540c\u7684CommandBuffer\u3002\u8fd9\u6837\uff0c\u60a8\u5c31\u53ef\u4ee5\u542f\u7528\u5f02\u6b65\u8ba1\u7b97\uff0c\u5982\u679c\u6267\u884c\u6b63\u786e\u7684\u8bdd\uff0c\u53ef\u4ee5\u5927\u5927\u63d0\u9ad8\u901f\u5ea6\u3002","title":"4. Queue"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#5-commandpool","text":"\u7528\u4e8e\u5206\u914d CommandBuffer \u3002\u5b83\u5df2\u8fde\u63a5\u5230\u7279\u5b9a\u7684 Queue Family \u3002","title":"5. CommandPool"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#6-commandbuffer","text":"\u4ece\u6307\u5b9a\u7684 CommandPool \u5206\u914d\u3002\u5b83\u4ee3\u8868 Device \u8981\u6267\u884c\u7684\u5404\u79cd\u547d\u4ee4\u7684\u7f13\u51b2\u533a\u3002 \u53ef\u4ee5\u5728 Command Buffer \u4e0a\u8c03\u7528\u5404 vkCmd \u5f00\u5934\u7684\u51fd\u6570\uff0c\u7528\u4e8e\u6307\u5b9a \u6267\u884c\u7684\u4efb\u52a1\u7684\u987a\u5e8f\uff0c\u7c7b\u578b\u548c\u53c2\u6570\u3002 \u4e4b\u540e CommandBuffer \u63d0\u4ea4\u5230 Queue \u5e76\u6700\u7ec8\u7531 Device \u6267\u884c","title":"6. CommandBuffer"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#7-sampler","text":"\u91c7\u6837\u5668 Sampler \u672a\u7ed1\u5b9a\u5230\u4efb\u4f55\u7279\u5b9a\u56fe\u50cf Image\u3002\u5b83\u53ea\u662f\u4e00\u7ec4\u72b6\u6001\u53c2\u6570 state parameters \uff0c \u4f8b\u5982\u8fc7\u6ee4\u6a21\u5f0f (filtering mode)\uff08\u6700\u8fd1\u6216\u7ebf\u6027 nearest or linear\uff09,\u6216\u5bfb\u5740\u6a21\u5f0f (addressing mode)\uff08\u91cd\u590d\uff0c\u94b3\u4f4d\u5230\u8fb9\u7f18\uff0c\u94b3\u4f4d\u5230\u8fb9\u754c\u7b49 repeat, clamp-to-edge, clamp-to-border\uff09\u3002","title":"7. Sampler"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#8-image-buffer","text":"","title":"8. Image &amp; Buffer"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#todo","text":"\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u662f\u5360\u7528\u8bbe\u5907\u5185\u5b58\u7684\u4e24\u79cd\u8d44\u6e90\u3002 \u7f13\u51b2\u533a\u6bd4\u8f83\u7b80\u5355\u3002 \u5b83\u662f\u4efb\u4f55\u5177\u6709\u957f\u5ea6\u7684\u4e8c\u8fdb\u5236\u6570\u636e\u7684\u5bb9\u5668, \u4ee5\u5b57\u8282\u8868\u793a\u3002 \u53e6\u4e00\u65b9\u9762\uff0c\u56fe\u50cf\u4ee3\u8868\u4e00\u7ec4\u50cf\u7d20\u3002 \u8fd9\u662f\u5176\u4ed6\u56fe\u5f62API\u4e2d\u79f0\u4e3a\u7eb9\u7406\u7684\u5bf9\u8c61\u3002 \u9700\u8981\u66f4\u591a\u53c2\u6570\u6765\u6307\u5b9a\u56fe\u50cf\u7684\u521b\u5efa\u3002 \u5b83\u53ef\u4ee5\u662f1D\uff0c2D\u62163D\uff0c\u5177\u6709\u5404\u79cd\u50cf\u7d20\u683c\u5f0f\uff08\u5982R8G8B8A8_UNORM\u6216R32_SFLOAT\uff09\uff0c \u5e76\u4e14\u8fd8\u53ef\u4ee5\u5305\u542b\u8bb8\u591a\u79bb\u6563\u56fe\u50cf\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u5177\u6709\u591a\u4e2a\u9635\u5217\u5c42\u6216MIP\u7ea7\u522b\uff08\u6216\u4e24\u8005\uff09\u3002 \u56fe\u7247\u662f\u4e00\u79cd\u72ec\u7acb\u7684\u5bf9\u8c61\u7c7b\u578b\uff0c\u56e0\u4e3a\u5b83\u4e0d\u4e00\u5b9a\u53ea\u5305\u542b\u53ef\u4ee5\u76f4\u63a5\u8bbf\u95ee\u7684\u7ebf\u6027\u50cf\u7d20\u96c6\u3002 \u56fe\u50cf\u53ef\u4ee5\u5177\u6709\u7531\u56fe\u5f62\u9a71\u52a8\u7a0b\u5e8f\u7ba1\u7406\u7684\u4e0d\u540c\u7684\u7279\u5b9a\u4e8e\u5b9e\u73b0\u7684\u5185\u90e8\u683c\u5f0f\uff08\u5e73\u94fa\u548c\u5e03\u5c40\uff09\u3002","title":"TODO"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#9-devicememory","text":"\u521b\u5efa\u4e00\u5b9a\u957f\u5ea6\u7684\u7f13\u51b2\u533a\u6216\u5177\u6709\u7279\u5b9a\u5c3a\u5bf8\u7684\u56fe\u50cf\u4e0d\u4f1a\u81ea\u52a8\u4e3a\u5176\u5206\u914d\u5185\u5b58\u3002 \u8fd9\u662f\u4e00\u4e2a\u4e09\u6b65\u8fc7\u7a0b\uff0c\u5fc5\u987b\u7531\u60a8\u624b\u52a8\u6267\u884c\u3002 \u60a8\u4e5f\u53ef\u4ee5\u9009\u62e9\u4f7f\u7528\u6211\u4eec\u7684Vulkan\u5185\u5b58\u5206\u914d\u5668\u5e93\uff0c\u8be5\u5e93\u5c06\u4e3a\u60a8\u5206\u914d\u8d44\u6e90\u3002 1.\u5206\u914dDeviceMemory\uff0c 2.\u521b\u5efa\u7f13\u51b2\u533a\u6216\u56fe\u50cf\uff0c 3.\u4f7f\u7528\u529f\u80fdvkBindBufferMemory\u6216vkBindImageMemory\u5c06\u5b83\u4eec\u7ed1\u5b9a\u5728\u4e00\u8d77\u3002 \u56e0\u6b64\uff0c\u60a8\u8fd8\u5fc5\u987b\u521b\u5efa\u4e00\u4e2aDeviceMemory\u5bf9\u8c61\u3002 \u5b83\u4ee3\u8868\u4ece\u7279\u5b9a\u5185\u5b58\u7c7b\u578b\uff08\u7531PhysicalDevice\u652f\u6301\uff09\u5206\u914d\u7684\u5185\u5b58\u5757\uff0c\u5177\u6709\u7279\u5b9a\u7684\u5b57\u8282\u957f\u5ea6\u3002 \u60a8\u4e0d\u5e94\u8be5\u4e3a\u6bcf\u4e2a\u7f13\u51b2\u533a\u6216\u6620\u50cf\u5206\u914d\u5355\u72ec\u7684DeviceMemory\u3002 \u76f8\u53cd\uff0c\u60a8\u5e94\u8be5\u5206\u914d\u66f4\u5927\u7684\u5185\u5b58\u5757\uff0c\u5e76\u5c06\u5176\u4e2d\u7684\u4e00\u90e8\u5206\u5206\u914d\u7ed9\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u3002 \u5206\u914d\u662f\u4e00\u9879\u6602\u8d35\u7684\u64cd\u4f5c\uff0c\u5e76\u4e14\u6700\u5927\u5206\u914d\u6570\u91cf\u4e5f\u53d7\u5230\u9650\u5236\uff0c\u6240\u6709\u8fd9\u4e9b\u90fd\u53ef\u4ee5\u4ecePhysicalDevice\u4e2d\u67e5\u8be2\u3002","title":"9. DeviceMemory"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#_1","text":"","title":"\u5bf9\u8c61\u7ec4"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#_2","text":"Instance PhysicalDevice Queue Family Memory Heap Memory Type --> Device Memory Device Queue <-- Queue Family","title":"\u8bbe\u5907"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#_3","text":"Surface Swapchain Image ImageView Framebuffer <--RenderPass","title":"\u56fe\u50cf"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#_4","text":"DescriptorSetLayout PipelineLayout ShaderModule Pipeline Cache PipeLine DescriptorSet <-- DescriptorSetLayout, DescriptorPool","title":"\u7ba1\u9053"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#3-pipeline","text":"","title":"3. Pipeline"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#4","text":"Instance \u5b9e\u4f8b [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe","title":"4. \u8be6\u7ec6"},{"location":"Vulkan/Pipeline/","text":"Pipeline \u5728 Vulkan \u4e2d, \u6e32\u67d3\u7ba1\u7ebf\u9700\u8981\u624b\u52a8\u521b\u5efa. Vulkan\u4e2d\u521b\u5efa\u5bf9\u8c61\u7684\u8fc7\u7a0b\u5927\u591a\u90fd\u901a\u8fc7\u4f7f\u7528 VkXXXCreateInfo \u7ed3\u6784\u4f53, \u4e3a\u7ed3\u6784\u4f53\u5404\u5c5e\u6027\u8d4b\u503c\u540e\u8c03\u7528 vk API\u521b\u5efa. \u5bf9\u5e94Pipeline\u7684\u521b\u5efa\u7ed3\u6784\u4f53\u4e3a VkGraphicsPipelineCreateInfo , \u5176\u9664\u4e86\u6240\u6709\u7ed3\u6784\u4f53\u7684\u5171\u6709\u5c5e\u6027(sType, pNext)\u5916, \u8fd8\u5305\u62ec\u4e86 10\u4e2a\u5b50\u7ed3\u6784\u4f53\u5c5e\u6027, \u5206\u522b\u5bf9\u5e94\u6e32\u67d3\u7ba1\u7ebf\u7684\u5341\u4e2a\u56fa\u5b9a\u6d41\u7a0b. \u4ee5\u53ca 3\u4e2a\u5bf9\u8c61: PipelineLayout, RenderPass, subpass Pipeline Fixed Functions: VkPipeline Shader StageCreateInfo* pStages; VkPipeline VertexInput StateCreateInfo* pVertexInputState; VkPipeline InputAssembly StateCreateInfo* pInputAssemblyState; VkPipeline Tessellation StateCreateInfo* pTessellationState; VkPipeline Viewport StateCreateInfo* pViewportState; VkPipeline Rasterization StateCreateInfo* pRasterizationState; VkPipeline Multisample StateCreateInfo* pMultisampleState; VkPipeline DepthStencil StateCreateInfo* pDepthStencilState; VkPipeline ColorBlend StateCreateInfo* pColorBlendState; VkPipeline Dynamic StateCreateInfo* pDynamicState; Objects: PipelineLayout layout; RenderPass renderPass; int subpass; // Shader Stages <-- Shader Modules VkPipelineShaderStageCreateInfo vertShaderStageInfo{}; vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; vertShaderStageInfo.module = vertShaderModule; vertShaderStageInfo.pName = \"main\"; VkPipelineShaderStageCreateInfo fragShaderStageInfo{}; fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; fragShaderStageInfo.module = fragShaderModule; fragShaderStageInfo.pName = \"main\"; VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo }; // Vertex Input State VkPipelineVertexInputStateCreateInfo vertexInputInfo{}; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.vertexAttributeDescriptionCount = 0; // Input Assembly State VkPipelineInputAssemblyStateCreateInfo inputAssembly{}; inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; inputAssembly.primitiveRestartEnable = VK_FALSE; VkViewport viewport{}; viewport.x = 0.0f; viewport.y = 0.0f; viewport.width = (float)swapChainExtent.width; viewport.height = (float)swapChainExtent.height; viewport.minDepth = 0.0f; viewport.maxDepth = 1.0f; VkRect2D scissor{}; scissor.offset = { 0, 0 }; scissor.extent = VkExtent2D; // Viewport State <-- viewport extent, scissor extent VkPipelineViewportStateCreateInfo viewportState{}; viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; viewportState.pScissors = &scissor; // Rasterization State VkPipelineRasterizationStateCreateInfo rasterizer{}; rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterizer.depthClampEnable = VK_FALSE; rasterizer.rasterizerDiscardEnable = VK_FALSE; rasterizer.polygonMode = VK_POLYGON_MODE_FILL; rasterizer.lineWidth = 1.0f; rasterizer.cullMode = VK_CULL_MODE_BACK_BIT; rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; rasterizer.depthBiasEnable = VK_FALSE; // Multisample State VkPipelineMultisampleStateCreateInfo multisampling{}; multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampling.sampleShadingEnable = VK_FALSE; multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; // Color Blend Attachment State VkPipelineColorBlendAttachmentState colorBlendAttachment{}; colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; colorBlendAttachment.blendEnable = VK_FALSE; VkPipelineColorBlendStateCreateInfo colorBlending{}; colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; colorBlending.logicOpEnable = VK_FALSE; colorBlending.logicOp = VK_LOGIC_OP_COPY; colorBlending.attachmentCount = 1; colorBlending.pAttachments = &colorBlendAttachment; colorBlending.blendConstants[0] = 0.0f; colorBlending.blendConstants[1] = 0.0f; colorBlending.blendConstants[2] = 0.0f; colorBlending.blendConstants[3] = 0.0f; // Pipeline Layout VkPipelineLayoutCreateInfo pipelineLayoutInfo{}; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; pipelineLayoutInfo.pushConstantRangeCount = 0; if (vkCreatePipelineLayout(mDevice, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) { throw std::runtime_error(\"failed to create pipeline layout!\"); } //------ Pipeline Layout & Render Pass are ready, setup finish // ----- Create Graphics Pipeline ---------- VkGraphicsPipelineCreateInfo pipelineInfo{}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 2; pipelineInfo.pStages = shaderStages; // shaders pipelineInfo.pVertexInputState = &vertexInputInfo; // vertex input pipelineInfo.pInputAssemblyState = &inputAssembly; // input assembly pipelineInfo.pViewportState = &viewportState; // viewport pipelineInfo.pRasterizationState = &rasterizer; // rasterizer pipelineInfo.pMultisampleState = &multisampling; // multisampling pipelineInfo.pColorBlendState = &colorBlending; // colorBlending pipelineInfo.layout = pipelineLayout; pipelineInfo.renderPass = renderPass; // render pass pipelineInfo.subpass = 0; pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; Pipeline Fixed Function Properties: // \u7701\u7565\u4e86\u6240\u6709 CreateInfo \u7684 sType, pNext, \u548c xxxxflags Graphics_Pipeline { stageCount = 2; // create infos pStages = [ // shader modules vertShaderStageInfo = { stage = VK_SHADER_STAGE_VERTEX_BIT; module = vertShaderModule; // VkShaderModule pName = \"main\"; // const VkSpecializationInfo* pSpecializationInfo; } fragShaderStageInfo = { stage = VK_SHADER_STAGE_FRAGMENT_BIT; module = fragShaderModule; // VkShaderModule pName = \"main\"; // const VkSpecializationInfo* pSpecializationInfo; } ], pVertexInputState = Vertex_Input_State { // vertex input vertexBindingDescriptionCount = 0; pVertexBindingDescriptions = null; vertexAttributeDescriptionCount = 0; pVertexAttributeDescriptions = null; }; pInputAssemblyState = { // input assembly topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; primitiveRestartEnable = VK_FALSE; }; pTessellationState = null; // Tessellation pViewportState = { // Viewport viewportCount = 1; pViewports = { x = 0.0f; y = 0.0f; width = (float)swapChainExtent.width; // VkExtent2D height = (float)swapChainExtent.height; minDepth = 0.0f; maxDepth = 1.0f; }; scissorCount = 1; pScissors = { offset: { 0, 0 }; extent = swapChainExtent; // VkExtent2D }; }; pRasterizationState = { // Rasterizer depthClampEnable = VK_FALSE; rasterizerDiscardEnable = VK_FALSE; polygonMode = VK_POLYGON_MODE_FILL; lineWidth = 1.0f; cullMode = VK_CULL_MODE_BACK_BIT; frontFace = VK_FRONT_FACE_CLOCKWISE; depthBiasEnable = VK_FALSE; //float depthBiasConstantFactor; //float depthBiasClamp; //float depthBiasSlopeFactor; }; pMultisampleState = { // multisampling sampleShadingEnable = VK_FALSE; rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; // float minSampleShading; // const VkSampleMask* pSampleMask; // VkBool32 alphaToCoverageEnable; // VkBool32 alphaToOneEnable; }; pDepthStencilState : null, pColorBlendState = { // colorBlending logicOpEnable = VK_FALSE; logicOp = VK_LOGIC_OP_COPY; attachmentCount = 1; pAttachments = &colorBlendAttachment; blendConstants[0] = 0.0f; blendConstants[1] = 0.0f; blendConstants[2] = 0.0f; blendConstants[3] = 0.0f; }; pDynamicState : null, // vars layout = { setLayoutCount = 0; // const VkDescriptorSetLayout* pSetLayouts; pushConstantRangeCount = 0; //const VkPushConstantRange* pPushConstantRanges; }; renderPass = renderPass; // render pass subpass = 0; basePipelineHandle = VK_NULL_HANDLE; basePipelineIndex = 0, } Render Pass VkAttachmentDescription colorAttachment{}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; VkAttachmentReference colorAttachmentRef{}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkSubpassDescription subpass{}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; // \u540e\u52a0\u7684?? VkSubpassDependency dependency{}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; VkRenderPassCreateInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; if (vkCreateRenderPass(mDevice, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } Json RenderPass { attachmentCount = 1; pAttachments = { // VkAttachmentDescription colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; }; subpassCount = 1; pSubpasses = { // VkSubpassDescription pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; colorAttachmentCount = 1; pColorAttachments = { // VkAttachmentReference colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; }; // uint32_t inputAttachmentCount; // const VkAttachmentReference* pInputAttachments; // const VkAttachmentReference* pResolveAttachments; // const VkAttachmentReference* pDepthStencilAttachment; // uint32_t preserveAttachmentCount; // const uint32_t* pPreserveAttachments; }; dependencyCount = 1; pDependencies = { srcSubpass = VK_SUBPASS_EXTERNAL; dstSubpass = 0; srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; srcAccessMask = 0; dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; }; // VkSubpassDependency }","title":"Pipeline"},{"location":"Vulkan/Pipeline/#pipeline","text":"\u5728 Vulkan \u4e2d, \u6e32\u67d3\u7ba1\u7ebf\u9700\u8981\u624b\u52a8\u521b\u5efa. Vulkan\u4e2d\u521b\u5efa\u5bf9\u8c61\u7684\u8fc7\u7a0b\u5927\u591a\u90fd\u901a\u8fc7\u4f7f\u7528 VkXXXCreateInfo \u7ed3\u6784\u4f53, \u4e3a\u7ed3\u6784\u4f53\u5404\u5c5e\u6027\u8d4b\u503c\u540e\u8c03\u7528 vk API\u521b\u5efa. \u5bf9\u5e94Pipeline\u7684\u521b\u5efa\u7ed3\u6784\u4f53\u4e3a VkGraphicsPipelineCreateInfo , \u5176\u9664\u4e86\u6240\u6709\u7ed3\u6784\u4f53\u7684\u5171\u6709\u5c5e\u6027(sType, pNext)\u5916, \u8fd8\u5305\u62ec\u4e86 10\u4e2a\u5b50\u7ed3\u6784\u4f53\u5c5e\u6027, \u5206\u522b\u5bf9\u5e94\u6e32\u67d3\u7ba1\u7ebf\u7684\u5341\u4e2a\u56fa\u5b9a\u6d41\u7a0b. \u4ee5\u53ca 3\u4e2a\u5bf9\u8c61: PipelineLayout, RenderPass, subpass Pipeline Fixed Functions: VkPipeline Shader StageCreateInfo* pStages; VkPipeline VertexInput StateCreateInfo* pVertexInputState; VkPipeline InputAssembly StateCreateInfo* pInputAssemblyState; VkPipeline Tessellation StateCreateInfo* pTessellationState; VkPipeline Viewport StateCreateInfo* pViewportState; VkPipeline Rasterization StateCreateInfo* pRasterizationState; VkPipeline Multisample StateCreateInfo* pMultisampleState; VkPipeline DepthStencil StateCreateInfo* pDepthStencilState; VkPipeline ColorBlend StateCreateInfo* pColorBlendState; VkPipeline Dynamic StateCreateInfo* pDynamicState; Objects: PipelineLayout layout; RenderPass renderPass; int subpass; // Shader Stages <-- Shader Modules VkPipelineShaderStageCreateInfo vertShaderStageInfo{}; vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; vertShaderStageInfo.module = vertShaderModule; vertShaderStageInfo.pName = \"main\"; VkPipelineShaderStageCreateInfo fragShaderStageInfo{}; fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; fragShaderStageInfo.module = fragShaderModule; fragShaderStageInfo.pName = \"main\"; VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo }; // Vertex Input State VkPipelineVertexInputStateCreateInfo vertexInputInfo{}; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.vertexAttributeDescriptionCount = 0; // Input Assembly State VkPipelineInputAssemblyStateCreateInfo inputAssembly{}; inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; inputAssembly.primitiveRestartEnable = VK_FALSE; VkViewport viewport{}; viewport.x = 0.0f; viewport.y = 0.0f; viewport.width = (float)swapChainExtent.width; viewport.height = (float)swapChainExtent.height; viewport.minDepth = 0.0f; viewport.maxDepth = 1.0f; VkRect2D scissor{}; scissor.offset = { 0, 0 }; scissor.extent = VkExtent2D; // Viewport State <-- viewport extent, scissor extent VkPipelineViewportStateCreateInfo viewportState{}; viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; viewportState.pScissors = &scissor; // Rasterization State VkPipelineRasterizationStateCreateInfo rasterizer{}; rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterizer.depthClampEnable = VK_FALSE; rasterizer.rasterizerDiscardEnable = VK_FALSE; rasterizer.polygonMode = VK_POLYGON_MODE_FILL; rasterizer.lineWidth = 1.0f; rasterizer.cullMode = VK_CULL_MODE_BACK_BIT; rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; rasterizer.depthBiasEnable = VK_FALSE; // Multisample State VkPipelineMultisampleStateCreateInfo multisampling{}; multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampling.sampleShadingEnable = VK_FALSE; multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; // Color Blend Attachment State VkPipelineColorBlendAttachmentState colorBlendAttachment{}; colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; colorBlendAttachment.blendEnable = VK_FALSE; VkPipelineColorBlendStateCreateInfo colorBlending{}; colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; colorBlending.logicOpEnable = VK_FALSE; colorBlending.logicOp = VK_LOGIC_OP_COPY; colorBlending.attachmentCount = 1; colorBlending.pAttachments = &colorBlendAttachment; colorBlending.blendConstants[0] = 0.0f; colorBlending.blendConstants[1] = 0.0f; colorBlending.blendConstants[2] = 0.0f; colorBlending.blendConstants[3] = 0.0f; // Pipeline Layout VkPipelineLayoutCreateInfo pipelineLayoutInfo{}; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; pipelineLayoutInfo.pushConstantRangeCount = 0; if (vkCreatePipelineLayout(mDevice, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) { throw std::runtime_error(\"failed to create pipeline layout!\"); } //------ Pipeline Layout & Render Pass are ready, setup finish // ----- Create Graphics Pipeline ---------- VkGraphicsPipelineCreateInfo pipelineInfo{}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 2; pipelineInfo.pStages = shaderStages; // shaders pipelineInfo.pVertexInputState = &vertexInputInfo; // vertex input pipelineInfo.pInputAssemblyState = &inputAssembly; // input assembly pipelineInfo.pViewportState = &viewportState; // viewport pipelineInfo.pRasterizationState = &rasterizer; // rasterizer pipelineInfo.pMultisampleState = &multisampling; // multisampling pipelineInfo.pColorBlendState = &colorBlending; // colorBlending pipelineInfo.layout = pipelineLayout; pipelineInfo.renderPass = renderPass; // render pass pipelineInfo.subpass = 0; pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; Pipeline Fixed Function Properties: // \u7701\u7565\u4e86\u6240\u6709 CreateInfo \u7684 sType, pNext, \u548c xxxxflags Graphics_Pipeline { stageCount = 2; // create infos pStages = [ // shader modules vertShaderStageInfo = { stage = VK_SHADER_STAGE_VERTEX_BIT; module = vertShaderModule; // VkShaderModule pName = \"main\"; // const VkSpecializationInfo* pSpecializationInfo; } fragShaderStageInfo = { stage = VK_SHADER_STAGE_FRAGMENT_BIT; module = fragShaderModule; // VkShaderModule pName = \"main\"; // const VkSpecializationInfo* pSpecializationInfo; } ], pVertexInputState = Vertex_Input_State { // vertex input vertexBindingDescriptionCount = 0; pVertexBindingDescriptions = null; vertexAttributeDescriptionCount = 0; pVertexAttributeDescriptions = null; }; pInputAssemblyState = { // input assembly topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; primitiveRestartEnable = VK_FALSE; }; pTessellationState = null; // Tessellation pViewportState = { // Viewport viewportCount = 1; pViewports = { x = 0.0f; y = 0.0f; width = (float)swapChainExtent.width; // VkExtent2D height = (float)swapChainExtent.height; minDepth = 0.0f; maxDepth = 1.0f; }; scissorCount = 1; pScissors = { offset: { 0, 0 }; extent = swapChainExtent; // VkExtent2D }; }; pRasterizationState = { // Rasterizer depthClampEnable = VK_FALSE; rasterizerDiscardEnable = VK_FALSE; polygonMode = VK_POLYGON_MODE_FILL; lineWidth = 1.0f; cullMode = VK_CULL_MODE_BACK_BIT; frontFace = VK_FRONT_FACE_CLOCKWISE; depthBiasEnable = VK_FALSE; //float depthBiasConstantFactor; //float depthBiasClamp; //float depthBiasSlopeFactor; }; pMultisampleState = { // multisampling sampleShadingEnable = VK_FALSE; rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; // float minSampleShading; // const VkSampleMask* pSampleMask; // VkBool32 alphaToCoverageEnable; // VkBool32 alphaToOneEnable; }; pDepthStencilState : null, pColorBlendState = { // colorBlending logicOpEnable = VK_FALSE; logicOp = VK_LOGIC_OP_COPY; attachmentCount = 1; pAttachments = &colorBlendAttachment; blendConstants[0] = 0.0f; blendConstants[1] = 0.0f; blendConstants[2] = 0.0f; blendConstants[3] = 0.0f; }; pDynamicState : null, // vars layout = { setLayoutCount = 0; // const VkDescriptorSetLayout* pSetLayouts; pushConstantRangeCount = 0; //const VkPushConstantRange* pPushConstantRanges; }; renderPass = renderPass; // render pass subpass = 0; basePipelineHandle = VK_NULL_HANDLE; basePipelineIndex = 0, } Render Pass VkAttachmentDescription colorAttachment{}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; VkAttachmentReference colorAttachmentRef{}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkSubpassDescription subpass{}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; // \u540e\u52a0\u7684?? VkSubpassDependency dependency{}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; VkRenderPassCreateInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; if (vkCreateRenderPass(mDevice, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } Json RenderPass { attachmentCount = 1; pAttachments = { // VkAttachmentDescription colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; }; subpassCount = 1; pSubpasses = { // VkSubpassDescription pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; colorAttachmentCount = 1; pColorAttachments = { // VkAttachmentReference colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; }; // uint32_t inputAttachmentCount; // const VkAttachmentReference* pInputAttachments; // const VkAttachmentReference* pResolveAttachments; // const VkAttachmentReference* pDepthStencilAttachment; // uint32_t preserveAttachmentCount; // const uint32_t* pPreserveAttachments; }; dependencyCount = 1; pDependencies = { srcSubpass = VK_SUBPASS_EXTERNAL; dstSubpass = 0; srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; srcAccessMask = 0; dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; }; // VkSubpassDependency }","title":"Pipeline"},{"location":"Vulkan/VkFramebuffer/","text":"Vulken Framebuffer Vulkan_\u5c4f\u5e55\u7a7a\u95f4\u53cd\u5c04(SSR) \u5ef6\u8fdf\u6e32\u67d3 VkRenderPass \u5728\u8fdb\u884c\u7ba1\u7ebf\u521b\u5efa\u4e4b\u524d\uff0c\u9700\u8981\u8bbe\u7f6e\u7528\u4e8e\u6e32\u67d3\u7684\u5e27\u7f13\u51b2\u9644\u7740\u3002\u6211\u4eec \u9700\u8981\u6307\u5b9a\u4f7f\u7528\u7684\u989c\u8272\u548c\u6df1\u5ea6\u7f13\u51b2\uff0c\u4ee5\u53ca\u91c7\u6837\u6570\uff0c\u6e32\u67d3\u64cd\u4f5c\u5982\u4f55\u5904\u7406\u7f13\u51b2\u7684 \u5185\u5bb9\u3002\u6240\u6709\u8fd9\u4e9b\u4fe1\u606f\u88abVulkan \u5305\u88c5\u4e3a\u4e00\u4e2a\u6e32\u67d3\u6d41\u7a0b\u5bf9\u8c61\uff0c void createRenderPass() { VkAttachmentDescription colorAttachment{}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; VkAttachmentReference colorAttachmentRef{}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkSubpassDescription subpass{}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; VkSubpassDependency dependency{}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; VkRenderPassCreateInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } } Draw \u591a\u4e2a Framebuffer \u4e0e ES FBO\u5bf9\u6bd4 \u9ed8\u8ba4fbo \u9644\u7740 \u79bb\u5c4f\u6e32\u67d3 \u62f7\u8d1d","title":"Vulken Framebuffer"},{"location":"Vulkan/VkFramebuffer/#vulken-framebuffer","text":"Vulkan_\u5c4f\u5e55\u7a7a\u95f4\u53cd\u5c04(SSR) \u5ef6\u8fdf\u6e32\u67d3","title":"Vulken Framebuffer"},{"location":"Vulkan/VkFramebuffer/#vkrenderpass","text":"\u5728\u8fdb\u884c\u7ba1\u7ebf\u521b\u5efa\u4e4b\u524d\uff0c\u9700\u8981\u8bbe\u7f6e\u7528\u4e8e\u6e32\u67d3\u7684\u5e27\u7f13\u51b2\u9644\u7740\u3002\u6211\u4eec \u9700\u8981\u6307\u5b9a\u4f7f\u7528\u7684\u989c\u8272\u548c\u6df1\u5ea6\u7f13\u51b2\uff0c\u4ee5\u53ca\u91c7\u6837\u6570\uff0c\u6e32\u67d3\u64cd\u4f5c\u5982\u4f55\u5904\u7406\u7f13\u51b2\u7684 \u5185\u5bb9\u3002\u6240\u6709\u8fd9\u4e9b\u4fe1\u606f\u88abVulkan \u5305\u88c5\u4e3a\u4e00\u4e2a\u6e32\u67d3\u6d41\u7a0b\u5bf9\u8c61\uff0c void createRenderPass() { VkAttachmentDescription colorAttachment{}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; VkAttachmentReference colorAttachmentRef{}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkSubpassDescription subpass{}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; VkSubpassDependency dependency{}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; VkRenderPassCreateInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } }","title":"VkRenderPass"},{"location":"Vulkan/VkFramebuffer/#draw","text":"","title":"Draw"},{"location":"Vulkan/VkFramebuffer/#framebuffer","text":"","title":"\u591a\u4e2a Framebuffer"},{"location":"Vulkan/VkFramebuffer/#es-fbo","text":"\u9ed8\u8ba4fbo \u9644\u7740 \u79bb\u5c4f\u6e32\u67d3 \u62f7\u8d1d","title":"\u4e0e ES FBO\u5bf9\u6bd4"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/","text":"Vulkan \u521b\u5efaVulkan\u5b9e\u4f8b Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217\u7c07 Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b Vulkan \u9a8c\u8bc1\u5c42 Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217 Vulkan \u4ea4\u6362\u94fe Vulkan Window Surface Vulkan \u56fe\u5f62\u7ba1\u7ebf Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe Vulkan \u7740\u8272\u5668\u6a21\u5757 Vulkan \u56fa\u6709\u529f\u80fd Vulkan \u5e27\u7f13\u51b2\u533a Vulkan \u96c6\u6210\u7ba1\u7ebf Vulkan \u6e32\u67d3\u901a\u9053 Vulkan \u547d\u4ee4\u7f13\u51b2\u533a Vulkan \u6e32\u67d3\u548c\u663e\u793a Vulkan \u91cd\u6784\u4ea4\u6362\u94fe Vulkan \u9876\u70b9\u8f93\u5165 Vulkan \u521b\u5efa\u9876\u70b9\u7f13\u51b2\u533a Vulkan \u4e34\u65f6\u7f13\u51b2\u533a Vulkan \u7d22\u5f15\u7f13\u51b2\u533a Vulkan \u63cf\u8ff0\u7b26\u5e03\u5c40\u548c\u7f13\u51b2\u533a Vulkan \u63cf\u8ff0\u7b26\u6c60\u548c\u96c6\u5408 Vulkan \u56fe\u50cf(Images) Vulkan \u56fe\u50cf\u89c6\u56fe\u548c\u91c7\u6837\u5668 Vulkan \u7ec4\u5408\u56fe\u50cf\u53d6\u6837\u5668 Vulkan \u6df1\u5ea6\u7f13\u51b2\u533a Vulkan \u52a0\u8f7d\u6a21\u578b Vulkan \u751f\u6210\u8d34\u56fe(mipmap) \u7b2c\u4e00\u7ae0 Vulkan \u521b\u5efaVulkan\u5b9e\u4f8b \u521b\u5efaVulkan\u5b9e\u4f8b \uff0c\u4e0e Vulkan \u6253\u4ea4\u9053\uff0c\u901a\u5e38\u7684\u6b65\u9aa4\u662f\u521b\u5efa\u4e00\u4e2a intance \u53bb\u521d\u59cb\u5316 Vulkan library \u3002\u8fd9\u4e2a instance \u662f\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u4e0e Vulkan \u5e93\u4e4b\u95f4\u7684\u8fde\u63a5\u6865\u6881,\u901a\u5e38\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u9700\u8981\u5411\u9a71\u52a8\u7a0b\u5e8f\u63d0\u4f9b\u4e00\u4e9b\u5e94\u7528\u5c42\u7684\u4fe1\u606f\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b 2 \u68c0\u67e5\u53ef\u9009\u529f\u80fd 3 \u9000\u51fa 4 \u6e90\u4ee3\u7801 \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b Vulkan API \u4f7f\u7528 vkInstance \u5bf9\u8c61\u6765\u5b58\u50a8\u6240\u6709\u6bcf\u4e2a\u5e94\u7528\u7684\u72b6\u6001\u3002\u5e94\u7528\u7a0b\u5e8f\u5fc5\u987b\u5728\u6267\u884c\u4efb\u4f55\u5176\u4ed6 Vulkan \u64cd\u4f5c\u4e4b\u524d\u521b\u5efa\u4e00\u4e2a Vulkan \u5b9e\u4f8b\uff0c\u57fa\u672c\u7684 Vulkan \u67b6\u6784\u770b\u8d77\u6765\u662f\u8fd9\u6837\u7684\uff1a \u8bf7\u6ce8\u610f\uff0c\u56fe\u4e2d\u6709\u4e00\u4e9b\u5c42\uff08 Layer )\uff0c\u8fd9\u4e9b\u5c42\u4e5f\u88ab\u52a0\u8f7d\u5668\u52a0\u8f7d\u3002\u5c42\u901a\u5e38\u7528\u4e8e\u9a8c\u8bc1\uff0c\u901a\u5e38\u662f\u7531\u9a71\u52a8\u6267\u884c\u7684\u9519\u8bef\u68c0\u67e5\u3002\u5728 Vulkan \u4e2d\uff0c\u9a71\u52a8\u7a0b\u5e8f\u6bd4 OpenGL \u7b49\u5176\u4ed6 API \u8981\u8f7b\u91cf\u5f97\u591a\uff0c\u90e8\u5206\u539f\u56e0\u662f\u5b83\u5c06\u529f\u80fd\u9a8c\u8bc1\u59d4\u6258\u7ed9\u9a8c\u8bc1\u5c42\u3002\u5c42\u662f\u53ef\u9009\u7684\uff0c\u6bcf\u6b21\u5e94\u7528\u7a0b\u5e8f\u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u65f6\u90fd\u53ef\u4ee5\u9009\u62e9\u6027\u5730\u88c5\u8f7d\u3002 Vulkan Layer \u8d85\u51fa\u4e86\u672c\u7ae0\u7684\u8303\u56f4\uff0c\u4e0b\u9762\u5f00\u59cb\u521b\u5efavulkan\u5b9e\u4f8b\uff0c\u9996\u5148\u6dfb\u52a0\u4e00\u4e2a createInstance \u51fd\u6570\uff0c\u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\u3002 void initVulkan() { createInstance(); } C++ \u53e6\u5916\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u6765\u4fdd\u5b58 instance \u53e5\u67c4: private: VkInstance instance; C++ \u73b0\u5728\u6211\u4eec\u521b\u5efa\u4e00\u4e2a instance \uff0c\u5e76\u4e14\u4e3a\u8be5\u6570\u636e\u7ed3\u6784\u8d4b\u4e88\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u4fe1\u606f\u3002\u8fd9\u4e9b\u6570\u636e\u4ece\u6280\u672f\u89d2\u5ea6\u662f\u53ef\u9009\u62e9\u7684\uff0c\u4f46\u662f\u5b83\u53ef\u4ee5\u4e3a\u9a71\u52a8\u7a0b\u5e8f\u63d0\u4f9b\u4e00\u4e9b\u6709\u7528\u7684\u4fe1\u606f\u6765\u4f18\u5316\u7a0b\u5e8f\u7279\u6b8a\u7684\u4f7f\u7528\u60c5\u666f\uff0c\u6bd4\u5982\u9a71\u52a8\u7a0b\u5e8f\u4f7f\u7528\u4e00\u4e9b\u56fe\u5f62\u5f15\u64ce\u7684\u7279\u6b8a\u884c\u4e3a\u3002\u8fd9\u4e2a\u6570\u636e\u7ed3\u6784\u79f0\u4e3a VkApplicationInfo : VkApplicationInfo appInfo = {}; appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;appInfo.pNext = nullptr; appInfo.pApplicationName = \"Hello Triangle\"; appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.pEngineName = \"No Engine\"; appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.apiVersion = VK_API_VERSION_1_0; C++ \u5982\u524d\u6240\u8ff0\uff0c Vulkan \u4e2d\u7684\u8bb8\u591a\u6570\u636e\u7ed3\u6784\u8981\u6c42\u5728 sType \u6210\u5458\u4e2d\u660e\u786e\u7684\u6307\u5b9a\u7c7b\u578b\u3002 pNext \u6210\u5458\u53ef\u7528\u4e8e\u6307\u5411\u7279\u5b9a\u7684\u6269\u5c55\u7ed3\u6784\u3002\u6211\u4eec\u5728\u8fd9\u91cc\u4f7f\u7528\u9ed8\u8ba4\u521d\u59cb\u5316\uff0c\u5c06\u5176\u8bbe\u7f6e\u4e3a nullptr \u3002 Vulkan \u4e2d\u7684\u5927\u91cf\u4fe1\u606f\u901a\u8fc7\u7ed3\u6784\u4f53\u800c\u4e0d\u662f\u51fd\u6570\u53c2\u6570\u4f20\u9012\uff0c\u6211\u4eec\u5c06\u586b\u5145\u4e00\u4e2a\u7ed3\u6784\u4f53\u4ee5\u63d0\u4f9b\u8db3\u591f\u7684\u4fe1\u606f\u521b\u5efa instance \u3002\u4e0b\u4e00\u4e2a\u7ed3\u6784\u4f53\u4e0d\u662f\u53ef\u9009\u7684\uff0c\u5b83\u9700\u8981\u544a\u77e5 Vulkan \u9a71\u52a8\u7a0b\u5e8f\u6211\u4eec\u9700\u8981\u4f7f\u7528\u54ea\u4e9b\u5168\u5c40\u7684 extensions \u548c validation layers \u3002\u8fd9\u91cc\u7684\u5168\u5c40\u610f\u5473\u7740\u5b83\u9002\u7528\u4e8e\u6574\u4e2a\u7a0b\u5e8f\uff0c\u800c\u4e0d\u662f\u7279\u5b9a\u7684\u8bbe\u5907\uff0c\u8fd9\u4e9b\u5185\u5bb9\u5c06\u5728\u63a5\u4e0b\u6765\u7684\u5c0f\u8282\u4e2d\u8bf4\u660e\u3002 VkInstanceCreateInfo \u7ed3\u6784\u4f53\u4fe1\u606f\u5982\u4e0b\uff1a VkInstanceCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pApplicationInfo = &appInfo; C++ \u524d\u51e0\u4e2a\u53c2\u6570\u6bd4\u8f83\u7b80\u5355\u3002\u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u6307\u5b9a\u9700\u8981\u7684\u5168\u5c40\u6269\u5c55\uff0c Vulakn \u5bf9\u4e8e\u5e73\u53f0\u7279\u6027\u662f\u96f6 API \u652f\u6301\u7684(\u81f3\u5c11\u6682\u65f6\u8fd9\u6837)\uff0c\u8fd9\u610f\u5473\u7740\u9700\u8981\u4e00\u4e2a\u6269\u5c55\u624d\u80fd\u4e0e\u4e0d\u540c\u5e73\u53f0\u7684\u7a97\u4f53\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002 GLFW \u6709\u4e00\u4e2a\u65b9\u4fbf\u7684\u5185\u7f6e\u51fd\u6570\uff0c\u8fd4\u56de\u5b83\u6709\u5173\u7684\u6269\u5c55\u4fe1\u606f\uff0c\u6211\u4eec\u53ef\u4ee5\u4f20\u9012\u7ed9 struct : unsigned int glfwExtensionCount = 0; const char** glfwExtensions; glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount); createInfo.enabledExtensionCount = glfwExtensionCount; createInfo.ppEnabledExtensionNames = glfwExtensions; C++ \u7ed3\u6784\u4f53\u7684\u6700\u540e\u4e24\u4e2a\u6210\u5458\u786e\u5b9a\u9700\u8981\u5f00\u542f\u7684\u5168\u5c40\u7684 validation layers \u3002\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u4e00\u8282\u4e2d\u6df1\u5165\u63a2\u8ba8\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u5728\u8fd9\u4e00\u8282\u8bbe\u7f6e\u4e3a\u7a7a\u3002 createInfo.enabledLayerCount = 0; C++ \u6211\u4eec\u73b0\u5728\u5df2\u7ecf\u6307\u5b9a\u4e86 Vulkan \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u9700\u8981\u7684\u4e00\u5207\u4fe1\u606f\uff0c\u8c03\u7528 vkCreateInstance \u521b\u5efa\u5c5e\u4e8e\u6211\u4eec\u7684\u7b2c\u4e00\u4e2a instance : VkResult result = vkCreateInstance(&createInfo, nullptr, &instance); C++ \u5982\u4f60\u6240\u89c1\uff0c Vulkan \u4e2d\u521b\u5efa\u3001\u5b9e\u4f8b\u5316\u76f8\u5173\u7684\u51fd\u6570\u53c2\u6570\u4e00\u822c\u9075\u5faa\u5982\u4e0b\u539f\u5219\u5b9a\u4e49: \u4f7f\u7528\u6709\u5173creation info \u7684\u7ed3\u6784\u4f53\u6307\u9488 \u4f7f\u7528\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u56de\u8c03\u7684\u6307\u9488 \u4f7f\u7528\u4fdd\u5b58\u65b0\u5bf9\u8c61\u53e5\u67c4\u7684\u6307\u9488 \u5982\u679c\u4e00\u5207\u987a\u5229\uff0c\u6b64\u523binstance\u7684\u53e5\u67c4\u5e94\u8be5\u5b58\u50a8\u5728 VkInstance \u7c7b\u6210\u5458\u4e2d\u4e86\u3002\u51e0\u4e4e\u6240\u6709\u7684Vulkan\u51fd\u6570\u90fd\u8fd4\u56de\u4e00\u4e2a\u503c\u4e3a VK_SUCCESS \u6216\u9519\u8bef\u4ee3\u7801\u7684 VkResult \u7c7b\u578b\u7684\u503c\u3002\u8981\u68c0\u67e5 instance \u662f\u5426\u5df2\u7ecf\u6210\u529f\u521b\u5efa\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u4fdd\u5b58\u7ed3\u679c\uff0c\u4ec5\u4ec5\u4f7f\u7528 VK_SUCCESS \u503c\u6765\u68c0\u6d4b\u5373\u53ef\uff1a if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) { throw std::runtime_error(\"failed to create instance!\"); } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\uff0c\u786e\u8ba4\u6211\u4eec\u7684 instance \u521b\u5efa\u6210\u529f\u3002 \u68c0\u67e5\u53ef\u9009\u529f\u80fd \u5982\u679c\u4f60\u67e5\u770b vkCreateInstance \u7684\u6587\u6863\uff0c\u4f60\u4f1a\u770b\u5230\u4e00\u4e2a\u53ef\u80fd\u51fa\u73b0\u7684\u9519\u8bef\u4ee3\u7801\u662f VK_ERROR_EXTENSION_NOT_PRESENT \u3002\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u5730\u6307\u5b9a\u6211\u4eec\u9700\u8981\u7684\u6269\u5c55\uff0c\u5982\u679c\u8be5\u9519\u8bef\u4ee3\u7801\u8fd4\u56de\uff0c\u5219\u7ec8\u6b62\u5b83\u4eec\u3002\u8fd9\u5bf9\u4e8e\u7a97\u4f53\u7cfb\u7edf\u6216\u8005\u8bf8\u5982\u6b64\u7c7b\u7684\u6269\u5c55\u662f\u6709\u610f\u4e49\u7684\uff0c\u90a3\u4e48\u5982\u4f55\u68c0\u67e5\u53ef\u9009\u529f\u80fd\u5462\uff1f \u5728\u521b\u5efa instance \u4e4b\u524d\u68c0\u7d22\u652f\u6301\u7684\u6269\u5c55\u5217\u8868\uff0c\u901a\u8fc7 vkEnumerateInstanceExtensionProperties \u51fd\u6570\u3002\u5b83\u6307\u5411\u4e00\u4e2a\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u5b58\u50a8\u6269\u5c55\u6570\u91cf\u548c\u4e00\u4e2a VkExtensionProperties \u6570\u7ec4\u6765\u5b58\u50a8\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f\u3002\u5b83\u4e5f\u63a5\u53d7\u4e00\u4e2a\u53ef\u9009\u62e9\u7684\u53c2\u6570\uff0c\u5141\u8bb8\u6211\u4eec\u901a\u8fc7\u7279\u5b9a\u7684 validation layers \u8fc7\u6ee4\u6269\u5c55\uff0c\u73b0\u5728\u6211\u4eec\u6682\u65f6\u5ffd\u7565\u8fd9\u4e9b\u3002 \u8981\u5206\u914d\u4e00\u4e2a\u6570\u7ec4\u6765\u4fdd\u5b58\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u77e5\u9053\u6709\u591a\u5c11\u4e2a\u6269\u5c55\u5b58\u5728\u3002\u53ef\u4ee5\u901a\u8fc7\u5c06\u540e\u4e00\u4e2a\u53c2\u6570\u7f6e\u7a7a\u6765\u83b7\u53d6\u6269\u5c55\u6570\u91cf: uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr); C++ \u73b0\u5728\u6211\u4eec\u5206\u914d\u4e00\u4e2a\u96c6\u5408\u53bb\u6301\u6709\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f( include ) std::vector<VkExtensionProperties> extensions(extensionCount); C++ \u6700\u540e\u6211\u4eec\u53ef\u4ee5\u904d\u5386\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f: vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data()); C++ \u6bcf\u4e2a VkExtensionProperties \u7ed3\u6784\u4f53\u5305\u542b\u6269\u5c55\u7684\u540d\u79f0\u548c\u7248\u672c\u3002\u6211\u4eec\u53ef\u4ee5\u7528\u7b80\u5355\u7684for\u5faa\u73af\u6253\u5370\u4ed6\u4eec(\\t\u662f\u7f29\u8fdb) std::cout << \"available extensions:\" << std::endl; for (const auto& extension : extensions) { std::cout << \"\\t\" << extension.extensionName << std::endl; } C++ \u5982\u679c\u9700\u8981\u83b7\u53d6\u6709\u5173 Vulkan \u652f\u6301\u7684\u4e00\u4e9b\u8be6\u7ec6\u4fe1\u606f\uff0c\u53ef\u4ee5\u5c06\u6b64\u4ee3\u7801\u6dfb\u52a0\u5230 createInstance \u51fd\u6570\u3002\u4f5c\u4e3a\u4e00\u4e2a\u5c1d\u8bd5\uff0c\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\uff0c\u68c0\u67e5 glfwGetRequiredInstanceExtensions \u8fd4\u56de\u7684\u6240\u6709\u6269\u5c55\u662f\u5426\u90fd\u5305\u542b\u5728\u53d7\u652f\u6301\u7684\u6269\u5c55\u5217\u8868\u4e2d\u3002 \u9000\u51fa \u5728\u7a0b\u5e8f\u9000\u51fa\u524d\uff0c\u8bf7\u6b63\u786e\u9500\u6bc1 VkInstance \u3002\u8fd9\u90e8\u5206\u53ef\u4ee5\u5b9a\u4e49\u5728cleanup\u51fd\u6570\u4e2d\uff0c\u8c03\u7528 vkDestroyInstance \u51fd\u6570\u5b8c\u6210\u3002 void cleanup() { vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate(); } C++ vkDestroyInstance \u51fd\u6570\u7684\u53c2\u6570\u5f88\u7b80\u5355\u3002\u50cf\u4e4b\u524d\u5c0f\u8282\u63d0\u5230\u7684\uff0cVulkan\u4e2d\u7684\u5206\u914d\u548c\u91ca\u653e\u529f\u80fd\u6709\u4e00\u4e2a\u53ef\u9009\u7684\u5206\u914d\u5668\u56de\u8c03\uff0c\u6211\u4eec\u901a\u8fc7\u5c06 nullptr \u8bbe\u7f6e\u5ffd\u7565\u3002\u540e\u7eed\u5c0f\u8282\u4e2d\u521b\u5efa\u7684\u6240\u6709Vulkan\u76f8\u5173\u8d44\u6e90\uff0c\u96c6\u4e2d\u5728cleanup\u51fd\u6570\u4e2d\u8fdb\u884c\u6e05\u7406\uff0c\u4e14\u786e\u4fdd\u5728\u9500\u6bc1 instance \u4e4b\u524d\u9500\u6bc1\u3002 \u5728\u8fdb\u884c\u66f4\u590d\u6742\u7684\u5185\u5bb9\u4e4b\u524d\uff0c\u662f\u65f6\u5019\u4e86\u89e3 validation layers \u4e86\u3002 Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217\u7c07 Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217 \uff0c\u901a\u8fc7 VkInstance \u521d\u59cb\u5316 Vulkan \u540e\uff0c\u6211\u4eec\u9700\u8981\u5728\u7cfb\u7edf\u4e2d\u67e5\u627e\u5e76\u9009\u62e9\u4e00\u4e2a\u652f\u6301\u6211\u4eec\u6240\u9700\u529f\u80fd\u7684\u663e\u5361\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u6570\u91cf\u7684\u663e\u5361\u5e76\u540c\u65f6\u4f7f\u7528\u4ed6\u4eec\uff0c\u4f46\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u5355\u7684\u8bbe\u5b9a\u9009\u62e9\u89c4\u5219\uff0c\u5373\u5c06\u67e5\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u56fe\u5f62\u5361\u4f5c\u4e3a\u6211\u4eec\u9002\u5408\u7684\u7269\u7406\u8bbe\u5907\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9009\u62e9\u7269\u7406\u8bbe\u5907 2 \u8bbe\u5907\u9700\u6c42\u68c0\u6d4b 3 \u961f\u5217\u65cf 4 \u6e90\u4ee3\u7801 \u9009\u62e9\u7269\u7406\u8bbe\u5907 \u901a\u8fc7 VkInstance \u521d\u59cb\u5316Vulkan\u540e\uff0c\u6211\u4eec\u9700\u8981\u5728\u7cfb\u7edf\u4e2d\u67e5\u627e\u5e76\u9009\u62e9\u4e00\u4e2a\u652f\u6301\u6211\u4eec\u6240\u9700\u529f\u80fd\u7684\u663e\u5361\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u6570\u91cf\u7684\u663e\u5361\u5e76\u540c\u65f6\u4f7f\u7528\u4ed6\u4eec\uff0c\u4f46\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u5355\u7684\u8bbe\u5b9a\u9009\u62e9\u89c4\u5219\uff0c\u5373\u5c06\u67e5\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u56fe\u5f62\u5361\u4f5c\u4e3a\u6211\u4eec\u9002\u5408\u7684\u7269\u7406\u8bbe\u5907\u3002 \u6211\u4eec\u6dfb\u52a0\u51fd\u6570 pickPhysicalDevice \u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); pickPhysicalDevice(); } void pickPhysicalDevice() { } C++ \u6700\u7ec8\u6211\u4eec\u9009\u62e9\u7684\u56fe\u5f62\u663e\u5361\u5b58\u50a8\u5728\u7c7b\u6210\u5458 VkPhysicalDevice \u53e5\u67c4\u4e2d\u3002\u5f53 VkInstance \u9500\u6bc1\u65f6\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u5c06\u4f1a\u88ab\u9690\u5f0f\u9500\u6bc1\uff0c\u6240\u4ee5\u6211\u4eec\u5e76\u4e0d\u9700\u8981\u5728 cleanup \u51fd\u6570\u4e2d\u505a\u4efb\u4f55\u64cd\u4f5c\u3002 VkPhysicalDevice physicalDevice = VK_NULL_HANDLE; C++ \u5173\u4e8e\u83b7\u53d6\u56fe\u5f62\u5361\u5217\u8868\u7684\u65b9\u5f0f\u4e0e\u83b7\u5f97\u6269\u5c55\u5217\u8868\u7684\u65b9\u5f0f\u7c7b\u4f3c\u3002 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); C++ \u5982\u679c Vulkan \u652f\u6301\u7684\u8bbe\u5907\u6570\u4e3a0\uff0c\u90a3\u4e48\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u8fdb\u884c\u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u9009\u62e9\u629b\u51fa\u5f02\u5e38\u3002 if (deviceCount == 0) { throw std::runtime_error(\"failed to find GPUs with Vulkan support!\"); } C++ \u5426\u5219\u6211\u4eec\u5206\u914d\u6570\u7ec4\u5b58\u50a8\u6240\u6709 VkPhysicalDevice \u7684\u53e5\u67c4\u3002 std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); C++ \u73b0\u5728\u6211\u4eec\u9700\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u8bc4\u4f30\uff0c\u68c0\u67e5\u5b83\u4eec\u662f\u5426\u9002\u5408\u6211\u4eec\u8981\u6267\u884c\u7684\u64cd\u4f5c\uff0c\u56e0\u4e3a\u5e76\u4e0d\u662f\u6240\u6709\u7684\u663e\u5361\u529f\u80fd\u4e00\u81f4\u3002\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u51fd\u6570: bool isDeviceSuitable(VkPhysicalDevice device) { return true; } C++ \u6211\u4eec\u5c06\u68c0\u67e5\u662f\u5426\u6709\u4efb\u4f55\u7269\u7406\u8bbe\u5907\u7b26\u5408\u6211\u4eec\u7684\u529f\u80fd\u9700\u6c42\u3002 for (const auto& device : devices) { if (isDeviceSuitable(device)) { physicalDevice = device; break; } } if (physicalDevice == VK_NULL_HANDLE) { throw std::runtime_error(\"failed to find a suitable GPU!\"); } C++ \u4e0b\u4e00\u8282\u6211\u4eec\u4ecb\u7ecd isDeviceSuitable \u51fd\u6570\uff0c\u5e76\u68c0\u67e5\u7b2c\u4e00\u4e2a\u9700\u8981\u6ee1\u8db3\u7684\u529f\u80fd\u3002\u5728\u540e\u7eed\u7684\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u5f00\u59cb\u4f7f\u7528\u66f4\u591a\u7684 Vulkan \u529f\u80fd\uff0c\u6211\u4eec\u4f1a\u6269\u5c55\u6b64\u529f\u80fd\u51fd\u6570\u4ee5\u6ee1\u8db3\u66f4\u591a\u7684\u68c0\u67e5\u6761\u4ef6\u3002 \u8bbe\u5907\u9700\u6c42\u68c0\u6d4b \u8bc4\u4f30\u5408\u9002\u7684\u8bbe\u5907\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u904d\u5386\u4e00\u4e9b\u7ec6\u8282\u6765\u5b8c\u6210\u3002\u57fa\u672c\u7684\u8bbe\u5907\u5c5e\u6027\u50cfname, type\u4ee5\u53ca Vulkan \u7248\u672c\u90fd\u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceProperties \u6765\u904d\u5386\u5f97\u5230\u3002 VkPhysicalDeviceProperties deviceProperties; vkGetPhysicalDeviceProperties(device, &deviceProperties); C++ \u53ef\u4ee5\u4f7f\u7528 vkGetPhysicalDeviceFeatures \u67e5\u8be2\u5bf9\u7eb9\u7406\u538b\u7f29\uff0c64\u4f4d\u6d6e\u70b9\u6570\u548c\u591a\u89c6\u56fe\u6e32\u67d3(VR\u975e\u5e38\u6709\u7528)\u7b49\u53ef\u9009\u529f\u80fd\u7684\u652f\u6301: VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceFeatures(device, &deviceFeatures); C++ \u66f4\u591a\u904d\u5386\u7269\u7406\u8bbe\u5907\u7ec6\u8282\u7684\u4fe1\u606f\uff0c\u8bf8\u5982\u8bbe\u5907\u5185\u5b58\u3001\u961f\u5217\u7c07\u6211\u4eec\u5c06\u4f1a\u5728\u540e\u7eed\u5c0f\u8282\u8ba8\u8bba\u3002 \u4f8b\u5982\uff0c\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u4ec5\u9002\u7528\u4e8e\u652f\u6301 geometry shaders \u7684\u4e13\u7528\u663e\u5361\u3002\u90a3\u4e48 isDeviceSuitable \u51fd\u6570\u5c06\u5982\u4e0b\u6240\u793a: bool isDeviceSuitable(VkPhysicalDevice device) { VkPhysicalDeviceProperties deviceProperties; VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceProperties(device, &deviceProperties); vkGetPhysicalDeviceFeatures(device, &deviceFeatures); return deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU && deviceFeatures.geometryShader; } C++ \u4e3a\u4e86\u907f\u514d\u7eaf\u7cb9\u7684\u5355\u4e00\u7684\u5224\u65ad\u4e00\u4e2a\u8bbe\u5907\u662f\u5426\u5408\u9002\uff0c\u5c24\u5176\u662f\u5f53\u4f60\u53d1\u73b0\u591a\u4e2a\u8bbe\u5907\u90fd\u5408\u9002\u7684\u6761\u4ef6\u4e0b\uff0c\u4f60\u4e5f\u53ef\u4ee5\u7ed9\u6bcf\u4e00\u4e2a\u8bbe\u5907\u505a\u6743\u503c\uff0c\u9009\u62e9\u6700\u9ad8\u7684\u4e00\u4e2a\u3002\u8fd9\u6837\uff0c\u53ef\u4ee5\u901a\u8fc7\u7ed9\u4e88\u66f4\u9ad8\u6743\u503c\u83b7\u53d6\u5b9a\u5236\u5316\u7684\u56fe\u5f62\u8bbe\u5907\uff0c\u4f46\u5982\u679c\u6ca1\u6709\u4e00\u4e2a\u53ef\u7528\u7684\u8bbe\u5907\uff0c\u53ef\u4ee5\u56de\u6eda\u5230\u96c6\u6210\u56fe\u5f62\u8bbe\u5907\u3002\u4f60\u53ef\u4ee5\u6309\u7167\u5982\u4e0b\u65b9\u5f0f\u5b9e\u73b0: #include <map> ... void pickPhysicalDevice() { ... // Use an ordered map to automatically sort candidates by increasing score std::multimap<int, VkPhysicalDevice> candidates; for (const auto& device : devices) { int score = rateDeviceSuitability(device); candidates.insert(std::make_pair(score, device)); } // Check if the best candidate is suitable at all if (candidates.rbegin()->first > 0) { physicalDevice = candidates.rbegin()->second; } else { throw std::runtime_error(\"failed to find a suitable GPU!\"); } } int rateDeviceSuitability(VkPhysicalDevice device) { ... int score = 0; // Discrete GPUs have a significant performance advantage if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) { score += 1000; } // Maximum possible size of textures affects graphics quality score += deviceProperties.limits.maxImageDimension2D; // Application can't function without geometry shaders if (!deviceFeatures.geometryShader) { return 0; } return score; } C++ \u6211\u4eec\u4e0d\u9700\u8981\u5728\u5c0f\u8282\u5185\u5b9e\u73b0\u6240\u6709\u5185\u5bb9\uff0c\u4f46\u6211\u4eec\u53ef\u4ee5\u4e86\u89e3\u5982\u4f55\u9009\u62e9\u56fe\u5f62\u8bbe\u5907\u7684\u8fc7\u7a0b\u3002\u5f53\u7136\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u793a\u56fe\u5f62\u8bbe\u5907\u7684\u540d\u79f0\u5217\u8868\uff0c\u8ba9\u7528\u6237\u9009\u62e9\u3002 \u56e0\u4e3a\u6211\u4eec\u521a\u521a\u5f00\u59cb\uff0c Vulkan \u7684\u652f\u6301\u662f\u6211\u4eec\u552f\u4e00\u9700\u8981\u7684\uff0c\u5728\u8fd9\u91cc\u5047\u8bbe\u4efb\u4f55GPU\u90fd\u53ef\u4ee5: bool isDeviceSuitable(VkPhysicalDevice device) { return true; } C++ \u5728\u4e0b\u4e00\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u8ba8\u8bba\u7b2c\u4e00\u4e2a\u771f\u6b63\u9700\u8981\u68c0\u67e5\u7684\u8bbe\u5907\u529f\u80fd\u3002 \u961f\u5217\u65cf \u4e4b\u524d\u5df2\u7ecf\u7b80\u8981\u7684\u4ecb\u7ecd\u8fc7\uff0c\u51e0\u4e4e\u6240\u6709\u7684 Vulkan \u64cd\u4f5c\uff0c\u4ece\u7ed8\u56fe\u5230\u4e0a\u4f20\u7eb9\u7406\uff0c\u90fd\u9700\u8981\u5c06\u547d\u4ee4\u63d0\u4ea4\u5230\u961f\u5217\u4e2d\u3002\u6709\u4e0d\u540c\u7c7b\u578b\u7684\u961f\u5217\u6765\u6e90\u4e8e\u4e0d\u540c\u7684\u961f\u5217\u7c07\uff0c\u6bcf\u4e2a\u961f\u5217\u7c07\u53ea\u5141\u8bb8\u90e8\u5206 commands \u3002\u4f8b\u5982\uff0c\u53ef\u4ee5\u6709\u4e00\u4e2a\u961f\u5217\u7c07\uff0c\u53ea\u5141\u8bb8\u5904\u7406\u8ba1\u7b97 commands \u6216\u8005\u53ea\u5141\u8bb8\u5185\u5b58\u4f20\u8f93 commands : \u6211\u4eec\u9700\u8981\u68c0\u6d4b\u8bbe\u5907\u4e2d\u652f\u6301\u7684\u961f\u5217\u7c07\uff0c\u5176\u4e2d\u54ea\u4e00\u4e2a\u961f\u5217\u7c07\u652f\u6301\u6211\u4eec\u60f3\u8981\u7684 commands \u3002\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u51fd\u6570 findQueueFamilies \u6765\u67e5\u627e\u6211\u4eec\u9700\u8981\u7684\u961f\u5217\u7c07\u3002\u73b0\u5728\u6211\u4eec\u53ea\u4f1a\u5bfb\u627e\u4e00\u4e2a\u652f\u6301\u56fe\u5f62 commands \u961f\u5217\u7c07\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u5728\u7a0d\u540e\u7684\u5c0f\u8282\u4e2d\u6269\u5c55\u66f4\u591a\u7684\u5185\u5bb9\u3002 \u6b64\u51fd\u6570\u8fd4\u56de\u6ee1\u8db3\u67d0\u4e2a\u5c5e\u6027\u7684\u961f\u5217\u7c07\u7d22\u5f15\u3002\u5b9a\u4e49\u7ed3\u6784\u4f53\uff0c\u5176\u4e2d\u7d22\u5f15 -1 \u8868\u793a\u201d\u672a\u627e\u5230\u201d: struct QueueFamilyIndices { int graphicsFamily = -1; bool isComplete() { return graphicsFamily >= 0; } }; C++ \u73b0\u5728\u6211\u4eec\u5b9e\u73b0 findQueueFamilies \u51fd\u6570: QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) { QueueFamilyIndices indices; ... return indices; } C++ \u83b7\u53d6\u961f\u5217\u7c07\u7684\u5217\u8868\u51fd\u6570\u4e3a vkGetPhysicalDeviceQueueFamilyProperties : uint32_t queueFamilyCount = 0; vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr); std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount); vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data()); C++ \u6709\u5173\u961f\u5217\u7c07\uff0c\u7ed3\u6784\u4f53 VkQueueFamilyProperties \u5305\u542b\u4e86\u5177\u4f53\u4fe1\u606f\uff0c\u5305\u62ec\u652f\u6301\u7684\u64cd\u4f5c\u7c7b\u578b\u548c\u57fa\u4e8e\u5f53\u524d\u961f\u5217\u7c07\u53ef\u4ee5\u521b\u5efa\u7684\u6709\u6548\u961f\u5217\u6570\u3002\u6211\u4eec\u81f3\u5c11\u9700\u8981\u627e\u5230\u4e00\u4e2a\u652f\u6301 VK_QUEUE_GRAPHICS_BIT \u7684\u961f\u5217\u7c07\u3002 int i = 0; for (const auto& queueFamily : queueFamilies) { if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) { indices.graphicsFamily = i; } if (indices.isComplete()) { break; } i++; } C++ \u73b0\u5728\u6211\u4eec\u6709\u4e86\u6bd4\u8f83\u7406\u60f3\u7684\u961f\u5217\u7c07\u67e5\u8be2\u529f\u80fd\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 isDeviceSuitable \u51fd\u6570\u4e2d\u4f7f\u7528\uff0c\u786e\u4fdd\u7269\u7406\u8bbe\u5907\u53ef\u4ee5\u5904\u7406\u6211\u4eec\u9700\u8981\u7684\u547d\u4ee4: bool isDeviceSuitable(VkPhysicalDevice device) { QueueFamilyIndices indices = findQueueFamilies(device); return indices.isComplete(); } C++ \u5f88\u597d\uff0c\u6211\u4eec\u5df2\u7ecf\u627e\u5230\u4e86\u6211\u4eec\u9700\u8981\u7684\u7269\u7406\u8bbe\u5907\uff0c\u5728 \u4e0b\u4e00\u4e2a\u5c0f\u8282 \u6211\u4eec\u4f1a\u8ba8\u8bba\u903b\u8f91\u8bbe\u5907\u3002 Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b \uff0c \u4e0a\u4e00\u8282 \u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6b63\u786e\u914d\u7f6e\u3001\u53ef\u8fd0\u884c\u7684\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u4f7f\u7528\u6d4b\u8bd5\u4ee3\u7801\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u672c\u8282\u4e2d\u6211\u4eec\u4ece\u5934\u5f00\u59cb\uff0c\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u6784\u5efa\u4e00\u4e2a\u57fa\u4e8e GLFW \u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\u539f\u578b\u6846\u67b6\u7684\u96cf\u5f62\u3002 \u64cd\u4f5c\u7cfb\u7edf: Windows8.1 \u663e\u5361:Nivida GTX965M \u5f00\u53d1\u5de5\u5177\uff1aVisual Studio 2017 \u6587\u7ae0\u76ee\u5f55 1 \u603b\u4f53\u7ed3\u6784 2 \u8d44\u6e90\u7ba1\u7406 3 \u6574\u5408GLFW \u603b\u4f53\u7ed3\u6784 \u5728\u4e0a\u4e00\u8282\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6b63\u786e\u914d\u7f6e\u3001\u53ef\u8fd0\u884c\u7684\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u4f7f\u7528\u6d4b\u8bd5\u4ee3\u7801\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u672c\u8282\u4e2d\u6211\u4eec\u4ece\u5934\u5f00\u59cb\uff0c\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u6784\u5efa\u4e00\u4e2a\u57fa\u4e8eGLFW\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\u539f\u578b\u6846\u67b6\u7684\u96cf\u5f62\u3002 #include <vulkan/vulkan.h> #include <iostream> #include <stdexcept> #include <functional> class HelloTriangleApplication { public: void run() { initVulkan(); mainLoop(); cleanup(); } private: void initVulkan() { } void mainLoop() { } void cleanup() { } }; int main() { HelloTriangleApplication app; try { app.run(); } catch (const std::runtime_error& e) { std::cerr << e.what() << std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; } C++ \u9996\u5148\u4ece LunarG SDK \u4e2d\u6dfb\u52a0 Vulkan \u5934\u6587\u4ef6\uff0c\u5b83\u63d0\u4f9b\u4e86\u8d2d\u673a\u7231\u4f60 Vulkan \u5e94\u7528\u7a0b\u5e8f\u9700\u8981\u7684\u51fd\u6570\u3001\u7ed3\u6784\u4f53\u3001\u548c\u679a\u4e3e\u3002\u6211\u4eec\u5305\u542b stdexcept \u548c iostream \u5934\u6587\u4ef6\u7528\u4e8e\u629b\u51fa\u5f02\u5e38\u4fe1\u606f\uff0c\u800c functional \u5934\u6587\u4ef6\u7528\u4e8e\u8d44\u6e90\u7ba1\u7406\u90e8\u5206\u652f\u6301 lambda \u8868\u8fbe\u5f0f\u3002 \u7a0b\u5e8f\u88ab\u5c01\u88c5\u5230\u4e00\u4e2a\u7c7b\u4e2d\uff0c\u8be5\u7c7b\u7ed3\u6784\u5c06\u4f1a\u5b58\u50a8Vulkan\u79c1\u6709\u6210\u5458\u5bf9\u8c61\uff0c\u5e76\u6dfb\u52a0\u57fa\u672c\u7684\u51fd\u6570\u6765\u521d\u59cb\u5316\u4ed6\u4eec\u3002\u9996\u5148\u4f1a\u4ece initVulkan \u51fd\u6570\u5f00\u59cb\u8c03\u7528\u3002\u5f53\u4e00\u5207\u51c6\u5907\u597d\uff0c\u6211\u4eec\u8fdb\u5165\u4e3b\u5faa\u73af\u5f00\u59cb\u6e32\u67d3\u5e27\u3002\u6211\u4eec\u5c06\u4f1a\u52a0\u5165 mainLoop \u51fd\u6570\u5305\u542bloop\u5faa\u73af\u8c03\u7528\uff0c\u8be5\u5faa\u73af\u8c03\u7528\u76f4\u5230GLFW\u7a97\u4f53\u7ba1\u7406\u624d\u4f1a\u505c\u6b62\u3002\u5f53\u7a97\u4f53\u5173\u95ed\u5e76\u4e14 mainLoop \u8fd4\u56de\u65f6\uff0c\u6211\u4eec\u9700\u8981\u91ca\u653e\u6211\u4eec\u5df2\u7ecf\u7533\u8bf7\u8fc7\u7684\u4efb\u4f55\u8d44\u6e90\uff0c\u8be5\u6e05\u7406\u903b\u8f91\u5728 cleanup \u51fd\u6570\u4e2d\u53bb\u5b9a\u4e49\u3002 \u7a0b\u5e8f\u8fd0\u884c\u671f\u95f4\uff0c\u5982\u679c\u53d1\u751f\u4e86\u4efb\u4f55\u4e25\u91cd\u7684\u9519\u8bef\u5f02\u5e38\uff0c\u6211\u4eec\u4f1a\u629b\u51fa std::runtime_error \u5e76\u6ce8\u660e\u5f02\u5e38\u63cf\u8ff0\u4fe1\u606f,\u8fd9\u4e2a\u5f02\u5e38\u4fe1\u606f\u4f1a\u88ab main \u51fd\u6570\u6355\u83b7\u53ca\u6253\u5370\u63d0\u793a\u3002\u5f88\u5feb\u4f60\u5c06\u4f1a\u9047\u5230\u4e00\u4e2a\u629b\u51faerror\u7684\u4f8b\u5b50\uff0c\u662f\u5173\u4e8e Vulkan \u5e94\u7528\u7a0b\u5e8f\u4e0d\u652f\u6301\u67d0\u4e2a\u5fc5\u8981\u7684\u6269\u5c55\u529f\u80fd\u3002 \u57fa\u672c\u4e0a\u5728\u4e4b\u540e\u7684\u6bcf\u4e00\u4e2a\u5c0f\u8282\u4e2d\u90fd\u4f1a\u4ece initVulkan \u51fd\u6570\u4e2d\u589e\u52a0\u4e00\u4e2a\u65b0\u7684 Vulkan \u51fd\u6570\u8c03\u7528,\u589e\u52a0\u7684\u51fd\u6570\u4f1a\u4ea7\u751f Vulkan objects \u5e76\u4fdd\u5b58\u4e3a\u7c7b\u7684\u79c1\u6709\u6210\u5458\uff0c\u8bf7\u8bb0\u5f97\u5728 cleanup \u4e2d\u8fdb\u884c\u8d44\u6e90\u7684\u6e05\u7406\u548c\u91ca\u653e\u3002 \u8d44\u6e90\u7ba1\u7406 \u6211\u4eec\u77e5\u9053\u901a\u8fc7 malloc \u5206\u914d\u7684\u6bcf\u4e00\u4e2a\u5185\u5b58\u5feb\u5728\u4f7f\u7528\u5b8c\u4e4b\u540e\u90fd\u9700\u8981 free \u5185\u5b58\u8d44\u6e90\uff0c\u6bcf\u4e00\u4e2a\u6211\u4eec\u521b\u5efa\u7684 Vulkan object \u4e0d\u5728\u4f7f\u7528\u65f6\u90fd\u9700\u8981\u660e\u786e\u7684\u9500\u6bc1\u3002\u5728 C++ \u4e2d\u53ef\u4ee5\u5229\u7528 \u5b8c\u6210auto\u8d44\u6e90\u7ba1\u7406\uff0c\u4f46\u662f\u5728\u672c\u8282\u4e2d\uff0c\u9009\u62e9\u660e\u786e\u7f16\u5199\u6240\u6709\u7684\u5185\u5b58\u7684\u5206\u914d\u548c\u91ca\u653e\u64cd\u4f5c\uff0c\u5176\u4e3b\u8981\u539f\u56e0\u662f`\u7684\u8bbe\u8ba1\u7406\u5ff5\u5c31\u662f\u660e\u786e\u6bcf\u4e00\u6b65\u64cd\u4f5c\uff0c\u6e05\u695a\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f\uff0c\u907f\u514d\u53ef\u80fd\u5b58\u5728\u7684\u672a\u77e5\u4ee3\u7801\u9020\u6210\u7684\u5f02\u5e38\u3002 \u5f53\u7136\u5728\u672c\u8282\u4e4b\u540e,\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u91cd\u8f7d std::shared_ptr \u6765\u5b9e\u73b0auto \u8d44\u6e90\u7ba1\u7406\u3002\u5bf9\u4e8e\u66f4\u5927\u4f53\u91cf\u7684Vulkan\u7a0b\u5e8f,\u5efa\u8bae\u9075\u5faa RAII \u7684\u539f\u5219\u7ef4\u62a4\u8d44\u6e90\u7684\u7ba1\u7406\u3002 Vulkan \u5bf9\u8c61\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 vkCreateXXX \u7cfb\u51fd\u6570\u521b\u5efa\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u5177\u6709 vkAllocateXXX \u7b49\u529f\u80fd\u7684\u4e00\u4e2a\u5bf9\u8c61\u8fdb\u884c\u5206\u914d\u3002\u786e\u4fdd\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u5728\u4e0d\u4f7f\u7528\u7684\u65f6\u5019\u8c03\u7528 vkDestroyXXX \u548c vkFreeXXX \u9500\u6bc1\u3001\u91ca\u653e\u5bf9\u5e94\u7684\u8d44\u6e90\u3002\u8fd9\u4e9b\u51fd\u6570\u7684\u53c2\u6570\u901a\u5e38\u56e0\u4e0d\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u800c\u4e0d\u540c\uff0c\u4f46\u662f\u4ed6\u4eec\u5171\u4eab\u4e00\u4e2a\u53c2\u6570:pAllocator\u3002\u8fd9\u662f\u4e00\u4e2a\u53ef\u9009\u7684\u53c2\u6570\uff0c Vulkan \u5141\u8bb8\u6211\u4eec\u81ea\u5b9a\u4e49\u5185\u5b58\u5206\u914d\u5668\u3002\u6211\u4eec\u5c06\u5728\u672c\u6559\u7a0b\u5ffd\u7565\u6b64\u53c2\u6570\uff0c\u59cb\u7ec8\u4ee5 nullptr \u4f5c\u4e3a\u53c2\u6570\u3002 \u6574\u5408GLFW \u5982\u679c\u6211\u4eec\u5f00\u53d1\u4e00\u4e9b\u4e0d\u9700\u8981\u57fa\u4e8e\u5c4f\u5e55\u663e\u793a\u7684\u7a0b\u5e8f\uff0c\u90a3\u4e48\u7eaf\u7cb9\u7684 Vulkan \u672c\u8eab\u53ef\u4ee5\u5b8c\u7f8e\u7684\u652f\u6301\u5f00\u53d1\u3002\u4f46\u662f\u5982\u679c\u521b\u5efa\u4e00\u4e9b\u8ba9\u4eba\u5174\u594b\u7684\u53ef\u89c6\u5316\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u5c31\u9700\u8981\u5f15\u5165\u7a97\u4f53\u7cfb\u7edf GLFW \uff0c\u5e76\u5c06 #include \u8fdb\u884c\u76f8\u5e94\u7684\u66ff\u6362\u3002 #define GLFW_INCLUDE_VULKAN #include <GLFW/glfw3.h> C++ \u5728\u65b0\u7248\u672c\u7684 GLFW \u4e2d\u5df2\u7ecf\u63d0\u4f9b\u4e86 Vulkan \u76f8\u5173\u7684\u652f\u6301\uff0c\u8be6\u7ec6\u7684\u4f7f\u7528\u5efa\u8bae\u53c2\u9605\u5b98\u65b9\u8d44\u6599\u3002 \u901a\u8fc7\u66ff\u6362\uff0c\u5c06\u4f1a\u4f7f\u7528 GLFW \u5bf9 Vulkan \u7684\u652f\u6301\uff0c\u5e76\u81ea\u52a8\u52a0\u8f7d Vulkan \u7684\u5934\u6587\u4ef6\u3002\u5728 run \u51fd\u6570\u4e2d\u6dfb\u52a0\u4e00\u4e2a initWindow \u51fd\u6570\u8c03\u7528\uff0c\u5e76\u786e\u4fdd\u5728\u5176\u4ed6\u51fd\u6570\u8c03\u7528\u524d\u4f18\u5148\u8c03\u7528\u3002\u6211\u4eec\u5c06\u4f1a\u901a\u8fc7\u8be5\u51fd\u6570\u5b8c\u6210 GLFW \u7684\u7a97\u4f53\u521d\u59cb\u5316\u5de5\u4f5c\u3002 void run() { initWindow(); initVulkan(); mainLoop(); cleanup(); } private: void initWindow() { } C++ initWindow \u4e2d\u7684\u7b2c\u4e00\u4e2a\u8c03\u7528\u662f glfwInit() ,\u5b83\u4f1a\u521d\u59cb\u5316 GLFW \u5e93\u3002\u56e0\u4e3a\u6700\u521d GLFW \u662f\u4e3a OpenGL \u521b\u5efa\u4e0a\u4e0b\u6587\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u4eec\u9700\u8981\u544a\u8bc9\u5b83\u4e0d\u8981\u8c03\u7528 OpenGL \u76f8\u5173\u7684\u521d\u59cb\u5316\u64cd\u4f5c\u3002 glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); C++ \u7279\u522b\u6ce8\u610f\u7a97\u53e3\u5927\u5c0f\u7684\u8bbe\u7f6e\uff0c\u7a0d\u540e\u6211\u4eec\u4f1a\u8c03\u7528\uff0c\u73b0\u5728\u4f7f\u7528\u53e6\u4e00\u4e2a\u7a97\u53e3\u63d0\u793a\u6765\u4ec5\u7528\u5b83\u3002 glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); C++ \u73b0\u5728\u5269\u4e0b\u7684\u5c31\u662f\u521b\u5efa\u5b9e\u9645\u7684\u7a97\u4f53\u3002\u6dfb\u52a0\u4e00\u4e2a GLFWwindow* \u7a97\u4f53\uff0c\u79c1\u6709\u7c7b\u6210\u5458\u5b58\u50a8\u5176\u5f15\u7528\u5e76\u521d\u59cb\u5316\u7a97\u4f53: window = glfwCreateWindow(800, 600, \"Vulkan\", nullptr, nullptr); C++ \u524d\u4e09\u4e2a\u53c2\u6570\u5b9a\u4e49\u7a97\u4f53\u7684\u5bbd\u5ea6\u3001\u9ad8\u5ea6\u548c Title \u3002\u7b2c\u56db\u4e2a\u53c2\u6570\u5141\u8bb8\u5236\u5b9a\u4e00\u4e2a\u76d1\u542c\u5668\u6765\u6253\u5f00\u7a97\u4f53\uff0c\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u4e0e OpenGL \u6709\u5173\uff0c\u6211\u4eec\u9009\u62e9 nullptr \u3002 \u4f7f\u7528\u5e38\u91cf\u4ee3\u66ff\u786c\u7f16\u7801\u5bbd\u5ea6\u548c\u9ad8\u5ea6\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u540e\u7eed\u7684\u5185\u5bb9\u4e2d\u4f1a\u5f15\u7528\u8be5\u6570\u503c\u591a\u6b21\u3002\u5728 HelloTriangleApplication \u7c7b\u5b9a\u4e49\u4e4b\u4e0a\u6dfb\u52a0\u4ee5\u4e0b\u51e0\u884c: const int WIDTH = 800; const int HEIGHT = 600; C++ \u5e76\u66ff\u6362\u7a97\u4f53\u521b\u5efa\u7684\u4ee3\u7801\u8bed\u53e5\u4e3a: window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); C++ \u4f60\u73b0\u5728\u5e94\u8be5\u6709\u4e00\u4e2a\u5982\u4e0b\u6240\u793a\u7684initWindow\u51fd\u6570: void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); } C++ \u4fdd\u6301\u7a0b\u5e8f\u8fd0\u884c\uff0c\u76f4\u5230\u53d1\u751f\u9519\u8bef\u6216\u8005\u7a97\u4f53\u5173\u95ed\uff0c\u6211\u4eec\u9700\u8981\u5411 mainLoop \u51fd\u6570\u6dfb\u52a0\u4e8b\u4ef6\u5faa\u73af\uff0c\u5982\u4e0b\u6240\u793a: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); } } C++ \u8fd9\u6bb5\u4ee3\u7801\u5e94\u8be5\u5f88\u5bb9\u6613\u770b\u61c2\u3002\u5b83\u5faa\u73af\u5e76\u68c0\u67e5 GLFW \u4e8b\u4ef6\uff0c\u76f4\u5230\u6309\u4e0b X \u6309\u94ae\uff0c\u6216\u8005\u5173\u95ed\u7a97\u4f53\u3002\u8be5\u5faa\u73af\u7ed3\u6784\u7a0d\u540e\u4f1a\u8c03\u7528\u6e32\u67d3\u51fd\u6570\u3002 \u4e00\u65e6\u7a97\u4f53\u5173\u95ed\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7 cleanup \u51fd\u6570\u6e05\u7406\u8d44\u6e90\u3001\u7ed3\u675f GLFW \u672c\u8eab\u3002 void cleanup() { glfwDestroyWindow(window); glfwTerminate(); } C++ \u8fd0\u884c\u7a0b\u5e8f\uff0c\u6211\u4eec\u5e94\u8be5\u4f1a\u770b\u5230\u4e00\u4e2a\u540d\u4e3a Vulkan \u7684\u767d\u8272\u7a97\u4f53\uff0c\u76f4\u5230\u5173\u95ed\u7a97\u4f53\u7ec8\u6b62\u5e94\u7528\u7a0b\u5e8f\u3002 ok\uff0c\u5230\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86\u4e00\u4e2a Vulkan \u7a0b\u5e8f\u7684\u9aa8\u67b6\u539f\u578b\uff0c\u5728 \u4e0b\u4e00\u8282 \u6211\u4eec\u4f1a\u521b\u5efa\u7b2c\u4e00\u4e2a Vulkan Object ! [Vulkan \u9a8c\u8bc1\u5c42] PASS Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217 Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217 \uff0c\u5728\u9009\u62e9\u8981\u4f7f\u7528\u7684\u7269\u7406\u8bbe\u5907\u4e4b\u540e\uff0c\u6211\u4eec\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u903b\u8f91\u8bbe\u5907\u7528\u4e8e\u4ea4\u4e92\u3002\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u8fc7\u7a0b\u4e0einstance\u521b\u5efa\u8fc7\u7a0b\u7c7b\u4f3c\uff0c\u4e5f\u9700\u8981\u63cf\u8ff0\u6211\u4eec\u9700\u8981\u4f7f\u7528\u7684\u529f\u80fd\u3002\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u67e5\u8be2\u8fc7\u54ea\u4e9b\u961f\u5217\u7c07\u53ef\u7528\uff0c\u5728\u8fd9\u91cc\u9700\u8981\u8fdb\u4e00\u6b65\u4e3a\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u5177\u4f53\u7c7b\u578b\u7684\u547d\u4ee4\u961f\u5217\u3002\u5982\u679c\u6709\u4e0d\u540c\u7684\u9700\u6c42\uff0c\u4e5f\u53ef\u4ee5\u57fa\u4e8e\u540c\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u521b\u5efa\u591a\u4e2a\u903b\u8f91\u8bbe\u5907\u3002 \u9996\u5148\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u7c7b\u6210\u5458\u6765\u5b58\u50a8\u903b\u8f91\u8bbe\u5907\u53e5\u67c4\u3002 VkDevice device; C++ \u63a5\u4e0b\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u51fd\u6570 createLogicalDevice \uff0c\u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\uff0c\u4ee5\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u3002 void initVulkan() { createInstance(); setupDebugCallback(); pickPhysicalDevice(); createLogicalDevice(); } void createLogicalDevice() { } C++ https://geek-docs.com/vulkan/vulkan-tutorial/vulkan-logical-devices-and-queues.html#i-5) \u6307\u5b9a\u521b\u5efa\u7684\u961f\u5217 \u521b\u5efa\u903b\u8f91\u8bbe\u5907\u9700\u8981\u5728\u7ed3\u6784\u4f53\u4e2d\u660e\u786e\u5177\u4f53\u7684\u4fe1\u606f\uff0c\u9996\u5148\u7b2c\u4e00\u4e2a\u7ed3\u6784\u4f53 VkDeviceQueueCreateInfo \u3002\u8fd9\u4e2a\u7ed3\u6784\u4f53\u63cf\u8ff0\u961f\u5217\u7c07\u4e2d\u9884\u8981\u7533\u8bf7\u4f7f\u7528\u7684\u961f\u5217\u6570\u91cf\u3002\u73b0\u5728\u6211\u4eec\u4ec5\u5173\u5fc3\u5177\u5907\u56fe\u5f62\u80fd\u529b\u7684\u961f\u5217\u3002 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); VkDeviceQueueCreateInfo queueCreateInfo = {}; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = indices.graphicsFamily; queueCreateInfo.queueCount = 1; C++ \u5f53\u524d\u53ef\u7528\u7684\u9a71\u52a8\u7a0b\u5e8f\u6240\u63d0\u4f9b\u7684\u961f\u5217\u7c07\u53ea\u5141\u8bb8\u521b\u5efa\u5c11\u91cf\u7684\u961f\u5217\uff0c\u5e76\u4e14\u5f88\u591a\u65f6\u5019\u6ca1\u6709\u5fc5\u8981\u521b\u5efa\u591a\u4e2a\u961f\u5217\u3002\u8fd9\u662f\u56e0\u4e3a\u53ef\u4ee5\u5728\u591a\u4e2a\u7ebf\u7a0b\u4e0a\u521b\u5efa\u6240\u6709\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u7136\u540e\u5728\u4e3b\u7ebf\u7a0b\u4e00\u6b21\u6027\u7684\u4ee5\u8f83\u4f4e\u5f00\u9500\u7684\u8c03\u7528\u63d0\u4ea4\u961f\u5217\u3002 Vulkan \u5141\u8bb8\u4f7f\u75280.0\u52301.0\u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u5206\u914d\u961f\u5217\u4f18\u5148\u7ea7\u6765\u5f71\u54cd\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u7684\u8c03\u7528\u3002\u5373\u4f7f\u53ea\u6709\u4e00\u4e2a\u961f\u5217\u4e5f\u662f\u5fc5\u987b\u7684: float queuePriority = 1.0f; queueCreateInfo.pQueuePriorities = &queuePriority; C++ \u6307\u5b9a\u4f7f\u7528\u7684\u8bbe\u5907\u7279\u6027 \u4e0b\u4e00\u4e2a\u8981\u660e\u786e\u7684\u4fe1\u606f\u6709\u5173\u8bbe\u5907\u8981\u4f7f\u7528\u7684\u529f\u80fd\u7279\u6027\u3002\u8fd9\u4e9b\u662f\u6211\u4eec\u5728\u4e0a\u4e00\u8282\u4e2d\u7528 vkGetPhysicalDeviceFeatures \u67e5\u8be2\u652f\u6301\u7684\u529f\u80fd\uff0c\u6bd4\u5982geometry shaders\u3002\u73b0\u5728\u6211\u4eec\u4e0d\u9700\u8981\u4efb\u4f55\u7279\u6b8a\u7684\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7684\u5b9a\u4e49\u5b83\u5e76\u5c06\u6240\u6709\u5185\u5bb9\u4fdd\u7559\u5230 VK_FALSE \u3002\u4e00\u65e6\u6211\u4eec\u8981\u5f00\u59cb\u7528Vulkan\u505a\u66f4\u591a\u7684\u4e8b\u60c5\uff0c\u6211\u4eec\u4f1a\u56de\u5230\u8fd9\u4e2a\u7ed3\u6784\u4f53\uff0c\u8fdb\u4e00\u6b65\u8bbe\u7f6e\u3002 VkPhysicalDeviceFeatures deviceFeatures = {}; C++ \u521b\u5efa\u903b\u8f91\u8bbe\u5907 \u4f7f\u7528\u524d\u9762\u7684\u4e24\u4e2a\u7ed3\u6784\u4f53\uff0c\u6211\u4eec\u53ef\u4ee5\u586b\u5145 VkDeviceCreateInfo \u7ed3\u6784\u3002 VkDeviceCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; C++ \u9996\u5148\u6dfb\u52a0\u6307\u5411\u961f\u5217\u521b\u5efa\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\u548c\u8bbe\u5907\u529f\u80fd\u7ed3\u6784\u4f53: createInfo.pQueueCreateInfos = &queueCreateInfo; createInfo.queueCreateInfoCount = 1; createInfo.pEnabledFeatures = &deviceFeatures; C++ \u7ed3\u6784\u4f53\u5176\u4f59\u7684\u90e8\u5206\u4e0e VkInstanceCreateInfo \u76f8\u4f3c\uff0c\u9700\u8981\u6307\u5b9a\u6269\u5c55\u548c validation layers \uff0c\u603b\u800c\u8a00\u4e4b\u8fd9\u6b21\u4e0d\u540c\u4e4b\u5904\u662f\u4e3a\u5177\u4f53\u7684\u8bbe\u5907\u8bbe\u7f6e\u4fe1\u606f\u3002 \u8bbe\u7f6e\u5177\u4f53\u6269\u5c55\u7684\u4e00\u4e2a\u6848\u4f8b\u662f VK_KHR_swapchain \uff0c\u5b83\u5141\u8bb8\u5c06\u6765\u81ea\u8bbe\u5907\u7684\u6e32\u67d3\u56fe\u5f62\u5448\u73b0\u5230 Windows \u3002\u7cfb\u7edf\u4e2d\u7684 Vulkan \u8bbe\u5907\u53ef\u80fd\u7f3a\u5c11\u8be5\u529f\u80fd\uff0c\u4f8b\u5982\u4ec5\u4ec5\u652f\u6301\u8ba1\u7b97\u64cd\u4f5c\u3002\u6211\u4eec\u5c06\u5728\u4ea4\u6362\u94fe\u7ae0\u8282\u4e2d\u5c55\u5f00\u8fd9\u4e2a\u6269\u5c55\u3002 \u5c31\u50cf\u4e4b\u524d validation layers \u5c0f\u8282\u4e2d\u63d0\u5230\u7684\uff0c\u5141\u8bb8\u4e3a instance \u5f00\u542f validation layers \uff0c\u73b0\u5728\u6211\u4eec\u5c06\u4e3a\u8bbe\u5907\u5f00\u542f validation layers \uff0c\u800c\u4e0d\u9700\u8981\u4e3a\u8bbe\u5907\u6307\u5b9a\u4efb\u4f55\u6269\u5c55\u3002 createInfo.enabledExtensionCount = 0; if (enableValidationLayers) { createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size()); createInfo.ppEnabledLayerNames = validationLayers.data(); } else { createInfo.enabledLayerCount = 0; } C++ \u5c31\u8fd9\u6837\uff0c\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 vkCreateDevice \u51fd\u6570\u6765\u521b\u5efa\u5b9e\u4f8b\u5316\u903b\u8f91\u8bbe\u5907\u3002 if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) { throw std::runtime_error(\"failed to create logical device!\"); } C++ \u8fd9\u4e9b\u53c2\u6570\u5206\u522b\u662f\u5305\u542b\u5177\u4f53\u961f\u5217\u4f7f\u7528\u4fe1\u606f\u7684\u7269\u7406\u8bbe\u5907\uff0c\u53ef\u9009\u7684\u5206\u914d\u5668\u56de\u8c03\u6307\u9488\u4ee5\u53ca\u7528\u4e8e\u5b58\u50a8\u903b\u8f91\u8bbe\u5907\u7684\u53e5\u67c4\u3002\u4e0e instance \u521b\u5efa\u7c7b\u4f3c\uff0c\u6b64\u8c03\u7528\u53ef\u80fd\u7531\u4e8e\u542f\u7528\u4e0d\u5b58\u5728\u7684\u6269\u5c55\u6216\u8005\u6307\u5b9a\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5bfc\u81f4\u8fd4\u56de\u9519\u8bef\u3002 \u5728 cleanup \u51fd\u6570\u4e2d\u903b\u8f91\u8bbe\u5907\u9700\u8981\u8c03\u7528 vkDestroyDevice \u9500\u6bc1: void cleanup() { vkDestroyDevice(device, nullptr); ... } C++ \u903b\u8f91\u8bbe\u5907\u4e0d\u4e0e instance \u4ea4\u4e92\uff0c\u6240\u4ee5\u53c2\u6570\u4e2d\u4e0d\u5305\u542b instance \u3002 \u68c0\u7d22\u961f\u5217\u5904\u7406 \u8fd9\u4e9b\u961f\u5217\u4e0e\u903b\u8f91\u8bbe\u5907\u81ea\u52a8\u7684\u4e00\u540c\u521b\u5efa\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u4e00\u4e2a\u4e0e\u5b83\u4eec\u8fdb\u884c\u4ea4\u4e92\u7684\u53e5\u67c4\u3002\u5728\u8fd9\u91cc\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u7c7b\u6210\u5458\u6765\u5b58\u50a8\u56fe\u5f62\u961f\u5217\u53e5\u67c4: VkQueue graphicsQueue; C++ \u8bbe\u5907\u961f\u5217\u5728\u8bbe\u5907\u88ab\u9500\u6bc1\u7684\u65f6\u5019\u9690\u5f0f\u6e05\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u5728 cleanup \u51fd\u6570\u4e2d\u505a\u4efb\u4f55\u64cd\u4f5c\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 vkGetDeviceQueue \u51fd\u6570\u6765\u68c0\u6d4b\u6bcf\u4e2a\u961f\u5217\u7c07\u4e2d\u961f\u5217\u7684\u53e5\u67c4\u3002\u53c2\u6570\u662f\u903b\u8f91\u8bbe\u5907\uff0c\u961f\u5217\u7c07\uff0c\u961f\u5217\u7d22\u5f15\u548c\u5b58\u50a8\u83b7\u53d6\u961f\u5217\u53d8\u91cf\u53e5\u67c4\u7684\u6307\u9488\u3002\u56e0\u4e3a\u6211\u4eec\u53ea\u662f\u4ece\u8fd9\u4e2a\u961f\u5217\u7c07\u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u6240\u4ee5\u9700\u8981\u4f7f\u7528\u7d22\u5f15 0 \u3002 vkGetDeviceQueue(device, indices.graphicsFamily, 0, &graphicsQueue); C++ \u5728\u6210\u529f\u83b7\u53d6\u903b\u8f91\u8bbe\u5907\u548c\u961f\u5217\u53e5\u67c4\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u663e\u5361\u505a\u4e00\u4e9b\u5b9e\u9645\u7684\u4e8b\u60c5\u4e86\uff0c\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u4f1a\u8bbe\u7f6e\u8d44\u6e90\u5e76\u5c06\u76f8\u5e94\u7684\u7ed3\u679c\u63d0\u4ea4\u5230\u7a97\u4f53\u7cfb\u7edf\u3002 Vulkan \u4ea4\u6362\u94fe Vulkan \u4ea4\u6362\u94fe \uff0c\u5728\u8fd9\u4e00\u7ae0\u8282\uff0c\u6211\u4eec\u4e86\u89e3\u4e00\u4e0b\u5c06\u6e32\u67d3\u56fe\u50cf\u63d0\u4ea4\u5230\u5c4f\u5e55\u7684\u57fa\u672c\u673a\u5236\u3002\u8fd9\u79cd\u673a\u5236\u79f0\u4e3a\u4ea4\u6362\u94fe\uff0c\u5e76\u4e14\u9700\u8981\u5728 Vulkan \u4e0a\u4e0b\u6587\u4e2d\u88ab\u660e\u786e\u521b\u5efa\u3002\u4ece\u5c4f\u5e55\u7684\u89d2\u5ea6\u89c2\u5bdf\uff0c\u4ea4\u6362\u94fe\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u56fe\u50cf\u961f\u5217\u3002\u5e94\u7528\u7a0b\u5e8f\u4f5c\u4e3a\u751f\u4ea7\u8005\u4f1a\u83b7\u53d6\u56fe\u50cf\u8fdb\u884c\u7ed8\u5236\uff0c\u7136\u540e\u5c06\u5176\u8fd4\u8fd8\u7ed9\u4ea4\u6362\u94fe\u56fe\u50cf\u961f\u5217\uff0c\u7b49\u5f85\u5c4f\u5e55\u6d88\u8d39\u3002\u4ea4\u6362\u94fe\u7684\u5177\u4f53\u914d\u7f6e\u4fe1\u606f\u51b3\u5b9a\u4e86\u5e94\u7528\u7a0b\u5e8f\u63d0\u4ea4\u7ed8\u5236\u56fe\u50cf\u5230\u961f\u5217\u7684\u6761\u4ef6\u4ee5\u53ca\u56fe\u50cf\u961f\u5217\u8868\u73b0\u7684\u6548\u679c\uff0c\u4f46\u4ea4\u6362\u94fe\u7684\u901a\u5e38\u4f7f\u7528\u76ee\u7684\u662f\u4f7f\u7ed8\u5236\u56fe\u50cf\u7684\u6700\u7ec8\u5448\u73b0\u4e0e\u5c4f\u5e55\u7684\u5237\u65b0\u9891\u7387\u540c\u6b65\u3002\u53ef\u4ee5\u7b80\u5355\u5c06\u4ea4\u6362\u94fe\u7406\u89e3\u4e3a\u4e00\u4e2a\u961f\u5217\uff0c\u540c\u6b65\u4ece\u751f\u4ea7\u8005\uff0c\u5373\u5e94\u7528\u7a0b\u5e8f\u7ed8\u5236\u56fe\u50cf\uff0c\u5230\u6d88\u8d39\u8005\uff0c\u5c4f\u5e55\u5237\u65b0\u7684 Produce-Consume \u5173\u7cfb\u3002\u5728\u6df1\u5165\u5185\u5bb9\u524d\u770b\u4e00\u4e0b\u5b98\u65b9\u7ed9\u51fa\u7684\u6574\u4f53\u4ea4\u6362\u94fe\u793a\u4f8b\u56fe\u3002 \u5f53\u7136\u56fe\u793a\u4e0a\u6709\u4e00\u4e9b\u964c\u751f\u7684\u5173\u952e\u5b57\u4f1a\u5728\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\u4e2d\u9010\u4e00\u4ecb\u7ecd\uff0c\u5728\u6b64\u6709\u4e00\u4e2a\u6574\u4f53\u6982\u5ff5\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u68c0\u67e5\u4ea4\u6362\u94fe\u652f\u6301 2 \u67e5\u8be2\u4ea4\u6362\u94fe\u652f\u6301\u7684\u8be6\u60c5 3 \u4e3a\u4ea4\u6362\u94fe\u9009\u62e9\u6b63\u786e\u7684\u8bbe\u7f6e 4 Surface \u683c\u5f0f 5 \u6f14\u793a\u6a21\u5f0f 6 \u4ea4\u6362\u8303\u56f4 7 \u521b\u5efa\u4ea4\u6362\u94fe 8 \u83b7\u53d6\u4ea4\u6362\u94fe\u56fe\u50cf \u68c0\u67e5\u4ea4\u6362\u94fe\u652f\u6301 \u5e76\u4e0d\u662f\u6240\u6709\u7684\u56fe\u5f62\u5361\u5177\u5907\u80fd\u529b\u5c06\u7ed8\u5236\u7684\u56fe\u50cf\u76f4\u63a5\u663e\u793a\u5230\u5c4f\u5e55\u4e0a\u3002\u6bd4\u5982\u4e00\u4e2aGPU\u5361\u662f\u4e3a\u670d\u52a1\u5668\u8bbe\u8ba1\u7684\uff0c\u90a3\u5c31\u4e0d\u4f1a\u5177\u5907\u4efb\u4f55\u6709\u5173\u663e\u793a\u7684\u8f93\u51fa\u3002\u5176\u6b21\uff0c\u56fe\u50cf\u5448\u73b0\u662f\u4e0e surface \u6253\u4ea4\u9053\uff0c\u800c surface \u53c8\u4e0e\u5177\u4f53\u7684\u7a97\u4f53\u7cfb\u7edf\u5f3a\u5173\u8054\uff0c\u4ece\u8fd9\u4e2a\u89d2\u5ea6\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u5b83\u4e0d\u662f Vulkan \u6838\u5fc3\u7684\u90e8\u5206\u3002\u5728\u67e5\u8be2\u56fe\u5f62\u5361\u662f\u5426\u652f\u6301\u540e\uff0c\u9700\u8981\u542f\u7528 VK_KHR_swapchain \u8bbe\u5907\u7ea7\u522b\u7684\u6269\u5c55\u3002 \u6240\u4ee5\u5462\uff0c\u6211\u4eec\u9996\u5148\u6269\u5c55\u4e4b\u524d\u7684 isDeviceSuitable \u51fd\u6570\uff0c\u786e\u8ba4\u8bbe\u5907\u662f\u5426\u652f\u6301\u3002\u4e4b\u524d\u6211\u4eec\u5df2\u7ecf\u4e86\u89e3\u5982\u4f55\u5217\u51fa VkPhysicalDevice \u652f\u6301\u7684\u6269\u5c55\u5217\u8868\uff0c\u5728\u6b64\u5c31\u4e0d\u5c55\u5f00\u5177\u4f53\u7ec6\u8282\u4e86\u3002\u8bf7\u6ce8\u610f\u7684\u662f\uff0cVulkan\u5934\u6587\u4ef6\u63d0\u4f9b\u7ed9\u4e86\u4e00\u4e2a\u65b9\u4fbf\u7684\u5b8f VK_KHR_SWAPCHAIN_EXTENSION_NAME \uff0c\u8be5\u5b8f\u5b9a\u4e49\u4e3a VK_KHR_swapchain \u3002\u4f7f\u7528\u5b8f\u7684\u4f18\u70b9\u5c31\u662f\u907f\u514d\u62fc\u5199\u9519\u8bef\u3002 \u9996\u5148\u58f0\u660e\u9700\u8981\u7684\u8bbe\u5907\u6269\u5c55\u6e05\u5355\uff0c\u4e0e\u4e4b\u524d\u5f00\u542f validation layers \u7684\u5217\u8868\u662f\u76f8\u4f3c\u7684\u3002 const std::vector<const char*> deviceExtensions = { VK_KHR_SWAPCHAIN_EXTENSION_NAME }; C++ \u63a5\u4e0b\u6765\uff0c\u521b\u5efa\u4e00\u4e2a\u4ece isDeviceSuitable \u8c03\u7528\u7684\u65b0\u51fd\u6570 checkDeviceExtensionSupport \u4f5c\u4e3a\u989d\u5916\u7684\u68c0\u67e5\u903b\u8f91: bool isDeviceSuitable(VkPhysicalDevice device) { QueueFamilyIndices indices = findQueueFamilies(device); bool extensionsSupported = checkDeviceExtensionSupport(device); return indices.isComplete() && extensionsSupported; } bool checkDeviceExtensionSupport(VkPhysicalDevice device) { return true; } C++ \u4fee\u6539\u51fd\u6570\u4f53\u4ee5\u4fbf\u4e8e\u679a\u4e3e\u8bbe\u5907\u6240\u6709\u96c6\u5408\uff0c\u5e76\u68c0\u6d4b\u662f\u5426\u6240\u6709\u9700\u8981\u7684\u6269\u5c55\u5728\u5176\u4e2d\u3002 bool checkDeviceExtensionSupport(VkPhysicalDevice device) { uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availableExtensions.data()); std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end()); for (const auto& extension : availableExtensions) { requiredExtensions.erase(extension.extensionName); } return requiredExtensions.empty(); } C++ \u9009\u62e9\u4e00\u7ec4\u5b57\u7b26\u4e32\u6765\u8868\u793a\u672a\u7ecf\u786e\u8ba4\u8fc7\u7684\u6269\u5c55\u540d\u3002\u8fd9\u6837\u505a\u53ef\u4ee5\u6bd4\u8f83\u5bb9\u6613\u7684\u8fdb\u884c\u589e\u5220\u53ca\u904d\u5386\u7684\u6b21\u5e8f\u3002\u5f53\u7136\u4e5f\u53ef\u4ee5\u50cf CheckValidationLayerSupport \u51fd\u6570\u90a3\u6837\u505a\u5d4c\u5957\u7684\u5faa\u73af\u3002\u6027\u80fd\u7684\u5dee\u5f02\u5728\u8fd9\u91cc\u662f\u4e0d\u5173\u7d27\u8981\u7684\u3002\u73b0\u5728\u8fd0\u884c\u4ee3\u7801\u9a8c\u8bc1\u56fe\u5f62\u5361\u662f\u5426\u80fd\u591f\u987a\u5229\u521b\u5efa\u4e00\u4e2a\u4ea4\u6362\u94fe\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u524d\u4e00\u4e2a\u7ae0\u8282\u4e2d\u9a8c\u8bc1\u8fc7\u7684 presentation \u961f\u5217\u6709\u6548\u6027\uff0c\u5e76\u6ca1\u6709\u660e\u786e\u6307\u51fa\u4ea4\u6362\u94fe\u6269\u5c55\u4e5f\u5fc5\u987b\u6709\u6548\u652f\u6301\u3002\u597d\u5728\u6269\u5c55\u5fc5\u987b\u660e\u786e\u7684\u5f00\u542f\u3002 \u542f\u7528\u6269\u5c55\u9700\u8981\u5bf9\u903b\u8f91\u8bbe\u5907\u7684\u521b\u5efa\u7ed3\u6784\u4f53\u505a\u4e00\u4e9b\u5c0f\u7684\u6539\u52a8: createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size()); createInfo.ppEnabledExtensionNames = deviceExtensions.data(); C++ \u67e5\u8be2\u4ea4\u6362\u94fe\u652f\u6301\u7684\u8be6\u60c5 \u5982\u679c\u4ec5\u4ec5\u662f\u4e3a\u4e86\u6d4b\u8bd5\u4ea4\u6362\u94fe\u7684\u6709\u6548\u6027\u662f\u8fdc\u8fdc\u4e0d\u591f\u7684\uff0c\u56e0\u4e3a\u5b83\u8fd8\u4e0d\u80fd\u5f88\u597d\u7684\u4e0e\u7a97\u4f53 surface \u517c\u5bb9\u3002\u521b\u5efa\u4ea4\u6362\u94fe\u540c\u6837\u4e5f\u9700\u8981\u5f88\u591a\u8bbe\u7f6e\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4e86\u89e3\u4e00\u4e9b\u6709\u5173\u8bbe\u7f6e\u7684\u7ec6\u8282\u3002 \u57fa\u672c\u4e0a\u6709\u4e09\u5927\u7c7b\u5c5e\u6027\u9700\u8981\u8bbe\u7f6e: \u57fa\u672c\u7684surface\u529f\u80fd\u5c5e\u6027(min/max number of images in swap chain, min/max width and height of images) Surface\u683c\u5f0f(pixel format, color space) \u6709\u6548\u7684presentation\u6a21\u5f0f \u4e0e findQueueFamilies \u7c7b\u4f3c\uff0c\u6211\u4eec\u4f7f\u7528\u7ed3\u6784\u4f53\u4e00\u6b21\u6027\u7684\u4f20\u9012\u8be6\u7ec6\u7684\u4fe1\u606f\u3002\u4e09\u7c7b\u5c5e\u6027\u5c01\u88c5\u5728\u5982\u4e0b\u7ed3\u6784\u4f53\u4e2d\uff1a struct SwapChainSupportDetails { VkSurfaceCapabilitiesKHR capabilities; std::vector<VkSurfaceFormatKHR> formats; std::vector<VkPresentModeKHR> presentModes; }; C++ \u73b0\u5728\u521b\u5efa\u65b0\u7684\u51fd\u6570 querySwapChainSupport \u586b\u5145\u8be5\u7ed3\u6784\u4f53\u3002 SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) { SwapChainSupportDetails details; return details; } C++ \u672c\u5c0f\u8282\u6d89\u53ca\u5982\u4f55\u67e5\u8be2\u5305\u542b\u6b64\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\uff0c\u8fd9\u4e9b\u7ed3\u6784\u4f53\u7684\u542b\u4e49\u53ca\u5305\u542b\u7684\u6570\u636e\u5c06\u5728\u4e0b\u4e00\u8282\u8ba8\u8bba\u3002 \u6211\u4eec\u73b0\u5728\u5f00\u59cb\u57fa\u672c\u7684 surface \u529f\u80fd\u8bbe\u7f6e\u90e8\u5206\u3002\u8fd9\u4e9b\u5c5e\u6027\u53ef\u4ee5\u901a\u8fc7\u7b80\u5355\u7684\u51fd\u6570\u8c03\u7528\u67e5\u8be2\uff0c\u5e76\u8fd4\u56de\u5230\u5355\u4e2a VkSurfaceCapabilitiesKHR \u7ed3\u6784\u4f53\u4e2d\u3002 vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &details.capabilities); C++ \u8fd9\u4e2a\u51fd\u6570\u9700\u8981 VkPhysicalDevice \u548c VkSurfaceKHR \u7a97\u4f53 surface \u51b3\u5b9a\u652f\u6301\u54ea\u4e9b\u5177\u4f53\u529f\u80fd\u3002\u6240\u6709\u7528\u4e8e\u67e5\u770b\u652f\u6301\u529f\u80fd\u7684\u51fd\u6570\u90fd\u9700\u8981\u8fd9\u4e24\u4e2a\u53c2\u6570\uff0c\u56e0\u4e3a\u5b83\u4eec\u662f\u4ea4\u6362\u94fe\u7684\u6838\u5fc3\u7ec4\u4ef6\u3002 \u4e0b\u4e00\u6b65\u67e5\u8be2\u652f\u6301\u7684 surface \u683c\u5f0f\u3002\u56e0\u4e3a\u83b7\u53d6\u5230\u7684\u662f\u4e00\u4e2a\u7ed3\u6784\u4f53\u5217\u8868\uff0c\u5177\u4f53\u5e94\u7528\u5f62\u5f0f\u5982\u4e0b: uint32_t formatCount; vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, nullptr); if (formatCount != 0) { details.formats.resize(formatCount); vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, details.formats.data()); } C++ \u786e\u4fdd\u96c6\u5408\u5bf9\u4e8e\u6240\u6709\u6709\u6548\u7684\u683c\u5f0f\u53ef\u6269\u5145\u3002\u6700\u540e\u67e5\u8be2\u652f\u6301\u7684 presentation \u6a21\u5f0f\uff0c\u540c\u6837\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528 vkGetPhysicalDeviceSurfacePresentModesKHR : uint32_t presentModeCount; vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, nullptr); if (presentModeCount != 0) { details.presentModes.resize(presentModeCount); vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, details.presentModes.data()); } C++ \u73b0\u5728\u7ed3\u6784\u4f53\u7684\u76f8\u5173\u7ec6\u8282\u4ecb\u7ecd\u5b8c\u6bd5\uff0c\u8ba9\u6211\u4eec\u6269\u5145 isDeviceSuitable \u51fd\u6570\uff0c\u4ece\u800c\u5229\u7528\u8be5\u51fd\u6570\u9a8c\u8bc1\u4ea4\u6362\u94fe\u8db3\u591f\u7684\u652f\u6301\u3002\u5728\u672c\u7ae0\u8282\u4e2d\u4ea4\u6362\u94fe\u7684\u652f\u6301\u662f\u8db3\u591f\u7684\uff0c\u56e0\u4e3a\u5bf9\u4e8e\u7ed9\u5b9a\u7684\u7a97\u4f53 surface \uff0c\u5b83\u81f3\u5c11\u652f\u6301\u4e00\u4e2a\u56fe\u50cf\u683c\u5f0f\uff0c\u4e00\u4e2a presentaion \u6a21\u5f0f\u3002 bool swapChainAdequate = false; if (extensionsSupported) { SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device); swapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty(); } C++ \u6bd4\u8f83\u91cd\u8981\u7684\u662f\u5c1d\u8bd5\u67e5\u8be2\u4ea4\u6362\u94fe\u7684\u652f\u6301\u662f\u5728\u9a8c\u8bc1\u5b8c\u6269\u5c55\u6709\u6548\u6027\u4e4b\u540e\u8fdb\u884c\u3002\u51fd\u6570\u7684\u6700\u540e\u4e00\u884c\u4ee3\u7801\u4fee\u6539\u4e3a: return indices.isComplete() && extensionsSupported && swapChainAdequate; C++ \u4e3a\u4ea4\u6362\u94fe\u9009\u62e9\u6b63\u786e\u7684\u8bbe\u7f6e \u5982\u679c swapChainAdequate \u6761\u4ef6\u8db3\u591f\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u652f\u6301\u7684\u8db3\u591f\u7684\uff0c\u4f46\u662f\u6839\u636e\u4e0d\u540c\u7684\u6a21\u5f0f\u4ecd\u7136\u6709\u4e0d\u540c\u7684\u6700\u4f73\u9009\u62e9\u3002\u6211\u4eec\u7f16\u5199\u4e00\u7ec4\u51fd\u6570\uff0c\u901a\u8fc7\u8fdb\u4e00\u6b65\u7684\u8bbe\u7f6e\u67e5\u627e\u6700\u5339\u914d\u7684\u4ea4\u6362\u94fe\u3002\u8fd9\u91cc\u6709\u4e09\u79cd\u7c7b\u578b\u7684\u8bbe\u7f6e\u53bb\u786e\u5b9a: Surface\u683c\u5f0f (color depth) Presentation mode (conditions for \u201cswapping\u201d image to the screen) Swap extent (resolution of images in swap chain) \u9996\u5148\u5728\u8111\u6d77\u4e2d\u5bf9\u6bcf\u4e00\u4e2a\u8bbe\u7f6e\u90fd\u6709\u4e00\u4e2a\u7406\u60f3\u7684\u6570\u503c\uff0c\u5982\u679c\u8fbe\u6210\u4e00\u81f4\u6211\u4eec\u5c31\u4f7f\u7528\uff0c\u5426\u5219\u6211\u4eec\u4e00\u8d77\u521b\u5efa\u4e00\u4e9b\u903b\u8f91\u53bb\u627e\u5230\u66f4\u597d\u7684\u89c4\u5219\u3001\u6570\u503c\u3002 Surface \u683c\u5f0f \u8fd9\u4e2a\u51fd\u6570\u7528\u6765\u8bbe\u7f6esurface\u683c\u5f0f\u3002\u6211\u4eec\u4f20\u9012 formats \u4f5c\u4e3a\u51fd\u6570\u7684\u53c2\u6570\uff0c\u7c7b\u578b\u4e3a SwapChainSupportDetails \u3002 VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) { } C++ \u6bcf\u4e2a VkSurfaceFormatKHR \u7ed3\u6784\u90fd\u5305\u542b\u4e00\u4e2a format \u548c\u4e00\u4e2a colorSpace \u6210\u5458\u3002 format \u6210\u5458\u53d8\u91cf\u6307\u5b9a\u8272\u5f69\u901a\u9053\u548c\u7c7b\u578b\u3002\u6bd4\u5982\uff0c VK_FORMAT_B8G8R8A8_UNORM \u4ee3\u8868\u4e86\u6211\u4eec\u4f7f\u7528B,G,R\u548calpha\u6b21\u5e8f\u7684\u901a\u9053\uff0c\u4e14\u6bcf\u4e00\u4e2a\u901a\u9053\u4e3a\u65e0\u7b26\u53f78bit\u6574\u6570\uff0c\u6bcf\u4e2a\u50cf\u7d20\u603b\u8ba132bits\u3002 colorSpace \u6210\u5458\u63cf\u8ff0 SRGB \u989c\u8272\u7a7a\u95f4\u662f\u5426\u901a\u8fc7 VK_COLOR_SPACE_SRGB_NONLINEAR_KHR \u6807\u5fd7\u652f\u6301\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u5728\u8f83\u65e9\u7248\u672c\u7684\u89c4\u8303\u4e2d\uff0c\u8fd9\u4e2a\u6807\u5fd7\u540d\u4e3a VK_COLORSPACE_SRGB_NONLINEAR_KHR \u3002 \u5982\u679c\u53ef\u4ee5\u6211\u4eec\u5c3d\u53ef\u80fd\u4f7f\u7528SRGB(\u5f69\u8272\u8bed\u8a00\u534f\u8bae)\uff0c \u56e0\u4e3a\u5b83\u4f1a\u5f97\u5230\u66f4\u5bb9\u6613\u611f\u77e5\u7684\u3001\u7cbe\u786e\u7684\u8272\u5f69 \u3002\u76f4\u63a5\u4e0e SRGB \u989c\u8272\u6253\u4ea4\u9053\u662f\u6bd4\u8f83\u6709\u6311\u6218\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u4f7f\u7528\u6807\u51c6\u7684RGB\u4f5c\u4e3a\u989c\u8272\u683c\u5f0f\uff0c\u8fd9\u4e5f\u662f\u901a\u5e38\u4f7f\u7528\u7684\u4e00\u4e2a\u683c\u5f0f VK_FORMAT_B8G8R8A8_UNORM \u3002 \u6700\u7406\u60f3\u7684\u60c5\u51b5\u662fsurface\u6ca1\u6709\u8bbe\u7f6e\u4efb\u4f55\u504f\u5411\u6027\u7684\u683c\u5f0f\uff0c\u8fd9\u4e2a\u65f6\u5019Vulkan\u4f1a\u901a\u8fc7\u4ec5\u8fd4\u56de\u4e00\u4e2a VkSurfaceFormatKHR \u7ed3\u6784\u8868\u793a\uff0c\u4e14\u8be5\u7ed3\u6784\u7684 format \u6210\u5458\u8bbe\u7f6e\u4e3a VK_FORMAT_UNDEFINED \u3002 if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) { return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; } C++ \u5982\u679c\u4e0d\u80fd\u81ea\u7531\u7684\u8bbe\u7f6e\u683c\u5f0f\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u904d\u5386\u5217\u8868\u8bbe\u7f6e\u5177\u6709\u504f\u5411\u6027\u7684\u7ec4\u5408: for (const auto& availableFormat : availableFormats) { if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { return availableFormat; } } C++ \u5982\u679c\u4ee5\u4e0a\u4e24\u79cd\u65b9\u5f0f\u90fd\u5931\u6548\u4e86\uff0c\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u201c\u4f18\u826f\u201d\u8fdb\u884c\u6253\u5206\u6392\u5e8f\uff0c\u4f46\u662f\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4f1a\u9009\u62e9\u7b2c\u4e00\u4e2a\u683c\u5f0f\u4f5c\u4e3a\u7406\u60f3\u7684\u9009\u62e9\u3002 VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) { if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) { return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; } for (const auto& availableFormat : availableFormats) { if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { return availableFormat; } } return availableFormats[0]; } C++ \u6f14\u793a\u6a21\u5f0f presentation \u6a21\u5f0f\u5bf9\u4e8e\u4ea4\u6362\u94fe\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u56e0\u4e3a\u5b83\u4ee3\u8868\u4e86\u5728\u5c4f\u5e55\u5448\u73b0\u56fe\u50cf\u7684\u6761\u4ef6\u3002\u5728 Vulkan \u4e2d\u6709\u56db\u4e2a\u6a21\u5f0f\u53ef\u4ee5\u4f7f\u7528: VK_PRESENT_MODE_IMMEDIATE_KHR : \u5e94\u7528\u7a0b\u5e8f\u63d0\u4ea4\u7684\u56fe\u50cf\u88ab\u7acb\u5373\u4f20\u8f93\u5230\u5c4f\u5e55\u5448\u73b0\uff0c\u8fd9\u79cd\u6a21\u5f0f\u53ef\u80fd\u4f1a\u9020\u6210\u6495\u88c2\u6548\u679c\u3002 VK_PRESENT_MODE_FIFO_KHR : \u4ea4\u6362\u94fe\u88ab\u770b\u4f5c\u4e00\u4e2a\u961f\u5217\uff0c\u5f53\u663e\u793a\u5185\u5bb9\u9700\u8981\u5237\u65b0\u7684\u65f6\u5019\uff0c\u663e\u793a\u8bbe\u5907\u4ece\u961f\u5217\u7684\u524d\u9762\u83b7\u53d6\u56fe\u50cf\uff0c\u5e76\u4e14\u7a0b\u5e8f\u5c06\u6e32\u67d3\u5b8c\u6210\u7684\u56fe\u50cf\u63d2\u5165\u961f\u5217\u7684\u540e\u9762\u3002\u5982\u679c\u961f\u5217\u662f\u6ee1\u7684\u7a0b\u5e8f\u4f1a\u7b49\u5f85\u3002\u8fd9\u79cd\u89c4\u6a21\u4e0e\u89c6\u9891\u6e38\u620f\u7684\u5782\u76f4\u540c\u6b65\u5f88\u7c7b\u4f3c\u3002\u663e\u793a\u8bbe\u5907\u7684\u5237\u65b0\u65f6\u523b\u88ab\u6210\u4e3a\u201c\u5782\u76f4\u4e2d\u65ad\u201d\u3002 VK_PRESENT_MODE_FIFO_RELAXED_KHR : \u8be5\u6a21\u5f0f\u4e0e\u4e0a\u4e00\u4e2a\u6a21\u5f0f\u7565\u6709\u4e0d\u540c\u7684\u5730\u65b9\u4e3a\uff0c\u5982\u679c\u5e94\u7528\u7a0b\u5e8f\u5b58\u5728\u5ef6\u8fdf\uff0c\u5373\u63a5\u53d7\u6700\u540e\u4e00\u4e2a\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\u65f6\u961f\u5217\u7a7a\u4e86\uff0c\u5c06\u4e0d\u4f1a\u7b49\u5f85\u4e0b\u4e00\u4e2a\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\uff0c\u800c\u662f\u5c06\u56fe\u50cf\u76f4\u63a5\u4f20\u9001\u3002\u8fd9\u6837\u505a\u53ef\u80fd\u5bfc\u81f4\u53ef\u89c1\u7684\u6495\u88c2\u6548\u679c\u3002 VK_PRESENT_MODE_MAILBOX_KHR : \u8fd9\u662f\u7b2c\u4e8c\u79cd\u6a21\u5f0f\u7684\u53d8\u79cd\u3002\u5f53\u4ea4\u6362\u94fe\u961f\u5217\u6ee1\u7684\u65f6\u5019\uff0c\u9009\u62e9\u65b0\u7684\u66ff\u6362\u65e7\u7684\u56fe\u50cf\uff0c\u4ece\u800c\u66ff\u4ee3\u963b\u585e\u5e94\u7528\u7a0b\u5e8f\u7684\u60c5\u5f62\u3002\u8fd9\u79cd\u6a21\u5f0f\u901a\u5e38\u7528\u6765\u5b9e\u73b0\u4e09\u91cd\u7f13\u51b2\u533a\uff0c\u4e0e\u6807\u51c6\u7684\u5782\u76f4\u540c\u6b65\u53cc\u7f13\u51b2\u76f8\u6bd4\uff0c\u5b83\u53ef\u4ee5\u6709\u6548\u907f\u514d\u5ef6\u8fdf\u5e26\u6765\u7684\u6495\u88c2\u6548\u679c\u3002 \u903b\u8f91\u4e0a\u770b\u4ec5\u4ec5 VR_PRESENT_MODE_FIFO_KHR \u6a21\u5f0f\u4fdd\u8bc1\u53ef\u7528\u6027\uff0c\u6240\u4ee5\u6211\u4eec\u518d\u6b21\u589e\u52a0\u4e00\u4e2a\u51fd\u6570\u67e5\u627e\u6700\u4f73\u7684\u6a21\u5f0f: VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { return VK_PRESENT_MODE_FIFO_KHR; } C++ \u6211\u4e2a\u4eba\u8ba4\u4e3a\u4e09\u7ea7\u7f13\u51b2\u662f\u4e00\u4e2a\u975e\u5e38\u597d\u7684\u7b56\u7565\u3002\u5b83\u5141\u8bb8\u6211\u4eec\u907f\u514d\u6495\u88c2\uff0c\u540c\u65f6\u4ecd\u7136\u4fdd\u6301\u76f8\u5bf9\u4f4e\u7684\u5ef6\u8fdf\uff0c\u901a\u8fc7\u6e32\u67d3\u5c3d\u53ef\u80fd\u65b0\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u63a5\u53d7\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\u3002\u6240\u4ee5\u6211\u4eec\u770b\u4e00\u4e0b\u5217\u8868\uff0c\u5b83\u662f\u5426\u53ef\u7528: VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { for (const auto& availablePresentMode : availablePresentModes) { if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { return availablePresentMode; } } return VK_PRESENT_MODE_FIFO_KHR; } C++ \u9057\u61be\u7684\u662f\uff0c\u4e00\u4e9b\u9a71\u52a8\u7a0b\u5e8f\u76ee\u524d\u5e76\u4e0d\u652f\u6301 VK_PRESENT_MODE_FIFO_KHR ,\u9664\u6b64\u4e4b\u5916\u5982\u679c VK_PRESENT_MODE_MAILBOX_KHR \u4e5f\u4e0d\u53ef\u7528\uff0c\u6211\u4eec\u66f4\u503e\u5411\u4f7f\u7528 VK_PRESENT_MODE_IMMEDIATE_KHR : VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { VkPresentModeKHR bestMode = VK_PRESENT_MODE_FIFO_KHR; for (const auto& availablePresentMode : availablePresentModes) { if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { return availablePresentMode; } else if (availablePresentMode == VK_PRESENT_MODE_IMMEDIATE_KHR) { bestMode = availablePresentMode; } } return bestMode; } C++ \u4ea4\u6362\u8303\u56f4 \u8fd8\u5269\u4e0b\u4e00\u4e2a\u5c5e\u6027\uff0c\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u51fd\u6570: VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) { } C++ \u4ea4\u6362\u8303\u56f4\u662f\u6307\u4ea4\u6362\u94fe\u56fe\u50cf\u7684\u5206\u8fa8\u7387\uff0c\u5b83\u51e0\u4e4e\u603b\u662f\u7b49\u4e8e\u6211\u4eec\u7ed8\u5236\u7a97\u4f53\u7684\u5206\u8fa8\u7387\u3002\u5206\u8fa8\u7387\u7684\u8303\u56f4\u88ab\u5b9a\u4e49\u5728 VkSurfaceCapabilitiesKHR \u7ed3\u6784\u4f53\u4e2d\u3002 Vulkan \u544a\u8bc9\u6211\u4eec\u901a\u8fc7\u8bbe\u7f6e currentExtent \u6210\u5458\u7684 width \u548c height \u6765\u5339\u914d\u7a97\u4f53\u7684\u5206\u8fa8\u7387\u3002\u7136\u800c\uff0c\u4e00\u4e9b\u7a97\u4f53\u7ba1\u7406\u5668\u5141\u8bb8\u4e0d\u540c\u7684\u8bbe\u7f6e\uff0c\u610f\u5473\u7740\u5c06 currentExtent \u7684width\u548cheight\u8bbe\u7f6e\u4e3a\u7279\u6b8a\u7684\u6570\u503c\u8868\u793a: uint32_t \u7684\u6700\u5927\u503c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53c2\u8003\u7a97\u4f53 minImageExtent \u548c maxImageExtent \u9009\u62e9\u6700\u5339\u914d\u7684\u5206\u8fa8\u7387\u3002 VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) { if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) { return capabilities.currentExtent; } else { VkExtent2D actualExtent = {WIDTH, HEIGHT}; actualExtent.width = std::max(capabilities.minImageExtent.width, std::min(capabilities.maxImageExtent.width, actualExtent.width)); actualExtent.height = std::max(capabilities.minImageExtent.height, std::min(capabilities.maxImageExtent.height, actualExtent.height)); return actualExtent; } } C++ max \u548c min \u51fd\u6570\u7528\u4e8e\u5c06 WIDTH \u548c HEIGHT \u6536\u655b\u5728\u5b9e\u9645\u652f\u6301\u7684 minimum \u548c maximum \u8303\u56f4\u4e2d\u3002\u5728\u8fd9\u91cc\u786e\u8ba4\u5305\u542b <algorithm> \u5934\u6587\u4ef6\u3002 \u521b\u5efa\u4ea4\u6362\u94fe \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6709\u4e86\u8fd9\u4e9b\u8f85\u52a9\u51fd\u6570\uff0c\u7528\u4ee5\u5728\u8fd0\u884c\u65f6\u5e2e\u52a9\u6211\u4eec\u505a\u51fa\u660e\u667a\u7684\u9009\u62e9\uff0c\u6700\u7ec8\u83b7\u5f97\u6709\u4e86\u521b\u5efa\u4ea4\u6362\u94fe\u6240\u9700\u8981\u7684\u6240\u6709\u4fe1\u606f\u3002 \u521b\u5efa\u4e00\u4e2a\u51fd\u6570 createSwapChain \uff0c\u5728 initVulkan \u51fd\u6570\u4e2d\uff0c\u8be5\u51fd\u6570\u4f1a\u5728\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u4e4b\u540e\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); } void createSwapChain() { SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice); VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats); VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes); VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities); } C++ \u5b9e\u9645\u4e0a\u8fd8\u6709\u4e00\u4e9b\u5c0f\u4e8b\u60c5\u9700\u8981\u786e\u5b9a\uff0c\u4f46\u662f\u6bd4\u8f83\u7b80\u5355\uff0c\u6240\u4ee5\u6ca1\u6709\u5355\u72ec\u521b\u5efa\u51fd\u6570\u3002\u7b2c\u4e00\u4e2a\u662f\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u53ef\u4ee5\u7406\u89e3\u4e3a\u961f\u5217\u7684\u957f\u5ea6\u3002\u5b83\u6307\u5b9a\u8fd0\u884c\u65f6\u56fe\u50cf\u7684\u6700\u5c0f\u6570\u91cf\uff0c\u6211\u4eec\u5c06\u5c1d\u8bd5\u5927\u4e8e1\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u4ee5\u5b9e\u73b0\u4e09\u91cd\u7f13\u51b2\u3002 uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1; if (swapChainSupport.capabilities.maxImageCount > 0 && imageCount > swapChainSupport.capabilities.maxImageCount) { imageCount = swapChainSupport.capabilities.maxImageCount; } C++ \u5bf9\u4e8e maxImageCount \u6570\u503c\u4e3a 0 \u4ee3\u8868\u9664\u4e86\u5185\u5b58\u4e4b\u5916\u6ca1\u6709\u9650\u5236\uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u9700\u8981\u68c0\u67e5\u3002 \u4e0eVulkan\u5176\u4ed6\u5bf9\u8c61\u7684\u521b\u5efa\u8fc7\u7a0b\u4e00\u6837\uff0c\u521b\u5efa\u4ea4\u6362\u94fe\u4e5f\u9700\u8981\u586b\u5145\u5927\u91cf\u7684\u7ed3\u6784\u4f53: VkSwapchainCreateInfoKHR createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; createInfo.surface = surface; C++ \u5728\u6307\u5b9a\u4ea4\u6362\u94fe\u7ed1\u5b9a\u5230\u5177\u4f53\u7684 surface \u4e4b\u540e\uff0c\u9700\u8981\u6307\u5b9a\u4ea4\u6362\u94fe\u56fe\u50cf\u6709\u5173\u7684\u8be6\u7ec6\u4fe1\u606f: createInfo.minImageCount = imageCount; createInfo.imageFormat = surfaceFormat.format; createInfo.imageColorSpace = surfaceFormat.colorSpace; createInfo.imageExtent = extent; createInfo.imageArrayLayers = 1; createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; C++ imageArrayLayers \u6307\u5b9a\u6bcf\u4e2a\u56fe\u50cf\u7ec4\u6210\u7684\u5c42\u6570\u3002\u9664\u975e\u6211\u4eec\u5f00\u53d13D\u5e94\u7528\u7a0b\u5e8f\uff0c\u5426\u5219\u59cb\u7ec8\u4e3a1\u3002 imageUsage \u4f4d\u5b57\u6bb5\u6307\u5b9a\u5728\u4ea4\u6362\u94fe\u4e2d\u5bf9\u56fe\u50cf\u8fdb\u884c\u7684\u5177\u4f53\u64cd\u4f5c\u3002\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u76f4\u63a5\u5bf9\u5b83\u4eec\u8fdb\u884c\u6e32\u67d3\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u4eec\u4f5c\u4e3a\u989c\u8272\u9644\u4ef6\u3002\u4e5f\u53ef\u4ee5\u9996\u5148\u5c06\u56fe\u50cf\u6e32\u67d3\u4e3a\u5355\u72ec\u7684\u56fe\u50cf\uff0c\u8fdb\u884c\u540e\u5904\u7406\u64cd\u4f5c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u53ef\u4ee5\u4f7f\u7528\u50cf VK_IMAGE_USAGE_TRANSFER_DST_BIT \u8fd9\u6837\u7684\u503c\uff0c\u5e76\u4f7f\u7528\u5185\u5b58\u64cd\u4f5c\u5c06\u6e32\u67d3\u7684\u56fe\u50cf\u4f20\u8f93\u5230\u4ea4\u6362\u94fe\u56fe\u50cf\u961f\u5217\u3002 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); uint32_t queueFamilyIndices[] = {(uint32_t) indices.graphicsFamily, (uint32_t) indices.presentFamily}; if (indices.graphicsFamily != indices.presentFamily) { createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT; createInfo.queueFamilyIndexCount = 2; createInfo.pQueueFamilyIndices = queueFamilyIndices; } else { createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; createInfo.queueFamilyIndexCount = 0; // Optional createInfo.pQueueFamilyIndices = nullptr; // Optional } C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u6307\u5b9a\u5982\u4f55\u5904\u7406\u8de8\u591a\u4e2a\u961f\u5217\u7c07\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u3002\u5982\u679cgraphics\u961f\u5217\u7c07\u4e0epresentation\u961f\u5217\u7c07\u4e0d\u540c\uff0c\u4f1a\u51fa\u73b0\u5982\u4e0b\u60c5\u5f62\u3002\u6211\u4eec\u5c06\u4ecegraphics\u961f\u5217\u4e2d\u7ed8\u5236\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\uff0c\u7136\u540e\u5728\u53e6\u4e00\u4e2apresentation\u961f\u5217\u4e2d\u63d0\u4ea4\u4ed6\u4eec\u3002\u591a\u961f\u5217\u5904\u7406\u56fe\u50cf\u6709\u4e24\u79cd\u65b9\u6cd5: VK_SHARING_MODE_EXCLUSIVE : \u540c\u4e00\u65f6\u95f4\u56fe\u50cf\u53ea\u80fd\u88ab\u4e00\u4e2a\u961f\u5217\u7c07\u5360\u7528\uff0c\u5982\u679c\u5176\u4ed6\u961f\u5217\u7c07\u9700\u8981\u5176\u6240\u6709\u6743\u9700\u8981\u660e\u786e\u6307\u5b9a\u3002\u8fd9\u79cd\u65b9\u5f0f\u63d0\u4f9b\u4e86\u6700\u597d\u7684\u6027\u80fd\u3002 VK_SHARING_MODE_CONCURRENT : \u56fe\u50cf\u53ef\u4ee5\u88ab\u591a\u4e2a\u961f\u5217\u7c07\u8bbf\u95ee\uff0c\u4e0d\u9700\u8981\u660e\u786e\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\u3002 \u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u5982\u679c\u961f\u5217\u7c07\u4e0d\u540c\uff0c\u5c06\u4f1a\u4f7f\u7528 concurrent \u6a21\u5f0f\uff0c\u907f\u514d\u5904\u7406\u56fe\u50cf\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\u7684\u5185\u5bb9\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u4f1a\u6d89\u53ca\u4e0d\u5c11\u6982\u5ff5\uff0c\u5efa\u8bae\u540e\u7eed\u7684\u7ae0\u8282\u8ba8\u8bba\u3002 Concurrent \u6a21\u5f0f\u9700\u8981\u9884\u5148\u6307\u5b9a\u961f\u5217\u7c07\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\uff0c\u901a\u8fc7 queueFamilyIndexCount \u548c pQueueFamilyIndices \u53c2\u6570\u8fdb\u884c\u5171\u4eab\u3002\u5982\u679c graphics \u961f\u5217\u7c07\u548cpresentation\u961f\u5217\u7c07\u76f8\u540c\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 exclusive \u6a21\u5f0f\uff0c\u56e0\u4e3a concurrent \u6a21\u5f0f\u9700\u8981\u81f3\u5c11\u4e24\u4e2a\u4e0d\u540c\u7684\u961f\u5217\u7c07\u3002 createInfo.preTransform = swapChainSupport.capabilities.currentTransform; C++ \u5982\u679c\u4ea4\u6362\u94fe\u652f\u6301( supportedTransforms in capabilities ),\u6211\u4eec\u53ef\u4ee5\u4e3a\u4ea4\u6362\u94fe\u56fe\u50cf\u6307\u5b9a\u67d0\u4e9b\u8f6c\u6362\u903b\u8f91\uff0c\u6bd4\u598290\u5ea6\u987a\u65f6\u9488\u65cb\u8f6c\u6216\u8005\u6c34\u5e73\u53cd\u8f6c\u3002\u5982\u679c\u4e0d\u9700\u8981\u4efb\u4f55 transoform \u64cd\u4f5c\uff0c\u53ef\u4ee5\u7b80\u5355\u7684\u8bbe\u7f6e\u4e3a currentTransoform \u3002 createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR; C++ \u6df7\u5408Alpha\u5b57\u6bb5\u6307\u5b9aalpha\u901a\u9053\u662f\u5426\u5e94\u7528\u4e0e\u4e0e\u5176\u4ed6\u7684\u7a97\u4f53\u7cfb\u7edf\u8fdb\u884c\u6df7\u5408\u64cd\u4f5c\u3002\u5982\u679c\u5ffd\u7565\u8be5\u529f\u80fd\uff0c\u7b80\u5355\u7684\u586b VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR \u3002 createInfo.presentMode = presentMode; createInfo.clipped = VK_TRUE; C++ presentMode \u6307\u5411\u81ea\u5df1\u3002\u5982\u679c clipped \u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u610f\u5473\u7740\u6211\u4eec\u4e0d\u5173\u5fc3\u88ab\u906e\u853d\u7684\u50cf\u7d20\u6570\u636e\uff0c\u6bd4\u5982\u7531\u4e8e\u5176\u4ed6\u7684\u7a97\u4f53\u7f6e\u4e8e\u524d\u65b9\u65f6\u6216\u8005\u6e32\u67d3\u7684\u90e8\u5206\u5185\u5bb9\u5b58\u5728\u4e8e\u53ef\u662f\u533a\u57df\u4e4b\u5916\uff0c\u9664\u975e\u771f\u7684\u9700\u8981\u8bfb\u53d6\u8fd9\u4e9b\u50cf\u7d20\u83b7\u6570\u636e\u8fdb\u884c\u5904\u7406\uff0c\u5426\u5219\u53ef\u4ee5\u5f00\u542f\u88c1\u526a\u83b7\u5f97\u6700\u4f73\u6027\u80fd\u3002 createInfo.oldSwapchain = VK_NULL_HANDLE; C++ \u6700\u540e\u4e00\u4e2a\u5b57\u6bb5 oldSwapChain \u3002Vulkan\u8fd0\u884c\u65f6\uff0c\u4ea4\u6362\u94fe\u53ef\u80fd\u5728\u67d0\u4e9b\u6761\u4ef6\u4e0b\u88ab\u66ff\u6362\uff0c\u6bd4\u5982\u7a97\u53e3\u8c03\u6574\u5927\u5c0f\u6216\u8005\u4ea4\u6362\u94fe\u9700\u8981\u91cd\u65b0\u5206\u914d\u66f4\u5927\u7684\u56fe\u50cf\u961f\u5217\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4ea4\u6362\u94fe\u5b9e\u9645\u4e0a\u9700\u8981\u91cd\u65b0\u5206\u914d\u521b\u5efa\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u6b64\u5b57\u6bb5\u4e2d\u6307\u5b9a\u5bf9\u65e7\u7684\u5f15\u7528\uff0c\u7528\u4ee5\u56de\u6536\u8d44\u6e90\u3002\u8fd9\u662f\u4e00\u4e2a\u6bd4\u8f83\u590d\u6742\u7684\u8bdd\u9898\uff0c\u6211\u4eec\u4f1a\u5728\u540e\u9762\u7684\u7ae0\u8282\u4e2d\u8be6\u7ec6\u4ecb\u7ecd\u3002\u73b0\u5728\u5047\u8bbe\u6211\u4eec\u53ea\u4f1a\u521b\u5efa\u4e00\u4e2a\u4ea4\u6362\u94fe\u3002 \u73b0\u5728\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u53d8\u91cf\u5b58\u50a8 VkSwapchainKHR \u5bf9\u8c61: VkSwapchainKHR swapChain; C++ \u521b\u5efa\u4ea4\u6362\u94fe\u53ea\u9700\u8981\u7b80\u5355\u7684\u8c03\u7528\u51fd\u6570: vkCreateSwapchainKHR : if (vkCreateSwapchainKHR(device, &createInfo, nullptr, &swapChain) != VK_SUCCESS) { throw std::runtime_error(\"failed to create swap chain!\"); } C++ \u53c2\u6570\u662f\u903b\u8f91\u8bbe\u5907\uff0c\u4ea4\u6362\u94fe\u521b\u5efa\u7684\u4fe1\u606f\uff0c\u53ef\u9009\u62e9\u7684\u5206\u914d\u5668\u548c\u4e00\u4e2a\u5b58\u50a8\u4ea4\u6362\u540e\u7684\u53e5\u67c4\u6307\u9488\u3002\u5b83\u4e5f\u9700\u8981\u5728\u8bbe\u5907\u88ab\u6e05\u7406\u524d\uff0c\u8fdb\u884c\u9500\u6bc1\u64cd\u4f5c\uff0c\u901a\u8fc7\u8c03\u7528 vkDestroySwapchainKHR \u3002 void cleanup() { vkDestroySwapchainKHR(device, swapChain, nullptr); ... } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\u786e\u4fdd\u4ea4\u6362\u94fe\u521b\u5efa\u6210\u529f\uff01 \u5c1d\u8bd5\u79fb\u9664 createInfo.imageExtent = extent; \u5e76\u5728validation layers\u5f00\u542f\u7684\u6761\u4ef6\u4e0b\uff0cvalidation layers\u4f1a\u7acb\u523b\u6355\u83b7\u5230\u6709\u5e2e\u52a9\u7684\u5f02\u5e38\u4fe1\u606f: \u83b7\u53d6\u4ea4\u6362\u94fe\u56fe\u50cf \u4ea4\u6362\u94fe\u521b\u5efa\u540e\uff0c\u9700\u8981\u83b7\u53d6 VkImage \u76f8\u5173\u7684\u53e5\u67c4\u3002\u5b83\u4f1a\u5728\u540e\u7eed\u6e32\u67d3\u7684\u7ae0\u8282\u4e2d\u5f15\u7528\u3002\u6dfb\u52a0\u7c7b\u6210\u5458\u53d8\u91cf\u5b58\u50a8\u8be5\u53e5\u67c4: std::vector<VkImage> swapChainImages; C++ \u56fe\u50cf\u88ab\u4ea4\u6362\u94fe\u521b\u5efa\uff0c\u4e5f\u4f1a\u5728\u4ea4\u6362\u94fe\u9500\u6bc1\u7684\u540c\u65f6\u81ea\u52a8\u6e05\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u6dfb\u52a0\u4efb\u4f55\u6e05\u7406\u4ee3\u7801\u3002 \u6211\u4eec\u5728 createSwapChain \u51fd\u6570\u4e0b\u9762\u6dfb\u52a0\u4ee3\u7801\u83b7\u53d6\u53e5\u67c4\uff0c\u5728 vkCreateSwapchainKHR \u540e\u8c03\u7528\u3002\u83b7\u53d6\u53e5\u67c4\u7684\u64cd\u4f5c\u540c\u4e4b\u524d\u83b7\u53d6\u6570\u7ec4\u96c6\u5408\u7684\u64cd\u4f5c\u975e\u5e38\u7c7b\u4f3c\u3002\u9996\u5148\u901a\u8fc7\u8c03\u7528 vkGetSwapchainImagesKHR \u83b7\u53d6\u4ea4\u6362\u94fe\u4e2d\u56fe\u50cf\u7684\u6570\u91cf\uff0c\u5e76\u6839\u636e\u6570\u91cf\u8bbe\u7f6e\u5408\u9002\u7684\u5bb9\u5668\u5927\u5c0f\u4fdd\u5b58\u83b7\u53d6\u5230\u7684\u53e5\u67c4\u96c6\u5408\u3002 vkGetSwapchainImagesKHR(device, swapChain, &imageCount, nullptr); swapChainImages.resize(imageCount); vkGetSwapchainImagesKHR(device, swapChain, &imageCount, swapChainImages.data()); C++ \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e4b\u524d\u521b\u5efa\u4ea4\u6362\u94fe\u6b65\u9aa4\u4e2d\u6211\u4eec\u4f20\u9012\u4e86\u671f\u671b\u7684\u56fe\u50cf\u5927\u5c0f\u5230\u5b57\u6bb5 minImageCount \u3002\u800c\u5b9e\u9645\u7684\u8fd0\u884c\uff0c\u5141\u8bb8\u6211\u4eec\u521b\u5efa\u66f4\u591a\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u9700\u8981\u518d\u4e00\u6b21\u83b7\u53d6\u6570\u91cf\u3002 \u6700\u540e\uff0c\u5b58\u50a8\u4ea4\u6362\u94fe\u683c\u5f0f\u548c\u8303\u56f4\u5230\u6210\u5458\u53d8\u91cf\u4e2d\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7ae0\u8282\u4f7f\u7528\u3002 VkSwapchainKHR swapChain; std::vector<VkImage> swapChainImages; VkFormat swapChainImageFormat; VkExtent2D swapChainExtent; ... swapChainImageFormat = surfaceFormat.format; swapChainExtent = extent; C++ \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u56fe\u50cf\uff0c\u8fd9\u4e9b\u56fe\u50cf\u53ef\u4ee5\u88ab\u7ed8\u5236\uff0c\u5e76\u5448\u73b0\u5230\u7a97\u4f53\u3002 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u5f00\u59cb\u8ba8\u8bba\u5982\u4f55\u4e3a\u56fe\u50cf\u8bbe\u7f6e\u6e32\u67d3\u76ee\u6807\uff0c\u5e76\u4e86\u89e3\u5b9e\u9645\u7684\u56fe\u50cf\u7ba1\u7ebf\u548c\u7ed8\u5236\u547d\u4ee4\u3002 Vulkan Window Surface Vulkan Window Surface \uff0c\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u4e86\u89e3\u5230 Vulkan \u662f\u4e00\u4e2a\u4e0e\u5e73\u53f0\u7279\u6027\u65e0\u5173\u8054\u7684 API \u96c6\u5408\u3002\u5b83\u4e0d\u80fd\u76f4\u63a5\u4e0e\u7a97\u53e3\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002\u4e3a\u4e86\u5c06\u6e32\u67d3\u7ed3\u679c\u5448\u73b0\u5230\u5c4f\u5e55\uff0c\u9700\u8981\u5efa\u7acb Vulkan \u4e0e\u7a97\u4f53\u7cfb\u7edf\u4e4b\u95f4\u7684\u8fde\u63a5\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 WSI (\u7a97\u4f53\u7cfb\u7edf\u96c6\u6210)\u6269\u5c55\u3002\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u8ba8\u8bba\u7b2c\u4e00\u4e2a\uff0c\u5373 VK_KHR_surface \u3002\u5b83\u66b4\u9732\u4e86 VkSurfaceKHR \uff0c\u5b83\u4ee3\u8868 surface \u7684\u4e00\u4e2a\u62bd\u8c61\u7c7b\u578b\uff0c\u7528\u4ee5\u5448\u73b0\u6e32\u67d3\u56fe\u50cf\u4f7f\u7528\u3002\u6211\u4eec\u7a0b\u5e8f\u4e2d\u5c06\u8981\u4f7f\u7528\u5230\u7684 surface \u662f\u7531\u6211\u4eec\u5df2\u7ecf\u5f15\u5165\u7684 GLFW \u6269\u5c55\u53ca\u5176\u6253\u5f00\u7684\u76f8\u5173\u7a97\u4f53\u652f\u6301\u7684\u3002\u7b80\u5355\u6765\u8bf4surface\u5c31\u662fVulkan\u4e0e\u7a97\u4f53\u7cfb\u7edf\u7684\u8fde\u63a5\u6865\u6881\u3002 VK_KHR_surface \u6269\u5c55\u662f\u4e00\u4e2ainstance\u7ea7\u6269\u5c55\uff0c\u6211\u4eec\u76ee\u524d\u4e3a\u6b62\u5df2\u7ecf\u542f\u7528\u8fc7\u5b83\uff0c\u5b83\u5305\u542b\u5728 glfwGetRequiredInstanceExtensions \u8fd4\u56de\u7684\u5217\u8868\u4e2d\u3002\u8be5\u5217\u8868\u8fd8\u5305\u62ec\u5c06\u5728\u63a5\u4e0b\u6765\u51e0\u5c0f\u8282\u4e2d\u4f7f\u7528\u7684\u4e00\u4e9b\u5176\u4ed6WSI\u6269\u5c55\u3002 \u9700\u8981\u5728 instance \u521b\u5efa\u4e4b\u540e\u7acb\u5373\u521b\u5efa\u7a97\u4f53 surface \uff0c\u56e0\u4e3a\u5b83\u4f1a\u5f71\u54cd\u7269\u7406\u8bbe\u5907\u7684\u9009\u62e9\u3002\u4e4b\u6240\u4ee5\u5728\u672c\u5c0f\u8282\u5c06 surface \u521b\u5efa\u903b\u8f91\u7eb3\u5165\u8ba8\u8bba\u8303\u56f4\uff0c\u662f\u56e0\u4e3a\u7a97\u4f53 surface \u5bf9\u4e8e\u6e32\u67d3\u3001\u5448\u73b0\u65b9\u5f0f\u662f\u4e00\u4e2a\u6bd4\u8f83\u5927\u7684\u8bfe\u9898\uff0c\u5982\u679c\u8fc7\u65e9\u7684\u5728\u521b\u5efa\u7269\u7406\u8bbe\u5907\u52a0\u5165\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u4f1a\u6df7\u6dc6\u57fa\u672c\u7684\u7269\u7406\u8bbe\u5907\u8bbe\u7f6e\u5de5\u4f5c\u3002\u53e6\u5916\u7a97\u4f53 surface \u672c\u8eab\u5bf9\u4e8e Vulkan \u4e5f\u662f\u975e\u5f3a\u5236\u7684\u3002 Vulkan \u5141\u8bb8\u8fd9\u6837\u505a\uff0c\u4e0d\u9700\u8981\u540c OpenGL \u4e00\u6837\u5fc5\u987b\u8981\u521b\u5efa\u7a97\u4f53 surface \u3002 \u6587\u7ae0\u76ee\u5f55 1 \u521b\u5efa Window Surface 2 \u67e5\u8be2\u6f14\u793a\u652f\u6301 3 \u521b\u5efa\u6f14\u793a\u961f\u5217 \u521b\u5efa Window Surface \u73b0\u5728\u5f00\u59cb\u7740\u624b\u521b\u5efa\u7a97\u4f53 surface \uff0c\u5728\u7c7b\u6210\u5458 debugCallback \u4e0b\u52a0\u5165\u6210\u5458\u53d8\u91cf surface \u3002 VkSurfaceKHR surface; C++ \u867d\u7136 VkSurfaceKHR \u5bf9\u8c61\u53ca\u5176\u7528\u6cd5\u4e0e\u5e73\u53f0\u65e0\u5173\u8054\uff0c\u4f46\u521b\u5efa\u8fc7\u7a0b\u9700\u8981\u4f9d\u8d56\u5177\u4f53\u7684\u7a97\u4f53\u7cfb\u7edf\u7684\u7ec6\u8282\u3002\u6bd4\u5982\uff0c\u5728 Windows \u5e73\u53f0\u4e2d\uff0c\u5b83\u9700\u8981 WIndows \u4e0a\u7684 HWND \u548c HMODULE \u53e5\u67c4\u3002\u56e0\u6b64\u9488\u5bf9\u7279\u5b9a\u5e73\u53f0\u63d0\u4f9b\u76f8\u5e94\u7684\u6269\u5c55\uff0c\u5728 Windows \u4e0a\u4e3a VK_KHR_win32_surface \uff0c\u5b83\u81ea\u52a8\u5305\u542b\u5728 glfwGetRequiredInstanceExtensions \u5217\u8868\u4e2d\u3002 \u6211\u4eec\u5c06\u4f1a\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u7279\u5b9a\u5e73\u53f0\u7684\u6269\u5c55\u6765\u521b\u5efa Windows \u4e0a\u7684 surface \u6865\uff0c\u4f46\u662f\u4e0d\u4f1a\u5728\u6559\u7a0b\u4e2d\u5b9e\u9645\u4f7f\u7528\u5b83\u3002\u4f7f\u7528GLFW\u8fd9\u6837\u7684\u5e93\u907f\u514d\u4e86\u7f16\u5199\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u7684\u8de8\u5e73\u53f0\u76f8\u5173\u4ee3\u7801\u3002 GLFW \u5b9e\u9645\u4e0a\u901a\u8fc7 glfwCreateWindowSurface \u5f88\u597d\u7684\u5904\u7406\u4e86\u5e73\u53f0\u5dee\u5f02\u6027\u3002\u5f53\u7136\u4e86\uff0c\u6bd4\u8f83\u7406\u60f3\u662f\u5728\u4f9d\u8d56\u5b83\u4eec\u5e2e\u52a9\u6211\u4eec\u5b8c\u6210\u5177\u4f53\u5de5\u4f5c\u4e4b\u524d\uff0c\u4e86\u89e3\u4e00\u4e0b\u80cc\u540e\u7684\u5b9e\u73b0\u662f\u6709\u5e2e\u52a9\u7684\u3002 \u56e0\u4e3a\u4e00\u4e2a\u7a97\u4f53 surface \u662f\u4e00\u4e2a Vulkan \u5bf9\u8c61\uff0c\u5b83\u9700\u8981\u586b\u5145 VkWin32SurfaceCreateInfoKHR \u7ed3\u6784\u4f53\uff0c\u8fd9\u91cc\u6709\u4e24\u4e2a\u6bd4\u8f83\u91cd\u8981\u7684\u53c2\u6570: hwnd \u548c hinstance \u3002\u5982\u679c\u719f\u6089 windows \u4e0b\u5f00\u53d1\u5e94\u8be5\u77e5\u9053\uff0c\u8fd9\u4e9b\u662f\u7a97\u53e3\u548c\u8fdb\u7a0b\u7684\u53e5\u67c4\u3002 VkWin32SurfaceCreateInfoKHR createInfo; createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR; createInfo.hwnd = glfwGetWin32Window(window); createInfo.hinstance = GetModuleHandle(nullptr); C++ glfwGetWin32Window \u51fd\u6570\u7528\u4e8e\u4eceGLFW\u7a97\u4f53\u5bf9\u8c61\u83b7\u53d6\u539f\u59cb\u7684 HWND \u3002 GetModuleHandle \u51fd\u6570\u8fd4\u56de\u5f53\u524d\u8fdb\u7a0b\u7684 HINSTANCE \u53e5\u67c4\u3002 \u586b\u5145\u5b8c\u7ed3\u6784\u4f53\u4e4b\u540e\uff0c\u53ef\u4ee5\u5229\u7528 vkCreateWin32SurfaceKHR \u521b\u5efasurface\u6865\uff0c\u548c\u4e4b\u524d\u83b7\u53d6\u521b\u5efa\u3001\u9500\u6bc1 DebugReportCallEXT \u4e00\u6837\uff0c\u8fd9\u91cc\u540c\u6837\u9700\u8981\u901a\u8fc7 instance \u83b7\u53d6\u521b\u5efa surface \u7528\u5230\u7684\u51fd\u6570\u3002\u8fd9\u91cc\u6d89\u53ca\u5230\u7684\u53c2\u6570\u5206\u522b\u4e3a instance , surface \u521b\u5efa\u7684\u4fe1\u606f\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u6700\u7ec8\u4fdd\u5b58 surface \u7684\u53e5\u67c4\u53d8\u91cf\u3002 auto CreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) vkGetInstanceProcAddr(instance, \"vkCreateWin32SurfaceKHR\"); if (!CreateWin32SurfaceKHR || CreateWin32SurfaceKHR(instance, &createInfo, nullptr, &surface) != VK_SUCCESS) { throw std::runtime_error(\"failed to create window surface!\"); } C++ \u8be5\u8fc7\u7a0b\u4e0e\u5176\u4ed6\u5e73\u53f0\u7c7b\u4f3c\uff0c\u6bd4\u5982 Linux \uff0c\u4f7f\u7528X11\u754c\u9762\u7a97\u4f53\u7cfb\u7edf\uff0c\u53ef\u4ee5\u901a\u8fc7 vkCreateXcbSurfaceKHR \u51fd\u6570\u5efa\u7acb\u8fde\u63a5\u3002 glfwCreateWindowSurface \u51fd\u6570\u6839\u636e\u4e0d\u540c\u5e73\u53f0\u7684\u5dee\u5f02\u6027\uff0c\u5728\u5b9e\u73b0\u7ec6\u8282\u4e0a\u4f1a\u6709\u6240\u4e0d\u540c\u3002\u6211\u4eec\u73b0\u5728\u5c06\u5176\u6574\u5408\u5230\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\u3002\u4ece initVulkan \u4e2d\u6dfb\u52a0\u4e00\u4e2a\u51fd\u6570 createSurface ,\u5b89\u6392\u5728 createInstnace \u548c setupDebugCallback \u51fd\u6570\u4e4b\u540e\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); } void createSurface() { } C++ GLFW \u6ca1\u6709\u4f7f\u7528\u7ed3\u6784\u4f53\uff0c\u800c\u662f\u9009\u62e9\u975e\u5e38\u76f4\u63a5\u7684\u53c2\u6570\u4f20\u9012\u6765\u8c03\u7528\u51fd\u6570\u3002 void createSurface() { if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) { throw std::runtime_error(\"failed to create window surface!\"); } } C++ \u53c2\u6570\u662f VkInstance , GLFW \u7a97\u4f53\u7684\u6307\u9488\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u7528\u4e8e\u5b58\u50a8 VkSurfaceKHR \u53d8\u91cf\u7684\u6307\u9488\u3002\u5bf9\u4e8e\u4e0d\u540c\u5e73\u53f0\u7edf\u4e00\u8fd4\u56de VkResult \u3002 GLFW \u6ca1\u6709\u63d0\u4f9b\u4e13\u7528\u7684\u51fd\u6570\u9500\u6bc1 surface ,\u4f46\u662f\u53ef\u4ee5\u7b80\u5355\u7684\u901a\u8fc7 Vulkan \u539f\u59cb\u7684 API \u5b8c\u6210: void cleanup() { ... vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); ... } C++ \u6700\u540e\u8bf7\u786e\u4fddsurface\u7684\u6e05\u7406\u662f\u5728instance\u9500\u6bc1\u4e4b\u524d\u5b8c\u6210\u3002 \u67e5\u8be2\u6f14\u793a\u652f\u6301 \u867d\u7136 Vulkan \u7684\u5b9e\u73b0\u652f\u6301\u7a97\u4f53\u96c6\u6210\u529f\u80fd\uff0c\u4f46\u662f\u5e76\u4e0d\u610f\u5473\u7740\u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u90fd\u652f\u6301\u5b83\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u6269\u5c55 isDeviceSuitable \u51fd\u6570\uff0c\u786e\u4fdd\u8bbe\u5907\u53ef\u4ee5\u5c06\u56fe\u50cf\u5448\u73b0\u5230\u6211\u4eec\u521b\u5efa\u7684 surface \u3002\u7531\u4e8e presentation \u662f\u4e00\u4e2a\u961f\u5217\u7684\u7279\u6027\u529f\u80fd\uff0c\u56e0\u6b64\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6cd5\u5c31\u662f\u627e\u5230\u652f\u6301 presentation \u7684\u961f\u5217\u7c07\uff0c\u6700\u7ec8\u83b7\u53d6\u961f\u5217\u6ee1\u8db3 surface \u521b\u5efa\u7684\u9700\u8981\u3002 \u5b9e\u9645\u60c5\u51b5\u662f\uff0c\u652f\u6301 graphics \u547d\u4ee4\u7684\u7684\u961f\u5217\u7c07\u548c\u652f\u6301 presentation \u547d\u4ee4\u7684\u961f\u5217\u7c07\u53ef\u80fd\u4e0d\u662f\u540c\u4e00\u4e2a\u7c07\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u4fee\u6539 QueueFamilyIndices \u7ed3\u6784\u4f53\uff0c\u4ee5\u652f\u6301\u5dee\u5f02\u5316\u7684\u5b58\u50a8\u3002 struct QueueFamilyIndices { int graphicsFamily = -1; int presentFamily = -1; bool isComplete() { return graphicsFamily >= 0 && presentFamily >= 0; } }; C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4fee\u6539 findQueueFamilies \u51fd\u6570\u6765\u67e5\u627e\u5177\u5907 presentation \u529f\u80fd\u7684\u961f\u5217\u7c07\u3002\u51fd\u6570\u4e2d\u7528\u4e8e\u68c0\u67e5\u7684\u6838\u5fc3\u4ee3\u7801\u662f vkGetPhysicalDeviceSurfaceSupportKHR ,\u5b83\u5c06\u7269\u7406\u8bbe\u5907\u3001\u961f\u5217\u7c07\u7d22\u5f15\u548c surface \u4f5c\u4e3a\u53c2\u6570\u3002\u5728 VK_QUEUE_GRAPHICS_BIT \u76f8\u540c\u7684\u5faa\u73af\u4f53\u4e2d\u6dfb\u52a0\u51fd\u6570\u7684\u8c03\u7528: VkBool32 presentSupport = false; vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport); C++ \u7136\u540e\u4e4b\u9700\u8981\u68c0\u67e5\u5e03\u5c14\u503c\u5e76\u5b58\u50a8 presentation \u961f\u5217\u7c07\u7684\u7d22\u5f15: if (queueFamily.queueCount > 0 && presentSupport) { indices.presentFamily = i; } C++ \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e3a\u4e86\u652f\u6301 graphics \u548c presentation \u529f\u80fd\uff0c\u6211\u4eec\u5b9e\u9645\u73af\u5883\u4e2d\u5f97\u5230\u7684\u53ef\u80fd\u662f\u540c\u4e00\u4e2a\u961f\u5217\u7c07\uff0c\u4e5f\u53ef\u80fd\u4e0d\u540c\uff0c\u4e3a\u6b64\u5728\u6211\u4eec\u7684\u7a0b\u5e8f\u6570\u636e\u7ed3\u6784\u53ca\u9009\u62e9\u903b\u8f91\u4e2d\uff0c\u5c06\u6309\u7167\u5747\u6765\u81ea\u4e0d\u540c\u7684\u961f\u5217\u7c07\u5206\u522b\u5904\u7406\uff0c\u8fd9\u6837\u4fbf\u53ef\u4ee5\u7edf\u4e00\u5904\u7406\u4ee5\u4e0a\u4e24\u79cd\u60c5\u51b5\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u51fa\u4e8e\u6027\u80fd\u7684\u8003\u8651\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u903b\u8f91\u660e\u786e\u7684\u6307\u5b9a\u7269\u7406\u8bbe\u5907\u6240\u4f7f\u7528\u7684 graphics \u548c presentation \u529f\u80fd\u6765\u81ea\u540c\u4e00\u4e2a\u961f\u5217\u7c07\u3002 \u521b\u5efa\u6f14\u793a\u961f\u5217 \u5269\u4e0b\u7684\u4e8b\u60c5\u662f\u4fee\u6539\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u8fc7\u7a0b\uff0c\u5728\u4e8e\u521b\u5efa presentation \u961f\u5217\u5e76\u83b7\u53d6 VkQueue \u7684\u53e5\u67c4\u3002\u6dfb\u52a0\u4fdd\u5b58\u961f\u5217\u53e5\u67c4\u7684\u6210\u5458\u53d8\u91cf: VkQueue presentQueue; C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u591a\u4e2a VkDeviceQueueCreateInfo \u7ed3\u6784\u6765\u521b\u5efa\u4e0d\u540c\u529f\u80fd\u7684\u961f\u5217\u3002\u4e00\u4e2a\u4f18\u96c5\u7684\u65b9\u5f0f\u662f\u9488\u5bf9\u4e0d\u540c\u529f\u80fd\u7684\u961f\u5217\u7c07\u521b\u5efa\u4e00\u4e2aset\u96c6\u5408\u786e\u4fdd\u961f\u5217\u7c07\u7684\u552f\u4e00\u6027: #include <set> ... QueueFamilyIndices indices = findQueueFamilies(physicalDevice); std::vector<VkDeviceQueueCreateInfo> queueCreateInfos; std::set<int> uniqueQueueFamilies = {indices.graphicsFamily, indices.presentFamily}; float queuePriority = 1.0f; for (int queueFamily : uniqueQueueFamilies) { VkDeviceQueueCreateInfo queueCreateInfo = {}; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = queueFamily; queueCreateInfo.queueCount = 1; queueCreateInfo.pQueuePriorities = &queuePriority; queueCreateInfos.push_back(queueCreateInfo); } C++ \u540c\u65f6\u8fd8\u8981\u4fee\u6539 VkDeviceCreateInfo \u6307\u5411\u961f\u5217\u96c6\u5408: createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size()); createInfo.pQueueCreateInfos = queueCreateInfos.data(); C++ \u5982\u679c\u961f\u5217\u7c07\u76f8\u540c\uff0c\u90a3\u4e48\u6211\u4eec\u4e4b\u9700\u8981\u4f20\u9012\u4e00\u6b21\u7d22\u5f15\u3002\u6700\u540e\uff0c\u6dfb\u52a0\u4e00\u4e2a\u8c03\u7528\u68c0\u7d22\u961f\u5217\u53e5\u67c4: vkGetDeviceQueue(device, indices.presentFamily, 0, &presentQueue); C++ \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u961f\u5217\u7c07\u662f\u76f8\u540c\u7684\uff0c\u4e24\u4e2a\u53e5\u67c4\u53ef\u80fd\u4f1a\u6709\u76f8\u540c\u7684\u503c\u3002\u5728 \u4e0b\u4e00\u4e2a\u7ae0\u8282 \u4e2d\u6211\u4eec\u4f1a\u770b\u770b\u4ea4\u6362\u94fe\uff0c\u4ee5\u53ca\u5b83\u4eec\u5982\u4f55\u4f7f\u6211\u4eec\u80fd\u591f\u5c06\u56fe\u50cf\u5448\u73b0\u7ed9 surface \u3002 Vulkan \u56fe\u5f62\u7ba1\u7ebf Vulkan \u56fe\u5f62\u7ba1\u7ebf \uff0c\u901a\u8fc7\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\uff0c\u6211\u4eec\u5c06\u4f1a\u5f00\u542f\u6709\u5173\u56fe\u5f62\u7ba1\u7ebf\u7684\u8bdd\u9898\uff0c\u901a\u8fc7\u5bf9\u56fe\u5f62\u6e32\u67d3\u7ba1\u7ebf\u7684\u914d\u7f6e\u5b8c\u6210\u6700\u540e\u7684\u4e09\u89d2\u5f62\u7ed8\u753b\u3002\u6240\u8c13\u56fe\u5f62\u7ba1\u7ebf\u5c31\u662f\u5c06 mesh \u4f7f\u7528\u5230\u7684 vertices \u5b9a\u70b9\u6570\u636e\u548c\u8d34\u56fe\u6570\u636e\uff0c\u8f6c\u5316\u4e3a\u6e32\u67d3 targets \u50cf\u7d20\u7684\u64cd\u4f5c\u5e8f\u5217\u3002\u7b80\u8981\u7684\u6982\u8ff0\u5982\u4e0b\u56fe\u6240\u793a: Input assembler \u6536\u96c6\u6700\u539f\u59cb\u7684\u9876\u70b9\u6570\u636e\uff0c\u5e76\u4e14\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7d22\u5f15\u7f13\u51b2\u533a\u590d\u7528\u8fd9\u4e9b\u6570\u636e\u5143\u7d20\uff0c\u800c\u4e0d\u5fc5\u590d\u5236\u5197\u4f59\u7684\u9876\u70b9\u6570\u636e\u526f\u672c\u3002 vertex shader \u4f1a\u5e94\u7528\u5728\u6bcf\u4e00\u4e2a\u9876\u70b9\u6570\u636e\uff0c\u901a\u5e38\u5e94\u7528\u53d8\u6362\u64cd\u4f5c\uff0c\u4ece\u800c\u5c06\u9876\u70b9\u7684\u4f4d\u7f6e\u5750\u6807\u6570\u636e\u4ece\u6a21\u578b\u7a7a\u95f4\u8f6c\u6362\u4e3a\u5c4f\u5e55\u7a7a\u95f4\u3002\u5728\u5904\u7406\u5b8c\u6bd5\u4e4b\u540e\u4f1a\u5c06\u6570\u636e\u7ee7\u7eed\u5728\u7ba1\u7ebf\u4f20\u9012\u4e0b\u53bb\u3002 tessellation shader \u66f2\u9762\u7740\u8272\u5668\u5141\u8bb8\u57fa\u4e8e\u67d0\u4e9b\u89c4\u5219\u8fdb\u4e00\u6b65\u7ec6\u5206\u51e0\u4f55\u6570\u636e\u589e\u52a0\u7f51\u683c\u7684\u8d28\u91cf\u3002\u7ecf\u5e38\u5e94\u7528\u4e0e\u5899\u9762\u548c\u697c\u68af\u8868\u9762\uff0c\u4f7f\u9644\u8fd1\u770b\u8d77\u6765\u4e0d\u662f\u90a3\u4e48\u5e73\u5766\u3002 geometry shader \u96c6\u5408\u7740\u8272\u5668\u5e94\u7528\u5728\u6bcf\u4e00\u4e2a\u56fe\u5143\u4e0a\uff0c\u53ef\u7528\u4e8e\u589e\u51cf\u56fe\u5143\uff0c\u5b83\u4e0e\u66f2\u9762\u7740\u8272\u5668\u7c7b\u4f3c\uff0c\u4f46\u66f4\u52a0\u7075\u6d3b\u3002\u7136\u800c\uff0c\u5b83\u5728\u4eca\u5929\u7684\u5e94\u7528\u4e2d\u5e76\u6ca1\u6709\u592a\u591a\u7684\u5e94\u7528\u60c5\u666f\uff0c\u56e0\u4e3a\u9664\u4e86 Intel \u7684\u96c6\u6210\u663e\u5361\u5916\uff0c\u5927\u591a\u6570\u663e\u5361\u6027\u80fd\u652f\u6301\u90fd\u4e0d\u7406\u60f3\u3002 \u5149\u6805\u5316\u9636\u6bb5\u5c06\u56fe\u5143\u5206\u89e3\u4e3a\u7247\u5143\u3002\u8fd9\u4e9b\u662f\u586b\u5145\u5728\u5e27\u7f13\u51b2\u533a\u4e0a\u7684\u50cf\u7d20\u5143\u7d20\u3002\u5c4f\u5e55\u5916\u533a\u57df\u7684\u7247\u5143\u4f1a\u88ab\u4e22\u5f03\uff0c\u9876\u70b9\u7740\u8272\u5668\u8f93\u51fa\u7684\u6570\u636e\u5728\u4f20\u9012\u5230\u7247\u5143\u7740\u8272\u5668\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u5982\u56fe\u6240\u793a\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u6839\u636e\u6df1\u5ea6\u6d4b\u8bd5\u7684\u7ed3\u679c\u4e5f\u4f1a\u5bf9\u7247\u5143\u8fdb\u884c\u4e22\u5f03\u3002 fragment shader \u5e94\u7528\u4e8e\u6bcf\u4e2a\u7247\u5143\uff0c\u786e\u5b9a\u6bcf\u4e2a\u5e27\u7f13\u51b2\u533a\u4e2d\u5199\u5165\u7684\u7247\u5143\u6570\u636e\u7684\u989c\u8272\u548c\u6df1\u5ea6\u503c\u3002\u7247\u5143\u7740\u8272\u5668\u53ef\u4ee5\u4f7f\u7528\u9876\u70b9\u7740\u8272\u5668\u7684\u63d2\u503c\u6570\u636e\uff0c\u8d34\u56fe\u7684UV\u5750\u6807\u548c\u5149\u6e90\u6cd5\u7ebf\u6570\u636e\u3002 \u6df7\u8272\u64cd\u4f5c\u9636\u6bb5\u4f1a\u5bf9\u4e0d\u540c\u7247\u5143\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\uff0c\u6700\u7ec8\u6620\u5c04\u5230\u5e27\u7f13\u51b2\u533a\u7684\u540c\u4e00\u4e2a\u50cf\u7d20\u4e0a\u3002\u7247\u5143\u4e5f\u53ef\u4ee5\u7b80\u5355\u7684\u4e92\u76f8\u91cd\u5199\uff0c\u53e0\u52a0\u6216\u8005\u6839\u636e\u900f\u660e\u5ea6\u6df7\u5408\u3002 \u7eff\u8272\u7684\u9636\u6bb5\u88ab\u79f0\u4e3a\u56fa\u5b9a\u6d41\u6c34\u7ebf\u3002\u8fd9\u4e2a\u9636\u6bb5\u5141\u8bb8\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684\u53c2\u6570\u6570\u503c\uff0c\u4f46\u662f\u5b83\u5185\u90e8\u7684\u5de5\u4f5c\u903b\u8f91\u662f\u9884\u5236\u597d\u7684\u3002 \u6a59\u8272\u7684\u9636\u6bb5\u88ab\u79f0\u4e3a\u53ef\u7f16\u7a0b\u9636\u6bb5 programmable \uff0c\u6211\u4eec\u53ef\u4ee5\u5411GPU\u63d0\u4ea4\u81ea\u5df1\u7f16\u5199\u7684\u4ee3\u7801\u6267\u884c\u5177\u4f53\u7684\u903b\u8f91\u3002\u6bd4\u5982\u5728\u4f7f\u7528 fragment shader \u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u5b9e\u73b0\u4efb\u4f55\u4ece\u8d34\u56fe\u5230\u706f\u5149\u7684\u5149\u7ebf\u8ffd\u8e2a\u3002\u8fd9\u4e9b\u7a0b\u5e8f\u540c\u65f6\u8fd0\u884c\u5728\u591a\u6838GPU\u4e0a\u5904\u7406\u8bb8\u591a\u5bf9\u8c61\uff0c\u6bd4\u5982\u5e76\u884c\u7684\u9876\u70b9\u548c\u7247\u6bb5\u7a0b\u5e8f\u3002 \u5982\u679c\u4e4b\u524d\u4f7f\u7528\u8fc7\u65e7\u7684API( OpenGL \u548c Direct3D ),\u90a3\u4e48\u5c06\u53ef\u4ee5\u968f\u610f\u901a\u8fc7 glBlendFunc \u548c OMSetBlendState \u8c03\u7528\u66f4\u6539\u7ba1\u7ebf\u8bbe\u7f6e\u3002 Vulkan\u4e2d \u7684\u56fe\u5f62\u7ba1\u7ebf\u51e0\u4e4e\u4e0d\u53ef\u6539\u53d8\uff0c\u56e0\u6b64\u5982\u679c\u9700\u8981\u66f4\u6539\u7740\u8272\u5668\uff0c\u7ed1\u5b9a\u5230\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u533a\u6216\u8005\u66f4\u6539\u6df7\u5408\u51fd\u6570\uff0c\u5219\u5fc5\u987b\u4ece\u5934\u521b\u5efa\u7ba1\u7ebf\u3002\u7f3a\u70b9\u662f\u5fc5\u987b\u521b\u5efa\u4e00\u4e9b\u7ba1\u7ebf\uff0c\u8fd9\u4e9b\u7ba1\u7ebf\u4ee3\u8868\u5728\u6e32\u67d3\u64cd\u4f5c\u4e2d\u4f7f\u7528\u7684\u4e0d\u540c\u7684\u7ec4\u5408\u72b6\u6001\u3002\u4f46\u662f\u7531\u4e8e\u6240\u6709\u7ba1\u7ebf\u7684\u64cd\u4f5c\u90fd\u662f\u63d0\u524d\u77e5\u9053\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7\u9a71\u52a8\u7a0b\u5e8f\u66f4\u597d\u7684\u4f18\u5316\u5b83\u3002 \u4e00\u4e9b\u53ef\u7f16\u7a0b\u9636\u6bb5\u662f\u57fa\u4e8e\u6253\u7b97\u505a\u4ec0\u4e48\u800c\u51b3\u5b9a\u7684\u3002\u6bd4\u5982\uff0c\u5982\u679c\u53ea\u662f\u7b80\u5355\u7684\u7ed8\u5236\u51e0\u4f55\u56fe\u5f62\uff0c\u5219\u53ef\u4ee5\u7981\u7528 tessellation \u548c geometry \u7740\u8272\u5668\u3002\u5982\u679c\u53ea\u5bf9\u6df1\u5ea6\u503c\u611f\u5174\u8da3\uff0c\u5219\u53ef\u4ee5\u7981\u7528 fragment \u7740\u8272\u5668\uff0c\u8fd9\u5bf9\u4e8e\u751f\u6210 shadow map \u751f\u6210\u5f88\u6709\u7528\u3002 \u5728\u4e0b\u4e00\u4e2a\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u9996\u5148\u521b\u5efa\u5c06\u4e09\u89d2\u5f62\u653e\u5728\u5c4f\u5e55\u4e0a\u6240\u9700\u8981\u7684\u4e24\u4e2a\u53ef\u7f16\u7a0b\u9636\u6bb5: vertice shader \u548c fragment shader \u3002\u56fa\u5b9a\u529f\u80fd\u7684\u8bbe\u7f6e\u5305\u62ec blending mode , viewport , rasterization \u5c06\u5728\u4e4b\u540e\u7684\u7ae0\u8282\u4e2d\u8bbe\u7f6e\u3002\u5728 Vulkan \u4e2d\u8bbe\u7f6e\u56fe\u5f62\u6d41\u6c34\u7ebf\u7684\u6700\u540e\u4e00\u90e8\u5206\u5185\u5bb9\u6d89\u53ca\u8f93\u5165\u548c\u8f93\u51fa\u5e27\u7f13\u51b2\u533a\u3002 \u5728 initVulkan \u4e2d\u521b\u5efa\u51fd\u6570 createGraphicsPipeline \u5e76\u5728 createImageViews \u540e\u7acb\u5373\u8c03\u7528\u3002\u6211\u4eec\u5728\u4e0b\u4e00\u7ae0\u8282\u4ecb\u7ecd\u51fd\u6570\u529f\u80fd\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createGraphicsPipeline(); } ... void createGraphicsPipeline() { } C++ \u5728\u7ed3\u5c3e\u5904\u5206\u4eab\u4e00\u4e0b Vulkan \u5b98\u65b9\u7684\u56fe\u5f62\u7ba1\u7ebf\u7ed3\u6784\u56fe\uff0c\u5982\u4e0b: Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe \uff0c\u4f7f\u7528\u4efb\u4f55\u7684 VkImage \uff0c\u5305\u62ec\u5728\u4ea4\u6362\u94fe\u6216\u8005\u6e32\u67d3\u7ba1\u7ebf\u4e2d\u7684\uff0c\u6211\u4eec\u90fd\u9700\u8981\u521b\u5efa VkImageView \u5bf9\u8c61\u3002\u4ece\u5b57\u9762\u4e0a\u7406\u89e3\u5b83\u5c31\u662f\u4e00\u4e2a\u9488\u5bf9\u56fe\u50cf\u7684\u89c6\u56fe\u6216\u5bb9\u5668\uff0c\u901a\u8fc7\u5b83\u5177\u4f53\u7684\u6e32\u67d3\u7ba1\u7ebf\u624d\u80fd\u591f\u8bfb\u5199\u6e32\u67d3\u6570\u636e\uff0c\u6362\u53e5\u8bdd\u8bf4 VkImage \u4e0d\u80fd\u4e0e\u6e32\u67d3\u7ba1\u7ebf\u8fdb\u884c\u4ea4\u4e92\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u56fe\u50cf\u89c6\u56fe\u53ef\u4ee5\u8fdb\u4e00\u6b65\u5b9a\u4e49\u5177\u4f53 Image \u7684\u683c\u5f0f\uff0c\u6bd4\u5982\u5b9a\u4e49\u4e3a2D\u8d34\u56fe\uff0c\u90a3\u4e48\u672c\u8d28\u4e0a\u5c31\u4e0d\u9700\u8981\u4efb\u4f55\u7ea7\u522b\u7684 mipmapping \u3002 \u5728\u672c\u7ae0\u8282\u6211\u4eec\u4f1a\u65b0\u589e\u4e00\u4e2a createImageViews \u51fd\u6570\uff0c\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u521b\u5efa\u57fa\u672c\u7684\u89c6\u56fe\uff0c\u8fd9\u4e9b\u89c6\u56fe\u5728\u540e\u9762\u7684\u5185\u5bb9\u4e2d\u4f1a\u88ab\u4f5c\u4e3a\u989c\u8272\u76ee\u6807\u4e0e\u6e32\u67d3\u7ba1\u7ebf\u914d\u5408\u4f7f\u7528\u3002 \u9996\u5148\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u7528\u4e8e\u4fdd\u5b58\u56fe\u50cf\u89c6\u56fe\u7684\u53e5\u67c4\u96c6: std::vector<VkImageView> swapChainImageViews; C++ \u521b\u5efa createImagesViews \u51fd\u6570\uff0c\u5e76\u5728\u521b\u5efa\u4ea4\u6362\u94fe\u5b8c\u6210\u4e4b\u540e\u8c03\u7528: void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); } void createImageViews() { } C++ \u6211\u4eec\u9700\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u9700\u8981\u5b9a\u4e49\u4fdd\u5b58\u56fe\u50cf\u89c6\u56fe\u96c6\u5408\u7684\u5927\u5c0f: void createImageViews() { swapChainImageViews.resize(swapChainImages.size()); } C++ \u4e0b\u4e00\u6b65\uff0c\u5faa\u73af\u8fed\u4ee3\u6240\u6709\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u3002 for (size_t i = 0; i < swapChainImages.size(); i++) { } C++ \u521b\u5efa\u56fe\u50cf\u89c6\u56fe\u7684\u53c2\u6570\u88ab\u5b9a\u4e49\u5728 VkImageViewCreateInfo \u7ed3\u6784\u4f53\u4e2d\u3002\u524d\u51e0\u4e2a\u53c2\u6570\u7684\u586b\u5145\u975e\u5e38\u7b80\u5355\u3001\u76f4\u63a5\u3002 VkImageViewCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; createInfo.image = swapChainImages[i]; C++ \u5176\u4e2d viewType \u548c format \u5b57\u6bb5\u7528\u4e8e\u63cf\u8ff0\u56fe\u50cf\u6570\u636e\u8be5\u88ab\u5982\u4f55\u89e3\u91ca\u3002 viewType \u53c2\u6570\u5141\u8bb8\u5c06\u56fe\u50cf\u5b9a\u4e49\u4e3a 1D textures , 2D textures , 3D textures \u548c cube maps \u3002 createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; createInfo.format = swapChainImageFormat; C++ components \u5b57\u6bb5\u5141\u8bb8\u8c03\u6574\u989c\u8272\u901a\u9053\u7684\u6700\u7ec8\u7684\u6620\u5c04\u903b\u8f91\u3002\u6bd4\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6240\u6709\u989c\u8272\u901a\u9053\u6620\u5c04\u4e3a\u7ea2\u8272\u901a\u9053\uff0c\u4ee5\u5b9e\u73b0\u5355\u8272\u7eb9\u7406\u3002\u6211\u4eec\u4e5f\u53ef\u4ee5\u5c06\u901a\u9053\u6620\u5c04\u5177\u4f53\u7684\u5e38\u91cf\u6570\u503c 0 \u548c 1 \u3002\u5728\u7ae0\u8282\u4e2d\u6211\u4eec\u4f7f\u7528\u9ed8\u8ba4\u7684\u6620\u5c04\u7b56\u7565\u3002 createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY; C++ subresourceRangle \u5b57\u6bb5\u7528\u4e8e\u63cf\u8ff0\u56fe\u50cf\u7684\u4f7f\u7528\u76ee\u6807\u662f\u4ec0\u4e48\uff0c\u4ee5\u53ca\u53ef\u4ee5\u88ab\u8bbf\u95ee\u7684\u6709\u6548\u533a\u57df\u3002\u6211\u4eec\u7684\u56fe\u50cf\u5c06\u4f1a\u4f5c\u4e3a color targets \uff0c\u6ca1\u6709\u4efb\u4f55 mipmapping levels \u6216\u662f\u591a\u5c42 multiple layers \u3002 createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; createInfo.subresourceRange.baseMipLevel = 0; createInfo.subresourceRange.levelCount = 1; createInfo.subresourceRange.baseArrayLayer = 0; createInfo.subresourceRange.layerCount = 1; C++ \u5982\u679c\u5728\u7f16\u5199\u6c89\u6d78\u5f0f\u7684 3D \u5e94\u7528\u7a0b\u5e8f\uff0c\u6bd4\u5982 VR \uff0c\u5c31\u9700\u8981\u521b\u5efa\u652f\u6301\u591a\u5c42\u7684\u4ea4\u6362\u94fe\u3002\u5e76\u4e14\u901a\u8fc7\u4e0d\u540c\u7684\u5c42\u4e3a\u6bcf\u4e00\u4e2a\u56fe\u50cf\u521b\u5efa\u591a\u4e2a\u89c6\u56fe\uff0c\u4ee5\u6ee1\u8db3\u4e0d\u540c\u5c42\u7684\u56fe\u50cf\u5728\u5de6\u53f3\u773c\u6e32\u67d3\u65f6\u5bf9\u89c6\u56fe\u7684\u9700\u8981\u3002 \u521b\u5efa\u56fe\u50cf\u89c6\u56fe\u8c03\u7528 vkCreateImageView \u51fd\u6570: if (vkCreateImageView(device, &createInfo, nullptr, &swapChainImageViews[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to create image views!\"); } C++ \u4e0e\u56fe\u50cf\u4e0d\u540c\u7684\u662f\uff0c\u56fe\u50cf\u89c6\u56fe\u9700\u8981\u660e\u786e\u7684\u521b\u5efa\u8fc7\u7a0b\uff0c\u6240\u4ee5\u5728\u7a0b\u5e8f\u9000\u51fa\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a\u5faa\u73af\u53bb\u9500\u6bc1\u4ed6\u4eec\u3002 void cleanup() { for (size_t i = 0; i < swapChainImageViews.size(); i++) { vkDestroyImageView(device, swapChainImageViews[i], nullptr); } ... } C++ \u62e5\u6709\u4e86\u56fe\u50cf\u89c6\u56fe\u540e\uff0c\u4f7f\u7528\u56fe\u50cf\u4f5c\u4e3a\u8d34\u56fe\u5df2\u7ecf\u8db3\u591f\u4e86\uff0c\u4f46\u662f\u5b83\u8fd8\u6ca1\u6709\u51c6\u5907\u597d\u4f5c\u4e3a\u6e32\u67d3\u7684 target \u3002\u5b83\u9700\u8981\u66f4\u591a\u7684\u95f4\u63a5\u6b65\u9aa4\u53bb\u51c6\u5907\uff0c\u5176\u4e2d\u4e00\u4e2a\u5c31\u662f framebuffer \uff0c\u88ab\u79f0\u4f5c\u5e27\u7f13\u51b2\u533a\u3002\u4f46\u9996\u5148\u6211\u4eec\u8981\u8bbe\u7f6e\u56fe\u5f62\u7ba1\u7ebf\u3002 Vulkan \u7740\u8272\u5668\u6a21\u5757 Vulkan \u7740\u8272\u5668\u6a21\u5757 \uff0c\u4e0e\u4e4b\u524d\u7684\u56fe\u50cf API \u4e0d\u540c\uff0c Vulkan \u4e2d\u7684\u7740\u8272\u5668\u4ee3\u7801\u5fc5\u987b\u4ee5\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u7684\u683c\u5f0f\u4f7f\u7528\uff0c\u800c\u4e0d\u662f\u50cf GLSL \u548c HLSL \u8fd9\u6837\u5177\u6709\u6bd4\u8f83\u597d\u7684\u53ef\u8bfb\u6027\u7684\u8bed\u6cd5\u3002\u6b64\u5b57\u8282\u683c\u5f0f\u6210\u4e3a SPIR-V \uff0c\u5b83\u53ef\u4ee5\u4e0e Vulkan \u548c OpenCL \u4e00\u540c\u4f7f\u7528\u3002\u8fd9\u662f\u4e00\u79cd\u53ef\u4ee5\u7f16\u5199\u56fe\u5f62\u548c\u8ba1\u7b97\u7740\u8272\u5668\u7684\u683c\u5f0f\uff0c\u4f46\u6211\u4eec\u91cd\u70b9\u4ecb\u7ecd\u672c\u6559\u7a0b\u4e2d Vulkan \u56fe\u5f62\u6d41\u6c34\u7ebf\u4f7f\u7528\u7684\u7740\u8272\u5668\u3002 \u4f7f\u7528\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u683c\u5f0f\u7684\u4f18\u70b9\u4e4b\u4e00\u662f \u4f7f\u5f97 GPU \u5382\u5546\u7f16\u5199\u5c06\u7740\u8272\u5668\u4ee3\u7801\u8f6c\u6362\u4e3a\u672c\u5730\u4ee3\u7801\u7684\u7f16\u8bd1\u5668\u590d\u6742\u5ea6\u51cf\u5c11\u4e86\u5f88\u591a\u3002\u7ecf\u9a8c\u8868\u660e\u4f7f\u7528\u53ef\u8bfb\u6027\u6bd4\u8f83\u5f3a\u7684\u8bed\u6cd5\uff0c\u6bd4\u5982 GLSL \u4e00\u4e9b GPU \u5382\u5546\u76f8\u5f53\u7075\u6d3b\u5730\u7406\u89e3\u8fd9\u4e2a\u6807\u51c6\u3002\u8fd9\u5bfc\u81f4\u4e00\u79cd\u60c5\u51b5\u4f1a\u53d1\u751f\uff0c\u6bd4\u5982\u7f16\u5199\u597d\uff0c\u5e76\u5728\u4e00\u4e2a\u5382\u5546\u7684 GPU \u8fd0\u884c\u7684\u4e0d\u9519\u7684\u7740\u8272\u5668\u7a0b\u5e8f\uff0c\u53ef\u80fd\u5728\u5176\u4ed6\u7684 GPU \u5382\u5546\u7684 GPU \u9a71\u52a8\u7a0b\u5e8f\u8fd0\u884c\u5f02\u5e38\uff0c\u53ef\u80fd\u662f\u8bed\u6cd5\u7684\u95ee\u9898\uff0c\u6216\u8005\u66f4\u7cdf\u7684\u662f\u4e0d\u540c GPU \u5382\u5546\u7f16\u5199\u7684\u7f16\u8bd1\u5668\u5dee\u5f02\uff0c\u5bfc\u81f4\u7740\u8272\u5668\u8fd0\u884c\u9519\u8bef\u3002\u5982\u679c\u76f4\u63a5\u4f7f\u7528\u7f16\u8bd1\u597d\u7684\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u683c\u5f0f\uff0c\u53ef\u4ee5\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\u3002 \u4f46\u662f\uff0c\u5e76\u4e0d\u610f\u5473\u7740\u6211\u4eec\u8981\u624b\u5199\u5b57\u8282\u7801\u3002 Khronos \u53d1\u5e03\u4e86\u4e0e\u5382\u5546\u65e0\u5173\u7684\u7f16\u8bd1\u5668\uff0c\u5b83\u5c06 GLSL \u7f16\u8bd1\u6210 SPIR-V \u3002\u8be5\u7f16\u8bd1\u5668\u7528\u4e8e\u9a8c\u8bc1\u7740\u8272\u5668\u4ee3\u7801\u662f\u5426\u7b26\u5408\u6807\u51c6\uff0c\u5e76\u751f\u6210\u4e0e Vulkan \u529f\u80fd\u8fd0\u884c\u7684 SPRIR-V \u4e8c\u8fdb\u5236\u6587\u4ef6\u3002\u9664\u6b64\u4e4b\u5916\u8fd8\u53ef\u4ee5\u5c06\u6b64\u7f16\u8bd1\u5668\u4f5c\u4e3a\u5e93\u5728\u8fd0\u884c\u65f6\u7f16\u8bd1\u751f\u6210 SPRI-V \uff0c\u4f46\u5728\u672c\u6559\u7a0b\u4e2d\u4e0d\u4f1a\u8fd9\u6837\u64cd\u4f5c\u3002\u7f16\u8bd1\u5668 glslangValidator.exe \u5305\u542b\u5728 LunarG SDK \u4e2d\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u4e0b\u8f7d\u4efb\u4f55\u989d\u5916\u7684\u5185\u5bb9\u3002 GLSL \u662f\u5177\u6709C\u98ce\u683c\u8bed\u6cd5\u7684\u7740\u8272\u8bed\u8a00\u3002\u5728\u7a0b\u5e8f\u4e2d\u9700\u8981\u5b9a\u4e49\u7f16\u5199 main \u51fd\u6570\u4f5c\u4e3a\u5165\u53e3\u3002 GLSL \u4e0d\u4f1a\u4f7f\u7528\u8f93\u5165\u53c2\u6570\u548c\u8fd4\u56de\u503c\u4f5c\u4e3a\u8f93\u51fa\uff0c\u800c\u662f\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\u6765\u5904\u7406\u8f93\u5165\u548c\u8f93\u51fa\u3002\u8be5\u8bed\u8a00\u5305\u62ec\u5f88\u591a\u529f\u80fd\u7b80\u5316\u56fe\u5f62\u7f16\u7a0b\uff0c\u6bd4\u5982\u5185\u7f6e\u7684\u57fa\u4e8e\u5411\u91cf\u548c\u77e9\u9635\u7684\u53c9\u79ef\u64cd\u4f5c\u51fd\u6570\uff0c\u77e9\u9635\u548c\u77e2\u91cf\u4e58\u6cd5\u64cd\u4f5c\u51fd\u6570\u3002\u77e2\u91cf\u7c7b\u578b\u4e3a vec \uff0c\u6570\u5b57\u8868\u793a\u5206\u91cf\u7684\u6570\u91cf\u3002\u4f8b\u59823D\u4f4d\u7f6e\u5b58\u50a8\u5728 vec3 \u4e2d\u3002\u53ef\u4ee5\u901a\u8fc7\u8bf8\u5982 .x \u4e4b\u7c7b\u7684\u6210\u5458\u8bbf\u95ee\u5355\u4e2a\u5206\u91cf\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u591a\u4e2a\u5206\u91cf\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5411\u91cf\u3002\u6bd4\u5982\uff0c\u8868\u8fbe\u5f0f vec3(1.0, 2.0, 3.0).xy \u622a\u53d6\u524d\u4e24\u4e2a\u5206\u91cf\uff0c\u5e76\u8d4b\u4e88\u65b0\u7684 vec2 \u4e2d\u3002\u5411\u91cf\u7684\u6784\u9020\u51fd\u6570\u4e5f\u53ef\u4ee5\u91c7\u7528\u77e2\u91cf\u5bf9\u8c61\u548c\u6807\u91cf\u503c\u7684\u7ec4\u5408\u3002\u6bd4\u5982 vec3 \u53ef\u4ee5\u7528 vec3(vec2(1.0, 2.0), 3.0) \u6784\u9020\u3002 \u5982\u524d\u9762\u63d0\u5230\u7684\u4e00\u6837\uff0c\u6211\u4eec\u9700\u8981\u7f16\u5199\u4e00\u4e2a vertex shader \u548c\u4e00\u4e2a fragment shader \u7ed8\u5236\u4e09\u89d2\u5f62\u5728\u5c4f\u5e55\u3002\u4e0b\u9762\u4e24\u4e2a\u5c0f\u8282\u4f1a\u63a2\u8ba8\u4e0e\u4e4b\u76f8\u5173\u7684 GLSL \u4ee3\u7801\uff0c\u5e76\u5c55\u793a\u5982\u4f55\u751f\u6210\u4e24\u4e2a SPIR-V \u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u6700\u540e\u52a0\u8f7d\u5230\u7a0b\u5e8f\u4e2d\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9876\u70b9\u7740\u8272\u5668 2 \u7247\u5143\u7740\u8272\u5668 3 \u9876\u70b9\u989c\u8272\u7ec4 4 \u7f16\u8bd1\u7740\u8272\u5668 5 \u52a0\u8f7d\u7740\u8272\u5668 6 \u521b\u5efa\u7740\u8272\u5668\u6a21\u578b 7 \u7740\u8272\u5668\u9636\u6bb5\u521b\u5efa \u9876\u70b9\u7740\u8272\u5668 \u9876\u70b9\u7740\u8272\u5668\u5904\u7406\u6bcf\u4e00\u4e2a\u9876\u70b9\u6570\u636e\u3002\u5b83\u7684\u5c5e\u6027\uff0c\u5982\u4e16\u754c\u5750\u6807\uff0c\u989c\u8272\uff0c\u6cd5\u7ebf\u548c\u7eb9\u7406UV\u5750\u6807\u4f5c\u4e3a\u8f93\u5165\u3002\u8f93\u51fa\u7684\u662f\u6700\u7ec8\u7684clip coordinates \u88c1\u526a\u5750\u6807\u548c\u9700\u8981\u4f20\u9012\u5230\u7247\u5143\u7740\u8272\u5668\u7684\u5c5e\u6027\uff0c\u5305\u62ec\u989c\u8272\u548c\u7eb9\u7406UV\u5750\u6807\u3002\u8fd9\u4e9b\u503c\u4f1a\u5728\u5149\u6805\u5316\u9636\u6bb5\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u4ee5\u4ea7\u751f\u5e73\u6ed1\u7684\u8fc7\u5ea6\u3002 \u88c1\u526a\u5750\u6807 clip coordinate \u662f\u4e00\u4e2a\u6765\u6b64\u9876\u70b9\u7740\u8272\u5668\u7684\u601d\u7ef4\u5411\u91cf\uff0c\u968f\u540e\u901a\u8fc7\u77e2\u91cf\u6700\u540e\u4e00\u4e2a\u5206\u91cf\u8fdb\u884c\u6574\u4f53\u5f52\u4e00\u5316\u64cd\u4f5c\u3002\u8fd9\u4e9b\u5f52\u4e00\u5316\u540e\u7684\u8bbe\u5907\u5750\u6807\u662f homogeneous coordinates ****\u6700\u7ec8\u6620\u5c04\u5230\u7f13\u51b2\u533a\u8303\u56f4\u4e3a [-1, 1] \u7684 [-1, 1] \u5750\u6807\u7cfb\u7edf\uff0c\u5982\u4e0b\u6240\u793a: \u5982\u679c\u4e4b\u524d\u7684\u8ba1\u7b97\u673a\u56fe\u5f62\u6bd4\u8f83\u719f\u6089\u7684\u8bdd\uff0c\u5bf9\u8fd9\u90e8\u5206\u4f1a\u6bd4\u8f83\u719f\u6089\u3002\u5982\u679c\u4f60\u4e4b\u524d\u4f7f\u7528\u8fc7 OpenGL \uff0c\u4f60\u4f1a\u6ce8\u610f\u5230Y\u5750\u6807\u8f74\u662f\u53cd\u8f6c\u7684\uff0cZ\u5750\u6807\u8f74\u7684\u8303\u56f4\u4e0e Direct3D \u662f\u4e00\u81f4\u7684\u8303\u56f4\uff0c\u4ece0\u52301. \u5bf9\u4e8e\u7b2c\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u6211\u4eec\u4e0d\u4f1a\u505a\u4efb\u4f55\u8f6c\u6362\u64cd\u4f5c\uff0c\u6211\u4eec\u5c06\u4e09\u4e2a\u9876\u70b9\u7684\u4f4d\u7f6e\u6307\u5b9a\u4e3a\u5f52\u4e00\u5316\u8bbe\u5907\u5750\u6807\uff0c\u521b\u5efa\u5982\u4e0b\u56fe\u5f62: \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5c06\u5176\u8f93\u51fa\u4e3a\u88c1\u526a\u5750\u6807\u76f4\u63a5\u8f93\u51fa\u5f52\u4e00\u5316\u7684\u8bbe\u5907\u5750\u6807\uff0c\u9876\u70b9\u7740\u8272\u5668\u7684\u5750\u6807\u4e0e\u6700\u540e\u4e00\u4e2a\u5206\u91cf\u8bbe\u7f6e\u4e3a 1 \u3002\u5c06\u88c1\u526a\u5750\u6807\u8f6c\u6362\u4e3a\u5f52\u4e00\u5316\u7684\u8bbe\u5907\u5750\u6807\u6ca1\u6709\u6539\u53d8\u4efb\u4f55\u4e1c\u897f\u3002 \u901a\u5e38\u60c5\u51b5\u4e0b\u9876\u70b9\u5750\u6807\u6570\u636e\u662f\u5b58\u50a8\u5728\u4e00\u4e2a\u9876\u70b9\u7f13\u51b2\u533a\u4e2d\uff0c\u4f46\u662f\u5728 Vulkan \u4e2d\u521b\u5efa\u4e00\u4e2a\u9876\u70b9\u7f13\u51b2\u533a\u5e76\u586b\u5145\u6570\u636e\u7684\u8fc7\u7a0b\u5e76\u4e0d\u662f\u76f4\u63a5\u7684\u3002\u6240\u4ee5\u6211\u4eec\u540e\u7f6e\u8fd9\u4e9b\u6b65\u9aa4\uff0c\u76f4\u5230\u6211\u4eec\u6ee1\u610f\u7684\u770b\u5230\u4e00\u4e2a\u4e09\u89d2\u5f62\u51fa\u73b0\u5728\u5c4f\u5e55\u4e0a\u3002\u540c\u65f6\u6211\u4eec\u9700\u8981\u505a\u4e00\u4e9b\u975e\u6b63\u7edf\u7684\u4e8b\u60c5:\u5c06\u5750\u6807\u76f4\u63a5\u5305\u542b\u5728\u9876\u70b9\u7740\u8272\u5668\u7684\u5185\u90e8\u3002\u4ee3\u7801\u5982\u4e0b\u6240\u793a: #version 450 #extension GL_ARB_separate_shader_objects : enable out gl_PerVertex { vec4 gl_Position; }; vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); } C++ main \u51fd\u6570\u7684\u6267\u884c\u5e94\u7528\u4e8e\u6bcf\u4e2a\u9876\u70b9\uff0c\u5185\u7f6e\u7684 gl_VertexIndex \u53d8\u91cf\u5305\u542b\u4e86\u5f53\u524d\u9876\u70b9\u7684\u7d22\u5f15\u4fe1\u606f\u3002\u901a\u5e38\u662f\u9876\u70b9\u7f13\u51b2\u533a\u7684\u7d22\u5f15\uff0c\u4f46\u662f\u5728\u8fd9\u91cc\u6211\u4eec\u786c\u7f16\u7801\u5230\u9876\u70b9\u6570\u636e\u7684\u96c6\u5408\u4e2d\u3002\u6bcf\u4e2a\u9876\u70b9\u7684\u4f4d\u7f6e\u4ece\u5e38\u91cf\u6570\u7ec4\u4e2d\u8bbf\u95ee\uff0c\u5e76\u4e0e z \u548c w \u5206\u91cf\u7ec4\u5408\u4f7f\u7528\uff0c\u4ee5\u4ea7\u751f\u88c1\u526a\u5750\u6807\u4e2d\u7684\u6709\u6548\u4f4d\u7f6e\u4fe1\u606f\u3002\u5185\u7f6e\u7684 gl_Position \u53d8\u91cf\u4f5c\u4e3a\u8f93\u51fa\u3002\u6700\u540eVulkan\u4e2d\u4f7f\u7528shader\uff0c\u9700\u8981\u786e\u4fdd GL_ARG_separate_shader_objects \u6269\u5c55\u5f00\u542f\u3002 \u7247\u5143\u7740\u8272\u5668 \u7531\u9876\u70b9\u7740\u8272\u5668\u7684\u4f4d\u7f6e\u6570\u636e\u5f62\u6210\u7684\u4e09\u89d2\u5f62\u7528\u7247\u6bb5\u7740\u8272\u5668\u586b\u5145\u5c4f\u5e55\u4e0a\u7684\u533a\u57df\u4e2d\u3002\u7247\u6bb5\u7740\u8272\u5668\u9488\u5bf9\u4e00\u4e2a\u6216\u8005\u591a\u4e2aframebuffer\u5e27\u7f13\u51b2\u533a\u7684\u6bcf\u4e2a\u7247\u5143\u4ea7\u751f\u5177\u4f53\u7684\u989c\u8272\u548c\u6df1\u5ea6\u4fe1\u606f\u3002\u4e00\u4e2a\u7b80\u5355\u7684\u7247\u6bb5\u7740\u8272\u5668\u4e3a\u5b8c\u6210\u7684\u4e09\u89d2\u5f62\u8f93\u51fa\u7ea2\u8272\u4fe1\u606f\u7684\u4ee3\u7801\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable layout(location = 0) out vec4 outColor; void main() { outColor = vec4(1.0, 0.0, 0.0, 1.0); } C++ fragment sahder\u4e2d\u7684 main \u51fd\u6570\u4e0e vertex shader \u4e2d\u7684 main \u51fd\u6570\u7c7b\u4f3c\uff0c\u4f1a\u4e3a\u6bcf\u4e00\u4e2a\u7247\u5143\u8c03\u7528\u5904\u7406\u3002\u989c\u8272\u7684\u4fe1\u606f\u5728GLSL\u4e2d\u662f4\u4e2a\u5206\u91cf\u7ec4\u6210\u7684\u77e2\u91cf\uff0c\u5305\u62ecR,G,B\u548cAlpha\u901a\u9053\uff0c\u503c\u57df\u6536\u655b\u5728[0, 1]\u8303\u56f4\u5185\u3002\u4e0d\u50cf\u9876\u70b9\u7740\u8272\u5668\u7684 gl_Position \uff0c\u5b83\u6ca1\u6709\u5185\u7f6e\u7684\u53d8\u91cf\u4e3a\u5f53\u524d\u7247\u5143\u8f93\u51fa\u989c\u8272\u4fe1\u606f\u3002\u5728\u8fd9\u91cc\u5fc5\u987b\u4e3aframebuffer\u5b9a\u4e49\u8f93\u51fa\u53d8\u91cf\uff0c layout(location = 0) \u4fee\u9970\u7b26\u660e\u786eframebuffer\u7684\u7d22\u5f15\u3002\u7ea2\u8272\u4fe1\u606f\u5199\u8fdb outColor \u53d8\u91cf\u4e2d\uff0c\u8be5\u53d8\u91cf\u94fe\u63a5\u7b2c\u4e00\u4e2aframebuffer\u4e2d\uff0c\u7d22\u5f15\u4e3a 0 \u3002 \u9876\u70b9\u989c\u8272\u7ec4 \u4e00\u4e2a\u7eaf\u7ea2\u8272\u7684\u4e09\u89d2\u5f62\u770b\u8d77\u6765\u5e76\u4e0d\u662f\u5f88\u9177\u70ab\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u8bd5\u7740\u9177\u70ab\u4e00\u4e9b\u5462? \u6211\u4eec\u9488\u5bf9\u4e24\u4e2a\u7c7b\u578b\u7684\u7740\u8272\u5668\u5c1d\u8bd5\u505a\u4e00\u4e9b\u6539\u53d8\uff0c\u5b8c\u6210\u4e0a\u56fe\u7684\u6548\u679c\u3002\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u6bcf\u4e2a\u9876\u70b9\u8bbe\u7f6e\u5dee\u5f02\u5316\u7684\u989c\u8272\u3002\u9876\u70b9\u7740\u8272\u5668\u5e94\u8be5\u5305\u542b\u4e00\u4e2a\u989c\u8272\u6570\u7ec4\uff0c\u5c31\u50cf\u4f4d\u7f6e\u4fe1\u606f\u7684\u6570\u7ec4\u4e00\u6837: vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) ); C++ \u73b0\u5728\u6211\u4eec\u9700\u8981\u628a\u6bcf\u4e2a\u9876\u70b9\u7684\u989c\u8272\u4f20\u9012\u5230\u7247\u6bb5\u7740\u8272\u5668\u4e2d\uff0c\u4ece\u800c\u8f93\u51fa\u7ecf\u8fc7\u63d2\u503c\u540e\u7684\u989c\u8272\u4fe1\u606f\u5230 framebuffer \u4e2d\u3002\u4e3a\u9876\u70b9\u7740\u8272\u5668\u6dfb\u589e\u52a0\u8f93\u51fa\u989c\u8272\u652f\u6301\uff0c\u5728 main \u51fd\u6570\u4e2d\u5b9a\u4e49\u5982\u4e0b: layout(location = 0) out vec3 fragColor; void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex]; } C++ \u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u9700\u8981\u5c06\u7247\u6bb5\u7740\u8272\u5668\u7684\u8f93\u5165\u5339\u914d\u9876\u70b9\u7740\u8272\u5668\u7684\u8f93\u51fa: layout(location = 0) in vec3 fragColor; void main() { outColor = vec4(fragColor, 1.0); } C++ \u8f93\u5165\u7684\u53d8\u91cf\u4e0d\u4e00\u5b9a\u8981\u540c\u540d\uff0c\u5b83\u4eec\u5c06\u901a\u8fc7 location \u7d22\u5f15\u6307\u4ee4\u94fe\u63a5\u5728\u4e00\u8d77\u3002 main \u51fd\u6570\u4e2d\u4fee\u6539\u5c06\u8981\u8f93\u51fa\u7684\u989c\u8272alpha\u503c\u3002\u5c31\u50cf\u4e4b\u524d\u8ba8\u8bba\u7684\u4e00\u6837\uff0c fragColor \u5c06\u4f1a\u4e3a\u4e09\u4e2a\u9876\u70b9\u6240\u5c5e\u7684\u7247\u5143\u81ea\u52a8\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u5f62\u6210\u5e73\u6ed1\u7684\u989c\u8272\u8fc7\u5ea6\u3002 \u7f16\u8bd1\u7740\u8272\u5668 \u5728\u9879\u76ee\u6839\u76ee\u5f55\u4e0b\u521b\u5efa\u4e00\u4e2a\u5b50\u76ee\u5f55\uff0c\u540d shaders \u7528\u4e8e\u5b58\u50a8\u9876\u70b9\u7740\u8272\u5668\u6587\u4ef6 shader.vert \u548c\u7247\u6bb5\u7740\u8272\u5668\u6587\u4ef6 shader.frag \u3002GLSL\u7740\u8272\u5668\u5b98\u65b9\u6ca1\u6709\u7ea6\u5b9a\u7684\u6269\u5c55\u540d\uff0c\u4f46\u662f\u8fd9\u4e24\u4e2a\u6269\u5c55\u540d\u662f\u6bd4\u8f83\u666e\u904d\u901a\u7528\u7684\u3002 shader.vert \u5185\u5bb9\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable out gl_PerVertex { vec4 gl_Position; }; layout(location = 0) out vec3 fragColor; vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex]; } C++ shader.frag \u6587\u4ef6\u5185\u5bb9\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable layout(location = 0) in vec3 fragColor; layout(location = 0) out vec4 outColor; void main() { outColor = vec4(fragColor, 1.0); } C++ \u73b0\u5728\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 glslangValidator \u7a0b\u5e8f\u7f16\u8bd1SPIR-V\u4e8c\u8fdb\u5236\u7801\u3002 \u521b\u5efa\u4e00\u4e2acompile.bat\u6279\u5904\u7406\u6587\u4ef6\uff0c\u5185\u5bb9\u5982\u4e0b: C:/VulkanSDK/1.0.17.0/Bin32/glslangValidator.exe -V shader.vert C:/VulkanSDK/1.0.17.0/Bin32/glslangValidator.exe -V shader.frag pause C++ \u5c06 glslangValidator.exe \u7684path\u8def\u5f84\u66ff\u6362\u4e3a\u4f60\u7684VulkanSDK\u5b89\u88c5\u8def\u5f84\uff0c\u7136\u540e\u53cc\u51fb\u8be5\u6587\u4ef6\u8fd0\u884c\u3002 \u8fd9\u4e24\u4e2a\u547d\u4ee4\u4f7f\u7528 -V \u6807\u5fd7\u8c03\u7528\u7f16\u8bd1\u5668\uff0c\u8be5\u6807\u5fd7\u544a\u8bc9\u5b83\u5c06GLSL\u6e90\u6587\u4ef6\u7f16\u8bd1\u4e3aSPIR-V\u5b57\u8282\u7801\u3002\u8fd0\u884c\u7f16\u8bd1\u811a\u672c\u65f6\uff0c\u4f1a\u770b\u5230\u521b\u5efa\u4e86\u4e24\u4e2aSPIR-V\u4e8c\u8fdb\u5236\u6587\u4ef6: vert.spv \u548c frag.spv \u3002\u8fd9\u4e9b\u540d\u79f0\u4ece\u7740\u8272\u5668\u4e2d\u6d3e\u751f\u800c\u6765\uff0c\u4f46\u662f\u53ef\u4ee5\u91cd\u547d\u540d\u4e3a\u4efb\u4f55\u540d\u5b57\u3002\u5728\u7f16\u8bd1\u7740\u8272\u5668\u65f6\uff0c\u53ef\u80fd\u6536\u5230\u5173\u4e8e\u67d0\u4e9b\u529f\u80fd\u7f3a\u5931\u7684\u8b66\u544a\u4fe1\u606f\uff0c\u5728\u8fd9\u91cc\u653e\u5fc3\u7684\u5ffd\u7565\u5b83\u4eec\u3002 \u5982\u679c\u7740\u8272\u5668\u5305\u542b\u8bed\u6cd5\u9519\u8bef\uff0c\u90a3\u4e48\u7f16\u8bd1\u5668\u4f1a\u6309\u7167\u60a8\u7684\u9884\u671f\u544a\u8bc9\u5177\u4f53\u7684\u884c\u53f7\u548c\u95ee\u9898\u3002\u5c1d\u8bd5\u7701\u7565\u4e00\u4e2a\u5206\u53f7\uff0c\u7136\u540e\u91cd\u65b0\u8fd0\u884c\u7f16\u8bd1\u811a\u672c\u3002\u8fd8\u53ef\u4ee5\u5c1d\u8bd5\u8fd0\u884c\u7f16\u8bd1\u5668\uff0c\u800c\u65e0\u9700\u4efb\u4f55\u53c2\u6570\u6765\u67e5\u770b\u5b83\u652f\u6301\u54ea\u4e9b\u7c7b\u578b\u7684\u6807\u5fd7\u3002\u4f8b\u5982\uff0c\u5b83\u53ef\u4ee5\u5c06\u5b57\u8282\u7801\u8f93\u51fa\u4e3a\u53ef\u8bfb\u7684\u683c\u5f0f\uff0c\u4ee5\u4fbf\u51c6\u786e\u4e86\u89e3\u7740\u8272\u5668\u6b63\u5728\u6267\u884c\u7684\u64cd\u4f5c\u4ee5\u53ca\u5728\u6b64\u9636\u6bb5\u5e94\u7528\u7684\u4efb\u4f55\u4f18\u5316\u3002 \u52a0\u8f7d\u7740\u8272\u5668 \u73b0\u5728\u6211\u4eec\u6709\u4e00\u79cd\u4ea7\u751fSPIR-V\u7740\u8272\u5668\u7684\u65b9\u6cd5\uff0c\u662f\u65f6\u5019\u52a0\u8f7d\u5b83\u4eec\u5230\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\uff0c\u4ee5\u4fbf\u5728\u9002\u5f53\u7684\u65f6\u5019\u63d2\u5165\u5230\u56fe\u5f62\u7ba1\u7ebf\u4e2d\u3002\u9996\u5148\u6211\u4eec\u7f16\u5199\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\u7528\u4ee5\u52a0\u8f7d\u4e8c\u8fdb\u5236\u6570\u636e\u6587\u4ef6\u3002 #include <fstream> ... static std::vector<char> readFile(const std::string& filename) { std::ifstream file(filename, std::ios::ate | std::ios::binary); if (!file.is_open()) { throw std::runtime_error(\"failed to open file!\"); } } C++ readFile \u51fd\u6570\u5c06\u4f1a\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6240\u6709\u7684\u4e8c\u8fdb\u5236\u6570\u636e\uff0c\u5e76\u7528 std::vector \u5b57\u8282\u96c6\u5408\u7ba1\u7406\u3002\u6211\u4eec\u4f7f\u7528\u4e24\u4e2a\u6807\u5fd7\u7528\u4ee5\u6253\u5f00\u6587\u4ef6: ate :\u5728\u6587\u4ef6\u672b\u5c3e\u5f00\u59cb\u8bfb\u53d6 binary :\u4ee5\u4e8c\u8fdb\u5236\u683c\u5f0f\u53bb\u8bfb\u6587\u4ef6(\u907f\u514d\u5b57\u7b26\u683c\u5f0f\u7684\u8f6c\u4e49) \u4ece\u6587\u4ef6\u672b\u5c3e\u5f00\u59cb\u8bfb\u53d6\u7684\u4f18\u70b9\u662f\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u8bfb\u53d6\u4f4d\u7f6e\u6765\u786e\u5b9a\u6587\u4ef6\u7684\u5927\u5c0f\u5e76\u5206\u914d\u7f13\u51b2\u533a: size_t fileSize = (size_t) file.tellg(); std::vector<char> buffer(fileSize); C++ \u4e4b\u540e\u6211\u4eec\u53ef\u4ee5\u8ffd\u6eaf\u5230\u6587\u4ef6\u7684\u5f00\u5934\uff0c\u540c\u65f6\u8bfb\u53d6\u6240\u6709\u7684\u5b57\u8282: file.seekg(0); file.read(buffer.data(), fileSize); C++ \u6700\u540e\u5173\u95ed\u6587\u4ef6\uff0c\u8fd4\u56de\u5b57\u8282\u6570\u636e: file.close(); return buffer; C++ \u6211\u4eec\u8c03\u7528\u51fd\u6570createGraphicsPipeline\u52a0\u8f7d\u4e24\u4e2a\u7740\u8272\u5668\u7684\u4e8c\u8fdb\u5236\u7801: void createGraphicsPipeline() { auto vertShaderCode = readFile(\"shaders/vert.spv\"); auto fragShaderCode = readFile(\"shaders/frag.spv\"); } C++ \u786e\u4fdd\u7740\u8272\u5668\u6b63\u786e\u52a0\u8f7d\uff0c\u5e76\u6253\u5370\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u662f\u5426\u4e0e\u6587\u4ef6\u5b9e\u9645\u5927\u5c0f\u4e00\u81f4\u3002 \u521b\u5efa\u7740\u8272\u5668\u6a21\u578b \u5728\u5c06\u4ee3\u7801\u4f20\u9012\u7ed9\u6e32\u67d3\u7ba1\u7ebf\u4e4b\u524d\uff0c\u6211\u4eec\u5fc5\u987b\u5c06\u5176\u5c01\u88c5\u5230 VkShaderModule \u5bf9\u8c61\u4e2d\u3002\u8ba9\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570 createShaderModule \u5b9e\u73b0\u8be5\u903b\u8f91\u3002 VkShaderModule createShaderModule(const std::vector<char>& code) { } C++ \u8be5\u51fd\u6570\u9700\u8981\u5b57\u8282\u7801\u7684\u7f13\u51b2\u533a\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u901a\u8fc7\u7f13\u51b2\u533a\u521b\u5efa VkShaderModule \u3002 \u521b\u5efashader module\u662f\u6bd4\u8f83\u7b80\u5355\u7684\uff0c\u6211\u4eec\u4ec5\u4ec5\u9700\u8981\u6307\u5b9a\u4e8c\u8fdb\u5236\u7801\u7f13\u51b2\u533a\u7684\u6307\u9488\u548c\u5b83\u7684\u5177\u4f53\u957f\u5ea6\u3002\u8fd9\u4e9b\u4fe1\u606f\u88ab\u586b\u5145\u5728 VkShaderModuleCreateInfo \u7ed3\u6784\u4f53\u4e2d\u3002\u9700\u8981\u7559\u610f\u7684\u662f\u5b57\u8282\u7801\u7684\u5927\u5c0f\u662f\u4ee5\u5b57\u8282\u6307\u5b9a\u7684\uff0c\u4f46\u662f\u5b57\u8282\u7801\u6307\u9488\u662f\u4e00\u4e2a uint32_t \u7c7b\u578b\u7684\u6307\u9488\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a char \u6307\u9488\u3002\u6240\u4ee5\u6211\u4eec\u4f7f\u7528 reinterpret_cast \u8fdb\u884c\u8f6c\u6362\u6307\u9488\u3002\u5982\u4e0b\u6240\u793a\uff0c\u5f53\u9700\u8981\u8f6c\u6362\u65f6\uff0c\u8fd8\u9700\u8981\u786e\u4fdd\u6570\u636e\u6ee1\u8db3 uint32_t \u7684\u5bf9\u9f50\u8981\u6c42\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u6570\u636e\u5b58\u50a8\u5728 std::vector \u4e2d\uff0c\u9ed8\u8ba4\u5206\u914d\u5668\u5df2\u7ecf\u786e\u4fdd\u6570\u636e\u6ee1\u8db3\u6700\u5dee\u60c5\u51b5\u4e0b\u7684\u5bf9\u9f50\u8981\u6c42\u3002 VkShaderModuleCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; createInfo.codeSize = code.size(); createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data()); C++ \u8c03\u7528 vkCreateShaderMoudle \u521b\u5efa VkShaderModule : VkShaderModule shaderModule; if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) { throw std::runtime_error(\"failed to create shader module!\"); } C++ \u53c2\u6570\u4e0e\u4e4b\u524d\u521b\u5efa\u5bf9\u8c61\u529f\u80fd\u7c7b\u4f3c:\u903b\u8f91\u8bbe\u5907\uff0c\u521b\u5efa\u5bf9\u8c61\u4fe1\u606f\u7ed3\u6784\u4f53\u7684\u6307\u9488\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u4fdd\u5b58\u7ed3\u679c\u7684\u53e5\u67c4\u53d8\u91cf\u3002\u5728shader module\u521b\u5efa\u5b8c\u6bd5\u540e\uff0c\u53ef\u4ee5\u5bf9\u4e8c\u8fdb\u5236\u7801\u7684\u7f13\u51b2\u533a\u8fdb\u884c\u7acb\u5373\u7684\u91ca\u653e\u3002\u6700\u540e\u4e0d\u8981\u5fd8\u8bb0\u8fd4\u56de\u521b\u5efa\u597d\u7684shader module\u3002 return shaderModule; C++ shader module\u5bf9\u8c61\u4ec5\u4ec5\u5728\u6e32\u67d3\u7ba1\u7ebf\u5904\u7406\u8fc7\u7a0b\u4e2d\u9700\u8981\uff0c\u6240\u4ee5\u6211\u4eec\u4f1a\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u5b9a\u4e49\u672c\u5730\u53d8\u91cf\u4fdd\u5b58\u5b83\u4eec\uff0c\u800c\u4e0d\u662f\u5b9a\u4e49\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709\u5b83\u4eec\u7684\u53e5\u67c4: VkShaderModule vertShaderModule; VkShaderModule fragShaderModule; C++ \u8c03\u7528\u52a0\u8f7dshader module\u7684\u8f85\u52a9\u51fd\u6570: vertShaderModule = createShaderModule(vertShaderCode); fragShaderModule = createShaderModule(fragShaderCode); C++ \u5728\u56fe\u5f62\u7ba1\u7ebf\u521b\u5efa\u5b8c\u6210\u4e14 createGraphicsPipeline \u51fd\u6570\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u5b83\u4eec\u5e94\u8be5\u88ab\u6e05\u7406\u6389\uff0c\u6240\u4ee5\u5728\u8be5\u51fd\u6570\u540e\u5220\u9664\u5b83\u4eec: ... vkDestroyShaderModule(device, fragShaderModule, nullptr); vkDestroyShaderModule(device, vertShaderModule, nullptr); } C++ \u7740\u8272\u5668\u9636\u6bb5\u521b\u5efa VkShaderModule \u5bf9\u8c61\u53ea\u662f\u5b57\u8282\u7801\u7f13\u51b2\u533a\u7684\u4e00\u4e2a\u5305\u88c5\u5bb9\u5668\u3002\u7740\u8272\u5668\u5e76\u6ca1\u6709\u5f7c\u6b64\u94fe\u63a5\uff0c\u751a\u81f3\u6ca1\u6709\u7ed9\u51fa\u76ee\u7684\u3002\u901a\u8fc7 VkPipelineShaderStageCreateInfo \u7ed3\u6784\u5c06\u7740\u8272\u5668\u6a21\u5757\u5206\u914d\u5230\u7ba1\u7ebf\u4e2d\u7684\u9876\u70b9\u6216\u8005\u7247\u6bb5\u7740\u8272\u5668\u9636\u6bb5\u3002VkPipelineShaderStageCreateInfo\u7ed3\u6784\u4f53\u662f\u5b9e\u9645\u7ba1\u7ebf\u521b\u5efa\u8fc7\u7a0b\u7684\u4e00\u90e8\u5206\u3002 \u6211\u4eec\u9996\u5148\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u586b\u5199\u9876\u70b9\u7740\u8272\u5668\u7ed3\u6784\u4f53\u3002 VkPipelineShaderStageCreateInfo vertShaderStageInfo = {}; vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; C++ \u9664\u4e86\u5f3a\u5236\u7684 sType \u6210\u5458\u5916\uff0c\u7b2c\u4e00\u4e2a\u9700\u8981\u544a\u77e5Vulkan\u5c06\u5728\u54ea\u4e2a\u6d41\u6c34\u7ebf\u9636\u6bb5\u4f7f\u7528\u7740\u8272\u5668\u3002\u5728\u4e0a\u4e00\u4e2a\u7ae0\u8282\u7684\u6bcf\u4e2a\u53ef\u7f16\u7a0b\u9636\u6bb5\u90fd\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u679a\u4e3e\u503c\u3002 vertShaderStageInfo.module = vertShaderModule; vertShaderStageInfo.pName = \"main\"; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u6210\u5458\u6307\u5b9a\u5305\u542b\u4ee3\u7801\u7684\u7740\u8272\u5668\u6a21\u5757\u548c\u8c03\u7528\u7684\u4e3b\u51fd\u6570\u3002\u8fd9\u610f\u5473\u7740\u53ef\u4ee5\u5c06\u591a\u4e2a\u7247\u6bb5\u7740\u8272\u5668\u7ec4\u5408\u5230\u5355\u4e2a\u7740\u8272\u5668\u6a21\u5757\u4e2d\uff0c\u5e76\u4f7f\u7528\u4e0d\u540c\u7684\u5165\u53e3\u70b9\u6765\u533a\u5206\u5b83\u4eec\u7684\u884c\u4e3a\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u575a\u6301\u4f7f\u7528\u6807\u51c6 main \u51fd\u6570\u4f5c\u4e3a\u5165\u53e3\u3002 \u8fd8\u6709\u4e00\u4e2a\u53ef\u9009\u6210\u5458\uff0c pSpecializationInfo ,\u5728\u8fd9\u91cc\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u5b83\uff0c\u4f46\u662f\u503c\u5f97\u8ba8\u8bba\u4e00\u4e0b\u3002\u5b83\u5141\u8bb8\u4e3a\u7740\u8272\u5668\u6307\u5b9a\u5e38\u91cf\u503c\u3002\u4f7f\u7528\u5355\u4e2a\u7740\u8272\u5668\u6a21\u5757\uff0c\u901a\u8fc7\u4e3a\u5176\u4e2d\u4f7f\u7528\u4e0d\u540c\u7684\u5e38\u91cf\u503c\uff0c\u53ef\u4ee5\u5728\u6d41\u6c34\u7ebf\u521b\u5efa\u65f6\u5bf9\u884c\u4e3a\u8fdb\u884c\u914d\u7f6e\u3002\u8fd9\u6bd4\u5728\u6e32\u67d3\u65f6\u4f7f\u7528\u53d8\u91cf\u914d\u7f6e\u7740\u8272\u5668\u66f4\u6709\u6548\u7387\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u53ef\u4ee5\u8fdb\u884c\u4f18\u5316\uff0c\u4f8b\u5982\u6d88\u9664 if \u503c\u5224\u65ad\u7684\u8bed\u53e5\u3002\u5982\u679c\u6ca1\u6709\u8fd9\u6837\u7684\u5e38\u91cf\uff0c\u53ef\u4ee5\u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a nullptr \uff0c\u6211\u4eec\u7684struct\u7ed3\u6784\u4f53\u521d\u59cb\u5316\u81ea\u52a8\u8fdb\u884c\u3002 \u4fee\u6539\u7ed3\u6784\u4f53\u6ee1\u8db3\u7247\u6bb5\u7740\u8272\u5668\u7684\u9700\u8981: VkPipelineShaderStageCreateInfo fragShaderStageInfo = {}; fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; fragShaderStageInfo.module = fragShaderModule; fragShaderStageInfo.pName = \"main\"; C++ \u5b8c\u6210\u4e24\u4e2a\u7ed3\u6784\u4f53\u7684\u521b\u5efa\uff0c\u5e76\u901a\u8fc7\u6570\u7ec4\u4fdd\u5b58\uff0c\u8fd9\u90e8\u5206\u5f15\u7528\u5c06\u4f1a\u5728\u5b9e\u9645\u7684\u7ba1\u7ebf\u521b\u5efa\u5f00\u59cb\u3002 VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo}; C++ \u5230\u6b64\u4e3a\u6b62\uff0c\u5c31\u662f\u6240\u6709\u5173\u4e8e\u53ef\u7f16\u7a0b\u7ba1\u7ebf\u9636\u6bb5\u7684\u903b\u8f91\u3002\u5728 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u4f1a\u770b\u4e00\u4e0b\u56fa\u5b9a\u7ba1\u7ebf\u5404\u4e2a\u9636\u6bb5\u3002 Vulkan \u56fa\u6709\u529f\u80fd Vulkan \u56fa\u6709\u529f\u80fd \uff0c\u65e9\u8d77\u7684\u56fe\u5f62API\u5728\u56fe\u5f62\u6e32\u67d3\u7ba1\u7ebf\u7684\u8bb8\u591a\u9636\u6bb5\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u7684\u72b6\u6001\u3002\u5728 Vulkan \u4e2d\uff0c\u4ece viewport \u7684\u5927\u5c0f\u5230\u6df7\u8272\u51fd\u6570\uff0c\u9700\u8981\u51e1\u4e8b\u505a\u5230\u4eb2\u5386\u4eb2\u4e3a\u3002\u5728\u672c\u7ae0\u8282\u4e2d\u6211\u4eec\u4f1a\u586b\u5145\u6709\u5173\u56fa\u6709\u529f\u80fd\u64cd\u4f5c\u7684\u6240\u6709\u7ed3\u6784\u4f53\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9876\u70b9\u8f93\u5165 2 \u8f93\u5165\u7ec4\u4ef6 3 \u89c6\u7a97\u548c\u88c1\u526a 4 \u5149\u6805\u5316 5 \u91cd\u91c7\u6837 6 \u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5 7 \u989c\u8272\u6df7\u5408 8 \u52a8\u6001\u4fee\u6539 9 \u7ba1\u9053\u5e03\u5c40 10 \u7ed3\u8bba \u9876\u70b9\u8f93\u5165 VkPipelineVertexInputStateCreateInfo \u7ed3\u6784\u4f53\u63cf\u8ff0\u4e86\u9876\u70b9\u6570\u636e\u7684\u683c\u5f0f\uff0c\u8be5\u7ed3\u6784\u4f53\u6570\u636e\u4f20\u9012\u5230 vertex shader \u4e2d\u3002\u5b83\u4ee5\u4e24\u79cd\u65b9\u5f0f\u8fdb\u884c\u63cf\u8ff0: Bindings :\u6839\u636e\u6570\u636e\u7684\u95f4\u9699\uff0c\u786e\u5b9a\u6570\u636e\u662f\u6bcf\u4e2a\u9876\u70b9\u6216\u8005\u662f\u6bcf\u4e2ainstance( instancing ) Attribute \u63cf\u8ff0:\u63cf\u8ff0\u5c06\u8981\u8fdb\u884c\u7ed1\u5b9a\u53ca\u52a0\u8f7d\u5c5e\u6027\u7684\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684\u76f8\u5173\u5c5e\u6027\u7c7b\u578b\u3002 \u56e0\u4e3a\u6211\u4eec\u5c06\u9876\u70b9\u6570\u636e\u786c\u7f16\u7801\u5230 vertex shader \u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u5c06\u8981\u586b\u5145\u7684\u7ed3\u6784\u4f53\u6ca1\u6709\u9876\u70b9\u6570\u636e\u53bb\u52a0\u8f7d\u3002\u6211\u4eec\u5c06\u4f1a\u5728 vertex buffer \u7ae0\u8282\u4e2d\u56de\u6765\u64cd\u4f5c\u3002 VkPipelineVertexInputStateCreateInfo vertexInputInfo = {}; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.pVertexBindingDescriptions = nullptr; // Optional vertexInputInfo.vertexAttributeDescriptionCount = 0; vertexInputInfo.pVertexAttributeDescriptions = nullptr; // Optional C++ pVertexBindingDescriptions \u548c pVertexAttributeDescriptions \u6210\u5458\u6307\u5411\u7ed3\u6784\u4f53\u6570\u7ec4\uff0c\u7528\u4e8e\u8fdb\u4e00\u6b65\u63cf\u8ff0\u52a0\u8f7d\u7684\u9876\u70b9\u6570\u636e\u4fe1\u606f\u3002\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u7684 shaderStages \u6570\u7ec4\u540e\u6dfb\u52a0\u8be5\u7ed3\u6784\u4f53\u3002 \u8f93\u5165\u7ec4\u4ef6 VkPipelineInputAssemblyStateCreateInfo \u7ed3\u6784\u4f53\u63cf\u8ff0\u4e24\u4ef6\u4e8b\u60c5:\u9876\u70b9\u6570\u636e\u4ee5\u4ec0\u4e48\u7c7b\u578b\u7684\u51e0\u4f55\u56fe\u5143\u62d3\u6251\u8fdb\u884c\u7ed8\u5236\u53ca\u662f\u5426\u542f\u7528\u9876\u70b9\u7d22\u91cd\u65b0\u5f00\u59cb\u56fe\u5143\u3002\u56fe\u5143\u7684\u62d3\u6251\u7ed3\u6784\u7c7b\u578b topology \u679a\u4e3e\u503c\u5982\u4e0b: VK_PRIMITIVE_TOPOLOGY_POINT_LIST : \u9876\u70b9\u5230\u70b9 VK_PRIMITIVE_TOPOLOGY_LINE_LIST : \u4e24\u70b9\u6210\u7ebf\uff0c\u9876\u70b9\u4e0d\u5171\u7528 VK_PRIMITIVE_TOPOLOGY_LINE_STRIP : \u4e24\u70b9\u6210\u7ebf\uff0c\u6bcf\u4e2a\u7ebf\u6bb5\u7684\u7ed3\u675f\u9876\u70b9\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u7ebf\u6bb5\u7684\u5f00\u59cb\u9876\u70b9 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST : \u4e09\u70b9\u6210\u9762\uff0c\u9876\u70b9\u4e0d\u5171\u7528 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP : \u6bcf\u4e2a\u4f46\u6559\u8bad\u7684\u7b2c\u4e8c\u4e2a\u3001\u7b2c\u4e09\u4e2a\u9876\u70b9\u90fd\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u4e09\u89d2\u5f62\u7684\u524d\u4e24\u4e2a\u9876\u70b9 \u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u9876\u70b9\u6570\u636e\u6309\u7167\u7f13\u51b2\u533a\u4e2d\u7684\u5e8f\u5217\u4f5c\u4e3a\u7d22\u5f15\uff0c\u4f46\u662f\u4e5f\u53ef\u4ee5\u901a\u8fc7element buffer\u7f13\u51b2\u533a\u81ea\u884c\u6307\u5b9a\u9876\u70b9\u6570\u636e\u7684\u7d22\u5f15\u3002\u901a\u8fc7\u590d\u7528\u9876\u70b9\u6570\u636e\u63d0\u5347\u6027\u80fd\u3002\u5982\u679c\u8bbe\u7f6e primitiveRestartEnable \u6210\u5458\u4e3a VK_TRUE \uff0c\u53ef\u4ee5\u901a\u8fc7 0xFFFF \u6216\u8005 0xFFFFFFFF \u4f5c\u4e3a\u7279\u6b8a\u7d22\u5f15\u6765\u5206\u89e3\u7ebf\u548c\u4e09\u89d2\u5f62\u5728 _STRIP \u6a21\u5f0f\u4e0b\u7684\u56fe\u5143\u62d3\u6251\u7ed3\u6784\u3002 \u901a\u8fc7\u672c\u6559\u7a0b\u7ed8\u5236\u4e09\u89d2\u5f62\uff0c\u6240\u4ee5\u6211\u4eec\u575a\u6301\u6309\u7167\u5982\u4e0b\u683c\u5f0f\u586b\u5145\u6570\u636e\u7ed3\u6784: VkPipelineInputAssemblyStateCreateInfo inputAssembly = {}; inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; inputAssembly.primitiveRestartEnable = VK_FALSE; C++ \u89c6\u7a97\u548c\u88c1\u526a Viewport\u7528\u4e8e\u63cf\u8ff0framebuffer\u4f5c\u4e3a\u6e32\u67d3\u8f93\u51fa\u7ed3\u679c\u76ee\u6807\u533a\u57df\u3002\u5b83\u7684\u6570\u503c\u5728\u672c\u6559\u7a0b\u4e2d\u603b\u662f\u8bbe\u7f6e\u5728 (0, 0) \u548c (width, height) \u3002 VkViewport viewport = {}; viewport.x = 0.0f; viewport.y = 0.0f; viewport.width = (float) swapChainExtent.width; viewport.height = (float) swapChainExtent.height; viewport.minDepth = 0.0f; viewport.maxDepth = 1.0f; C++ \u8bb0\u5f97\u4ea4\u6362\u94fe\u548c\u5b83\u7684images\u56fe\u50cf\u5927\u5c0f WIDTH \u548c HEIGHT \u4f1a\u6839\u636e\u4e0d\u540c\u7684\u7a97\u4f53\u800c\u4e0d\u540c\u3002\u4ea4\u6362\u94fe\u56fe\u50cf\u5c06\u4f1a\u5728\u5e27\u7f13\u51b2\u533aframebuffers\u4f7f\u7528\uff0c\u6240\u4ee5\u6211\u4eec\u5e94\u8be5\u575a\u6301\u5b83\u4eec\u7684\u5927\u5c0f\u3002 minDepth \u548c maxDepth \u6570\u503c\u6307\u5b9aframebuffer\u4e2d\u6df1\u5ea6\u7684\u8303\u56f4\u3002\u8fd9\u4e9b\u6570\u503c\u5fc5\u987b\u6536\u655b\u5728 [0.0f, 1.0f] \u533a\u95f4\u51b2\uff0c\u4f46\u662f minDepth \u53ef\u80fd\u4f1a\u5927\u4e8e maxDepth \u3002\u5982\u679c\u4f60\u4e0d\u505a\u4efb\u4f55\u6307\u5b9a\uff0c\u5efa\u8bae\u4f7f\u7528\u6807\u51c6\u7684\u6570\u503c 0.0 f\u548c 1.0f \u3002 viewports \u5b9a\u4e49\u4e86image\u56fe\u50cf\u5230framebuffer\u5e27\u7f13\u51b2\u533a\u7684\u8f6c\u6362\u5173\u7cfb\uff0c\u88c1\u526a\u77e9\u5f62\u5b9a\u4e49\u4e86\u54ea\u4e9b\u533a\u57df\u7684\u50cf\u7d20\u88ab\u5b58\u50a8\u3002\u4efb\u4f55\u5728\u88c1\u526a\u5de8\u578b\u5916\u7684\u50cf\u7d20\u90fd\u4f1a\u5728\u5149\u6805\u5316\u9636\u6bb5\u4e22\u5f03\u3002\u5b83\u4eec\u7684\u529f\u80fd\u66f4\u50cf\u8fc7\u6ee4\u5668\u800c\u4e0d\u662f\u5b9a\u4e49\u8f6c\u6362\u5173\u7cfb\u3002\u8fd9\u4e2a\u533a\u522b\u5982\u4e0b\u56fe\u6240\u793a\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5bf9\u4e8e\u56fe\u50cf\u6bd4 viewport \u5c3a\u5bf8\u5927\u7684\u60c5\u5f62\uff0c\u5de6\u4fa7\u7684\u88c1\u526a\u77e9\u5f62\u53ea\u662f\u4f17\u591a\u53ef\u80fd\u7684\u4e00\u4e2a\u8868\u73b0\u3002 \u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u9700\u8981\u5c06\u56fe\u50cf\u7ed8\u5236\u5230\u5b8c\u6574\u7684\u5e27\u7f13\u51b2\u533a framebuffer \u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u5b9a\u4e49\u88c1\u526a\u77e9\u5f62\u8986\u76d6\u5230\u6574\u4f53\u56fe\u50cf: VkRect2D scissor = {}; scissor.offset = {0, 0}; scissor.extent = swapChainExtent; C++ viewport\u548c\u88c1\u526a\u77e9\u5f62\u9700\u8981\u501f\u52a9 VkPipelineViewportStateCreateInfo \u7ed3\u6784\u4f53\u8054\u5408\u4f7f\u7528\u3002\u53ef\u4ee5\u4f7f\u7528\u591a viewports \u548c\u88c1\u526a\u77e9\u5f62\u5728\u4e00\u4e9b\u56fe\u5f62\u5361\uff0c\u901a\u8fc7\u6570\u7ec4\u5f15\u7528\u3002\u4f7f\u7528\u8be5\u7279\u6027\u9700\u8981GPU\u652f\u6301\u8be5\u529f\u80fd\uff0c\u5177\u4f53\u770b\u903b\u8f91\u8bbe\u5907\u7684\u521b\u5efa\u3002 VkPipelineViewportStateCreateInfo viewportState = {}; viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; viewportState.pScissors = &scissor; C++ \u5149\u6805\u5316 \u5149\u6805\u5316\u901a\u8fc7\u9876\u70b9\u7740\u8272\u5668\u53ca\u5177\u4f53\u7684\u51e0\u4f55\u7b97\u6cd5\u5c06\u9876\u70b9\u8fdb\u884c\u5851\u5f62\uff0c\u5e76\u5c06\u56fe\u5f62\u4f20\u9012\u5230\u7247\u6bb5\u7740\u8272\u5668\u8fdb\u884c\u7740\u8272\u5de5\u4f5c\u3002\u5b83\u4e5f\u4f1a\u6267\u884c\u6df1\u5ea6\u6d4b\u8bd5 depth testing \u3001\u9762\u88c1\u5207 face culling \u548c\u88c1\u526a\u6d4b\u8bd5\uff0c\u5b83\u53ef\u4ee5\u5bf9\u8f93\u51fa\u7684\u7247\u5143\u8fdb\u884c\u914d\u7f6e\uff0c\u51b3\u5b9a\u662f\u5426\u8f93\u51fa\u6574\u4e2a\u56fe\u5143\u62d3\u6251\u6216\u8005\u662f\u8fb9\u6846(\u7ebf\u6846\u6e32\u67d3)\u3002\u6240\u6709\u7684\u914d\u7f6e\u901a\u8fc7 VkPipelineRasterizationStateCreateInfo \u7ed3\u6784\u4f53\u5b9a\u4e49\u3002 VkPipelineRasterizationStateCreateInfo rasterizer = {}; rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterizer.depthClampEnable = VK_FALSE; C++ \u5b83\u7684 depthClampEnable \u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u8d85\u8fc7\u8fdc\u8fd1\u88c1\u526a\u9762\u7684\u7247\u5143\u4f1a\u8fdb\u884c\u6536\u655b\uff0c\u800c\u4e0d\u662f\u4e22\u5f03\u5b83\u4eec\u3002\u5b83\u5728\u7279\u6b8a\u7684\u60c5\u51b5\u4e0b\u6bd4\u8f83\u6709\u7528\uff0c\u50cf\u9634\u5f71\u8d34\u56fe\u3002\u4f7f\u7528\u8be5\u529f\u80fd\u9700\u8981\u5f97\u5230 GPU \u7684\u652f\u6301\u3002 rasterizer.rasterizerDiscardEnable = VK_FALSE; C++ \u5982\u679c rasterizerDiscardEnable \u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u90a3\u4e48\u51e0\u4f55\u56fe\u5143\u6c38\u8fdc\u4e0d\u4f1a\u4f20\u9012\u5230\u5149\u6805\u5316\u9636\u6bb5\u3002\u8fd9\u662f\u57fa\u672c\u7684\u7981\u6b62\u4efb\u4f55\u8f93\u51fa\u5230framebuffer\u5e27\u7f13\u51b2\u533a\u7684\u65b9\u6cd5\u3002 rasterizer.polygonMode = VK_POLYGON_MODE_FILL; C++ polygonMode \u51b3\u5b9a\u51e0\u4f55\u4ea7\u751f\u56fe\u7247\u7684\u5185\u5bb9\u3002\u4e0b\u5217\u6709\u6548\u6a21\u5f0f: VK_POLYGON_MODE_FILL : \u591a\u8fb9\u5f62\u533a\u57df\u586b\u5145 VK_POLYGON_MODE_LINE : \u591a\u8fb9\u5f62\u8fb9\u7f18\u7ebf\u6846\u7ed8\u5236 VK_POLYGON_MODE_POINT : \u591a\u8fb9\u5f62\u9876\u70b9\u4f5c\u4e3a\u63cf\u70b9\u7ed8\u5236 \u4f7f\u7528\u4efb\u4f55\u6a21\u5f0f\u586b\u5145\u9700\u8981\u5f00\u542fGPU\u529f\u80fd\u3002 rasterizer.lineWidth = 1.0f; C++ lineWidth \u6210\u5458\u662f\u76f4\u63a5\u586b\u5145\u7684\uff0c\u6839\u636e\u7247\u5143\u7684\u6570\u91cf\u63cf\u8ff0\u7ebf\u7684\u5bbd\u5ea6\u3002\u6700\u5927\u7684\u7ebf\u5bbd\u652f\u6301\u53d6\u51b3\u4e8e\u786c\u4ef6\uff0c\u4efb\u4f55\u5927\u4e8e 1.0 \u7684\u7ebf\u5bbd\u9700\u8981\u5f00\u542fGPU\u7684 wideLines \u7279\u6027\u652f\u6301\u3002 rasterizer.cullMode = VK_CULL_MODE_BACK_BIT; rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; C++ cullMode \u53d8\u91cf\u7528\u4e8e\u51b3\u5b9a\u9762\u88c1\u526a\u7684\u7c7b\u578b\u65b9\u5f0f\u3002\u53ef\u4ee5\u7981\u6b62 culling \uff0c\u88c1\u526a front faces \uff0c cull back faces \u6216\u8005\u5168\u90e8\u3002 frontFace \u7528\u4e8e\u63cf\u8ff0\u4f5c\u4e3a front-facing \u9762\u7684\u9876\u70b9\u7684\u987a\u5e8f\uff0c\u53ef\u4ee5\u662f\u987a\u65f6\u9488\u4e5f\u53ef\u4ee5\u662f\u9006\u65f6\u9488\u3002 rasterizer.depthBiasEnable = VK_FALSE; rasterizer.depthBiasConstantFactor = 0.0f; // Optional rasterizer.depthBiasClamp = 0.0f; // Optional rasterizer.depthBiasSlopeFactor = 0.0f; // Optional C++ \u5149\u6805\u5316\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u5e38\u91cf\u6216\u8005\u57fa\u4e8e\u7247\u5143\u7684\u659c\u7387\u6765\u66f4\u6539\u6df1\u5ea6\u503c\u3002\u4e00\u4e9b\u65f6\u5019\u5bf9\u4e8e\u9634\u5f71\u8d34\u56fe\u662f\u6709\u7528\u7684\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u4f1a\u5728\u7ae0\u8282\u4e2d\u4f7f\u7528\uff0c\u8bbe\u7f6e depthBiasEnable \u4e3a VK_FALSE \u3002 \u91cd\u91c7\u6837 VkPipelineMultisampleStateCreateInfo \u7ed3\u6784\u4f53\u7528\u4e8e\u914d\u7f6e\u591a\u91cd\u91c7\u6837\u3002\u6240\u8c13\u591a\u91cd\u91c7\u6837\u662f\u6297\u952f\u9f7f anti-aliasing \u7684\u4e00\u79cd\u5b9e\u73b0\u3002\u5b83\u901a\u8fc7\u7ec4\u5408\u591a\u4e2a\u591a\u8fb9\u5f62\u7684\u7247\u6bb5\u7740\u8272\u5668\u7ed3\u679c\uff0c\u5149\u6805\u5316\u5230\u540c\u4e00\u4e2a\u50cf\u7d20\u3002\u8fd9\u4e3b\u8981\u53d1\u751f\u5728\u8fb9\u7f18\uff0c\u8fd9\u4e5f\u662f\u6700\u5f15\u4eba\u6ce8\u76ee\u7684\u952f\u9f7f\u51fa\u73b0\u7684\u5730\u65b9\u3002\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u591a\u8fb9\u5f62\u6620\u5c04\u5230\u50cf\u7d20\u662f\u4e0d\u9700\u8981\u591a\u6b21\u8fd0\u884c\u7247\u6bb5\u7740\u8272\u5668\u8fdb\u884c\u91c7\u6837\u7684\uff0c\u76f8\u6bd4\u9ad8\u5206\u8fa8\u7387\u6765\u8bf4\uff0c\u5b83\u4f1a\u82b1\u8d39\u8f83\u4f4e\u7684\u5f00\u9500\u3002\u5f00\u542f\u8be5\u529f\u80fd\u9700\u8981GPU\u652f\u6301\u3002 VkPipelineMultisampleStateCreateInfo multisampling = {}; multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampling.sampleShadingEnable = VK_FALSE; multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; multisampling.minSampleShading = 1.0f; // Optional multisampling.pSampleMask = nullptr; // Optional multisampling.alphaToCoverageEnable = VK_FALSE; // Optional multisampling.alphaToOneEnable = VK_FALSE; // Optional C++ \u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u591a\u91cd\u91c7\u6837\uff0c\u4f46\u662f\u53ef\u4ee5\u968f\u610f\u7684\u5c1d\u8bd5\uff0c\u5177\u4f53\u7684\u53c2\u6570\u8bf7\u53c2\u9605\u89c4\u8303\u3002 \u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5 \u5982\u679c\u4f7f\u7528depth \u6216\u8005 stencil\u7f13\u51b2\u533a\uff0c\u9700\u8981\u4f7f\u7528 VkPipelineDepthStencilStateCreateInfo \u914d\u7f6e\u3002\u6211\u4eec\u73b0\u5728\u4e0d\u9700\u8981\u4f7f\u7528\uff0c\u6240\u4ee5\u7b80\u5355\u7684\u4f20\u9012 nullptr \uff0c\u5173\u4e8e\u8fd9\u90e8\u5206\u4f1a\u4e13\u95e8\u5728\u6df1\u5ea6\u7f13\u51b2\u533a\u7ae0\u8282\u4e2d\u8ba8\u8bba\u3002 \u989c\u8272\u6df7\u5408 \u7247\u6bb5\u7740\u8272\u5668\u8f93\u51fa\u5177\u4f53\u7684\u989c\u8272\uff0c\u5b83\u9700\u8981\u4e0e\u5e27\u7f13\u51b2\u533a framebuffer \u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\u3002\u8fd9\u4e2a\u8f6c\u6362\u7684\u8fc7\u7a0b\u6210\u4e3a\u6df7\u8272\uff0c\u5b83\u6709\u4e24\u79cd\u65b9\u5f0f: \u5c06old\u548cnew\u989c\u8272\u8fdb\u884c\u6df7\u5408\u4ea7\u51fa\u4e00\u4e2a\u6700\u7ec8\u7684\u989c\u8272 \u4f7f\u7528\u6309\u4f4d\u64cd\u4f5c\u6df7\u5408old\u548cnew\u989c\u8272\u7684\u503c \u6709\u4e24\u4e2a\u7ed3\u6784\u4f53\u7528\u4e8e\u914d\u7f6e\u989c\u8272\u6df7\u5408\u3002\u7b2c\u4e00\u4e2a\u7ed3\u6784\u4f53 VkPipelineColorBlendAttachmentState \u5305\u62ec\u4e86\u6bcf\u4e2a\u9644\u52a0\u5230\u5e27\u7f13\u51b2\u533a\u7684\u914d\u7f6e\u3002\u7b2c\u4e8c\u4e2a\u7ed3\u6784\u4f53 VkPipelineColorBlendStateCreateInfo \u5305\u542b\u4e86\u5168\u5c40\u6df7\u8272\u7684\u8bbe\u7f6e\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u4ec5\u4f7f\u7528\u7b2c\u4e00\u79cd\u65b9\u5f0f: VkPipelineColorBlendAttachmentState colorBlendAttachment = {}; colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; colorBlendAttachment.blendEnable = VK_FALSE; colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; // Optional colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; // Optional colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; // Optional colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; // Optional C++ \u8fd9\u79cd\u9488\u5bf9\u6bcf\u4e2a\u5e27\u7f13\u51b2\u533a\u914d\u7f6e\u6df7\u8272\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528\u5982\u4e0b\u4f2a\u4ee3\u7801\u8fdb\u884c\u8bf4\u660e: if (blendEnable) { finalColor.rgb = (srcColorBlendFactor * newColor.rgb) <colorBlendOp> (dstColorBlendFactor * oldColor.rgb); finalColor.a = (srcAlphaBlendFactor * newColor.a) <alphaBlendOp> (dstAlphaBlendFactor * oldColor.a); } else { finalColor = newColor; } finalColor = finalColor & colorWriteMask; C++ \u5982\u679c blendEnable \u8bbe\u7f6e\u4e3a VK_FALSE ,\u90a3\u4e48\u4ece\u7247\u6bb5\u7740\u8272\u5668\u8f93\u51fa\u7684\u65b0\u989c\u8272\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u5426\u5219\u4e24\u4e2a\u6df7\u8272\u64cd\u4f5c\u4f1a\u8ba1\u7b97\u65b0\u7684\u989c\u8272\u3002\u6240\u5f97\u5230\u7684\u7ed3\u679c\u4e0e colorWriteMask \u8fdb\u884cAND\u8fd0\u7b97\uff0c\u4ee5\u786e\u5b9a\u5b9e\u9645\u4f20\u9012\u7684\u901a\u9053\u3002 \u5927\u591a\u6570\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u6df7\u8272\u7528\u4e8e\u5b9e\u73b0 alpha blending \uff0c\u65b0\u7684\u989c\u8272\u4e0e\u65e7\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\u4f1a\u57fa\u4e8e\u5b83\u4eec\u7684 opacity \u900f\u660e\u901a\u9053\u3002 finalColor \u4f5c\u4e3a\u6700\u7ec8\u7684\u8f93\u51fa: finalColor.rgb = newAlpha * newColor + (1 - newAlpha) * oldColor; finalColor.a = newAlpha.a; C++ \u53ef\u4ee5\u901a\u8fc7\u4e00\u4e0b\u53c2\u6570\u5b8c\u6210: colorBlendAttachment.blendEnable = VK_TRUE; colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA; colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; C++ \u53ef\u4ee5\u5728\u89c4\u8303\u4e2d\u627e\u5230\u6240\u6709\u6709\u5173 VkBlendFactor \u548c VkBlendOp \u7684\u679a\u4e3e\u503c\u3002 \u7b2c\u4e8c\u4e2a\u7ed3\u6784\u4f53\u6301\u6709\u6240\u6709\u5e27\u7f13\u51b2\u533a\u7684\u5f15\u7528\uff0c\u5b83\u5141\u8bb8\u8bbe\u7f6e\u6df7\u5408\u64cd\u4f5c\u7684\u5e38\u91cf\uff0c\u8be5\u5e38\u91cf\u53ef\u4ee5\u4f5c\u4e3a\u540e\u7eed\u8ba1\u7b97\u7684\u6df7\u5408\u56e0\u5b50: VkPipelineColorBlendStateCreateInfo colorBlending = {}; colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; colorBlending.logicOpEnable = VK_FALSE; colorBlending.logicOp = VK_LOGIC_OP_COPY; // Optional colorBlending.attachmentCount = 1; colorBlending.pAttachments = &colorBlendAttachment; colorBlending.blendConstants[0] = 0.0f; // Optional colorBlending.blendConstants[1] = 0.0f; // Optional colorBlending.blendConstants[2] = 0.0f; // Optional colorBlending.blendConstants[3] = 0.0f; // Optional C++ \u5982\u679c\u9700\u8981\u4f7f\u7528\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u8bbe\u7f6e\u6df7\u5408\u64cd\u4f5c( bitwise combination ), \u9700\u8981\u8bbe\u7f6e logicOpEnable \u4e3a VK_TURE \u3002\u4e8c\u8fdb\u5236\u4f4d\u64cd\u4f5c\u5728 logicOp \u5b57\u6bb5\u4e2d\u6307\u5b9a\u3002\u5728\u7b2c\u4e00\u79cd\u65b9\u5f0f\u4e2d\u4f1a\u81ea\u52a8\u7981\u6b62\uff0c\u7b49\u540c\u4e8e\u4e3a\u6bcf\u4e00\u4e2a\u9644\u52a0\u7684\u5e27\u7f13\u51b2\u533aframebuffer\u5173\u95ed\u6df7\u5408\u64cd\u4f5c\uff0c blendEnable \u4e3a VK_FALSE \u3002 colorWriteMask \u63a9\u7801\u4f1a\u7528\u786e\u5b9a\u5e27\u7f13\u51b2\u533a\u4e2d\u5177\u4f53\u54ea\u4e2a\u901a\u9053\u7684\u989c\u8272\u53d7\u5230\u5f71\u54cd\u3002\u5b83\u4e5f\u53ef\u4ee5\u5728\u4e24\u79cd\u65b9\u5f0f\u4e0b\u7981\u6b62\uff0c\u622a\u81f3\u76ee\u524d\uff0c\u7247\u6bb5\u7f13\u51b2\u533a\u5411\u5e27\u7f13\u51b2\u533a\u4e2d\u8f93\u51fa\u7684\u989c\u8272\u4e0d\u4f1a\u8fdb\u884c\u4efb\u4f55\u53d8\u5316\u3002 \u52a8\u6001\u4fee\u6539 \u4e4b\u524d\u521b\u5efa\u7684\u4e00\u4e9b\u7ed3\u6784\u4f53\u7684\u72b6\u6001\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u52a8\u6001\u4fee\u6539\uff0c\u800c\u4e0d\u5fc5\u91cd\u65b0\u521b\u5efa\u3002\u6bd4\u5982 viewport \u7684\u5927\u5c0f, line width \u548c blend constants \u3002\u5982\u679c\u9700\u8981\u8fdb\u884c\u8fd9\u6837\u7684\u64cd\u4f5c\uff0c\u9700\u8981\u586b\u5145 VkPipelineDynamicStateCreateInfo \u7ed3\u6784\u4f53: VkDynamicState dynamicStates[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_LINE_WIDTH }; VkPipelineDynamicStateCreateInfo dynamicState = {}; dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO; dynamicState.dynamicStateCount = 2; dynamicState.pDynamicStates = dynamicStates; C++ \u5728\u7ed8\u5236\u7684\u8fc7\u7a0b\u4e2d\u6307\u5b9a\u8fd9\u4e9b\u6570\u636e\uff0c\u8fd9\u4f1a\u5bfc\u81f4\u5ffd\u7565\u4e4b\u524d\u7684\u76f8\u5173\u6570\u503c\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7684\u7ae0\u8282\u4e2d\u56de\u8fc7\u5934\u6765\u8ba8\u8bba\u3002\u5982\u679c\u6ca1\u6709\u4efb\u4f55\u9700\u8981\u52a8\u6001\u4fee\u6539\u7684\u6570\u503c\u6e05\u8bbe\u7f6e\u4e3a nullptr \u3002 \u7ba1\u9053\u5e03\u5c40 \u53ef\u4ee5\u5728\u7740\u8272\u5668\u4e2d\u4f7f\u7528 uniform \uff0c\u5b83\u662f\u7c7b\u4f3c\u4e0e\u52a8\u6001\u72b6\u6001\u53d8\u91cf\u7684\u5168\u5c40\u53d8\u91cf\uff0c\u53ef\u4ee5\u5728\u7ed8\u753b\u65f6\u4fee\u6539\uff0c\u53ef\u4ee5\u66f4\u6539\u7740\u8272\u5668\u7684\u884c\u4e3a\u800c\u65e0\u9700\u91cd\u65b0\u521b\u5efa\u5b83\u4eec\u3002\u5b83\u4eec\u901a\u5e38\u7528\u4e8e\u5c06\u53d8\u6362\u77e9\u9635\u4f20\u9012\u5230\u9876\u70b9\u7740\u8272\u5668\u6216\u8005\u5728\u7247\u6bb5\u7740\u8272\u5668\u51b2\u521b\u5efa\u7eb9\u7406\u91c7\u6837\u5668\u3002 \u8fd9\u4e9b uniform \u6570\u503c\u9700\u8981\u5728\u7ba1\u7ebf\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u901a\u8fc7 VkPipelineLayout \u5bf9\u8c61\u6307\u5b9a\u3002\u5373\u4f7f\u5728\u540e\u7eed\u5185\u5bb9\u4e2d\u7528\u5230\uff0c\u6211\u4eec\u4e5f\u4ecd\u7136\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u7a7a\u7684 pipeline layout \u3002 \u521b\u5efa\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709\u8be5\u5bf9\u8c61\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u540e\u7eed\u7ae0\u8282\u4e2d\u7684\u51fd\u6570\u4e2d\u5f15\u7528\u5b83: VkPipelineLayout pipelineLayout; C++ \u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u521b\u5efa\u5bf9\u8c61: VkPipelineLayoutCreateInfo pipelineLayoutInfo = {}; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; // Optional pipelineLayoutInfo.pSetLayouts = nullptr; // Optional pipelineLayoutInfo.pushConstantRangeCount = 0; // Optional pipelineLayoutInfo.pPushConstantRanges = 0; // Optional if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) { throw std::runtime_error(\"failed to create pipeline layout!\"); } C++ \u8be5\u7ed3\u6784\u4f53\u8fd8\u6307\u5b9a\u4e86 push \u5e38\u91cf\uff0c\u8fd9\u662f\u5c06\u52a8\u6001\u503c\u4f20\u9012\u7ed9\u7740\u8272\u5668\u7684\u62ce\u4e00\u4e2a\u65b9\u5f0f\u3002 pipeline layout \u53ef\u4ee5\u5728\u6574\u4e2a\u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\u5185\u5f15\u7528\uff0c\u6240\u4ee5\u5b83\u5728\u7a0b\u5e8f\u9000\u51fa\u7684\u65f6\u5019\u8fdb\u884c\u9500\u6bc1\u3002 void cleanup() { vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ... } C++ \u7ed3\u8bba \u8fd9\u5c31\u662f\u6240\u6709\u6709\u5173 fixed-function \u7684\u5185\u5bb9\uff0c\u770b\u8d77\u6765\u6709\u5f88\u591a\u7684\u5de5\u4f5c\u53bb\u505a\uff0c\u503c\u5f97\u5e86\u5e78\u7684\u662f\u6211\u4eec\u51e0\u4e4e\u4e86\u89e3\u4e86\u6240\u6709\u6709\u5173\u6e32\u67d3\u7ba1\u7ebf\u7684\u5185\u5bb9\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u51cf\u5c11\u4e86\u56e0\u4e3a\u4e0d\u4e86\u89e3\u67d0\u4e9b\u7ec4\u4ef6\u7684\u9ed8\u8ba4\u72b6\u6001\uff0c\u800c\u9020\u6210\u8fd0\u884c\u65f6\u78b0\u5230\u672a\u77e5\u884c\u4e3a\u7684\u53ef\u80fd\u6027\u3002 \u7136\u800c\uff0c\u5728\u6211\u4eec\u53ef\u4ee5\u6700\u7ec8\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u4e4b\u524d\uff0c\u8fd8\u6709\u4e00\u4e2a\u5bf9\u8c61\u9700\u8981\u521b\u5efa\uff0c\u5b83\u5c31\u662f render pass \u3002 Vulkan \u5e27\u7f13\u51b2\u533a Vulkan \u5e27\u7f13\u51b2\u533a \uff0c\u6211\u4eec\u5728\u524d\u9762\u7684\u7ae0\u8282\u4e2d\u5df2\u7ecf\u8ba8\u8bba\u4e86\u5f88\u591a\u6b21 framebuffers \u5e27\u7f13\u51b2\u533a\uff0c\u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u914d\u7f6e\u4e86 render pass \u6e32\u67d3\u901a\u9053\u5e76\u5e0c\u671b\u8f93\u51fa\u4e00\u4e2a\u4e0e\u4ea4\u6362\u94fe\u56fe\u50cf\u683c\u5f0f\u4e00\u81f4\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u4f46\u662f\u6211\u4eec\u5b9e\u9645\u4e0a\u8fd8\u6ca1\u6709\u521b\u5efa\u3002 \u5728 render pass \u521b\u5efa\u9636\u6bb5\u6211\u4eec\u6307\u5b9a\u4e86\u5177\u4f53\u7684\u9644\u4ef6\uff0c\u5e76\u901a\u8fc7 VkFramebuffer \u5bf9\u8c61\u5305\u88c5\u7ed1\u5b9a\u3002\u5e27\u7f13\u51b2\u533a\u5bf9\u8c61\u5f15\u7528\u8868\u793a\u4e3a\u9644\u4ef6\u7684\u6240\u6709\u7684 VkImageView \u5bf9\u8c61\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u53ea\u4f1a\u4f7f\u7528\u4e00\u4e2a\u5e27\u7f13\u51b2\u533a: color attachment \u3002\u7136\u800c\u6211\u4eec\u4f5c\u4e3a\u9644\u4ef6\u7684\u56fe\u50cf\u4f9d\u8d56\u4ea4\u6362\u94fe\u7528\u4e8e\u5448\u73b0\u65f6\u8fd4\u56de\u7684\u56fe\u50cf\u3002\u8fd9\u610f\u5473\u7740\u6211\u4eec\u5fc5\u987b\u4e3a\u4ea4\u6362\u94fe\u4e2d\u7684\u6240\u6709\u56fe\u50cf\u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u5728\u7ed8\u5236\u7684\u65f6\u5019\u4f7f\u7528\u5bf9\u5e94\u7684\u56fe\u50cf\u3002 \u6700\u540e\uff0c\u5728\u7c7b\u6210\u5458\u4e2d\u521b\u5efa\u53e6\u4e00\u4e2a std::vector \u7528\u4e8e\u4fdd\u5b58 framebuffers : std::vector<VkFramebuffer> swapChainFramebuffers; C++ \u6211\u4eec\u5728\u65b0\u7684\u51fd\u6570 createFramebuffers \u4e2d\u4e3a\u6570\u7ec4\u521b\u5efa\u5bf9\u8c61\u96c6\u5408\uff0c\u8fd9\u4e2a\u51fd\u6570\u5728 initVulkan \u521b\u5efa\u5b8c\u7ba1\u7ebf\u540e\u8c03\u7528: void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); } ... void createFramebuffers() { } C++ \u52a8\u6001\u8c03\u6574\u7528\u4e8e\u4fdd\u5b58 framebuffers \u7684\u5bb9\u5668\u5927\u5c0f: void createFramebuffers() { swapChainFramebuffers.resize(swapChainImageViews.size()); } C++ \u6211\u4eec\u63a5\u4e0b\u6765\u8fed\u4ee3\u5de6\u53f3\u7684\u56fe\u50cf\u89c6\u56fe\u5e76\u901a\u8fc7\u5b83\u4eec\u521b\u5efa\u5bf9\u5e94\u7684 framebuffers : for (size_t i = 0; i < swapChainImageViews.size(); i++) { VkImageView attachments[] = { swapChainImageViews[i] }; VkFramebufferCreateInfo framebufferInfo = {}; framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; framebufferInfo.renderPass = renderPass; framebufferInfo.attachmentCount = 1; framebufferInfo.pAttachments = attachments; framebufferInfo.width = swapChainExtent.width; framebufferInfo.height = swapChainExtent.height; framebufferInfo.layers = 1; if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &swapChainFramebuffers[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to create framebuffer!\"); } } C++ \u5982\u4f60\u6240\u89c1\uff0c\u521b\u5efa framebuffers \u662f\u975e\u5e38\u76f4\u63a5\u7684\u3002\u9996\u5148\u9700\u8981\u6307\u5b9a framebuffer \u9700\u8981\u517c\u5bb9\u7684 renderPass \u3002\u6211\u4eec\u53ea\u80fd\u4f7f\u7528\u4e0e\u5176\u517c\u5bb9\u7684\u6e32\u67d3\u901a\u9053\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u8fd9\u5927\u4f53\u4e0a\u610f\u5473\u7740\u5b83\u4eec\u4f7f\u7528\u76f8\u540c\u7684\u9644\u4ef6\u6570\u91cf\u548c\u7c7b\u578b\u3002 attachmentCount \u548c pAttachments \u53c2\u6570\u6307\u5b9a\u5728\u6e32\u67d3\u901a\u9053\u7684 pAttachment \u6570\u7ec4\u4e2d\u7ed1\u5b9a\u5230\u76f8\u5e94\u7684\u9644\u4ef6\u63cf\u8ff0\u7684 VkImageView \u5bf9\u8c61\u3002 width \u548c height \u53c2\u6570\u662f\u5bb9\u6613\u7406\u89e3\u7684\uff0c layer \u662f\u6307\u5b9a\u56fe\u50cf\u6570\u7ec4\u4e2d\u7684\u5c42\u6570\u3002\u6211\u4eec\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u662f\u5355\u4e2a\u56fe\u50cf\uff0c\u56e0\u6b64\u5c42\u6570\u4e3a 1 \u3002 \u6211\u4eec\u5728\u56fe\u50cf\u89c6\u56fe\u548c\u6e32\u67d3\u901a\u9053\u6e32\u67d3\u5b8c\u6bd5\u4e4b\u540e\uff0c\u5220\u9664\u5bf9\u5e94\u7684\u5e27\u7f13\u51b2\u533a: void cleanup() { for (size_t i = 0; i < swapChainFramebuffers.size(); i++) { vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); } ... } C++ \u6211\u4eec\u5df2\u7ecf\u8fbe\u5230\u4e86\u4e00\u4e2a\u91cc\u7a0b\u7891\uff0c\u6211\u4eec\u62e5\u6709\u6e32\u67d3\u9700\u8981\u7684\u6240\u6709\u5bf9\u8c61\u3002\u5728\u4e0b\u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u7f16\u5199\u7b2c\u4e00\u4e2a\u5b9e\u9645\u7ed8\u5236\u7684\u547d\u4ee4\u3002 Vulkan \u6e32\u67d3\u901a\u9053 Vulkan \u6e32\u67d3\u901a\u9053 \uff0c\u5728\u6211\u4eec\u5b8c\u6210\u7ba1\u7ebf\u7684\u521b\u5efa\u5de5\u4f5c\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9 Vulkan \u6e32\u67d3\u65f6\u5019\u4f7f\u7528\u7684 framebuffer \u5e27\u7f13\u51b2\u533a\u9644\u4ef6\u76f8\u5173\u4fe1\u606f\u3002\u6211\u4eec\u9700\u8981\u6307\u5b9a\u591a\u5c11\u4e2a\u989c\u8272\u548c\u6df1\u5ea6\u7f13\u51b2\u533a\u5c06\u4f1a\u88ab\u4f7f\u7528\uff0c\u6307\u5b9a\u591a\u5c11\u4e2a\u91c7\u6837\u5668\u88ab\u7528\u5230\u53ca\u5728\u6574\u4e2a\u6e32\u67d3\u64cd\u4f5c\u4e2d\u76f8\u5173\u7684\u5185\u5bb9\u5982\u4f55\u5904\u7406\u3002\u6240\u6709\u7684\u8fd9\u4e9b\u4fe1\u606f\u90fd\u88ab\u5c01\u88c5\u5728\u4e00\u4e2a\u53eb\u505a render pass \u7684\u5bf9\u8c61\u4e2d\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u8bbe\u7f6e 2 \u9644\u4ef6\u63cf\u8ff0 3 \u5b50\u901a\u9053\u548c\u9644\u4ef6\u5f15\u7528 4 \u6e32\u67d3\u901a\u9053 \u8bbe\u7f6e \u6211\u4eec\u65b0\u6dfb\u52a0\u4e00\u4e2a createRenderPass \u51fd\u6570\uff0c\u5728 initVulkan \u51fd\u6570\u4e2d\u786e\u4fdd createGraphicsPipeline \u8c03\u7528\u4e4b\u524d\uff0c\u8c03\u7528\u5b83\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); } ... void createRenderPass() { } C++ \u9644\u4ef6\u63cf\u8ff0 \u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u5c06\u53ea\u6709\u4e00\u4e2a\u989c\u8272\u7f13\u51b2\u533a\u9644\u4ef6\uff0c\u5b83\u7531\u4ea4\u6362\u94fe\u4e2d\u7684\u4e00\u4e2a\u56fe\u50cf\u6240\u8868\u793a\u3002 void createRenderPass() { VkAttachmentDescription colorAttachment = {}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; } C++ format \u662f\u989c\u8272\u9644\u4ef6\u7684\u683c\u5f0f\uff0c\u5b83\u5e94\u8be5\u4e0e\u4ea4\u6362\u94fe\u4e2d\u56fe\u50cf\u7684\u683c\u5f0f\u76f8\u5339\u914d\uff0c\u540c\u65f6\u6211\u4eec\u4e0d\u4f1a\u505a\u4efb\u4f55\u591a\u91cd\u91c7\u6837\u7684\u5de5\u4f5c\uff0c\u6240\u4ee5\u91c7\u6837\u5668\u8bbe\u7f6e\u4e3a1\u3002 colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; C++ loadOp \u548c storeOp \u51b3\u5b9a\u4e86\u6e32\u67d3\u524d\u548c\u6e32\u67d3\u540e\u6570\u636e\u5728\u5bf9\u5e94\u9644\u4ef6\u7684\u64cd\u4f5c\u884c\u4e3a\u3002\u5bf9\u4e8e loadOp \u6211\u4eec\u6709\u5982\u4e0b\u9009\u9879\uff1a VK_ATTACHMENT_LOAD_OP_LOAD : \u4fdd\u5b58\u5df2\u7ecf\u5b58\u5728\u4e8e\u5f53\u524d\u9644\u4ef6\u7684\u5185\u5bb9 VK_ATTACHMENT_LOAD_OP_CLEAR : \u8d77\u59cb\u9636\u6bb5\u4ee5\u4e00\u4e2a\u5e38\u91cf\u6e05\u7406\u9644\u4ef6\u5185\u5bb9 VK_ATTACHMENT_LOAD_OP_DONT_CARE : \u5b58\u5728\u7684\u5185\u5bb9\u672a\u5b9a\u4e49\uff0c\u5ffd\u7565\u5b83\u4eec \u5728\u7ed8\u5236\u65b0\u7684\u4e00\u5e27\u5185\u5bb9\u4e4b\u524d\uff0c\u6211\u4eec\u8981\u505a\u7684\u662f\u4f7f\u7528\u6e05\u7406\u64cd\u4f5c\u6765\u6e05\u7406\u5e27\u7f13\u51b2\u533aframebuffer\u4e3a\u9ed1\u8272\u3002\u540c\u65f6\u5bf9\u4e8e storeOp \u4ec5\u6709\u4e24\u4e2a\u9009\u9879\uff1a VK_ATTACHMENT_STORE_OP_STORE : \u6e32\u67d3\u7684\u5185\u5bb9\u4f1a\u5b58\u50a8\u5728\u5185\u5b58\uff0c\u5e76\u5728\u4e4b\u540e\u8fdb\u884c\u8bfb\u53d6\u64cd\u4f5c VK_ATTACHMENT_STORE_OP_DONT_CARE : \u5e27\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u5728\u6e32\u67d3\u64cd\u4f5c\u5b8c\u6bd5\u540e\u8bbe\u7f6e\u4e3aundefined \u6211\u4eec\u8981\u505a\u7684\u662f\u6e32\u67d3\u4e00\u4e2a\u4e09\u89d2\u5f62\u5728\u5c4f\u5e55\u4e0a\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u5b58\u50a8\u64cd\u4f5c\u3002 colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; C++ loadOp \u548c storeOp \u5e94\u7528\u5728\u989c\u8272\u548c\u6df1\u5ea6\u6570\u636e\uff0c\u540c\u65f6 stencilLoadOp / stencilStoreOp \u5e94\u7528\u5728\u6a21\u7248\u6570\u636e\u3002\u6211\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u4e0d\u4f1a\u505a\u4efb\u4f55\u6a21\u7248\u7f13\u51b2\u533a\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u5b83\u7684loading\u548cstoring\u65e0\u5173\u7d27\u8981\u3002 colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; C++ \u7eb9\u7406\u548c\u5e27\u7f13\u51b2\u533a\u5728Vulkan\u4e2d\u901a\u5e38\u7528 VkImage \u5bf9\u8c61\u914d\u4ee5\u67d0\u79cd\u50cf\u7d20\u683c\u5f0f\u6765\u4ee3\u8868\u3002\u4f46\u662f\u50cf\u7d20\u5728\u5185\u5b58\u4e2d\u7684\u5e03\u5c40\u53ef\u4ee5\u57fa\u4e8e\u9884\u8981\u5bf9image\u56fe\u50cf\u8fdb\u884c\u7684\u64cd\u4f5c\u53d1\u751f\u5185\u5b58\u5e03\u5c40\u7684\u53d8\u5316\u3002 \u4e00\u4e9b\u5e38\u7528\u7684\u5e03\u5c40: VK_IMAGE_LAYOUT_COLOR_ATTACHMET_OPTIMAL : \u56fe\u50cf\u4f5c\u4e3a\u989c\u8272\u9644\u4ef6 VK_IMAGE_LAYOUT_PRESENT_SRC_KHR : \u56fe\u50cf\u5728\u4ea4\u6362\u94fe\u4e2d\u88ab\u5448\u73b0 VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL : \u56fe\u50cf\u4f5c\u4e3a\u76ee\u6807\uff0c\u7528\u4e8e\u5185\u5b58COPY\u64cd\u4f5c \u6211\u4eec\u4f1a\u6df1\u5165\u8ba8\u8bba\u8fd9\u4e9b\u5185\u5bb9\u5728\u7eb9\u7406\u7ae0\u8282\uff0c\u73b0\u5728\u6700\u91cd\u8981\u7684\u662f\u4e3a\u9700\u8981\u8f6c\u53d8\u7684\u56fe\u50cf\u6307\u5b9a\u5408\u9002\u7684layout\u5e03\u5c40\u8fdb\u884c\u64cd\u4f5c\u3002 initialLayout \u6307\u5b9a\u56fe\u50cf\u5728\u5f00\u59cb\u8fdb\u5165\u6e32\u67d3\u901a\u9053render pass\u524d\u5c06\u8981\u4f7f\u7528\u7684\u5e03\u5c40\u7ed3\u6784\u3002 finalLayout \u6307\u5b9a\u5f53\u6e32\u67d3\u901a\u9053\u7ed3\u675f\u81ea\u52a8\u53d8\u6362\u65f6\u4f7f\u7528\u7684\u5e03\u5c40\u3002\u4f7f\u7528 VK_IMAGE_LAYOUT_UNDEFINED \u8bbe\u7f6e initialLayout \uff0c\u610f\u4e3a\u4e0d\u5173\u5fc3\u56fe\u50cf\u4e4b\u524d\u7684\u5e03\u5c40\u3002\u7279\u6b8a\u503c\u8868\u660e\u56fe\u50cf\u7684\u5185\u5bb9\u4e0d\u786e\u5b9a\u4f1a\u88ab\u4fdd\u7559\uff0c\u4f46\u662f\u8fd9\u5e76\u4e0d\u603b\u8981\uff0c\u56e0\u4e3a\u65e0\u8bba\u5982\u4f55\u6211\u4eec\u90fd\u8981\u6e05\u7406\u5b83\u3002\u6211\u4eec\u5e0c\u671b\u56fe\u50cf\u6e32\u67d3\u5b8c\u6bd5\u540e\u4f7f\u7528\u4ea4\u6362\u94fe\u8fdb\u884c\u5448\u73b0\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48 finalLayout \u8981\u8bbe\u7f6e\u4e3a VK_IMAGE_LAYOUT_PRESENT_SRC_KHR \u3002 \u5982\u679c\u6ca1\u6709\u641e\u6e05\u695a\u5e03\u5c40\u5b58\u5728\u7684\u610f\u4e49\uff0c\u8fdb\u4e00\u6b65\u89e3\u91calayout\u8bf7\u770b\u5982\u4e0b\u56fe\u793a: \u4e00\u822c\u610f\u4e49\u4e0a\uff0c\u6211\u4eec\u7406\u89e3 CPU \u8fdb\u884c\u5185\u5b58\u4e2d\u7684\u6570\u636e\u8bfb\u5199\u5f80\u5f80\u90fd\u662f\u7ebf\u6027\u6392\u5e8f\u7684 linear memory layout \uff0c\u53ef\u4ee5\u770b\u5230 AB \u4e0e CD \u4f5c\u4e3a\u6765\u4e2a\u8fde\u7eed\u7684\u884c\u6765\u8fdb\u884c\u8bfb\u53d6\u3002\u4f46\u662f\u5728\u5f88\u591a\u65f6\u5019\u5bf9\u4e8e\u50cf\u7d20\u7eb9\u7406\u6570\u636e\u7684\u64cd\u4f5c\u662f\u975e\u7ebf\u6027\u8fde\u7eed\u7684\uff0c\u8fd9\u79cd\u60c5\u666f\u66f4\u591a\u53d1\u751f\u5728 GPU \u64cd\u4f5c\u4e2d\uff0c\u6240\u4ee5 GPU \u786c\u4ef6\u66f4\u591a\u7684\u652f\u6301\u57fa\u4e8e( Tiled )\u5e73\u94fa\u7684\u6216\u8005\u6210\u4e3a\u6700\u4f73\u7684\u5185\u5b58\u5e03\u5c40\u7ed3\u6784\uff0c\u6765\u63d0\u964d\u4f4e GPU \u5904\u7406\u6570\u636e\u7684\u5f00\u9500\u3002 \u6240\u4ee5\u4ece CPU linear layout \u5185\u5b58\u6570\u636e \u5230 GPU optimal layout \u663e\u5b58\u6570\u636e\u7684\u8bfb\u5199 \u5f80\u8fd4\u4e4b\u95f4\u5b58\u5728\u6570\u636e\u5b58\u50a8\u683c\u5f0f\u7684\u4f18\u5316\u8f6c\u53d8\u6b65\u9aa4\u3002 \u5b50\u901a\u9053\u548c\u9644\u4ef6\u5f15\u7528 \u4e00\u4e2a\u5355\u72ec\u7684\u6e32\u67d3\u901a\u9053\u53ef\u4ee5\u7531\u591a\u4e2a\u5b50\u901a\u9053\u7ec4\u6210\u3002\u5b50\u901a\u9053\u662f\u6e32\u67d3\u64cd\u4f5c\u7684\u4e00\u4e2a\u5e8f\u5217\u3002\u5b50\u901a\u9053\u4f5c\u7528\u4e0e\u540e\u7eed\u7684\u6e32\u67d3\u64cd\u4f5c\uff0c\u5e76\u4f9d\u8d56\u4e4b\u524d\u6e32\u67d3\u901a\u9053\u8f93\u51fa\u5230\u5e27\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u3002\u6bd4\u5982\u8bf4\u540e\u5904\u7406\u6548\u679c\u7684\u5e8f\u5217\u901a\u5e38\u6bcf\u4e00\u6b65\u90fd\u4f9d\u8d56\u4e4b\u524d\u7684\u64cd\u4f5c\u3002\u5982\u679c\u5c06\u8fd9\u4e9b\u6e32\u67d3\u64cd\u4f5c\u5206\u7ec4\u5230\u4e00\u4e2a\u6e32\u67d3\u901a\u9053\u4e2d\uff0c\u901a\u8fc7 Vulkan \u5c06\u901a\u9053\u4e2d\u7684\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u91cd\u6392\u5e8f\uff0c\u53ef\u4ee5\u8282\u7701\u5185\u5b58\u4ece\u800c\u83b7\u5f97\u66f4\u597d\u7684\u6027\u80fd\u3002\u5bf9\u4e8e\u6211\u4eec\u8981\u7ed8\u5236\u7684\u4e09\u89d2\u5f62\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4e00\u4e2a\u5b50\u901a\u9053\u3002 \u6bcf\u4e2a\u5b50\u901a\u9053\u5f15\u7528\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\u4e4b\u524d\u4f7f\u7528\u7ed3\u6784\u4f53\u63cf\u8ff0\u7684\u9644\u4ef6\u3002\u8fd9\u4e9b\u5f15\u7528\u672c\u8eab\u5c31\u662f VkAttachmentReference \u7ed3\u6784\u4f53: VkAttachmentReference colorAttachmentRef = {}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; C++ attachment \u9644\u4ef6\u53c2\u6570\u901a\u8fc7\u9644\u4ef6\u63cf\u8ff0\u7b26\u96c6\u5408\u4e2d\u7684\u7d22\u5f15\u6765\u6301\u6709\u3002\u6211\u4eec\u7684\u96c6\u5408\u662f\u7531\u4e00\u4e2a VkAttachmentDesription \u7ec4\u6210\u7684\uff0c\u6240\u4ee5\u5b83\u7684\u7d22\u5f15\u4e3a 0 \u3002 layout \u4e3a\u9644\u4ef6\u6307\u5b9a\u5b50\u901a\u9053\u5728\u6301\u6709\u5f15\u7528\u65f6\u5019\u7684layout\u3002\u5f53\u5b50\u901a\u9053\u5f00\u59cb\u7684\u65f6\u5019Vulkan\u4f1a\u81ea\u52a8\u8f6c\u53d8\u9644\u4ef6\u5230\u8fd9\u4e2alayout\u3002\u56e0\u4e3a\u6211\u4eec\u671f\u671b\u9644\u4ef6\u8d77\u5230\u989c\u8272\u7f13\u51b2\u533a\u7684\u4f5c\u7528\uff0clayout\u8bbe\u7f6e\u4e3a VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL \u4f1a\u7ed9\u6211\u4eec\u6700\u597d\u7684\u6027\u80fd\u3002 \u5b50\u901a\u9053\u4f7f\u7528 VkSubpassDescription \u7ed3\u6784\u4f53\u63cf\u8ff0: VkSubpassDescription subpass = {}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; C++ Vulkan\u5728\u672a\u6765\u53ef\u80fd\u4f1a\u652f\u6301\u5173\u4e8e compute subpasses \u7684\u529f\u80fd\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u4eec\u660e\u786e\u6307\u5b9a graphics subpass \u56fe\u5f62\u5b50\u901a\u9053\u3002\u4e0b\u4e00\u6b65\u4e3a\u5b83\u6307\u5b9a\u989c\u8272\u9644\u4ef6\u7684\u5f15\u7528: subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; C++ \u9644\u4ef6\u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15\u76f4\u63a5\u4ece\u7247\u6bb5\u7740\u8272\u5668\u5f15\u7528\uff0c\u5176 layout(location = 0) out vec4 outColor \u6307\u4ee4! \u53ef\u4ee5\u88ab\u5b50\u901a\u9053\u5f15\u7528\u7684\u9644\u4ef6\u7c7b\u578b\u5982\u4e0b: pInputAttachments : \u9644\u4ef6\u4ece\u7740\u8272\u5668\u4e2d\u8bfb\u53d6 pResolveAttachments : \u9644\u4ef6\u7528\u4e8e\u989c\u8272\u9644\u4ef6\u7684\u591a\u91cd\u91c7\u6837 pDepthStencilAttachment : \u9644\u4ef6\u7528\u4e8e\u6df1\u5ea6\u548c\u6a21\u7248\u6570\u636e pPreserveAttachments : \u9644\u4ef6\u4e0d\u88ab\u5b50\u901a\u9053\u4f7f\u7528\uff0c\u4f46\u662f\u6570\u636e\u88ab\u4fdd\u5b58 \u6e32\u67d3\u901a\u9053 \u73b0\u5728\u9644\u4ef6\u548c\u57fa\u672c\u7684\u5b50\u901a\u9053\u5df2\u7ecf\u4ecb\u7ecd\u8fc7\u4e86\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u6e32\u67d3\u901a\u9053\u4e86\u3002\u9996\u5148\u65b0\u5efa\u4e00\u4e2a\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709 VkRenderPass \u5bf9\u8c61\uff0c\u8be5\u53d8\u91cf\u5728 pipelineLayout \u4e0a\u5b9a\u4e49: VkRenderPass renderPass; VkPipelineLayout pipelineLayout; C++ \u6e32\u67d3\u901a\u9053\u5bf9\u8c61\u521b\u5efa\u901a\u8fc7\u586b\u5145 VkRenderPassCreateInfo \u7ed3\u6784\u4f53\uff0c\u5e76\u914d\u5408\u76f8\u5173\u9644\u4ef6\u548c\u5b50\u901a\u9053\u6765\u5b8c\u6210\u3002 VkAttachmentReference \u5bf9\u8c61\u5f15\u7528\u9644\u4ef6\u6570\u7ec4\u3002 VkRenderPassCreateInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } C++ \u5c31\u50cf pipeline layout \u4e00\u6837\uff0c\u6e32\u67d3\u901a\u9053\u5728\u6574\u4e2a\u7a0b\u5e8f\u751f\u547d\u5468\u671f\u5185\u90fd\u88ab\u4f7f\u7528\uff0c\u6240\u4ee5\u9700\u8981\u5728\u9000\u51fa\u9636\u6bb5\u8fdb\u884c\u6e05\u7406\uff1a void cleanup() { vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); ... } C++ \u8fd9\u770b\u8d77\u6765\u5f88\u591a\u5de5\u4f5c\u91cf\uff0c\u4f46\u662f\u5728 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u4f1a\u628a\u6240\u6709\u7684\u7ec4\u4ef6\u6574\u5408\u8d77\u6765\uff0c\u521b\u5efa\u6700\u7ec8\u7684\u56fe\u5f62\u7ba1\u7ebf\u5bf9\u8c61\u3002 Vulkan \u96c6\u6210\u7ba1\u7ebf ulkan \u96c6\u6210\u7ba1\u7ebf \uff0c\u6211\u4eec\u73b0\u5728\u6574\u5408\u524d\u51e0\u7ae0\u8282\u7684\u7ed3\u6784\u4f53\u548c \u5bf9\u8c61\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf \uff01\u4ee5\u4e0b\u662f\u6211\u4eec\u73b0\u5728\u7528\u5230\u7684\u5bf9\u8c61\u7c7b\u578b\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u5feb\u901f\u56de\u987e: Shader stages : \u7740\u8272\u5668\u6a21\u5757\u5b9a\u4e49\u4e86\u56fe\u5f62\u7ba1\u7ebf\u53ef\u7f16\u7a0b\u9636\u6bb5\u7684\u529f\u80fd Fixed-function state : \u7ed3\u6784\u4f53\u5b9a\u4e49\u56fa\u5b9a\u7ba1\u7ebf\u529f\u80fd\uff0c\u6bd4\u5982\u8f93\u5165\u88c5\u914d\u3001\u5149\u6805\u5316\u3001viewport\u548ccolor blending Pipeline layout : \u7ba1\u7ebf\u5e03\u5c40\u5b9a\u4e49uniform \u548c push values\uff0c\u88ab\u7740\u8272\u5668\u6bcf\u4e00\u6b21\u7ed8\u5236\u7684\u65f6\u5019\u5f15\u7528 Render pass : \u6e32\u67d3\u901a\u9053\u901a\u8fc7\u7ba1\u7ebf\u9636\u6bb5\u5f15\u7528\u9644\u4ef6\uff0c\u5e76\u5b9a\u4e49\u5b83\u7684\u4f7f\u7528\u65b9\u5f0f \u6240\u6709\u8fd9\u4e9b\u51b3\u5b9a\u4e86\u56fe\u5f62\u7ba1\u7ebf\u7684\u6700\u7ec8\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u5728 createGraphicsPipeline \u51fd\u6570\u7684\u6700\u540e\u586b\u5145 VkGraphicsPipelineCreateInfo \u7ed3\u6784\u4f53\u3002 VkGraphicsPipelineCreateInfo pipelineInfo = {}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 2; pipelineInfo.pStages = shaderStages; C++ \u73b0\u5728\u5f00\u59cb\u5f15\u7528\u4e4b\u524d\u7684 VkPipelineShaderStageCreateInfo \u7ed3\u6784\u4f53\u6570\u7ec4\u3002 pipelineInfo.pVertexInputState = &vertexInputInfo; pipelineInfo.pInputAssemblyState = &inputAssembly; pipelineInfo.pViewportState = &viewportState; pipelineInfo.pRasterizationState = &rasterizer; pipelineInfo.pMultisampleState = &multisampling; pipelineInfo.pDepthStencilState = nullptr; // Optional pipelineInfo.pColorBlendState = &colorBlending; pipelineInfo.pDynamicState = nullptr; // Optional C++ \u5e76\u5f15\u7528\u4e4b\u524d\u63cf\u8ff0\u56fa\u5b9a\u7ba1\u7ebf\u529f\u80fd\u7684\u7ed3\u6784\u4f53\u3002 pipelineInfo.layout = pipelineLayout; C++ \u5b8c\u6210\u4e4b\u540e\uff0c pipeline layout \u7ba1\u7ebf\u5e03\u5c40\uff0c\u5b83\u662f\u4e00\u4e2a Vulkan \u53e5\u67c4\u800c\u4e0d\u662f\u7ed3\u6784\u4f53\u6307\u9488\u3002 pipelineInfo.renderPass = renderPass; pipelineInfo.subpass = 0; C++ \u6700\u540e\u6211\u4eec\u9700\u8981\u5f15\u7528 render pass \u548c\u56fe\u5f62\u7ba1\u7ebf\u5c06\u8981\u4f7f\u7528\u7684\u5b50\u901a\u9053 sub pass \u7684\u7d22\u5f15\u3002 pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; // Optional pipelineInfo.basePipelineIndex = -1; // Optional C++ \u5b9e\u9645\u4e0a\u8fd8\u6709\u4e24\u4e2a\u53c2\u6570: basePipelineHandle \u548c basePipelineIndex \u3002Vulkan\u5141\u8bb8\u60a8\u901a\u8fc7\u5df2\u7ecf\u5b58\u5728\u7684\u7ba1\u7ebf\u521b\u5efa\u65b0\u7684\u56fe\u5f62\u7ba1\u7ebf\u3002\u8fd9\u79cd\u884d\u751f\u51fa\u65b0\u7ba1\u7ebf\u7684\u60f3\u6cd5\u5728\u4e8e\uff0c\u5f53\u8981\u521b\u5efa\u7684\u7ba1\u7ebf\u4e0e\u73b0\u6709\u7ba1\u9053\u529f\u80fd\u76f8\u540c\u65f6\uff0c\u83b7\u5f97\u8f83\u4f4e\u7684\u5f00\u9500\uff0c\u540c\u65f6\u4e5f\u53ef\u4ee5\u66f4\u5feb\u7684\u5b8c\u6210\u7ba1\u7ebf\u5207\u6362\uff0c\u5f53\u5b83\u4eec\u6765\u81ea\u540c\u4e00\u4e2a\u7236\u7ba1\u7ebf\u3002\u53ef\u4ee5\u901a\u8fc7 basePipelineHandle \u6307\u5b9a\u73b0\u6709\u7ba1\u7ebf\u7684\u53e5\u67c4\uff0c\u4e5f\u53ef\u4ee5\u5f15\u7528\u7531 basePipelineIndex \u6240\u4ee5\u521b\u5efa\u7684\u53e6\u4e00\u4e2a\u7ba1\u7ebf\u3002\u76ee\u524d\u53ea\u6709\u4e00\u4e2a\u7ba1\u7ebf\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u6307\u5b9a\u4e00\u4e2a\u7a7a\u53e5\u67c4\u548c\u4e00\u4e2a\u65e0\u6548\u7684\u7d22\u5f15\u3002\u53ea\u6709\u5728 VkGraphicsPipelineCreateInfo \u7684 flags \u5b57\u6bb5\u4e2d\u4e5f\u6307\u5b9a\u4e86 VK_PIPELINE_CREATE_DERIVATIVE_BIT \u6807\u5fd7\u65f6\uff0c\u624d\u9700\u8981\u4f7f\u7528\u8fd9\u4e9b\u503c\u3002 \u73b0\u5728\u51c6\u5907\u6700\u540e\u4e00\u6b65\uff0c\u521b\u5efa\u4e00\u4e2a\u7c7b\u6210\u5458\u4fdd\u5b58 VkPipeline \u5bf9\u8c61: VkPipeline graphicsPipeline; C++ \u6700\u540e\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf: if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline) != VK_SUCCESS) { throw std::runtime_error(\"failed to create graphics pipeline!\"); } C++ vkCreateGraphicsPipelines \u51fd\u6570\u5728Vulkan\u4e2d\u6bd4\u8d77\u4e00\u822c\u7684\u521b\u5efa\u5bf9\u8c61\u51fd\u6570\u9700\u8981\u66f4\u591a\u7684\u53c2\u6570\u3002\u5b83\u53ef\u4ee5\u7528\u6765\u4f20\u9012\u591a\u4e2a VkGraphicsPipelineCreateInfo \u5bf9\u8c61\u5e76\u521b\u5efa\u591a\u4e2a VkPipeline \u5bf9\u8c61\u3002 \u6211\u4eec\u4f20\u9012 VK_NULL_HANDLE \u53c2\u6570\u4f5c\u4e3a\u7b2c\u4e8c\u4e2a\u53c2\u6570\uff0c\u4f5c\u4e3a\u53ef\u9009 VkPipelineCache \u5bf9\u8c61\u7684\u5f15\u7528\u3002\u7ba1\u7ebf\u7f13\u5b58\u53ef\u4ee5\u7528\u4e8e\u5b58\u50a8\u548c\u590d\u7528\u4e0e\u901a\u8fc7\u591a\u6b21\u8c03\u7528 vkCreateGraphicsPipelines \u51fd\u6570\u76f8\u5173\u7684\u6570\u636e\uff0c\u751a\u81f3\u5728\u7a0b\u5e8f\u6267\u884c\u7684\u65f6\u5019\u7f13\u5b58\u5230\u4e00\u4e2a\u6587\u4ef6\u4e2d\u3002\u8fd9\u6837\u53ef\u4ee5\u52a0\u901f\u540e\u7eed\u7684\u7ba1\u7ebf\u521b\u5efa\u903b\u8f91\u3002\u5177\u4f53\u7684\u5185\u5bb9\u6211\u4eec\u4f1a\u5728\u7ba1\u7ebf\u7f13\u5b58\u7ae0\u8282\u4ecb\u7ecd\u3002 \u56fe\u5f62\u7ba1\u7ebf\u5bf9\u4e8e\u5e38\u89c1\u7684\u7ed8\u56fe\u64cd\u4f5c\u662f\u5fc5\u987b\u7684\uff0c\u6240\u4ee5\u5b83\u4e5f\u5e94\u8be5\u5728\u7a0b\u5e8f\u7ed3\u675f\u65f6\u9500\u6bc1: void cleanup() { vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ... } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\uff0c\u786e\u8ba4\u6240\u6709\u5de5\u4f5c\u6b63\u5e38\uff0c\u5e76\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u6210\u529f\uff01\u6211\u4eec\u5df2\u7ecf\u65e0\u6bd4\u63a5\u8fd1\u5728\u5c4f\u5e55\u4e0a\u7ed8\u5236\u51fa\u4e1c\u897f\u6765\u4e86\u3002\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u4e2a\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4ece\u4ea4\u6362\u94fe\u56fe\u50cf\u4e2d\u8bbe\u7f6e\u5b9e\u9645\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u51c6\u5907\u7ed8\u5236\u547d\u4ee4\u3002 Vulkan \u547d\u4ee4\u7f13\u51b2\u533a Vulkan \u547d\u4ee4\u7f13\u51b2\u533a \uff0c\u8bf8\u5982\u7ed8\u5236\u548c\u5185\u5b58\u64cd\u4f5c\u76f8\u5173\u547d\u4ee4\uff0c\u5728 Vulkan \u4e2d\u4e0d\u662f\u901a\u8fc7\u51fd\u6570\u76f4\u63a5\u8c03\u7528\u7684\u3002\u6211\u4eec\u9700\u8981\u5728\u547d\u4ee4\u7f13\u51b2\u533a\u5bf9\u8c61\u4e2d\u8bb0\u5f55\u6211\u4eec\u671f\u671b\u7684\u4efb\u4f55\u64cd\u4f5c\u3002\u8fd9\u6837\u505a\u7684\u4f18\u70b9\u662f\u53ef\u4ee5\u63d0\u524d\u5728\u591a\u7ebf\u7a0b\u4e2d\u5b8c\u6210\u6240\u6709\u7ed8\u5236\u547d\u4ee4\u76f8\u5173\u7684\u88c5\u914d\u5de5\u4f5c\uff0c\u5e76\u5728\u4e3b\u7ebf\u7a0b\u5faa\u73af\u7ed3\u6784\u4e2d\u901a\u77e5 Vulkan \u6267\u884c\u5177\u4f53\u7684\u547d\u4ee4\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u547d\u4ee4\u6c60 2 \u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a 3 \u542f\u52a8\u547d\u4ee4\u7f13\u51b2\u8bb0\u5f55 4 \u542f\u52a8\u6e32\u67d3\u901a\u9053 5 \u57fa\u672c\u7ed8\u56fe\u547d\u4ee4 6 \u7ed3\u675f\u6e32\u67d3 \u547d\u4ee4\u6c60 \u6211\u4eec\u5728\u4f7f\u7528\u4efb\u4f55 command buffers \u4e4b\u524d\u9700\u8981\u521b\u5efa\u547d\u4ee4\u5bf9\u8c61\u6c60 command pool \u3002 Command pools \u7ba1\u7406\u7528\u4e8e\u5b58\u50a8\u7f13\u51b2\u533a\u7684\u5185\u5b58\uff0c\u5e76\u4ece\u4e2d\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u6dfb\u52a0\u65b0\u7684\u7c7b\u6210\u5458\u4fdd\u5b58 VkCommandPool : VkCommandPool commandPool; \u521b\u5efa\u65b0\u7684\u51fd\u6570 createCommandPool \u5e76\u5728 initVulkan \u51fd\u6570\u521b\u5efa\u5b8c framebuffers \u540e\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); } ... void createCommandPool() { } \u547d\u4ee4\u5bf9\u8c61\u6c60\u521b\u5efa\u4ec5\u4ec5\u9700\u8981\u4e24\u4e2a\u53c2\u6570: QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice); VkCommandPoolCreateInfo poolInfo = {}; poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily; poolInfo.flags = 0; // Optional \u547d\u4ee4\u7f13\u51b2\u533a\u901a\u8fc7\u5c06\u5176\u63d0\u4ea4\u5230\u5176\u4e2d\u4e00\u4e2a\u8bbe\u5907\u961f\u5217\u4e0a\u6765\u6267\u884c\uff0c\u5982\u6211\u4eec\u68c0\u7d22\u7684 graphics \u548c presentation \u961f\u5217\u3002\u6bcf\u4e2a\u547d\u4ee4\u5bf9\u8c61\u6c60\u53ea\u80fd\u5206\u914d\u5728\u5355\u4e00\u7c7b\u578b\u7684\u961f\u5217\u4e0a\u63d0\u4ea4\u7684\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u6362\u53e5\u8bdd\u8bf4\u8981\u5206\u914d\u7684\u547d\u4ee4\u9700\u8981\u4e0e\u961f\u5217\u7c7b\u578b\u4e00\u81f4\u3002\u6211\u4eec\u8981\u8bb0\u5f55\u7ed8\u5236\u7684\u547d\u4ee4\uff0c\u8fd9\u5c31\u8bf4\u660e\u4e3a\u4ec0\u4e48\u8981\u9009\u62e9\u56fe\u5f62\u961f\u5217\u7c07\u7684\u539f\u56e0\u3002 \u6709\u4e24\u4e2a\u6807\u5fd7\u4f4d\u7528\u4e8e command pools : VK_COMMAND_POOL_CREATE_TRANSIENT_BIT : \u63d0\u793a\u547d\u4ee4\u7f13\u51b2\u533a\u975e\u5e38\u9891\u7e41\u7684\u91cd\u65b0\u8bb0\u5f55\u65b0\u547d\u4ee4(\u53ef\u80fd\u4f1a\u6539\u53d8\u5185\u5b58\u5206\u914d\u884c\u4e3a) VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT : \u5141\u8bb8\u547d\u4ee4\u7f13\u51b2\u533a\u5355\u72ec\u91cd\u65b0\u8bb0\u5f55\uff0c\u6ca1\u6709\u8fd9\u4e2a\u6807\u5fd7\uff0c\u6240\u6709\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u90fd\u5fc5\u987b\u4e00\u8d77\u91cd\u7f6e \u6211\u4eec\u4ec5\u4ec5\u5728\u7a0b\u5e8f\u5f00\u59cb\u7684\u65f6\u5019\u8bb0\u5f55\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u5e76\u5728\u4e3b\u5faa\u73af\u4f53 main loop \u4e2d\u591a\u6b21\u6267\u884c\uff0c\u56e0\u6b64\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u8fd9\u4e9b\u6807\u5fd7\u3002 if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) { throw std::runtime_error(\"failed to create command pool!\"); } \u901a\u8fc7 vkCreateCommandPool \u51fd\u6570\u5b8c\u6210 command pool \u521b\u5efa\u5de5\u4f5c\u3002\u5b83\u4e0d\u9700\u8981\u4efb\u4f55\u7279\u6b8a\u7684\u53c2\u6570\u8bbe\u7f6e\u3002\u547d\u4ee4\u5c06\u88ab\u6574\u4e2a\u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\u4f7f\u7528\u4ee5\u5b8c\u6210\u5c4f\u5e55\u7684\u7ed8\u5236\u5de5\u4f5c\uff0c\u6240\u4ee5\u5bf9\u8c61\u6c60\u5e94\u8be5\u88ab\u5728\u6700\u540e\u9500\u6bc1: void cleanup() { vkDestroyCommandPool(device, commandPool, nullptr); ... } \u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a \u73b0\u5728\u6211\u4eec\u5f00\u59cb\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a\u5e76\u901a\u8fc7\u5b83\u4eec\u8bb0\u5f55\u7ed8\u5236\u6307\u4ee4\u3002\u56e0\u4e3a\u5176\u4e2d\u4e00\u4e2a\u7ed8\u56fe\u547d\u4ee4\u9700\u8981\u6b63\u786e\u7ed1\u5b9a VkFrameBuffer \uff0c\u6211\u4eec\u5b9e\u9645\u4e0a\u9700\u8981\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u8bb0\u5f55\u4e00\u4e2a\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u6700\u540e\u521b\u5efa\u4e00\u4e2a VkCommandBuffer \u5bf9\u8c61\u5217\u8868\u4f5c\u4e3a\u6210\u5458\u53d8\u91cf\u3002\u547d\u4ee4\u7f13\u51b2\u533a\u4f1a\u5728 common pool \u9500\u6bc1\u7684\u65f6\u5019\u81ea\u52a8\u91ca\u653e\u7cfb\u7edf\u8d44\u6e90\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u660e\u786e\u7f16\u5199 cleanup \u903b\u8f91\u3002 std::vector<VkCommandBuffer> commandBuffers; \u73b0\u5728\u5f00\u59cb\u4f7f\u7528\u4e00\u4e2a createCommandBuffers \u51fd\u6570\u6765\u5206\u914d\u548c\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u56fe\u50cf\u5c06\u8981\u5e94\u7528\u7684\u547d\u4ee4\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); } ... void createCommandBuffers() { commandBuffers.resize(swapChainFramebuffers.size()); } \u547d\u4ee4\u7f13\u51b2\u533a\u901a\u8fc7 vkAllocateCommandBuffers \u51fd\u6570\u5206\u914d\uff0c\u5b83\u9700\u8981 VkCommandBufferAllocateInfo \u7ed3\u6784\u4f53\u4f5c\u4e3a\u53c2\u6570\uff0c\u7528\u4ee5\u6307\u5b9a command pool \u548c\u7f13\u51b2\u533a\u5c06\u4f1a\u5206\u914d\u7684\u5927\u5c0f: VkCommandBufferAllocateInfo allocInfo = {}; allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; allocInfo.commandPool = commandPool; allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; allocInfo.commandBufferCount = (uint32_t) commandBuffers.size(); if (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.data()) != VK_SUCCESS) { throw std::runtime_error(\"failed to allocate command buffers!\"); } level \u53c2\u6570\u6307\u5b9a\u5206\u914d\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u4e3b\u4ece\u5173\u7cfb\u3002 VK_COMMAND_BUFFER_LEVEL_PRIMARY : \u53ef\u4ee5\u63d0\u4ea4\u5230\u961f\u5217\u6267\u884c\uff0c\u4f46\u4e0d\u80fd\u4ece\u5176\u4ed6\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u8c03\u7528\u3002 VK_COMMAND_BUFFER_LEVEL_SECONDARY : \u65e0\u6cd5\u76f4\u63a5\u63d0\u4ea4\uff0c\u4f46\u662f\u53ef\u4ee5\u4ece\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u8c03\u7528\u3002 \u6211\u4eec\u4e0d\u4f1a\u5728\u8fd9\u91cc\u4f7f\u7528\u8f85\u52a9\u7f13\u51b2\u533a\u529f\u80fd\uff0c\u4f46\u662f\u53ef\u4ee5\u60f3\u50cf\uff0c\u5bf9\u4e8e\u590d\u7528\u4e3b\u7f13\u51b2\u533a\u7684\u5e38\u7528\u64cd\u4f5c\u5f88\u6709\u5e2e\u52a9\u3002 \u542f\u52a8\u547d\u4ee4\u7f13\u51b2\u8bb0\u5f55 \u901a\u8fc7 vkBeginCommandBuffer \u6765\u5f00\u542f\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u8bb0\u5f55\u529f\u80fd\uff0c\u8be5\u51fd\u6570\u9700\u8981\u4f20\u9012 VkCommandBufferBeginInfo \u7ed3\u6784\u4f53\u4f5c\u4e3a\u53c2\u6570\uff0c\u7528\u4ee5\u6307\u5b9a\u547d\u4ee4\u7f13\u51b2\u533a\u5728\u4f7f\u7528\u8fc7\u7a0b\u4e2d\u7684\u4e00\u4e9b\u5177\u4f53\u4fe1\u606f\u3002 for (size_t i = 0; i < commandBuffers.size(); i++) { VkCommandBufferBeginInfo beginInfo = {}; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT; beginInfo.pInheritanceInfo = nullptr; // Optional vkBeginCommandBuffer(commandBuffers[i], &beginInfo); } flags \u6807\u5fd7\u4f4d\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u5982\u4f55\u4f7f\u7528\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u53ef\u9009\u7684\u53c2\u6570\u7c7b\u578b\u5982\u4e0b: VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT : \u547d\u4ee4\u7f13\u51b2\u533a\u5c06\u5728\u6267\u884c\u4e00\u6b21\u540e\u7acb\u5373\u91cd\u65b0\u8bb0\u5f55\u3002 VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT : \u8fd9\u662f\u4e00\u4e2a\u8f85\u52a9\u7f13\u51b2\u533a\uff0c\u5b83\u9650\u5236\u5728\u5728\u4e00\u4e2a\u6e32\u67d3\u901a\u9053\u4e2d\u3002 VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT : \u547d\u4ee4\u7f13\u51b2\u533a\u4e5f\u53ef\u4ee5\u91cd\u65b0\u63d0\u4ea4\uff0c\u540c\u65f6\u5b83\u4e5f\u5728\u7b49\u5f85\u6267\u884c\u3002 \u6211\u4eec\u4f7f\u7528\u4e86\u6700\u540e\u4e00\u4e2a\u6807\u5fd7\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u80fd\u5df2\u7ecf\u5728\u4e0b\u4e00\u5e27\u7684\u65f6\u5019\u5b89\u6392\u4e86\u7ed8\u5236\u547d\u4ee4\uff0c\u800c\u6700\u540e\u4e00\u5e27\u5c1a\u672a\u5b8c\u6210\u3002 pInheritanceInfo \u53c2\u6570\u4e0e\u8f85\u52a9\u7f13\u51b2\u533a\u76f8\u5173\u3002\u5b83\u6307\u5b9a\u4ece\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u7ee7\u627f\u7684\u72b6\u6001\u3002 \u5982\u679c\u547d\u4ee4\u7f13\u51b2\u533a\u5df2\u7ecf\u88ab\u8bb0\u5f55\u4e00\u6b21\uff0c\u90a3\u4e48\u8c03\u7528 vkBeginCommandBuffer \u4f1a\u9690\u5f0f\u5730\u91cd\u7f6e\u5b83\u3002\u5426\u5219\u5c06\u547d\u4ee4\u9644\u52a0\u5230\u7f13\u51b2\u533a\u662f\u4e0d\u53ef\u80fd\u7684\u3002 \u542f\u52a8\u6e32\u67d3\u901a\u9053 \u7ed8\u5236\u5f00\u59cb\u4e8e\u8c03\u7528 vkCmdBeginRenderPass \u5f00\u542f\u6e32\u67d3\u901a\u9053\u3002render pass\u4f7f\u7528 VkRenderPassBeginInfo \u7ed3\u6784\u4f53\u586b\u5145\u914d\u7f6e\u4fe1\u606f\u4f5c\u4e3a\u8c03\u7528\u65f6\u4f7f\u7528\u7684\u53c2\u6570\u3002 VkRenderPassBeginInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; renderPassInfo.renderPass = renderPass; renderPassInfo.framebuffer = swapChainFramebuffers[i]; \u7ed3\u6784\u4f53\u7b2c\u4e00\u4e2a\u53c2\u6570\u4f20\u9012\u4e3a\u7ed1\u5b9a\u5230\u5bf9\u5e94\u9644\u4ef6\u7684\u6e32\u67d3\u901a\u9053\u672c\u8eab\u3002\u6211\u4eec\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u521b\u5efa\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u6307\u5b9a\u4e3a\u989c\u8272\u9644\u4ef6\u3002 renderPassInfo.renderArea.offset = {0, 0}; renderPassInfo.renderArea.extent = swapChainExtent; \u540e\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u4e86\u6e32\u67d3\u533a\u57df\u7684\u5927\u5c0f\u3002\u6e32\u67d3\u533a\u57df\u5b9a\u4e49\u7740\u8272\u5668\u52a0\u8f7d\u548c\u5b58\u50a8\u5c06\u8981\u53d1\u751f\u7684\u4f4d\u7f6e\u3002\u533a\u57df\u5916\u7684\u50cf\u7d20\u5c06\u5177\u6709\u672a\u5b9a\u7684\u503c\u3002\u4e3a\u4e86\u6700\u4f73\u7684\u6027\u80fd\u5b83\u7684\u5c3a\u5bf8\u5e94\u8be5\u4e0e\u9644\u4ef6\u5339\u914d\u3002 VkClearValue clearColor = {0.0f, 0.0f, 0.0f, 1.0f}; renderPassInfo.clearValueCount = 1; renderPassInfo.pClearValues = &clearColor; \u6700\u540e\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u4e86\u7528\u4e8e VK_ATTACHMENT_LOAD_OP_CLEAR \u7684\u6e05\u9664\u503c\uff0c\u6211\u4eec\u5c06\u5176\u7528\u4f5c\u989c\u8272\u9644\u4ef6\u7684\u52a0\u8f7d\u64cd\u4f5c\u3002\u4e3a\u4e86\u7b80\u5316\u64cd\u4f5c\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86 clear color \u4e3a100%\u9ed1\u8272\u3002 vkCmdBeginRenderPass(commandBuffers[i], &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE); \u6e32\u67d3\u901a\u9053\u73b0\u5728\u53ef\u4ee5\u542f\u7528\u3002\u6240\u6709\u53ef\u4ee5\u88ab\u8bb0\u5f55\u7684\u547d\u4ee4\uff0c\u88ab\u8bc6\u522b\u7684\u524d\u63d0\u662f\u4f7f\u7528 vkCmd \u524d\u7f00\u3002\u5b83\u4eec\u5168\u90e8\u8fd4\u56de void \uff0c\u6240\u4ee5\u5728\u7ed3\u675f\u8bb0\u5f55\u4e4b\u524d\u4e0d\u4f1a\u6709\u4efb\u4f55\u9519\u8bef\u5904\u7406\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u547d\u4ee4\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u603b\u662f\u8bb0\u5f55\u8be5\u547d\u4ee4\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u7b2c\u4e8c\u4e2a\u53c2\u6570\u6307\u5b9a\u6211\u4eec\u4f20\u9012\u7684\u6e32\u67d3\u901a\u9053\u7684\u5177\u4f53\u4fe1\u606f\u3002\u6700\u540e\u7684\u53c2\u6570\u63a7\u5236\u5982\u4f55\u63d0\u4f9b render pass \u5c06\u8981\u5e94\u7528\u7684\u7ed8\u5236\u547d\u4ee4\u3002\u5b83\u4f7f\u7528\u4ee5\u4e0b\u6570\u503c\u4efb\u610f\u4e00\u4e2a: VK_SUBPASS_CONTENTS_INLINE : \u6e32\u67d3\u8fc7\u7a0b\u547d\u4ee4\u88ab\u5d4c\u5165\u5728\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u4e2d\uff0c\u6ca1\u6709\u8f85\u52a9\u7f13\u51b2\u533a\u6267\u884c\u3002 VK_SUBPASS_CONTENTS_SECONDARY_COOMAND_BUFFERS : \u6e32\u67d3\u901a\u9053\u547d\u4ee4\u5c06\u4f1a\u4ece\u8f85\u52a9\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u3002 \u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u8f85\u52a9\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u7b2c\u4e00\u4e2a\u3002 \u57fa\u672c\u7ed8\u56fe\u547d\u4ee4 \u73b0\u5728\u6211\u4eec\u7ed1\u5b9a\u56fe\u5f62\u7ba1\u7ebf: vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline); \u7b2c\u4e8c\u4e2a\u53c2\u6570\u6307\u5b9a\u5177\u4f53\u7ba1\u7ebf\u7c7b\u578b\uff0c graphics or compute pipeline \u3002\u6211\u4eec\u544a\u8bc9Vulkan\u5728\u56fe\u5f62\u7ba1\u7ebf\u4e2d\u6bcf\u4e00\u4e2a\u64cd\u4f5c\u5982\u4f55\u6267\u884c\u53ca\u54ea\u4e2a\u9644\u4ef6\u5c06\u4f1a\u5728\u7247\u6bb5\u7740\u8272\u5668\u4e2d\u4f7f\u7528\uff0c\u6240\u4ee5\u5269\u4e0b\u7684\u5c31\u662f\u544a\u8bc9\u5b83\u7ed8\u5236\u4e09\u89d2\u5f62\u3002 vkCmdDraw(commandBuffers[i], 3, 1, 0, 0); C++ \u5b9e\u9645\u7684 vkCmdDraw \u51fd\u6570\u6709\u70b9\u4e0e\u5b57\u9762\u610f\u601d\u4e0d\u4e00\u81f4\uff0c\u5b83\u662f\u5982\u6b64\u7b80\u5355\uff0c\u4ec5\u56e0\u4e3a\u6211\u4eec\u63d0\u524d\u6307\u5b9a\u6240\u6709\u6e32\u67d3\u76f8\u5173\u7684\u4fe1\u606f\u3002\u5b83\u6709\u5982\u4e0b\u7684\u53c2\u6570\u9700\u8981\u6307\u5b9a\uff0c\u9664\u4e86\u547d\u4ee4\u7f13\u51b2\u533a: vertexCount : \u5373\u4f7f\u6211\u4eec\u6ca1\u6709\u9876\u70b9\u7f13\u51b2\u533a\uff0c\u4f46\u662f\u6211\u4eec\u4ecd\u7136\u67093\u4e2a\u5b9a\u70b9\u9700\u8981\u7ed8\u5236\u3002 instanceCount : \u7528\u4e8einstanced \u6e32\u67d3\uff0c\u5982\u679c\u6ca1\u6709\u4f7f\u7528\u8bf7\u586b1\u3002 firstVertex : \u4f5c\u4e3a\u9876\u70b9\u7f13\u51b2\u533a\u7684\u504f\u79fb\u91cf\uff0c\u5b9a\u4e49gl_VertexIndex\u7684\u6700\u5c0f\u503c\u3002 firstInstance : \u4f5c\u4e3ainstanced \u6e32\u67d3\u7684\u504f\u79fb\u91cf\uff0c\u5b9a\u4e49\u4e86gl_InstanceIndex\u7684\u6700\u5c0f\u503c\u3002 \u7ed3\u675f\u6e32\u67d3 render pass \u6267\u884c\u5b8c\u7ed8\u5236\uff0c\u53ef\u4ee5\u7ed3\u675f\u6e32\u67d3\u4f5c\u4e1a: vkCmdEndRenderPass(commandBuffers[i]); C++ \u5e76\u505c\u6b62\u8bb0\u5f55\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u5de5\u4f5c: if (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to record command buffer!\"); } C++ \u5728\u4e0b\u4e00\u7ae0\u8282\u6211\u4eec\u4f1a\u5c1d\u8bd5\u5728 main loop \u4e2d\u7f16\u5199\u4ee3\u7801\uff0c\u7528\u4e8e\u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u56fe\u50cf\uff0c\u6267\u884c\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u547d\u4ee4\uff0c\u518d\u5c06\u6e32\u67d3\u540e\u7684\u56fe\u50cf\u8fd4\u8fd8\u7ed9\u4ea4\u6362\u94fe\u3002 Vulkan \u6e32\u67d3\u548c\u663e\u793a Vulkan \u6e32\u67d3\u548c\u663e\u793a \uff0c\u8fd9\u4e00\u7ae0\u8282\u4f1a\u628a\u4e4b\u524d\u7684\u6240\u6709\u5185\u5bb9\u8fdb\u884c\u6574\u5408\uff0c\u6211\u4eec\u5c06\u4f1a\u7f16\u5199 drawFrame \u51fd\u6570\uff0c\u901a\u8fc7\u4e3b\u5faa\u73af main loop \u5c06\u4e09\u89d2\u5f62\u7ed8\u5236\u5230\u5c4f\u5e55\u3002 drawFrame \u51fd\u6570\u5c06\u4f1a\u6267\u884c\u5982\u4e0b\u64cd\u4f5c: \u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u4e00\u4e2a\u56fe\u50cf \u5728\u5e27\u7f13\u51b2\u533a\u4e2d\uff0c\u4f7f\u7528\u4f5c\u4e3a\u9644\u4ef6\u7684\u56fe\u50cf\u6765\u6267\u884c\u547d\u4ee4\u7f13\u51b2\u533a\u4e2d\u7684\u547d\u4ee4 \u4e3a\u4e86\u6700\u7ec8\u5448\u73b0\uff0c\u5c06\u56fe\u50cf\u8fd4\u8fd8\u5230\u4ea4\u6362\u94fe \u6bcf\u4e2a\u4e8b\u4ef6\u6d3e\u53d1\u90fd\u6709\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u6765\u5bf9\u5e94\uff0c\u4f46\u5b83\u4eec\u7684\u6267\u884c\u662f\u5f02\u6b65\u7684\u3002\u51fd\u6570\u8c03\u7528\u5c06\u5728\u64cd\u4f5c\u5b9e\u9645\u5b8c\u6210\u4e4b\u524d\u8fd4\u56de\uff0c\u5e76\u4e14\u6267\u884c\u987a\u5e8f\u4e5f\u662f\u672a\u5b9a\u4e49\u7684\u3002\u8fd9\u662f\u4e0d\u7406\u60f3\u7684\uff0c\u56e0\u4e3a\u6bcf\u4e00\u4e2a\u64cd\u4f5c\u90fd\u53d6\u51b3\u4e8e\u524d\u4e00\u4e2a\u64cd\u4f5c\u3002 \u5728 mainLoop \u51fd\u6570\u8c03\u7528: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); drawFrame(); } } ... void drawFrame() { } C++ \u540c\u6b65\u4ea4\u6362\u94fe\u4e8b\u4ef6\u6709\u4e24\u79cd\u65b9\u6cd5:\u6805\u680f\u548c\u4fe1\u53f7\u91cf\u3002\u5b83\u4eec\u90fd\u662f\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u4e00\u4e2a\u64cd\u4f5c\u4fe1\u53f7\uff0c\u8d1f\u8d23\u534f\u8c03\u64cd\u4f5c\u7684\u5bf9\u8c61\u3002\u53e6\u4e00\u4e2a\u64cd\u4f5c\u7b49\u5f85\u6805\u680f\u6216\u8005\u4fe1\u53f7\u91cf\u4ece\u65e0\u4fe1\u53f7\u72b6\u6001\u8f6c\u53d8\u5230\u6709\u4fe1\u53f7\u72b6\u6001\u3002 \u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u53ef\u4ee5\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u8c03\u7528 vkWaitForFence \u8fdb\u5165\u6805\u680f\u72b6\u6001\uff0c\u800c\u4fe1\u53f7\u91cf\u4e0d\u53ef\u4ee5\u3002\u6805\u680f\u4e3b\u8981\u7528\u4e8e\u5e94\u7528\u7a0b\u5e8f\u81ea\u8eab\u4e0e\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u540c\u6b65\uff0c\u800c\u4fe1\u53f7\u91cf\u7528\u4e8e\u5728\u547d\u4ee4\u961f\u5217\u5185\u6216\u8005\u8de8\u547d\u4ee4\u961f\u5217\u540c\u6b65\u64cd\u4f5c\u3002\u6211\u4eec\u671f\u671b\u540c\u6b65\u7ed8\u5236\u4e0e\u5448\u73b0\u7684\u961f\u5217\u64cd\u4f5c\uff0c\u6240\u4ee5\u4f7f\u7528\u4fe1\u53f7\u91cf\u6700\u5408\u9002\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u4fe1\u53f7\u91cf 2 \u4ece\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf 3 \u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a 4 Subpass \u4f9d\u8d56\u6027 5 \u5448\u73b0 6 \u5185\u5b58\u6cc4\u6f0f 7 \u7ed3\u8bba \u4fe1\u53f7\u91cf \u5728\u83b7\u5f97\u4e00\u4e2a\u56fe\u50cf\u65f6\uff0c\u6211\u4eec\u9700\u8981\u53d1\u51fa\u4e00\u4e2a\u4fe1\u53f7\u91cf\u51c6\u5907\u8fdb\u884c\u6e32\u67d3\uff0c\u53e6\u4e00\u4e2a\u4fe1\u53f7\u91cf\u7684\u53d1\u51fa\u7528\u4e8e\u6e32\u67d3\u7ed3\u675f\uff0c\u51c6\u5907\u8fdb\u884c\u5448\u73b0presentation\u3002\u521b\u5efa\u4e24\u4e2a\u6210\u5458\u53d8\u91cf\u5b58\u50a8\u4fe1\u53f7\u91cf\u5bf9\u8c61: VkSemaphore imageAvailableSemaphore; VkSemaphore renderFinishedSemaphore; C++ \u4e3a\u4e86\u521b\u5efa\u4fe1\u53f7\u91cfsemaphores\uff0c\u6211\u4eec\u5c06\u8981\u65b0\u589e\u672c\u7cfb\u5217\u6559\u7a0b\u6700\u540e\u4e00\u4e2a\u51fd\u6570: createSemaphores : void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); createSemaphores(); } ... void createSemaphores() { } C++ \u521b\u5efa\u4fe1\u53f7\u91cf\u5bf9\u8c61\u9700\u8981\u586b\u5145 VkSemaphoreCreateInfo \u7ed3\u6784\u4f53\uff0c\u4f46\u662f\u5728\u5f53\u524d\u7248\u672c\u7684 API \u4e2d\uff0c\u5b9e\u9645\u4e0a\u4e0d\u9700\u8981\u586b\u5145\u4efb\u4f55\u5b57\u6bb5\uff0c\u9664 sType : void createSemaphores() { VkSemaphoreCreateInfo semaphoreInfo = {}; semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; } C++ Vulkan API\u672a\u6765\u7248\u672c\u6216\u8005\u6269\u5c55\u4e2d\u6216\u8bb8\u4f1a\u4e3a flags \u548c pNext \u53c2\u6570\u589e\u52a0\u529f\u80fd\u9009\u9879\u3002\u521b\u5efa\u4fe1\u53f7\u91cf\u5bf9\u8c61\u7684\u8fc7\u7a0b\u5f88\u719f\u6089\u4e86\uff0c\u5728\u8fd9\u91cc\u4f7f\u7528 vkCreateSemaphore : if (vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphore) != VK_SUCCESS || vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphore) != VK_SUCCESS) { throw std::runtime_error(\"failed to create semaphores!\"); } C++ \u5728\u7a0b\u5e8f\u7ed3\u675f\u65f6\uff0c\u5f53\u6240\u6709\u547d\u4ee4\u5b8c\u6210\u5e76\u4e0d\u9700\u8981\u540c\u6b65\u65f6\uff0c\u5e94\u8be5\u6e05\u9664\u4fe1\u53f7\u91cf: void cleanup() { vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); C++ \u4ece\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf \u5c31\u50cf\u4e4b\u524d\u8bf4\u5230\u7684\uff0c drawFrame \u51fd\u6570\u9700\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u56fe\u50cf\u3002\u56de\u60f3\u4e00\u4e0b\u4ea4\u6362\u94fe\u662f\u4e00\u4e2a\u6269\u5c55\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u4f7f\u7528\u5177\u6709vk*KHR\u547d\u540d\u7ea6\u5b9a\u7684\u51fd\u6570: void drawFrame() { uint32_t imageIndex; vkAcquireNextImageKHR(device, swapChain, std::numeric_limits<uint64_t>::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex); } C++ vkAcquireNextImageKHR \u51fd\u6570\u524d\u4e24\u4e2a\u53c2\u6570\u662f\u6211\u4eec\u5e0c\u671b\u83b7\u53d6\u5230\u56fe\u50cf\u7684\u903b\u8f91\u8bbe\u5907\u548c\u4ea4\u6362\u94fe\u3002\u7b2c\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u83b7\u53d6\u6709\u6548\u56fe\u50cf\u7684\u64cd\u4f5ctimeout\uff0c\u5355\u4f4d\u7eb3\u79d2\u3002\u6211\u4eec\u4f7f\u752864\u4f4d\u65e0\u7b26\u53f7\u6700\u5927\u503c\u7981\u6b62 timeout \u3002 \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u4f7f\u7528\u7684\u540c\u6b65\u5bf9\u8c61\uff0c\u5f53 presentation \u5f15\u64ce\u5b8c\u6210\u4e86\u56fe\u50cf\u7684\u5448\u73b0\u540e\u4f1a\u4f7f\u7528\u8be5\u5bf9\u8c61\u53d1\u8d77\u4fe1\u53f7\u3002\u8fd9\u5c31\u662f\u5f00\u59cb\u7ed8\u5236\u7684\u65f6\u95f4\u70b9\u3002\u5b83\u53ef\u4ee5\u6307\u5b9a\u4e00\u4e2a\u4fe1\u53f7\u91cf semaphore \u6216\u8005\u6805\u680f\u6216\u8005\u4e24\u8005\u3002\u51fa\u4e8e\u76ee\u7684\u6027\uff0c\u6211\u4eec\u4f1a\u4f7f\u7528 imageAvailableSemaphore \u3002 \u6700\u540e\u7684\u53c2\u6570\u6307\u5b9a\u4ea4\u6362\u94fe\u4e2d\u6210\u4e3a available \u72b6\u6001\u7684\u56fe\u50cf\u5bf9\u5e94\u7684\u7d22\u5f15\u3002\u5176\u4e2d\u7d22\u5f15\u4f1a\u5f15\u7528\u4ea4\u6362\u94fe\u56fe\u50cf\u6570\u7ec4 swapChainImages \u7684\u56fe\u50cf VkImage \u3002\u6211\u4eec\u4f7f\u7528\u8fd9\u4e2a\u7d22\u5f15\u9009\u62e9\u6b63\u786e\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002 \u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a \u961f\u5217\u63d0\u4ea4\u548c\u540c\u6b65\u901a\u8fc7 VkSubmitInfo \u7ed3\u6784\u4f53\u8fdb\u884c\u53c2\u6570\u914d\u7f6e\u3002 VkSubmitInfo submitInfo = {}; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; VkSemaphore waitSemaphores[] = {imageAvailableSemaphore}; VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT}; submitInfo.waitSemaphoreCount = 1; submitInfo.pWaitSemaphores = waitSemaphores; submitInfo.pWaitDstStageMask = waitStages; C++ \u524d\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u5728\u6267\u884c\u5f00\u59cb\u4e4b\u524d\u8981\u7b49\u5f85\u7684\u54ea\u4e2a\u4fe1\u53f7\u91cf\u53ca\u8981\u7b49\u5f85\u7684\u901a\u9053\u7684\u54ea\u4e2a\u9636\u6bb5\u3002\u4e3a\u4e86\u5411\u56fe\u50cf\u5199\u5165\u989c\u8272\uff0c\u6211\u4eec\u4f1a\u7b49\u5f85\u56fe\u50cf\u72b6\u6001\u53d8\u4e3a available \uff0c\u6240\u6211\u4eec\u6307\u5b9a\u5199\u5165\u989c\u8272\u9644\u4ef6\u7684\u56fe\u5f62\u7ba1\u7ebf\u9636\u6bb5\u3002\u7406\u8bba\u4e0a\u8fd9\u610f\u5473\u7740\uff0c\u5177\u4f53\u7684\u9876\u70b9\u7740\u8272\u5668\u5f00\u59cb\u6267\u884c\uff0c\u800c\u56fe\u50cf\u4e0d\u53ef\u7528\u3002 waitStages \u6570\u7ec4\u5bf9\u5e94 pWaitSemaphores \u4e2d\u5177\u6709\u76f8\u540c\u7d22\u5f15\u7684\u4fe1\u53f7\u91cf\u3002 submitInfo.commandBufferCount = 1; submitInfo.pCommandBuffers = &commandBuffers[imageIndex]; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u54ea\u4e2a\u547d\u4ee4\u7f13\u51b2\u533a\u88ab\u5b9e\u9645\u63d0\u4ea4\u6267\u884c\u3002\u5982\u521d\u671f\u63d0\u5230\u7684\uff0c\u6211\u4eec\u5e94\u8be5\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u5b83\u5c06\u6211\u4eec\u521a\u83b7\u53d6\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u505a\u4e3a\u989c\u8272\u9644\u4ef6\u8fdb\u884c\u7ed1\u5b9a\u3002 VkSemaphore signalSemaphores[] = {renderFinishedSemaphore}; submitInfo.signalSemaphoreCount = 1; submitInfo.pSignalSemaphores = signalSemaphores; C++ signalSemaphoreCount \u548c pSignalSemaphores \u53c2\u6570\u6307\u5b9a\u4e86\u5f53\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u7ed3\u675f\u5411\u54ea\u4e9b\u4fe1\u53f7\u91cf\u53d1\u51fa\u4fe1\u53f7\u3002\u6839\u636e\u6211\u4eec\u7684\u9700\u8981\u4f7f\u7528 renderFinishedSemaphore \u3002 if (vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE) != VK_SUCCESS) { throw std::runtime_error(\"failed to submit draw command buffer!\"); } C++ \u4f7f\u7528 vkQueueSubmit \u51fd\u6570\u5411\u56fe\u50cf\u961f\u5217\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u5f53\u5f00\u9500\u8d1f\u8f7d\u6bd4\u8f83\u5927\u7684\u65f6\u5019\uff0c\u5904\u4e8e\u6548\u7387\u8003\u8651\uff0c\u51fd\u6570\u53ef\u4ee5\u6301\u6709 VkSubmitInfo \u7ed3\u6784\u4f53\u6570\u7ec4\u3002\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u5f15\u7528\u4e86\u4e00\u4e2a\u53ef\u9009\u7684\u6805\u680f\uff0c\u5f53\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u5b8c\u6bd5\u65f6\u5019\u5b83\u4f1a\u88ab\u53d1\u9001\u4fe1\u53f7\u3002\u6211\u4eec\u4f7f\u7528\u4fe1\u53f7\u91cf\u8fdb\u884c\u540c\u6b65\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4f20\u9012 VK_NULL_HANDLE \u3002 Subpass \u4f9d\u8d56\u6027 \u8bf7\u8bb0\u4f4f\uff0c\u6e32\u67d3\u901a\u9053\u4e2d\u7684\u5b50\u901a\u9053\u4f1a\u81ea\u52a8\u5904\u7406\u5e03\u5c40\u7684\u53d8\u6362\u3002\u8fd9\u4e9b\u53d8\u6362\u901a\u8fc7\u5b50\u901a\u9053\u7684\u4f9d\u8d56\u5173\u7cfb\u8fdb\u884c\u63a7\u5236\uff0c\u5b83\u4eec\u6307\u5b9a\u4e86\u5f7c\u6b64\u4e4b\u95f4\u5185\u5b58\u548c\u6267\u884c\u7684\u4f9d\u8d56\u5173\u7cfb\u3002\u73b0\u5728\u53ea\u6709\u4e00\u4e2a\u5b50\u901a\u9053\uff0c\u4f46\u662f\u5728\u6b64\u5b50\u901a\u9053\u4e4b\u524d\u548c\u4e4b\u540e\u7684\u64cd\u4f5c\u4e5f\u88ab\u89c6\u4e3a\u9690\u5f0f\u201c\u5b50\u901a\u9053\u201d\u3002 \u6709\u4e24\u4e2a\u5185\u7f6e\u7684\u4f9d\u8d56\u5173\u7cfb\u5728\u6e32\u67d3\u901a\u9053\u5f00\u59cb\u548c\u6e32\u67d3\u901a\u9053\u7ed3\u675f\u5904\u7406\u8f6c\u6362\uff0c\u4f46\u662f\u524d\u8005\u4e0d\u4f1a\u5728\u5f53\u4e0b\u53d1\u751f\u3002\u5047\u8bbe\u8f6c\u6362\u53d1\u751f\u5728\u7ba1\u7ebf\u7684\u8d77\u59cb\u9636\u6bb5\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u83b7\u53d6\u56fe\u50cf\uff01\u6709\u4e24\u4e2a\u65b9\u6cd5\u5904\u7406\u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u5c06 imageAvailableSemaphore \u7684 waitStages \u66f4\u6539\u4e3a VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT \uff0c\u786e\u4fdd\u56fe\u50cf\u6709\u6548\u4e4b\u524d\u6e32\u67d3\u901a\u9053\u4e0d\u4f1a\u5f00\u59cb\uff0c\u6216\u8005\u6211\u4eec\u8ba9\u6e32\u67d3\u901a\u9053\u7b49\u5f85 VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT \u9636\u6bb5\u3002\u6211\u89c9\u5f97\u4f7f\u7528\u7b2c\u4e8c\u4e2a\u9009\u9879\uff0c\u56e0\u4e3a\u53ef\u4ee5\u6bd4\u8f83\u5168\u9762\u7684\u4e86\u89e3 subpass \u4f9d\u8d56\u5173\u7cfb\u53ca\u5176\u5de5\u4f5c\u65b9\u5f0f\u3002 \u5b50\u901a\u9053\u4f9d\u8d56\u5173\u7cfb\u53ef\u4ee5\u901a\u8fc7 VkSubpassDependency \u7ed3\u6784\u4f53\u6307\u5b9a\uff0c\u5728 createRenderPass \u51fd\u6570\u4e2d\u6dfb\u52a0: VkSubpassDependency dependency = {}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; C++ \u524d\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u4f9d\u8d56\u7684\u5173\u7cfb\u548c\u4ece\u5c5e\u5b50\u901a\u9053\u7684\u7d22\u5f15\u3002\u7279\u6b8a\u503c VK_SUBPASS_EXTERNAL \u662f\u6307\u5728\u6e32\u67d3\u901a\u9053\u4e4b\u524d\u6216\u8005\u4e4b\u540e\u7684\u9690\u5f0f\u5b50\u901a\u9053\uff0c\u53d6\u51b3\u4e8e\u5b83\u662f\u5426\u5728 srcSubpass \u6216\u8005 dstSubPass \u4e2d\u6307\u5b9a\u3002\u7d22\u5f150\u6307\u5b9a\u6211\u4eec\u7684\u5b50\u901a\u9053\uff0c\u8fd9\u662f\u7b2c\u4e00\u4e2a\u4e5f\u662f\u552f\u4e00\u7684\u3002 dstSubpass \u5fc5\u987b\u59cb\u7ec8\u9ad8\u4e8e srcSubPass \u4ee5\u9632\u6b62\u4f9d\u8d56\u5173\u7cfb\u51fa\u73b0\u5faa\u73af\u3002 dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u5b57\u6bb5\u6307\u5b9a\u8981\u7b49\u5f85\u7684\u64cd\u4f5c\u548c\u8fd9\u4e9b\u64cd\u4f5c\u53d1\u751f\u7684\u9636\u6bb5\u3002\u5728\u6211\u4eec\u53ef\u4ee5\u8bbf\u95ee\u5bf9\u8c61\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u7b49\u5f85\u4ea4\u6362\u94fe\u5b8c\u6210\u5bf9\u5e94\u56fe\u50cf\u7684\u8bfb\u53d6\u64cd\u4f5c\u3002\u8fd9\u53ef\u4ee5\u901a\u8fc7\u7b49\u5f85\u989c\u8272\u9644\u4ef6\u8f93\u51fa\u7684\u9636\u6bb5\u6765\u5b9e\u73b0\u3002 dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; C++ \u5728\u989c\u8272\u9644\u4ef6\u9636\u6bb5\u7684\u64cd\u4f5c\u53ca\u6d89\u53ca\u989c\u8272\u9644\u4ef6\u7684\u8bfb\u53d6\u548c\u5199\u5165\u7684\u64cd\u4f5c\u5e94\u8be5\u7b49\u5f85\u3002\u8fd9\u4e9b\u8bbe\u7f6e\u5c06\u963b\u6b62\u8f6c\u6362\u53d1\u751f\uff0c\u76f4\u5230\u5b9e\u9645\u9700\u8981(\u5e76\u5141\u8bb8):\u5f53\u6211\u4eec\u9700\u8981\u5199\u5165\u989c\u8272\u65f6\u5019\u3002 renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; C++ VkRenderPassCreateInfo \u7ed3\u6784\u4f53\u6709\u4e24\u4e2a\u5b57\u6bb5\u6307\u5b9a\u4f9d\u8d56\u7684\u6570\u7ec4\u3002 \u5448\u73b0 \u7ed8\u5236\u5e27\u6700\u540e\u4e00\u4e2a\u6b65\u9aa4\u662f\u5c06\u7ed3\u679c\u63d0\u4ea4\u5230\u4ea4\u6362\u94fe\uff0c\u4f7f\u5176\u6700\u7ec8\u663e\u793a\u5728\u5c4f\u5e55\u4e0a\u3002 Presentation \u901a\u8fc7 VkPresentInfoKHR \u7ed3\u6784\u4f53\u914d\u7f6e\uff0c\u5177\u4f53\u4f4d\u7f6e\u5728 drawFrame \u51fd\u6570\u6700\u540e\u3002 VkPresentInfoKHR presentInfo = {}; presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR; presentInfo.waitSemaphoreCount = 1; presentInfo.pWaitSemaphores = signalSemaphores; C++ \u524d\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u5728\u8fdb\u884cpresentation\u4e4b\u524d\u8981\u7b49\u5f85\u7684\u4fe1\u53f7\u91cf\uff0c\u5c31\u50cf VkSubmitInfo \u4e00\u6837\u3002 VkSwapchainKHR swapChains[] = {swapChain}; presentInfo.swapchainCount = 1; presentInfo.pSwapchains = swapChains; presentInfo.pImageIndices = &imageIndex; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u7528\u4e8e\u63d0\u4ea4\u56fe\u50cf\u7684\u4ea4\u6362\u94fe\u548c\u6bcf\u4e2a\u4ea4\u6362\u94fe\u56fe\u50cf\u7d22\u5f15\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4ec5\u4e00\u4e2a\u3002 presentInfo.pResults = nullptr; // Optional C++ \u6700\u540e\u4e00\u4e2a\u53ef\u9009\u53c2\u6570 pResults \uff0c\u5b83\u5141\u8bb8\u6307\u5b9a\u4e00\u7ec4 VkResult \u503c\uff0c\u4ee5\u4fbf\u5728 presentation \u6210\u529f\u65f6\u68c0\u67e5\u6bcf\u4e2a\u72ec\u7acb\u7684\u4ea4\u6362\u94fe\u3002\u5982\u679c\u53ea\u4f7f\u7528\u5355\u4e2a\u4ea4\u6362\u94fe\uff0c\u5219\u4e0d\u9700\u8981\uff0c\u56e0\u4e3a\u53ef\u4ee5\u7b80\u5355\u7684\u4f7f\u7528\u5f53\u524d\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002 vkQueuePresentKHR(presentQueue, &presentInfo); C++ vkQueuePresentKHR \u51fd\u6570\u63d0\u4ea4\u8bf7\u6c42\u5448\u73b0\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u3002\u6211\u4eec\u5728\u4e0b\u4e00\u4e2a\u7ae0\u8282\u4e3a vkAcquireNextImageKHR \u548c vkQueuePresentKHR \u53ef\u4ee5\u6dfb\u52a0\u9519\u8bef\u5904\u7406\u3002\u56e0\u4e3a\u5b83\u4eec\u5931\u8d25\u5e76\u4e0d\u4e00\u5b9a\u610f\u5473\u7740\u7a0b\u5e8f\u5e94\u8be5\u7ec8\u6b62\uff0c\u4e0e\u6211\u4eec\u8fc4\u4eca\u4e3a\u6b62\u770b\u5230\u7684\u529f\u80fd\u4e0d\u540c\u3002 \u5982\u679c\u4e00\u5207\u987a\u5229\uff0c\u5f53\u518d\u6b21\u8fd0\u884c\u7a0b\u5e8f\u65f6\u5019\uff0c\u5e94\u8be5\u53ef\u4ee5\u770b\u5230\u4e00\u4e0b\u5185\u5bb9: \u9057\u61be\u7684\u662f\uff0c\u53ea\u8981\u7a0b\u5e8f\u5173\u95ed\uff0c\u7531\u4e8e\u5f00\u542f\u4e86validation layers\u4f60\u5c06\u4f1a\u770b\u5230\u7a0b\u5e8f\u5d29\u6e83\u7684\u4fe1\u606f\u3002\u4ece\u7ec8\u7aef\u63a7\u5236\u53f0\u6253\u5370\u7684\u4fe1\u606f\u6765\u6e90 debugCallback \uff0c\u544a\u8bc9\u4e86\u6211\u4eec\u5177\u4f53\u7684\u539f\u56e0: \u9700\u8981\u4e86\u89e3\u7684\u662f drawFrame \u51fd\u6570\u4e2d\u6240\u6709\u7684\u64cd\u4f5c\u90fd\u662f\u5f02\u6b65\u7684\u3002\u610f\u5473\u7740\u5f53\u7a0b\u5e8f\u9000\u51fa mainLoop \uff0c\u7ed8\u5236\u548c\u5448\u73b0\u64cd\u4f5c\u53ef\u80fd\u4ecd\u7136\u5728\u6267\u884c\u3002\u6240\u4ee5\u6e05\u7406\u8be5\u90e8\u5206\u7684\u8d44\u6e90\u662f\u4e0d\u53cb\u597d\u7684\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u5e94\u8be5\u5728\u9000\u51fa mainLoop \u9500\u6bc1\u7a97\u4f53\u524d\u7b49\u5f85\u903b\u8f91\u8bbe\u5907\u7684\u64cd\u4f5c\u5b8c\u6210: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); drawFrame(); } vkDeviceWaitIdle(device); } C++ \u4e5f\u53ef\u4ee5\u4f7f\u7528 vkQueueWaitIdle \u7b49\u5f85\u7279\u5b9a\u547d\u4ee4\u961f\u5217\u4e2d\u7684\u64cd\u4f5c\u5b8c\u6210\u3002\u8fd9\u4e9b\u529f\u80fd\u53ef\u4ee5\u4f5c\u4e3a\u4e00\u4e2a\u975e\u5e38\u57fa\u672c\u7684\u65b9\u5f0f\u6765\u6267\u884c\u540c\u6b65\u3002\u8fd9\u4e2a\u65f6\u5019\u7a97\u4f53\u5173\u95ed\u540e\u8be5\u95ee\u9898\u4e0d\u4f1a\u51fa\u73b0\u3002 \u5185\u5b58\u6cc4\u6f0f \u5982\u679c\u8fd0\u884c\u65f6\u542f\u7528\u4e86 validation layers \u5e76\u76d1\u89c6\u5e94\u7528\u7a0b\u5e8f\u7684\u5185\u5b58\u4f7f\u7528\u60c5\u51b5\uff0c\u4f60\u4f1a\u53d1\u73b0\u5b83\u5728\u6162\u6162\u589e\u52a0\u3002\u539f\u56e0\u662f validation layers \u7684\u5b9e\u73b0\u671f\u671b\u4e0e GPU \u540c\u6b65\u3002\u867d\u7136\u5728\u6280\u672f\u4e0a\u662f\u4e0d\u9700\u8981\u7684\uff0c\u4f46\u662f\u4e00\u65e6\u8fd9\u6837\u505a\uff0c\u6bcf\u4e00\u9488\u5e27\u4e0d\u4f1a\u51fa\u73b0\u660e\u663e\u7684\u6027\u80fd\u5f71\u54cd\u3002 \u6211\u4eec\u53ef\u4ee5\u5728\u5f00\u59cb\u7ed8\u5236\u4e0b\u4e00\u5e27\u4e4b\u524d\u660e\u786e\u7684\u7b49\u5f85 presentation \u5b8c\u6210: void drawFrame() { ... vkQueuePresentKHR(presentQueue, &presentInfo); vkQueueWaitIdle(presentQueue); } C++ \u5728\u5f88\u591a\u5e94\u7528\u7a0b\u5e8f\u7684\u7684\u72b6\u6001\u4e5f\u4f1a\u5728\u6bcf\u4e00\u5e27\u66f4\u65b0\u3002\u4e3a\u6b64\u66f4\u9ad8\u6548\u7684\u7ed8\u5236\u4e00\u9635\u7684\u65b9\u5f0f\u5982\u4e0b\uff1a void drawFrame() { updateAppState(); vkQueueWaitIdle(presentQueue); vkAcquireNextImageKHR(...) submitDrawCommands(); vkQueuePresentKHR(presentQueue, &presentInfo); } C++ \u8be5\u65b9\u6cd5\u5141\u8bb8\u6211\u4eec\u66f4\u65b0\u5e94\u7528\u7a0b\u5e8f\u7684\u72b6\u6001\uff0c\u6bd4\u5982\u8fd0\u884c\u6e38\u620f\u7684AI\u534f\u540c\u7a0b\u5e8f\uff0c\u800c\u524d\u4e00\u5e27\u88ab\u6e32\u67d3\u3002\u8fd9\u6837\uff0c\u59cb\u7ec8\u4fdd\u6301 CPU \u548c GPU \u5904\u4e8e\u5de5\u4f5c\u72b6\u6001\u3002 \u7ed3\u8bba \u5927\u7ea6800\u884c\u4ee3\u7801\u4e4b\u540e\uff0c\u6211\u4eec\u7ec8\u4e8e\u770b\u5230\u4e86\u4e09\u89d2\u5f62\u7ed8\u5236\u5728\u5c4f\u5e55\u4e0a\uff01 Vulkan \u5f15\u5bfc\u7a0b\u5e8f\u9700\u8981\u5f88\u591a\u7684\u5de5\u4f5c\u8981\u53bb\u505a\uff0c\u4f46\u597d\u5904\u662f Vulkan \u901a\u8fc7\u8981\u6c42\u6bcf\u4e00\u4e2a\u660e\u786e\u7684\u5b9e\u73b0\uff0c\u5e26\u6765\u4e86\u4e86\u5de8\u5927\u7684\u63a7\u5236\u6743\u3002\u5efa\u8bae\u82b1\u8d39\u4e00\u4e9b\u65f6\u95f4\u91cd\u65b0\u8bfb\u4ee3\u7801\uff0c\u5e76\u5efa\u7acb\u4e00\u4e2a\u601d\u7ef4\u5bfc\u56fe\u6a21\u578b\uff0c\u76ee\u7684\u5728\u4e8e\u4e86\u89e3 Vulkan \u4e2d\u6bcf\u4e00\u4e2a\u5bf9\u8c61\uff0c\u4ee5\u53ca\u5b83\u4eec\u7684\u4e92\u76f8\u7684\u5173\u7cfb\u3002\u4e4b\u540e\u6211\u4eec\u5c06\u4f1a\u57fa\u4e8e\u8fd9\u4e2a\u57fa\u7840\u6784\u5efa\u6269\u5c55\u7a0b\u5e8f\u529f\u80fd\u3002 \u5728\u4e0b\u4e00\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u7ec6\u5316 Vulkan \u7a0b\u5e8f\u4e2d\u7684\u4e00\u4e9b\u7ec6\u8282\uff0c\u4f7f\u5176\u8868\u73b0\u66f4\u7a33\u5b9a\u3002 Vulkan \u91cd\u6784\u4ea4\u6362\u94fe Vulkan \u91cd\u6784\u4ea4\u6362\u94fe \uff0c\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6210\u529f\u7684\u5728\u5c4f\u5e55\u4e0a\u7ed8\u5236\u51fa\u4e09\u89d2\u5f62\uff0c\u4f46\u662f\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5b83\u4f1a\u51fa\u73b0\u5f02\u5e38\u60c5\u51b5\u3002\u7a97\u4f53 surface \u4f1a\u53d1\u751f\u6539\u53d8\uff0c\u4f7f\u5f97\u4ea4\u6362\u94fe\u4e0d\u5728\u4e0e\u5176\u517c\u5bb9\u3002\u53ef\u80fd\u5bfc\u81f4\u8fd9\u79cd\u60c5\u51b5\u53d1\u751f\u7684\u539f\u56e0\u4e4b\u4e00\u662f\u7a97\u4f53\u7684\u5927\u5c0f\u53d8\u5316\u3002\u6211\u4eec\u5fc5\u987b\u5728\u8fd9\u4e2a\u65f6\u673a\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe 2 \u7a97\u53e3\u5927\u5c0f\u8c03\u6574 3 \u6b21\u4f18\u6216\u8fc7\u671f\u7684\u4ea4\u6362\u94fe \u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe \u6dfb\u52a0\u65b0\u7684\u51fd\u6570 recreateSwapChain \u5e76\u8c03\u7528 createSwapChain \u53ca\u4f9d\u8d56\u4e8e\u4ea4\u6362\u94fe\u6216\u8005\u7a97\u4f53\u5927\u5c0f\u7684\u5bf9\u8c61\u76f8\u5173\u7684\u6240\u6709\u521b\u5efa\u51fd\u6570\u3002 void recreateSwapChain() { vkDeviceWaitIdle(device); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers(); } \u6211\u4eec\u9996\u5148\u8c03\u7528 vkDeviceIdle ,\u5c31\u50cf\u524d\u4e00\u4e2a\u7ae0\u8282\u63d0\u5230\u7684\uff0c\u6211\u4eec\u4e0d\u80fd\u89e6\u78b0\u6b63\u5728\u4f7f\u7528\u4e2d\u7684\u8d44\u6e90\u3002\u5f88\u660e\u663e\uff0c\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u672c\u8eab\u3002\u56fe\u50cf\u89c6\u56fe\u4e5f\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4eec\u76f4\u63a5\u5efa\u7acb\u5728\u4ea4\u6362\u94fe\u56fe\u50cf\u57fa\u7840\u4e0a\u3002\u6e32\u67d3\u901a\u9053\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4f9d\u8d56\u4ea4\u6362\u94fe\u56fe\u50cf\u7684\u683c\u5f0f\u3002\u5728\u7a97\u4f53\u8c03\u6574\u5927\u5c0f\u7684\u64cd\u4f5c\u671f\u95f4\uff0c\u4ea4\u6362\u94fe\u56fe\u50cf\u683c\u5f0f\u5f88\u5c11\u53d1\u751f\u53d8\u5316\uff0c\u4f46\u4ecd\u5e94\u8be5\u88ab\u5904\u7406\u3002\u5728\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u671f\u95f4\u6307\u5b9a Viewport \u548c scissor \u77e9\u5f62\u5927\u5c0f\uff0c\u6240\u4ee5\u7ba1\u7ebf\u9700\u8981\u91cd\u65b0\u6784\u5efa\u3002\u53ef\u4ee5\u4f7f\u7528\u52a8\u6001\u72b6\u6001\u6539\u53d8 viewports \u548c scissor rectangles \uff0c\u907f\u514d\u91cd\u65b0\u521b\u5efa\u3002\u6700\u540e\u5e27\u7f13\u51b2\u533a\u548c\u547d\u4ee4\u7f13\u51b2\u533a\u4e5f\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4eec\u4e5f\u4f9d\u8d56\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u3002 \u4e3a\u4e86\u786e\u4fdd\u91cd\u65b0\u521b\u5efa\u76f8\u5173\u7684\u5bf9\u8c61\u4e4b\u524d\uff0c\u8001\u7248\u672c\u7684\u5bf9\u8c61\u88ab\u7cfb\u7edf\u6b63\u786e\u56de\u6536\u6e05\u7406\uff0c\u6211\u4eec\u9700\u8981\u79fb\u52a8\u4e00\u4e9bcleanup\u4ee3\u7801\u5230\u4e0d\u540c\u7684\u51fd\u6570\u4e2d\uff0c\u8fd9\u6837\u53ef\u4ee5\u5728 recreateSwapChain \u51fd\u6570\u8c03\u7528\u3002\u8be5\u51fd\u6570\u5b9a\u4e49\u4e3a cleanupSwapChain : void cleanupSwapChain() { } void recreateSwapChain() { vkDeviceWaitIdle(device); cleanupSwapChain() createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers(); } \u6211\u4eec\u4ece cleanup \u4e2d\u5c06\u9700\u8981\u88ab\u91cd\u65b0\u521b\u5efa\u7684\u5bf9\u8c61\u6240\u5bf9\u5e94\u7684\u6e05\u7406\u4ee3\u7801\u79fb\u52a8\u5230 cleanupSwapChain \u4e2d: void cleanupSwapChain() { for (size_t i = 0; i < swapChainFramebuffers.size(); i++) { vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); } vkFreeCommandBuffers(device, commandPool, static_cast<uint32_t>(commandBuffers.size()), commandBuffers.data()); vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); for (size_t i = 0; i < swapChainImageViews.size(); i++) { vkDestroyImageView(device, swapChainImageViews[i], nullptr); } vkDestroySwapchainKHR(device, swapChain, nullptr); } void cleanup() { cleanupSwapChain(); vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); vkDestroyCommandPool(device, commandPool, nullptr); vkDestroyDevice(device, nullptr); DestroyDebugReportCallbackEXT(instance, callback, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate(); } \u6211\u4eec\u91cd\u5934\u521b\u5efa\u547d\u4ee4\u5bf9\u8c61\u6c60 command pool \uff0c\u4f46\u662f\u6bd4\u8f83\u6d6a\u8d39\u770b\u8d77\u6765\u3002\u76f8\u53cd\u7684\uff0c\u6211\u4eec\u9009\u62e9\u501f\u52a9 vkFreeCommandBuffers \u51fd\u6570\u6e05\u7406\u5df2\u7ecf\u5b58\u5728\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u8fd9\u79cd\u65b9\u5f0f\u53ef\u4ee5\u91cd\u7528\u5bf9\u8c61\u6c60\u4e2d\u5df2\u7ecf\u5206\u914d\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002 \u4ee5\u4e0a\u90e8\u5206\u5c31\u662f\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u7684\u5de5\u4f5c\uff01\u7136\u800c\u8fd9\u6837\u505a\u7684\u7f3a\u70b9\u5c31\u662f\u5728\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u5b8c\u6bd5\u4e4b\u524d\uff0c\u4f1a\u9020\u6210\u6e32\u67d3\u505c\u6b62\u3002\u521b\u5efa\u65b0\u4ea4\u6362\u94fe\u7684\u540c\u65f6\u5141\u8bb8\u5728\u65e7\u7684\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u4e0a\u7ee7\u7eed\u7ed8\u5236\u547d\u4ee4\u3002\u9700\u8981\u5c06\u4e4b\u524d\u7684\u4ea4\u6362\u94fe\u4f20\u9012\u5230 VkSwapchainCreateInfoKHR \u7ed3\u6784\u4f53\u4e2d\u7684 oldSwapChain \u5b57\u6bb5\uff0c\u5e76\u5728\u4f7f\u7528\u4e4b\u540e\u7acb\u5373\u9500\u6bc1\u3002 \u7a97\u53e3\u5927\u5c0f\u8c03\u6574 \u73b0\u5728\u6211\u4eec\u9700\u8981\u641e\u6e05\u695a\u54ea\u4e9b\u60c5\u51b5\u4e0b\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u662f\u5fc5\u8981\u7684\uff0c\u5e76\u8c03\u7528 recreateSwapChain \u51fd\u6570\u3002\u4e00\u4e2a\u901a\u5e38\u7684\u6761\u4ef6\u662f\u7a97\u4f53\u7684\u5927\u5c0f\u53d8\u5316\u3002\u8ba9\u6211\u4eec\u8c03\u6574\u7a97\u4f53\u7684\u5927\u5c0f\uff0c\u5e76\u89c2\u5bdf\u6355\u6349\u5230\u7684\u4e8b\u4ef6\u3002\u4fee\u6539 initWindow \u51fd\u6570\u4e0d\u518d\u5305\u542b GLFW_RESIZABLE \u884c\uff0c\u6216\u8005\u5c06\u5176\u53c2\u6570\u4ece GLFW_FALSE \u4fee\u6539\u4e3a GLFW_TRUE \u3002 void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); glfwSetWindowUserPointer(window, this); glfwSetWindowSizeCallback(window, HelloTriangleApplication::onWindowResized); } ... static void onWindowResized(GLFWwindow* window, int width, int height) { if (width == 0 || height == 0) return; HelloTriangleApplication* app = reinterpret_cast<HelloTriangleApplication*>(glfwGetWindowUserPointer(window)); app->recreateSwapChain(); } C++ glfwSetWindowSizeCallback \u51fd\u6570\u4f1a\u5728\u7a97\u4f53\u53d1\u751f\u5927\u5c0f\u53d8\u5316\u7684\u65f6\u5019\u88ab\u4e8b\u4ef6\u56de\u8c03\u3002\u9057\u61be\u7684\u662f\uff0c\u5b83\u53ea\u80fd\u63a5\u53d7\u4e00\u4e2a\u6307\u9488\u4f5c\u4e3a\u53c2\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u76f4\u63a5\u4f7f\u7528\u6210\u5458\u51fd\u6570\u3002\u4f46\u5e78\u8fd0\u7684\u662f\uff0cGLFW\u5141\u8bb8\u6211\u4eec\u4f7f\u7528 glfwSetWindowUserPointer \u5c06\u4efb\u610f\u6307\u9488\u5b58\u50a8\u5728\u7a97\u4f53\u5bf9\u8c61\u4e2d\uff0c\u56e0\u6b64\u53ef\u4ee5\u6307\u5b9a\u9759\u6001\u7c7b\u6210\u5458\u8c03\u7528 glfwGetWindowUserPointer \u8fd4\u56de\u539f\u59cb\u7684\u5b9e\u4f8b\u5bf9\u8c61\u3002\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528 recreateSwapChain \uff0c\u8fd9\u79cd\u60c5\u51b5\u901a\u5e38\u53d1\u751f\u5728\uff0c\u7a97\u4f53\u6700\u5c0f\u5316\u5e76\u4e14\u5bfc\u81f4\u4ea4\u6362\u94fe\u521b\u5efa\u5931\u8d25\u65f6. chooseSwapExtent \u51fd\u6570\u5e94\u8be5\u589e\u52a0\u66f4\u65b0\u903b\u8f91\uff0c\u4f7f\u7528\u7a97\u4f53\u6700\u65b0\u7684 width \u548c height \u4ee3\u66ff\u6700\u521d\u7684 WIDTH \u548c HEIGHT : int width, height; glfwGetWindowSize(window, &width, &height); VkExtent2D actualExtent = {width, height}; C++ \u6b21\u4f18\u6216\u8fc7\u671f\u7684\u4ea4\u6362\u94fe \u6709\u4e9b\u65f6\u5019 Vulkan \u53ef\u80fd\u544a\u8bc9\u6211\u4eec\u5f53\u524d\u7684\u4ea4\u6362\u94fe\u5728 presentation \u65f6\u4e0d\u518d\u517c\u5bb9\u3002 vkAcquireNextImageKHR \u548c vkQueuePresentKHR \u51fd\u6570\u53ef\u4ee5\u8fd4\u56de\u5177\u4f53\u7684\u503c\u660e\u786e\u3002 VK_ERROR_OUT_DATE_KHR : \u4ea4\u6362\u94fe\u4e0esurface\u4e0d\u518d\u517c\u5bb9\uff0c\u4e0d\u53ef\u8fdb\u884c\u6e32\u67d3 VK_SUBOPTIMAL_KHR : \u4ea4\u6362\u94fe\u4ecd\u7136\u53ef\u4ee5\u5411surface\u63d0\u4ea4\u56fe\u50cf\uff0c\u4f46\u662fsurface\u7684\u5c5e\u6027\u4e0d\u518d\u5339\u914d\u51c6\u786e\u3002\u6bd4\u5982\u5e73\u53f0\u53ef\u80fd\u91cd\u65b0\u8c03\u6574\u56fe\u50cf\u7684\u5c3a\u5bf8\u9002\u5e94\u7a97\u4f53\u5927\u5c0f\u3002 VkResult result = vkAcquireNextImageKHR(device, swapChain, std::numeric_limits<uint64_t>::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex); if (result == VK_ERROR_OUT_OF_DATE_KHR) { recreateSwapChain(); return; } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) { throw std::runtime_error(\"failed to acquire swap chain image!\"); } C++ \u5982\u679c\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf timeout \uff0c\u8868\u660e\u4e0d\u518d\u53ef\u7528\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u7acb\u5373\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\uff0c\u5e76\u5728\u4e0b\u4e00\u6b21 drawFrame \u8c03\u7528\u4e2d\u5c1d\u8bd5\u83b7\u53d6\u3002 \u4f60\u4e5f\u53ef\u4ee5\u9009\u62e9\u5728\u4ea4\u6362\u94fe\u4e0d\u662f\u6700\u4f73\u72b6\u6001\u7684\u65f6\u5019\uff0c\u9009\u62e9\u91cd\u65b0\u521b\u5efa\uff0c\u6bd4\u5982\u521a\u624d\u8bf4\u7684\u5927\u5c0f\u4e0d\u5339\u914d\u95ee\u9898\u3002\u5728\u8fd9\u91cc\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u83b7\u5f97\u4e86\u4e00\u4e2a\u56fe\u50cf\uff0c\u6240\u4ee5\u7ee7\u7eed\u8fdb\u884c\u3002 VK_SUCCESS \u548c VK_SUBOPTIMAL_KHR \u90fd\u88ab\u8ba4\u4e3a\u662f\u201c\u6210\u529f\u201d\u8fd4\u56de\u7801\u3002 result = vkQueuePresentKHR(presentQueue, &presentInfo); if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) { recreateSwapChain(); } else if (result != VK_SUCCESS) { throw std::runtime_error(\"failed to present swap chain image!\"); } vkQueueWaitIdle(presentQueue); vkQueuePresentKHR \u51fd\u6570\u8fd4\u56de\u540c\u6837\u7684\u503c\u3002\u5728\u6211\u4eec\u7684\u6848\u4f8b\u4e2d\u6211\u4eec\uff0c\u5982\u679c\u662f\u975e\u6700\u4f73\u72b6\u6001\uff0c\u4e5f\u9009\u62e9\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u3002\u56e0\u4e3a\u6211\u4eec\u9700\u8981\u6700\u597d\u7684\u6548\u679c\u3002\u5c1d\u8bd5\u8c03\u6574\u7a97\u4f53\u7684\u5927\u5c0f\uff0c\u5e27\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u53d8\u5316\u4e0e\u7a97\u4f53\u5339\u914d\u3002 Congratulations \uff0c\u6211\u4eec\u5b8c\u7ed3\u4e86\u7b2c\u4e00\u4e2a\u8fd0\u884c\u6bd4\u8f83\u5b8c\u6574\u7684 Vulkan \u7a0b\u5e8f\uff0c\u5728\u4e0b\u9762\u7684\u7ae0\u8282\u4e2d\u6211\u4eec\u5c1d\u8bd5\u6446\u8131\u4e4b\u524d\u7684\u786c\u7f16\u7801\uff0c\u4f7f\u7528\u9876\u70b9\u7f13\u51b2\u533a\u4ee3\u66ff vertex shader \u4e2d\u5199\u6b7b\u9876\u70b9\u6570\u636e\u3002 \u7b2c\u4e8c\u7ae0 Vulkan \u9876\u70b9\u8f93\u5165 Vulkan \u521b\u5efa\u9876\u70b9\u7f13\u51b2\u533a Vulkan \u4e34\u65f6\u7f13\u51b2\u533a Vulkan \u7d22\u5f15\u7f13\u51b2\u533a Vulkan \u63cf\u8ff0\u7b26\u5e03\u5c40\u548c\u7f13\u51b2\u533a Vulkan \u63cf\u8ff0\u7b26\u6c60\u548c\u96c6\u5408 Vulkan \u56fe\u50cf(Images) Vulkan \u56fe\u50cf\u89c6\u56fe\u548c\u91c7\u6837\u5668 Vulkan \u7ec4\u5408\u56fe\u50cf\u53d6\u6837\u5668 Vulkan \u6df1\u5ea6\u7f13\u51b2\u533a Vulkan \u52a0\u8f7d\u6a21\u578b Vulkan \u751f\u6210\u8d34\u56fe(mipmap)","title":"Vulkan\u6559\u7a0b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_1","text":"","title":"\u7b2c\u4e00\u7ae0"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan-vulkan","text":"\u521b\u5efaVulkan\u5b9e\u4f8b \uff0c\u4e0e Vulkan \u6253\u4ea4\u9053\uff0c\u901a\u5e38\u7684\u6b65\u9aa4\u662f\u521b\u5efa\u4e00\u4e2a intance \u53bb\u521d\u59cb\u5316 Vulkan library \u3002\u8fd9\u4e2a instance \u662f\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u4e0e Vulkan \u5e93\u4e4b\u95f4\u7684\u8fde\u63a5\u6865\u6881,\u901a\u5e38\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u9700\u8981\u5411\u9a71\u52a8\u7a0b\u5e8f\u63d0\u4f9b\u4e00\u4e9b\u5e94\u7528\u5c42\u7684\u4fe1\u606f\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b 2 \u68c0\u67e5\u53ef\u9009\u529f\u80fd 3 \u9000\u51fa 4 \u6e90\u4ee3\u7801","title":"Vulkan \u521b\u5efaVulkan\u5b9e\u4f8b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_2","text":"Vulkan API \u4f7f\u7528 vkInstance \u5bf9\u8c61\u6765\u5b58\u50a8\u6240\u6709\u6bcf\u4e2a\u5e94\u7528\u7684\u72b6\u6001\u3002\u5e94\u7528\u7a0b\u5e8f\u5fc5\u987b\u5728\u6267\u884c\u4efb\u4f55\u5176\u4ed6 Vulkan \u64cd\u4f5c\u4e4b\u524d\u521b\u5efa\u4e00\u4e2a Vulkan \u5b9e\u4f8b\uff0c\u57fa\u672c\u7684 Vulkan \u67b6\u6784\u770b\u8d77\u6765\u662f\u8fd9\u6837\u7684\uff1a \u8bf7\u6ce8\u610f\uff0c\u56fe\u4e2d\u6709\u4e00\u4e9b\u5c42\uff08 Layer )\uff0c\u8fd9\u4e9b\u5c42\u4e5f\u88ab\u52a0\u8f7d\u5668\u52a0\u8f7d\u3002\u5c42\u901a\u5e38\u7528\u4e8e\u9a8c\u8bc1\uff0c\u901a\u5e38\u662f\u7531\u9a71\u52a8\u6267\u884c\u7684\u9519\u8bef\u68c0\u67e5\u3002\u5728 Vulkan \u4e2d\uff0c\u9a71\u52a8\u7a0b\u5e8f\u6bd4 OpenGL \u7b49\u5176\u4ed6 API \u8981\u8f7b\u91cf\u5f97\u591a\uff0c\u90e8\u5206\u539f\u56e0\u662f\u5b83\u5c06\u529f\u80fd\u9a8c\u8bc1\u59d4\u6258\u7ed9\u9a8c\u8bc1\u5c42\u3002\u5c42\u662f\u53ef\u9009\u7684\uff0c\u6bcf\u6b21\u5e94\u7528\u7a0b\u5e8f\u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u65f6\u90fd\u53ef\u4ee5\u9009\u62e9\u6027\u5730\u88c5\u8f7d\u3002 Vulkan Layer \u8d85\u51fa\u4e86\u672c\u7ae0\u7684\u8303\u56f4\uff0c\u4e0b\u9762\u5f00\u59cb\u521b\u5efavulkan\u5b9e\u4f8b\uff0c\u9996\u5148\u6dfb\u52a0\u4e00\u4e2a createInstance \u51fd\u6570\uff0c\u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\u3002 void initVulkan() { createInstance(); } C++ \u53e6\u5916\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u6765\u4fdd\u5b58 instance \u53e5\u67c4: private: VkInstance instance; C++ \u73b0\u5728\u6211\u4eec\u521b\u5efa\u4e00\u4e2a instance \uff0c\u5e76\u4e14\u4e3a\u8be5\u6570\u636e\u7ed3\u6784\u8d4b\u4e88\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u4fe1\u606f\u3002\u8fd9\u4e9b\u6570\u636e\u4ece\u6280\u672f\u89d2\u5ea6\u662f\u53ef\u9009\u62e9\u7684\uff0c\u4f46\u662f\u5b83\u53ef\u4ee5\u4e3a\u9a71\u52a8\u7a0b\u5e8f\u63d0\u4f9b\u4e00\u4e9b\u6709\u7528\u7684\u4fe1\u606f\u6765\u4f18\u5316\u7a0b\u5e8f\u7279\u6b8a\u7684\u4f7f\u7528\u60c5\u666f\uff0c\u6bd4\u5982\u9a71\u52a8\u7a0b\u5e8f\u4f7f\u7528\u4e00\u4e9b\u56fe\u5f62\u5f15\u64ce\u7684\u7279\u6b8a\u884c\u4e3a\u3002\u8fd9\u4e2a\u6570\u636e\u7ed3\u6784\u79f0\u4e3a VkApplicationInfo : VkApplicationInfo appInfo = {}; appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;appInfo.pNext = nullptr; appInfo.pApplicationName = \"Hello Triangle\"; appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.pEngineName = \"No Engine\"; appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.apiVersion = VK_API_VERSION_1_0; C++ \u5982\u524d\u6240\u8ff0\uff0c Vulkan \u4e2d\u7684\u8bb8\u591a\u6570\u636e\u7ed3\u6784\u8981\u6c42\u5728 sType \u6210\u5458\u4e2d\u660e\u786e\u7684\u6307\u5b9a\u7c7b\u578b\u3002 pNext \u6210\u5458\u53ef\u7528\u4e8e\u6307\u5411\u7279\u5b9a\u7684\u6269\u5c55\u7ed3\u6784\u3002\u6211\u4eec\u5728\u8fd9\u91cc\u4f7f\u7528\u9ed8\u8ba4\u521d\u59cb\u5316\uff0c\u5c06\u5176\u8bbe\u7f6e\u4e3a nullptr \u3002 Vulkan \u4e2d\u7684\u5927\u91cf\u4fe1\u606f\u901a\u8fc7\u7ed3\u6784\u4f53\u800c\u4e0d\u662f\u51fd\u6570\u53c2\u6570\u4f20\u9012\uff0c\u6211\u4eec\u5c06\u586b\u5145\u4e00\u4e2a\u7ed3\u6784\u4f53\u4ee5\u63d0\u4f9b\u8db3\u591f\u7684\u4fe1\u606f\u521b\u5efa instance \u3002\u4e0b\u4e00\u4e2a\u7ed3\u6784\u4f53\u4e0d\u662f\u53ef\u9009\u7684\uff0c\u5b83\u9700\u8981\u544a\u77e5 Vulkan \u9a71\u52a8\u7a0b\u5e8f\u6211\u4eec\u9700\u8981\u4f7f\u7528\u54ea\u4e9b\u5168\u5c40\u7684 extensions \u548c validation layers \u3002\u8fd9\u91cc\u7684\u5168\u5c40\u610f\u5473\u7740\u5b83\u9002\u7528\u4e8e\u6574\u4e2a\u7a0b\u5e8f\uff0c\u800c\u4e0d\u662f\u7279\u5b9a\u7684\u8bbe\u5907\uff0c\u8fd9\u4e9b\u5185\u5bb9\u5c06\u5728\u63a5\u4e0b\u6765\u7684\u5c0f\u8282\u4e2d\u8bf4\u660e\u3002 VkInstanceCreateInfo \u7ed3\u6784\u4f53\u4fe1\u606f\u5982\u4e0b\uff1a VkInstanceCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pApplicationInfo = &appInfo; C++ \u524d\u51e0\u4e2a\u53c2\u6570\u6bd4\u8f83\u7b80\u5355\u3002\u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u6307\u5b9a\u9700\u8981\u7684\u5168\u5c40\u6269\u5c55\uff0c Vulakn \u5bf9\u4e8e\u5e73\u53f0\u7279\u6027\u662f\u96f6 API \u652f\u6301\u7684(\u81f3\u5c11\u6682\u65f6\u8fd9\u6837)\uff0c\u8fd9\u610f\u5473\u7740\u9700\u8981\u4e00\u4e2a\u6269\u5c55\u624d\u80fd\u4e0e\u4e0d\u540c\u5e73\u53f0\u7684\u7a97\u4f53\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002 GLFW \u6709\u4e00\u4e2a\u65b9\u4fbf\u7684\u5185\u7f6e\u51fd\u6570\uff0c\u8fd4\u56de\u5b83\u6709\u5173\u7684\u6269\u5c55\u4fe1\u606f\uff0c\u6211\u4eec\u53ef\u4ee5\u4f20\u9012\u7ed9 struct : unsigned int glfwExtensionCount = 0; const char** glfwExtensions; glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount); createInfo.enabledExtensionCount = glfwExtensionCount; createInfo.ppEnabledExtensionNames = glfwExtensions; C++ \u7ed3\u6784\u4f53\u7684\u6700\u540e\u4e24\u4e2a\u6210\u5458\u786e\u5b9a\u9700\u8981\u5f00\u542f\u7684\u5168\u5c40\u7684 validation layers \u3002\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u4e00\u8282\u4e2d\u6df1\u5165\u63a2\u8ba8\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u5728\u8fd9\u4e00\u8282\u8bbe\u7f6e\u4e3a\u7a7a\u3002 createInfo.enabledLayerCount = 0; C++ \u6211\u4eec\u73b0\u5728\u5df2\u7ecf\u6307\u5b9a\u4e86 Vulkan \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u9700\u8981\u7684\u4e00\u5207\u4fe1\u606f\uff0c\u8c03\u7528 vkCreateInstance \u521b\u5efa\u5c5e\u4e8e\u6211\u4eec\u7684\u7b2c\u4e00\u4e2a instance : VkResult result = vkCreateInstance(&createInfo, nullptr, &instance); C++ \u5982\u4f60\u6240\u89c1\uff0c Vulkan \u4e2d\u521b\u5efa\u3001\u5b9e\u4f8b\u5316\u76f8\u5173\u7684\u51fd\u6570\u53c2\u6570\u4e00\u822c\u9075\u5faa\u5982\u4e0b\u539f\u5219\u5b9a\u4e49: \u4f7f\u7528\u6709\u5173creation info \u7684\u7ed3\u6784\u4f53\u6307\u9488 \u4f7f\u7528\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u56de\u8c03\u7684\u6307\u9488 \u4f7f\u7528\u4fdd\u5b58\u65b0\u5bf9\u8c61\u53e5\u67c4\u7684\u6307\u9488 \u5982\u679c\u4e00\u5207\u987a\u5229\uff0c\u6b64\u523binstance\u7684\u53e5\u67c4\u5e94\u8be5\u5b58\u50a8\u5728 VkInstance \u7c7b\u6210\u5458\u4e2d\u4e86\u3002\u51e0\u4e4e\u6240\u6709\u7684Vulkan\u51fd\u6570\u90fd\u8fd4\u56de\u4e00\u4e2a\u503c\u4e3a VK_SUCCESS \u6216\u9519\u8bef\u4ee3\u7801\u7684 VkResult \u7c7b\u578b\u7684\u503c\u3002\u8981\u68c0\u67e5 instance \u662f\u5426\u5df2\u7ecf\u6210\u529f\u521b\u5efa\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u4fdd\u5b58\u7ed3\u679c\uff0c\u4ec5\u4ec5\u4f7f\u7528 VK_SUCCESS \u503c\u6765\u68c0\u6d4b\u5373\u53ef\uff1a if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) { throw std::runtime_error(\"failed to create instance!\"); } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\uff0c\u786e\u8ba4\u6211\u4eec\u7684 instance \u521b\u5efa\u6210\u529f\u3002","title":"\u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_3","text":"\u5982\u679c\u4f60\u67e5\u770b vkCreateInstance \u7684\u6587\u6863\uff0c\u4f60\u4f1a\u770b\u5230\u4e00\u4e2a\u53ef\u80fd\u51fa\u73b0\u7684\u9519\u8bef\u4ee3\u7801\u662f VK_ERROR_EXTENSION_NOT_PRESENT \u3002\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u5730\u6307\u5b9a\u6211\u4eec\u9700\u8981\u7684\u6269\u5c55\uff0c\u5982\u679c\u8be5\u9519\u8bef\u4ee3\u7801\u8fd4\u56de\uff0c\u5219\u7ec8\u6b62\u5b83\u4eec\u3002\u8fd9\u5bf9\u4e8e\u7a97\u4f53\u7cfb\u7edf\u6216\u8005\u8bf8\u5982\u6b64\u7c7b\u7684\u6269\u5c55\u662f\u6709\u610f\u4e49\u7684\uff0c\u90a3\u4e48\u5982\u4f55\u68c0\u67e5\u53ef\u9009\u529f\u80fd\u5462\uff1f \u5728\u521b\u5efa instance \u4e4b\u524d\u68c0\u7d22\u652f\u6301\u7684\u6269\u5c55\u5217\u8868\uff0c\u901a\u8fc7 vkEnumerateInstanceExtensionProperties \u51fd\u6570\u3002\u5b83\u6307\u5411\u4e00\u4e2a\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u5b58\u50a8\u6269\u5c55\u6570\u91cf\u548c\u4e00\u4e2a VkExtensionProperties \u6570\u7ec4\u6765\u5b58\u50a8\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f\u3002\u5b83\u4e5f\u63a5\u53d7\u4e00\u4e2a\u53ef\u9009\u62e9\u7684\u53c2\u6570\uff0c\u5141\u8bb8\u6211\u4eec\u901a\u8fc7\u7279\u5b9a\u7684 validation layers \u8fc7\u6ee4\u6269\u5c55\uff0c\u73b0\u5728\u6211\u4eec\u6682\u65f6\u5ffd\u7565\u8fd9\u4e9b\u3002 \u8981\u5206\u914d\u4e00\u4e2a\u6570\u7ec4\u6765\u4fdd\u5b58\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u77e5\u9053\u6709\u591a\u5c11\u4e2a\u6269\u5c55\u5b58\u5728\u3002\u53ef\u4ee5\u901a\u8fc7\u5c06\u540e\u4e00\u4e2a\u53c2\u6570\u7f6e\u7a7a\u6765\u83b7\u53d6\u6269\u5c55\u6570\u91cf: uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr); C++ \u73b0\u5728\u6211\u4eec\u5206\u914d\u4e00\u4e2a\u96c6\u5408\u53bb\u6301\u6709\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f( include ) std::vector<VkExtensionProperties> extensions(extensionCount); C++ \u6700\u540e\u6211\u4eec\u53ef\u4ee5\u904d\u5386\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f: vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data()); C++ \u6bcf\u4e2a VkExtensionProperties \u7ed3\u6784\u4f53\u5305\u542b\u6269\u5c55\u7684\u540d\u79f0\u548c\u7248\u672c\u3002\u6211\u4eec\u53ef\u4ee5\u7528\u7b80\u5355\u7684for\u5faa\u73af\u6253\u5370\u4ed6\u4eec(\\t\u662f\u7f29\u8fdb) std::cout << \"available extensions:\" << std::endl; for (const auto& extension : extensions) { std::cout << \"\\t\" << extension.extensionName << std::endl; } C++ \u5982\u679c\u9700\u8981\u83b7\u53d6\u6709\u5173 Vulkan \u652f\u6301\u7684\u4e00\u4e9b\u8be6\u7ec6\u4fe1\u606f\uff0c\u53ef\u4ee5\u5c06\u6b64\u4ee3\u7801\u6dfb\u52a0\u5230 createInstance \u51fd\u6570\u3002\u4f5c\u4e3a\u4e00\u4e2a\u5c1d\u8bd5\uff0c\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\uff0c\u68c0\u67e5 glfwGetRequiredInstanceExtensions \u8fd4\u56de\u7684\u6240\u6709\u6269\u5c55\u662f\u5426\u90fd\u5305\u542b\u5728\u53d7\u652f\u6301\u7684\u6269\u5c55\u5217\u8868\u4e2d\u3002","title":"\u68c0\u67e5\u53ef\u9009\u529f\u80fd"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_4","text":"\u5728\u7a0b\u5e8f\u9000\u51fa\u524d\uff0c\u8bf7\u6b63\u786e\u9500\u6bc1 VkInstance \u3002\u8fd9\u90e8\u5206\u53ef\u4ee5\u5b9a\u4e49\u5728cleanup\u51fd\u6570\u4e2d\uff0c\u8c03\u7528 vkDestroyInstance \u51fd\u6570\u5b8c\u6210\u3002 void cleanup() { vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate(); } C++ vkDestroyInstance \u51fd\u6570\u7684\u53c2\u6570\u5f88\u7b80\u5355\u3002\u50cf\u4e4b\u524d\u5c0f\u8282\u63d0\u5230\u7684\uff0cVulkan\u4e2d\u7684\u5206\u914d\u548c\u91ca\u653e\u529f\u80fd\u6709\u4e00\u4e2a\u53ef\u9009\u7684\u5206\u914d\u5668\u56de\u8c03\uff0c\u6211\u4eec\u901a\u8fc7\u5c06 nullptr \u8bbe\u7f6e\u5ffd\u7565\u3002\u540e\u7eed\u5c0f\u8282\u4e2d\u521b\u5efa\u7684\u6240\u6709Vulkan\u76f8\u5173\u8d44\u6e90\uff0c\u96c6\u4e2d\u5728cleanup\u51fd\u6570\u4e2d\u8fdb\u884c\u6e05\u7406\uff0c\u4e14\u786e\u4fdd\u5728\u9500\u6bc1 instance \u4e4b\u524d\u9500\u6bc1\u3002 \u5728\u8fdb\u884c\u66f4\u590d\u6742\u7684\u5185\u5bb9\u4e4b\u524d\uff0c\u662f\u65f6\u5019\u4e86\u89e3 validation layers \u4e86\u3002","title":"\u9000\u51fa"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan","text":"Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217 \uff0c\u901a\u8fc7 VkInstance \u521d\u59cb\u5316 Vulkan \u540e\uff0c\u6211\u4eec\u9700\u8981\u5728\u7cfb\u7edf\u4e2d\u67e5\u627e\u5e76\u9009\u62e9\u4e00\u4e2a\u652f\u6301\u6211\u4eec\u6240\u9700\u529f\u80fd\u7684\u663e\u5361\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u6570\u91cf\u7684\u663e\u5361\u5e76\u540c\u65f6\u4f7f\u7528\u4ed6\u4eec\uff0c\u4f46\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u5355\u7684\u8bbe\u5b9a\u9009\u62e9\u89c4\u5219\uff0c\u5373\u5c06\u67e5\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u56fe\u5f62\u5361\u4f5c\u4e3a\u6211\u4eec\u9002\u5408\u7684\u7269\u7406\u8bbe\u5907\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9009\u62e9\u7269\u7406\u8bbe\u5907 2 \u8bbe\u5907\u9700\u6c42\u68c0\u6d4b 3 \u961f\u5217\u65cf 4 \u6e90\u4ee3\u7801","title":"Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217\u7c07"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_5","text":"\u901a\u8fc7 VkInstance \u521d\u59cb\u5316Vulkan\u540e\uff0c\u6211\u4eec\u9700\u8981\u5728\u7cfb\u7edf\u4e2d\u67e5\u627e\u5e76\u9009\u62e9\u4e00\u4e2a\u652f\u6301\u6211\u4eec\u6240\u9700\u529f\u80fd\u7684\u663e\u5361\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u6570\u91cf\u7684\u663e\u5361\u5e76\u540c\u65f6\u4f7f\u7528\u4ed6\u4eec\uff0c\u4f46\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u5355\u7684\u8bbe\u5b9a\u9009\u62e9\u89c4\u5219\uff0c\u5373\u5c06\u67e5\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u56fe\u5f62\u5361\u4f5c\u4e3a\u6211\u4eec\u9002\u5408\u7684\u7269\u7406\u8bbe\u5907\u3002 \u6211\u4eec\u6dfb\u52a0\u51fd\u6570 pickPhysicalDevice \u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); pickPhysicalDevice(); } void pickPhysicalDevice() { } C++ \u6700\u7ec8\u6211\u4eec\u9009\u62e9\u7684\u56fe\u5f62\u663e\u5361\u5b58\u50a8\u5728\u7c7b\u6210\u5458 VkPhysicalDevice \u53e5\u67c4\u4e2d\u3002\u5f53 VkInstance \u9500\u6bc1\u65f6\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u5c06\u4f1a\u88ab\u9690\u5f0f\u9500\u6bc1\uff0c\u6240\u4ee5\u6211\u4eec\u5e76\u4e0d\u9700\u8981\u5728 cleanup \u51fd\u6570\u4e2d\u505a\u4efb\u4f55\u64cd\u4f5c\u3002 VkPhysicalDevice physicalDevice = VK_NULL_HANDLE; C++ \u5173\u4e8e\u83b7\u53d6\u56fe\u5f62\u5361\u5217\u8868\u7684\u65b9\u5f0f\u4e0e\u83b7\u5f97\u6269\u5c55\u5217\u8868\u7684\u65b9\u5f0f\u7c7b\u4f3c\u3002 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); C++ \u5982\u679c Vulkan \u652f\u6301\u7684\u8bbe\u5907\u6570\u4e3a0\uff0c\u90a3\u4e48\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u8fdb\u884c\u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u9009\u62e9\u629b\u51fa\u5f02\u5e38\u3002 if (deviceCount == 0) { throw std::runtime_error(\"failed to find GPUs with Vulkan support!\"); } C++ \u5426\u5219\u6211\u4eec\u5206\u914d\u6570\u7ec4\u5b58\u50a8\u6240\u6709 VkPhysicalDevice \u7684\u53e5\u67c4\u3002 std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); C++ \u73b0\u5728\u6211\u4eec\u9700\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u8bc4\u4f30\uff0c\u68c0\u67e5\u5b83\u4eec\u662f\u5426\u9002\u5408\u6211\u4eec\u8981\u6267\u884c\u7684\u64cd\u4f5c\uff0c\u56e0\u4e3a\u5e76\u4e0d\u662f\u6240\u6709\u7684\u663e\u5361\u529f\u80fd\u4e00\u81f4\u3002\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u51fd\u6570: bool isDeviceSuitable(VkPhysicalDevice device) { return true; } C++ \u6211\u4eec\u5c06\u68c0\u67e5\u662f\u5426\u6709\u4efb\u4f55\u7269\u7406\u8bbe\u5907\u7b26\u5408\u6211\u4eec\u7684\u529f\u80fd\u9700\u6c42\u3002 for (const auto& device : devices) { if (isDeviceSuitable(device)) { physicalDevice = device; break; } } if (physicalDevice == VK_NULL_HANDLE) { throw std::runtime_error(\"failed to find a suitable GPU!\"); } C++ \u4e0b\u4e00\u8282\u6211\u4eec\u4ecb\u7ecd isDeviceSuitable \u51fd\u6570\uff0c\u5e76\u68c0\u67e5\u7b2c\u4e00\u4e2a\u9700\u8981\u6ee1\u8db3\u7684\u529f\u80fd\u3002\u5728\u540e\u7eed\u7684\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u5f00\u59cb\u4f7f\u7528\u66f4\u591a\u7684 Vulkan \u529f\u80fd\uff0c\u6211\u4eec\u4f1a\u6269\u5c55\u6b64\u529f\u80fd\u51fd\u6570\u4ee5\u6ee1\u8db3\u66f4\u591a\u7684\u68c0\u67e5\u6761\u4ef6\u3002","title":"\u9009\u62e9\u7269\u7406\u8bbe\u5907"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_6","text":"\u8bc4\u4f30\u5408\u9002\u7684\u8bbe\u5907\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u904d\u5386\u4e00\u4e9b\u7ec6\u8282\u6765\u5b8c\u6210\u3002\u57fa\u672c\u7684\u8bbe\u5907\u5c5e\u6027\u50cfname, type\u4ee5\u53ca Vulkan \u7248\u672c\u90fd\u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceProperties \u6765\u904d\u5386\u5f97\u5230\u3002 VkPhysicalDeviceProperties deviceProperties; vkGetPhysicalDeviceProperties(device, &deviceProperties); C++ \u53ef\u4ee5\u4f7f\u7528 vkGetPhysicalDeviceFeatures \u67e5\u8be2\u5bf9\u7eb9\u7406\u538b\u7f29\uff0c64\u4f4d\u6d6e\u70b9\u6570\u548c\u591a\u89c6\u56fe\u6e32\u67d3(VR\u975e\u5e38\u6709\u7528)\u7b49\u53ef\u9009\u529f\u80fd\u7684\u652f\u6301: VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceFeatures(device, &deviceFeatures); C++ \u66f4\u591a\u904d\u5386\u7269\u7406\u8bbe\u5907\u7ec6\u8282\u7684\u4fe1\u606f\uff0c\u8bf8\u5982\u8bbe\u5907\u5185\u5b58\u3001\u961f\u5217\u7c07\u6211\u4eec\u5c06\u4f1a\u5728\u540e\u7eed\u5c0f\u8282\u8ba8\u8bba\u3002 \u4f8b\u5982\uff0c\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u4ec5\u9002\u7528\u4e8e\u652f\u6301 geometry shaders \u7684\u4e13\u7528\u663e\u5361\u3002\u90a3\u4e48 isDeviceSuitable \u51fd\u6570\u5c06\u5982\u4e0b\u6240\u793a: bool isDeviceSuitable(VkPhysicalDevice device) { VkPhysicalDeviceProperties deviceProperties; VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceProperties(device, &deviceProperties); vkGetPhysicalDeviceFeatures(device, &deviceFeatures); return deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU && deviceFeatures.geometryShader; } C++ \u4e3a\u4e86\u907f\u514d\u7eaf\u7cb9\u7684\u5355\u4e00\u7684\u5224\u65ad\u4e00\u4e2a\u8bbe\u5907\u662f\u5426\u5408\u9002\uff0c\u5c24\u5176\u662f\u5f53\u4f60\u53d1\u73b0\u591a\u4e2a\u8bbe\u5907\u90fd\u5408\u9002\u7684\u6761\u4ef6\u4e0b\uff0c\u4f60\u4e5f\u53ef\u4ee5\u7ed9\u6bcf\u4e00\u4e2a\u8bbe\u5907\u505a\u6743\u503c\uff0c\u9009\u62e9\u6700\u9ad8\u7684\u4e00\u4e2a\u3002\u8fd9\u6837\uff0c\u53ef\u4ee5\u901a\u8fc7\u7ed9\u4e88\u66f4\u9ad8\u6743\u503c\u83b7\u53d6\u5b9a\u5236\u5316\u7684\u56fe\u5f62\u8bbe\u5907\uff0c\u4f46\u5982\u679c\u6ca1\u6709\u4e00\u4e2a\u53ef\u7528\u7684\u8bbe\u5907\uff0c\u53ef\u4ee5\u56de\u6eda\u5230\u96c6\u6210\u56fe\u5f62\u8bbe\u5907\u3002\u4f60\u53ef\u4ee5\u6309\u7167\u5982\u4e0b\u65b9\u5f0f\u5b9e\u73b0: #include <map> ... void pickPhysicalDevice() { ... // Use an ordered map to automatically sort candidates by increasing score std::multimap<int, VkPhysicalDevice> candidates; for (const auto& device : devices) { int score = rateDeviceSuitability(device); candidates.insert(std::make_pair(score, device)); } // Check if the best candidate is suitable at all if (candidates.rbegin()->first > 0) { physicalDevice = candidates.rbegin()->second; } else { throw std::runtime_error(\"failed to find a suitable GPU!\"); } } int rateDeviceSuitability(VkPhysicalDevice device) { ... int score = 0; // Discrete GPUs have a significant performance advantage if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) { score += 1000; } // Maximum possible size of textures affects graphics quality score += deviceProperties.limits.maxImageDimension2D; // Application can't function without geometry shaders if (!deviceFeatures.geometryShader) { return 0; } return score; } C++ \u6211\u4eec\u4e0d\u9700\u8981\u5728\u5c0f\u8282\u5185\u5b9e\u73b0\u6240\u6709\u5185\u5bb9\uff0c\u4f46\u6211\u4eec\u53ef\u4ee5\u4e86\u89e3\u5982\u4f55\u9009\u62e9\u56fe\u5f62\u8bbe\u5907\u7684\u8fc7\u7a0b\u3002\u5f53\u7136\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u793a\u56fe\u5f62\u8bbe\u5907\u7684\u540d\u79f0\u5217\u8868\uff0c\u8ba9\u7528\u6237\u9009\u62e9\u3002 \u56e0\u4e3a\u6211\u4eec\u521a\u521a\u5f00\u59cb\uff0c Vulkan \u7684\u652f\u6301\u662f\u6211\u4eec\u552f\u4e00\u9700\u8981\u7684\uff0c\u5728\u8fd9\u91cc\u5047\u8bbe\u4efb\u4f55GPU\u90fd\u53ef\u4ee5: bool isDeviceSuitable(VkPhysicalDevice device) { return true; } C++ \u5728\u4e0b\u4e00\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u8ba8\u8bba\u7b2c\u4e00\u4e2a\u771f\u6b63\u9700\u8981\u68c0\u67e5\u7684\u8bbe\u5907\u529f\u80fd\u3002","title":"\u8bbe\u5907\u9700\u6c42\u68c0\u6d4b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_7","text":"\u4e4b\u524d\u5df2\u7ecf\u7b80\u8981\u7684\u4ecb\u7ecd\u8fc7\uff0c\u51e0\u4e4e\u6240\u6709\u7684 Vulkan \u64cd\u4f5c\uff0c\u4ece\u7ed8\u56fe\u5230\u4e0a\u4f20\u7eb9\u7406\uff0c\u90fd\u9700\u8981\u5c06\u547d\u4ee4\u63d0\u4ea4\u5230\u961f\u5217\u4e2d\u3002\u6709\u4e0d\u540c\u7c7b\u578b\u7684\u961f\u5217\u6765\u6e90\u4e8e\u4e0d\u540c\u7684\u961f\u5217\u7c07\uff0c\u6bcf\u4e2a\u961f\u5217\u7c07\u53ea\u5141\u8bb8\u90e8\u5206 commands \u3002\u4f8b\u5982\uff0c\u53ef\u4ee5\u6709\u4e00\u4e2a\u961f\u5217\u7c07\uff0c\u53ea\u5141\u8bb8\u5904\u7406\u8ba1\u7b97 commands \u6216\u8005\u53ea\u5141\u8bb8\u5185\u5b58\u4f20\u8f93 commands : \u6211\u4eec\u9700\u8981\u68c0\u6d4b\u8bbe\u5907\u4e2d\u652f\u6301\u7684\u961f\u5217\u7c07\uff0c\u5176\u4e2d\u54ea\u4e00\u4e2a\u961f\u5217\u7c07\u652f\u6301\u6211\u4eec\u60f3\u8981\u7684 commands \u3002\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u51fd\u6570 findQueueFamilies \u6765\u67e5\u627e\u6211\u4eec\u9700\u8981\u7684\u961f\u5217\u7c07\u3002\u73b0\u5728\u6211\u4eec\u53ea\u4f1a\u5bfb\u627e\u4e00\u4e2a\u652f\u6301\u56fe\u5f62 commands \u961f\u5217\u7c07\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u5728\u7a0d\u540e\u7684\u5c0f\u8282\u4e2d\u6269\u5c55\u66f4\u591a\u7684\u5185\u5bb9\u3002 \u6b64\u51fd\u6570\u8fd4\u56de\u6ee1\u8db3\u67d0\u4e2a\u5c5e\u6027\u7684\u961f\u5217\u7c07\u7d22\u5f15\u3002\u5b9a\u4e49\u7ed3\u6784\u4f53\uff0c\u5176\u4e2d\u7d22\u5f15 -1 \u8868\u793a\u201d\u672a\u627e\u5230\u201d: struct QueueFamilyIndices { int graphicsFamily = -1; bool isComplete() { return graphicsFamily >= 0; } }; C++ \u73b0\u5728\u6211\u4eec\u5b9e\u73b0 findQueueFamilies \u51fd\u6570: QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) { QueueFamilyIndices indices; ... return indices; } C++ \u83b7\u53d6\u961f\u5217\u7c07\u7684\u5217\u8868\u51fd\u6570\u4e3a vkGetPhysicalDeviceQueueFamilyProperties : uint32_t queueFamilyCount = 0; vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr); std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount); vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data()); C++ \u6709\u5173\u961f\u5217\u7c07\uff0c\u7ed3\u6784\u4f53 VkQueueFamilyProperties \u5305\u542b\u4e86\u5177\u4f53\u4fe1\u606f\uff0c\u5305\u62ec\u652f\u6301\u7684\u64cd\u4f5c\u7c7b\u578b\u548c\u57fa\u4e8e\u5f53\u524d\u961f\u5217\u7c07\u53ef\u4ee5\u521b\u5efa\u7684\u6709\u6548\u961f\u5217\u6570\u3002\u6211\u4eec\u81f3\u5c11\u9700\u8981\u627e\u5230\u4e00\u4e2a\u652f\u6301 VK_QUEUE_GRAPHICS_BIT \u7684\u961f\u5217\u7c07\u3002 int i = 0; for (const auto& queueFamily : queueFamilies) { if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) { indices.graphicsFamily = i; } if (indices.isComplete()) { break; } i++; } C++ \u73b0\u5728\u6211\u4eec\u6709\u4e86\u6bd4\u8f83\u7406\u60f3\u7684\u961f\u5217\u7c07\u67e5\u8be2\u529f\u80fd\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 isDeviceSuitable \u51fd\u6570\u4e2d\u4f7f\u7528\uff0c\u786e\u4fdd\u7269\u7406\u8bbe\u5907\u53ef\u4ee5\u5904\u7406\u6211\u4eec\u9700\u8981\u7684\u547d\u4ee4: bool isDeviceSuitable(VkPhysicalDevice device) { QueueFamilyIndices indices = findQueueFamilies(device); return indices.isComplete(); } C++ \u5f88\u597d\uff0c\u6211\u4eec\u5df2\u7ecf\u627e\u5230\u4e86\u6211\u4eec\u9700\u8981\u7684\u7269\u7406\u8bbe\u5907\uff0c\u5728 \u4e0b\u4e00\u4e2a\u5c0f\u8282 \u6211\u4eec\u4f1a\u8ba8\u8bba\u903b\u8f91\u8bbe\u5907\u3002","title":"\u961f\u5217\u65cf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_1","text":"Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b \uff0c \u4e0a\u4e00\u8282 \u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6b63\u786e\u914d\u7f6e\u3001\u53ef\u8fd0\u884c\u7684\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u4f7f\u7528\u6d4b\u8bd5\u4ee3\u7801\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u672c\u8282\u4e2d\u6211\u4eec\u4ece\u5934\u5f00\u59cb\uff0c\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u6784\u5efa\u4e00\u4e2a\u57fa\u4e8e GLFW \u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\u539f\u578b\u6846\u67b6\u7684\u96cf\u5f62\u3002 \u64cd\u4f5c\u7cfb\u7edf: Windows8.1 \u663e\u5361:Nivida GTX965M \u5f00\u53d1\u5de5\u5177\uff1aVisual Studio 2017 \u6587\u7ae0\u76ee\u5f55 1 \u603b\u4f53\u7ed3\u6784 2 \u8d44\u6e90\u7ba1\u7406 3 \u6574\u5408GLFW","title":"Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_8","text":"\u5728\u4e0a\u4e00\u8282\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6b63\u786e\u914d\u7f6e\u3001\u53ef\u8fd0\u884c\u7684\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u4f7f\u7528\u6d4b\u8bd5\u4ee3\u7801\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u672c\u8282\u4e2d\u6211\u4eec\u4ece\u5934\u5f00\u59cb\uff0c\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u6784\u5efa\u4e00\u4e2a\u57fa\u4e8eGLFW\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\u539f\u578b\u6846\u67b6\u7684\u96cf\u5f62\u3002 #include <vulkan/vulkan.h> #include <iostream> #include <stdexcept> #include <functional> class HelloTriangleApplication { public: void run() { initVulkan(); mainLoop(); cleanup(); } private: void initVulkan() { } void mainLoop() { } void cleanup() { } }; int main() { HelloTriangleApplication app; try { app.run(); } catch (const std::runtime_error& e) { std::cerr << e.what() << std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; } C++ \u9996\u5148\u4ece LunarG SDK \u4e2d\u6dfb\u52a0 Vulkan \u5934\u6587\u4ef6\uff0c\u5b83\u63d0\u4f9b\u4e86\u8d2d\u673a\u7231\u4f60 Vulkan \u5e94\u7528\u7a0b\u5e8f\u9700\u8981\u7684\u51fd\u6570\u3001\u7ed3\u6784\u4f53\u3001\u548c\u679a\u4e3e\u3002\u6211\u4eec\u5305\u542b stdexcept \u548c iostream \u5934\u6587\u4ef6\u7528\u4e8e\u629b\u51fa\u5f02\u5e38\u4fe1\u606f\uff0c\u800c functional \u5934\u6587\u4ef6\u7528\u4e8e\u8d44\u6e90\u7ba1\u7406\u90e8\u5206\u652f\u6301 lambda \u8868\u8fbe\u5f0f\u3002 \u7a0b\u5e8f\u88ab\u5c01\u88c5\u5230\u4e00\u4e2a\u7c7b\u4e2d\uff0c\u8be5\u7c7b\u7ed3\u6784\u5c06\u4f1a\u5b58\u50a8Vulkan\u79c1\u6709\u6210\u5458\u5bf9\u8c61\uff0c\u5e76\u6dfb\u52a0\u57fa\u672c\u7684\u51fd\u6570\u6765\u521d\u59cb\u5316\u4ed6\u4eec\u3002\u9996\u5148\u4f1a\u4ece initVulkan \u51fd\u6570\u5f00\u59cb\u8c03\u7528\u3002\u5f53\u4e00\u5207\u51c6\u5907\u597d\uff0c\u6211\u4eec\u8fdb\u5165\u4e3b\u5faa\u73af\u5f00\u59cb\u6e32\u67d3\u5e27\u3002\u6211\u4eec\u5c06\u4f1a\u52a0\u5165 mainLoop \u51fd\u6570\u5305\u542bloop\u5faa\u73af\u8c03\u7528\uff0c\u8be5\u5faa\u73af\u8c03\u7528\u76f4\u5230GLFW\u7a97\u4f53\u7ba1\u7406\u624d\u4f1a\u505c\u6b62\u3002\u5f53\u7a97\u4f53\u5173\u95ed\u5e76\u4e14 mainLoop \u8fd4\u56de\u65f6\uff0c\u6211\u4eec\u9700\u8981\u91ca\u653e\u6211\u4eec\u5df2\u7ecf\u7533\u8bf7\u8fc7\u7684\u4efb\u4f55\u8d44\u6e90\uff0c\u8be5\u6e05\u7406\u903b\u8f91\u5728 cleanup \u51fd\u6570\u4e2d\u53bb\u5b9a\u4e49\u3002 \u7a0b\u5e8f\u8fd0\u884c\u671f\u95f4\uff0c\u5982\u679c\u53d1\u751f\u4e86\u4efb\u4f55\u4e25\u91cd\u7684\u9519\u8bef\u5f02\u5e38\uff0c\u6211\u4eec\u4f1a\u629b\u51fa std::runtime_error \u5e76\u6ce8\u660e\u5f02\u5e38\u63cf\u8ff0\u4fe1\u606f,\u8fd9\u4e2a\u5f02\u5e38\u4fe1\u606f\u4f1a\u88ab main \u51fd\u6570\u6355\u83b7\u53ca\u6253\u5370\u63d0\u793a\u3002\u5f88\u5feb\u4f60\u5c06\u4f1a\u9047\u5230\u4e00\u4e2a\u629b\u51faerror\u7684\u4f8b\u5b50\uff0c\u662f\u5173\u4e8e Vulkan \u5e94\u7528\u7a0b\u5e8f\u4e0d\u652f\u6301\u67d0\u4e2a\u5fc5\u8981\u7684\u6269\u5c55\u529f\u80fd\u3002 \u57fa\u672c\u4e0a\u5728\u4e4b\u540e\u7684\u6bcf\u4e00\u4e2a\u5c0f\u8282\u4e2d\u90fd\u4f1a\u4ece initVulkan \u51fd\u6570\u4e2d\u589e\u52a0\u4e00\u4e2a\u65b0\u7684 Vulkan \u51fd\u6570\u8c03\u7528,\u589e\u52a0\u7684\u51fd\u6570\u4f1a\u4ea7\u751f Vulkan objects \u5e76\u4fdd\u5b58\u4e3a\u7c7b\u7684\u79c1\u6709\u6210\u5458\uff0c\u8bf7\u8bb0\u5f97\u5728 cleanup \u4e2d\u8fdb\u884c\u8d44\u6e90\u7684\u6e05\u7406\u548c\u91ca\u653e\u3002","title":"\u603b\u4f53\u7ed3\u6784"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_9","text":"\u6211\u4eec\u77e5\u9053\u901a\u8fc7 malloc \u5206\u914d\u7684\u6bcf\u4e00\u4e2a\u5185\u5b58\u5feb\u5728\u4f7f\u7528\u5b8c\u4e4b\u540e\u90fd\u9700\u8981 free \u5185\u5b58\u8d44\u6e90\uff0c\u6bcf\u4e00\u4e2a\u6211\u4eec\u521b\u5efa\u7684 Vulkan object \u4e0d\u5728\u4f7f\u7528\u65f6\u90fd\u9700\u8981\u660e\u786e\u7684\u9500\u6bc1\u3002\u5728 C++ \u4e2d\u53ef\u4ee5\u5229\u7528 \u5b8c\u6210auto\u8d44\u6e90\u7ba1\u7406\uff0c\u4f46\u662f\u5728\u672c\u8282\u4e2d\uff0c\u9009\u62e9\u660e\u786e\u7f16\u5199\u6240\u6709\u7684\u5185\u5b58\u7684\u5206\u914d\u548c\u91ca\u653e\u64cd\u4f5c\uff0c\u5176\u4e3b\u8981\u539f\u56e0\u662f`\u7684\u8bbe\u8ba1\u7406\u5ff5\u5c31\u662f\u660e\u786e\u6bcf\u4e00\u6b65\u64cd\u4f5c\uff0c\u6e05\u695a\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f\uff0c\u907f\u514d\u53ef\u80fd\u5b58\u5728\u7684\u672a\u77e5\u4ee3\u7801\u9020\u6210\u7684\u5f02\u5e38\u3002 \u5f53\u7136\u5728\u672c\u8282\u4e4b\u540e,\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u91cd\u8f7d std::shared_ptr \u6765\u5b9e\u73b0auto \u8d44\u6e90\u7ba1\u7406\u3002\u5bf9\u4e8e\u66f4\u5927\u4f53\u91cf\u7684Vulkan\u7a0b\u5e8f,\u5efa\u8bae\u9075\u5faa RAII \u7684\u539f\u5219\u7ef4\u62a4\u8d44\u6e90\u7684\u7ba1\u7406\u3002 Vulkan \u5bf9\u8c61\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 vkCreateXXX \u7cfb\u51fd\u6570\u521b\u5efa\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u5177\u6709 vkAllocateXXX \u7b49\u529f\u80fd\u7684\u4e00\u4e2a\u5bf9\u8c61\u8fdb\u884c\u5206\u914d\u3002\u786e\u4fdd\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u5728\u4e0d\u4f7f\u7528\u7684\u65f6\u5019\u8c03\u7528 vkDestroyXXX \u548c vkFreeXXX \u9500\u6bc1\u3001\u91ca\u653e\u5bf9\u5e94\u7684\u8d44\u6e90\u3002\u8fd9\u4e9b\u51fd\u6570\u7684\u53c2\u6570\u901a\u5e38\u56e0\u4e0d\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u800c\u4e0d\u540c\uff0c\u4f46\u662f\u4ed6\u4eec\u5171\u4eab\u4e00\u4e2a\u53c2\u6570:pAllocator\u3002\u8fd9\u662f\u4e00\u4e2a\u53ef\u9009\u7684\u53c2\u6570\uff0c Vulkan \u5141\u8bb8\u6211\u4eec\u81ea\u5b9a\u4e49\u5185\u5b58\u5206\u914d\u5668\u3002\u6211\u4eec\u5c06\u5728\u672c\u6559\u7a0b\u5ffd\u7565\u6b64\u53c2\u6570\uff0c\u59cb\u7ec8\u4ee5 nullptr \u4f5c\u4e3a\u53c2\u6570\u3002","title":"\u8d44\u6e90\u7ba1\u7406"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#glfw","text":"\u5982\u679c\u6211\u4eec\u5f00\u53d1\u4e00\u4e9b\u4e0d\u9700\u8981\u57fa\u4e8e\u5c4f\u5e55\u663e\u793a\u7684\u7a0b\u5e8f\uff0c\u90a3\u4e48\u7eaf\u7cb9\u7684 Vulkan \u672c\u8eab\u53ef\u4ee5\u5b8c\u7f8e\u7684\u652f\u6301\u5f00\u53d1\u3002\u4f46\u662f\u5982\u679c\u521b\u5efa\u4e00\u4e9b\u8ba9\u4eba\u5174\u594b\u7684\u53ef\u89c6\u5316\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u5c31\u9700\u8981\u5f15\u5165\u7a97\u4f53\u7cfb\u7edf GLFW \uff0c\u5e76\u5c06 #include \u8fdb\u884c\u76f8\u5e94\u7684\u66ff\u6362\u3002 #define GLFW_INCLUDE_VULKAN #include <GLFW/glfw3.h> C++ \u5728\u65b0\u7248\u672c\u7684 GLFW \u4e2d\u5df2\u7ecf\u63d0\u4f9b\u4e86 Vulkan \u76f8\u5173\u7684\u652f\u6301\uff0c\u8be6\u7ec6\u7684\u4f7f\u7528\u5efa\u8bae\u53c2\u9605\u5b98\u65b9\u8d44\u6599\u3002 \u901a\u8fc7\u66ff\u6362\uff0c\u5c06\u4f1a\u4f7f\u7528 GLFW \u5bf9 Vulkan \u7684\u652f\u6301\uff0c\u5e76\u81ea\u52a8\u52a0\u8f7d Vulkan \u7684\u5934\u6587\u4ef6\u3002\u5728 run \u51fd\u6570\u4e2d\u6dfb\u52a0\u4e00\u4e2a initWindow \u51fd\u6570\u8c03\u7528\uff0c\u5e76\u786e\u4fdd\u5728\u5176\u4ed6\u51fd\u6570\u8c03\u7528\u524d\u4f18\u5148\u8c03\u7528\u3002\u6211\u4eec\u5c06\u4f1a\u901a\u8fc7\u8be5\u51fd\u6570\u5b8c\u6210 GLFW \u7684\u7a97\u4f53\u521d\u59cb\u5316\u5de5\u4f5c\u3002 void run() { initWindow(); initVulkan(); mainLoop(); cleanup(); } private: void initWindow() { } C++ initWindow \u4e2d\u7684\u7b2c\u4e00\u4e2a\u8c03\u7528\u662f glfwInit() ,\u5b83\u4f1a\u521d\u59cb\u5316 GLFW \u5e93\u3002\u56e0\u4e3a\u6700\u521d GLFW \u662f\u4e3a OpenGL \u521b\u5efa\u4e0a\u4e0b\u6587\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u4eec\u9700\u8981\u544a\u8bc9\u5b83\u4e0d\u8981\u8c03\u7528 OpenGL \u76f8\u5173\u7684\u521d\u59cb\u5316\u64cd\u4f5c\u3002 glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); C++ \u7279\u522b\u6ce8\u610f\u7a97\u53e3\u5927\u5c0f\u7684\u8bbe\u7f6e\uff0c\u7a0d\u540e\u6211\u4eec\u4f1a\u8c03\u7528\uff0c\u73b0\u5728\u4f7f\u7528\u53e6\u4e00\u4e2a\u7a97\u53e3\u63d0\u793a\u6765\u4ec5\u7528\u5b83\u3002 glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); C++ \u73b0\u5728\u5269\u4e0b\u7684\u5c31\u662f\u521b\u5efa\u5b9e\u9645\u7684\u7a97\u4f53\u3002\u6dfb\u52a0\u4e00\u4e2a GLFWwindow* \u7a97\u4f53\uff0c\u79c1\u6709\u7c7b\u6210\u5458\u5b58\u50a8\u5176\u5f15\u7528\u5e76\u521d\u59cb\u5316\u7a97\u4f53: window = glfwCreateWindow(800, 600, \"Vulkan\", nullptr, nullptr); C++ \u524d\u4e09\u4e2a\u53c2\u6570\u5b9a\u4e49\u7a97\u4f53\u7684\u5bbd\u5ea6\u3001\u9ad8\u5ea6\u548c Title \u3002\u7b2c\u56db\u4e2a\u53c2\u6570\u5141\u8bb8\u5236\u5b9a\u4e00\u4e2a\u76d1\u542c\u5668\u6765\u6253\u5f00\u7a97\u4f53\uff0c\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u4e0e OpenGL \u6709\u5173\uff0c\u6211\u4eec\u9009\u62e9 nullptr \u3002 \u4f7f\u7528\u5e38\u91cf\u4ee3\u66ff\u786c\u7f16\u7801\u5bbd\u5ea6\u548c\u9ad8\u5ea6\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u540e\u7eed\u7684\u5185\u5bb9\u4e2d\u4f1a\u5f15\u7528\u8be5\u6570\u503c\u591a\u6b21\u3002\u5728 HelloTriangleApplication \u7c7b\u5b9a\u4e49\u4e4b\u4e0a\u6dfb\u52a0\u4ee5\u4e0b\u51e0\u884c: const int WIDTH = 800; const int HEIGHT = 600; C++ \u5e76\u66ff\u6362\u7a97\u4f53\u521b\u5efa\u7684\u4ee3\u7801\u8bed\u53e5\u4e3a: window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); C++ \u4f60\u73b0\u5728\u5e94\u8be5\u6709\u4e00\u4e2a\u5982\u4e0b\u6240\u793a\u7684initWindow\u51fd\u6570: void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); } C++ \u4fdd\u6301\u7a0b\u5e8f\u8fd0\u884c\uff0c\u76f4\u5230\u53d1\u751f\u9519\u8bef\u6216\u8005\u7a97\u4f53\u5173\u95ed\uff0c\u6211\u4eec\u9700\u8981\u5411 mainLoop \u51fd\u6570\u6dfb\u52a0\u4e8b\u4ef6\u5faa\u73af\uff0c\u5982\u4e0b\u6240\u793a: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); } } C++ \u8fd9\u6bb5\u4ee3\u7801\u5e94\u8be5\u5f88\u5bb9\u6613\u770b\u61c2\u3002\u5b83\u5faa\u73af\u5e76\u68c0\u67e5 GLFW \u4e8b\u4ef6\uff0c\u76f4\u5230\u6309\u4e0b X \u6309\u94ae\uff0c\u6216\u8005\u5173\u95ed\u7a97\u4f53\u3002\u8be5\u5faa\u73af\u7ed3\u6784\u7a0d\u540e\u4f1a\u8c03\u7528\u6e32\u67d3\u51fd\u6570\u3002 \u4e00\u65e6\u7a97\u4f53\u5173\u95ed\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7 cleanup \u51fd\u6570\u6e05\u7406\u8d44\u6e90\u3001\u7ed3\u675f GLFW \u672c\u8eab\u3002 void cleanup() { glfwDestroyWindow(window); glfwTerminate(); } C++ \u8fd0\u884c\u7a0b\u5e8f\uff0c\u6211\u4eec\u5e94\u8be5\u4f1a\u770b\u5230\u4e00\u4e2a\u540d\u4e3a Vulkan \u7684\u767d\u8272\u7a97\u4f53\uff0c\u76f4\u5230\u5173\u95ed\u7a97\u4f53\u7ec8\u6b62\u5e94\u7528\u7a0b\u5e8f\u3002 ok\uff0c\u5230\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86\u4e00\u4e2a Vulkan \u7a0b\u5e8f\u7684\u9aa8\u67b6\u539f\u578b\uff0c\u5728 \u4e0b\u4e00\u8282 \u6211\u4eec\u4f1a\u521b\u5efa\u7b2c\u4e00\u4e2a Vulkan Object !","title":"\u6574\u5408GLFW"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_2","text":"PASS","title":"[Vulkan \u9a8c\u8bc1\u5c42]"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_3","text":"Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217 \uff0c\u5728\u9009\u62e9\u8981\u4f7f\u7528\u7684\u7269\u7406\u8bbe\u5907\u4e4b\u540e\uff0c\u6211\u4eec\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u903b\u8f91\u8bbe\u5907\u7528\u4e8e\u4ea4\u4e92\u3002\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u8fc7\u7a0b\u4e0einstance\u521b\u5efa\u8fc7\u7a0b\u7c7b\u4f3c\uff0c\u4e5f\u9700\u8981\u63cf\u8ff0\u6211\u4eec\u9700\u8981\u4f7f\u7528\u7684\u529f\u80fd\u3002\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u67e5\u8be2\u8fc7\u54ea\u4e9b\u961f\u5217\u7c07\u53ef\u7528\uff0c\u5728\u8fd9\u91cc\u9700\u8981\u8fdb\u4e00\u6b65\u4e3a\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u5177\u4f53\u7c7b\u578b\u7684\u547d\u4ee4\u961f\u5217\u3002\u5982\u679c\u6709\u4e0d\u540c\u7684\u9700\u6c42\uff0c\u4e5f\u53ef\u4ee5\u57fa\u4e8e\u540c\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u521b\u5efa\u591a\u4e2a\u903b\u8f91\u8bbe\u5907\u3002 \u9996\u5148\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u7c7b\u6210\u5458\u6765\u5b58\u50a8\u903b\u8f91\u8bbe\u5907\u53e5\u67c4\u3002 VkDevice device; C++ \u63a5\u4e0b\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u51fd\u6570 createLogicalDevice \uff0c\u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\uff0c\u4ee5\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u3002 void initVulkan() { createInstance(); setupDebugCallback(); pickPhysicalDevice(); createLogicalDevice(); } void createLogicalDevice() { } C++ https://geek-docs.com/vulkan/vulkan-tutorial/vulkan-logical-devices-and-queues.html#i-5)","title":"Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_10","text":"\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u9700\u8981\u5728\u7ed3\u6784\u4f53\u4e2d\u660e\u786e\u5177\u4f53\u7684\u4fe1\u606f\uff0c\u9996\u5148\u7b2c\u4e00\u4e2a\u7ed3\u6784\u4f53 VkDeviceQueueCreateInfo \u3002\u8fd9\u4e2a\u7ed3\u6784\u4f53\u63cf\u8ff0\u961f\u5217\u7c07\u4e2d\u9884\u8981\u7533\u8bf7\u4f7f\u7528\u7684\u961f\u5217\u6570\u91cf\u3002\u73b0\u5728\u6211\u4eec\u4ec5\u5173\u5fc3\u5177\u5907\u56fe\u5f62\u80fd\u529b\u7684\u961f\u5217\u3002 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); VkDeviceQueueCreateInfo queueCreateInfo = {}; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = indices.graphicsFamily; queueCreateInfo.queueCount = 1; C++ \u5f53\u524d\u53ef\u7528\u7684\u9a71\u52a8\u7a0b\u5e8f\u6240\u63d0\u4f9b\u7684\u961f\u5217\u7c07\u53ea\u5141\u8bb8\u521b\u5efa\u5c11\u91cf\u7684\u961f\u5217\uff0c\u5e76\u4e14\u5f88\u591a\u65f6\u5019\u6ca1\u6709\u5fc5\u8981\u521b\u5efa\u591a\u4e2a\u961f\u5217\u3002\u8fd9\u662f\u56e0\u4e3a\u53ef\u4ee5\u5728\u591a\u4e2a\u7ebf\u7a0b\u4e0a\u521b\u5efa\u6240\u6709\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u7136\u540e\u5728\u4e3b\u7ebf\u7a0b\u4e00\u6b21\u6027\u7684\u4ee5\u8f83\u4f4e\u5f00\u9500\u7684\u8c03\u7528\u63d0\u4ea4\u961f\u5217\u3002 Vulkan \u5141\u8bb8\u4f7f\u75280.0\u52301.0\u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u5206\u914d\u961f\u5217\u4f18\u5148\u7ea7\u6765\u5f71\u54cd\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u7684\u8c03\u7528\u3002\u5373\u4f7f\u53ea\u6709\u4e00\u4e2a\u961f\u5217\u4e5f\u662f\u5fc5\u987b\u7684: float queuePriority = 1.0f; queueCreateInfo.pQueuePriorities = &queuePriority; C++","title":"\u6307\u5b9a\u521b\u5efa\u7684\u961f\u5217"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_11","text":"\u4e0b\u4e00\u4e2a\u8981\u660e\u786e\u7684\u4fe1\u606f\u6709\u5173\u8bbe\u5907\u8981\u4f7f\u7528\u7684\u529f\u80fd\u7279\u6027\u3002\u8fd9\u4e9b\u662f\u6211\u4eec\u5728\u4e0a\u4e00\u8282\u4e2d\u7528 vkGetPhysicalDeviceFeatures \u67e5\u8be2\u652f\u6301\u7684\u529f\u80fd\uff0c\u6bd4\u5982geometry shaders\u3002\u73b0\u5728\u6211\u4eec\u4e0d\u9700\u8981\u4efb\u4f55\u7279\u6b8a\u7684\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7684\u5b9a\u4e49\u5b83\u5e76\u5c06\u6240\u6709\u5185\u5bb9\u4fdd\u7559\u5230 VK_FALSE \u3002\u4e00\u65e6\u6211\u4eec\u8981\u5f00\u59cb\u7528Vulkan\u505a\u66f4\u591a\u7684\u4e8b\u60c5\uff0c\u6211\u4eec\u4f1a\u56de\u5230\u8fd9\u4e2a\u7ed3\u6784\u4f53\uff0c\u8fdb\u4e00\u6b65\u8bbe\u7f6e\u3002 VkPhysicalDeviceFeatures deviceFeatures = {}; C++","title":"\u6307\u5b9a\u4f7f\u7528\u7684\u8bbe\u5907\u7279\u6027"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_12","text":"\u4f7f\u7528\u524d\u9762\u7684\u4e24\u4e2a\u7ed3\u6784\u4f53\uff0c\u6211\u4eec\u53ef\u4ee5\u586b\u5145 VkDeviceCreateInfo \u7ed3\u6784\u3002 VkDeviceCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; C++ \u9996\u5148\u6dfb\u52a0\u6307\u5411\u961f\u5217\u521b\u5efa\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\u548c\u8bbe\u5907\u529f\u80fd\u7ed3\u6784\u4f53: createInfo.pQueueCreateInfos = &queueCreateInfo; createInfo.queueCreateInfoCount = 1; createInfo.pEnabledFeatures = &deviceFeatures; C++ \u7ed3\u6784\u4f53\u5176\u4f59\u7684\u90e8\u5206\u4e0e VkInstanceCreateInfo \u76f8\u4f3c\uff0c\u9700\u8981\u6307\u5b9a\u6269\u5c55\u548c validation layers \uff0c\u603b\u800c\u8a00\u4e4b\u8fd9\u6b21\u4e0d\u540c\u4e4b\u5904\u662f\u4e3a\u5177\u4f53\u7684\u8bbe\u5907\u8bbe\u7f6e\u4fe1\u606f\u3002 \u8bbe\u7f6e\u5177\u4f53\u6269\u5c55\u7684\u4e00\u4e2a\u6848\u4f8b\u662f VK_KHR_swapchain \uff0c\u5b83\u5141\u8bb8\u5c06\u6765\u81ea\u8bbe\u5907\u7684\u6e32\u67d3\u56fe\u5f62\u5448\u73b0\u5230 Windows \u3002\u7cfb\u7edf\u4e2d\u7684 Vulkan \u8bbe\u5907\u53ef\u80fd\u7f3a\u5c11\u8be5\u529f\u80fd\uff0c\u4f8b\u5982\u4ec5\u4ec5\u652f\u6301\u8ba1\u7b97\u64cd\u4f5c\u3002\u6211\u4eec\u5c06\u5728\u4ea4\u6362\u94fe\u7ae0\u8282\u4e2d\u5c55\u5f00\u8fd9\u4e2a\u6269\u5c55\u3002 \u5c31\u50cf\u4e4b\u524d validation layers \u5c0f\u8282\u4e2d\u63d0\u5230\u7684\uff0c\u5141\u8bb8\u4e3a instance \u5f00\u542f validation layers \uff0c\u73b0\u5728\u6211\u4eec\u5c06\u4e3a\u8bbe\u5907\u5f00\u542f validation layers \uff0c\u800c\u4e0d\u9700\u8981\u4e3a\u8bbe\u5907\u6307\u5b9a\u4efb\u4f55\u6269\u5c55\u3002 createInfo.enabledExtensionCount = 0; if (enableValidationLayers) { createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size()); createInfo.ppEnabledLayerNames = validationLayers.data(); } else { createInfo.enabledLayerCount = 0; } C++ \u5c31\u8fd9\u6837\uff0c\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 vkCreateDevice \u51fd\u6570\u6765\u521b\u5efa\u5b9e\u4f8b\u5316\u903b\u8f91\u8bbe\u5907\u3002 if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) { throw std::runtime_error(\"failed to create logical device!\"); } C++ \u8fd9\u4e9b\u53c2\u6570\u5206\u522b\u662f\u5305\u542b\u5177\u4f53\u961f\u5217\u4f7f\u7528\u4fe1\u606f\u7684\u7269\u7406\u8bbe\u5907\uff0c\u53ef\u9009\u7684\u5206\u914d\u5668\u56de\u8c03\u6307\u9488\u4ee5\u53ca\u7528\u4e8e\u5b58\u50a8\u903b\u8f91\u8bbe\u5907\u7684\u53e5\u67c4\u3002\u4e0e instance \u521b\u5efa\u7c7b\u4f3c\uff0c\u6b64\u8c03\u7528\u53ef\u80fd\u7531\u4e8e\u542f\u7528\u4e0d\u5b58\u5728\u7684\u6269\u5c55\u6216\u8005\u6307\u5b9a\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5bfc\u81f4\u8fd4\u56de\u9519\u8bef\u3002 \u5728 cleanup \u51fd\u6570\u4e2d\u903b\u8f91\u8bbe\u5907\u9700\u8981\u8c03\u7528 vkDestroyDevice \u9500\u6bc1: void cleanup() { vkDestroyDevice(device, nullptr); ... } C++ \u903b\u8f91\u8bbe\u5907\u4e0d\u4e0e instance \u4ea4\u4e92\uff0c\u6240\u4ee5\u53c2\u6570\u4e2d\u4e0d\u5305\u542b instance \u3002","title":"\u521b\u5efa\u903b\u8f91\u8bbe\u5907"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_13","text":"\u8fd9\u4e9b\u961f\u5217\u4e0e\u903b\u8f91\u8bbe\u5907\u81ea\u52a8\u7684\u4e00\u540c\u521b\u5efa\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u4e00\u4e2a\u4e0e\u5b83\u4eec\u8fdb\u884c\u4ea4\u4e92\u7684\u53e5\u67c4\u3002\u5728\u8fd9\u91cc\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u7c7b\u6210\u5458\u6765\u5b58\u50a8\u56fe\u5f62\u961f\u5217\u53e5\u67c4: VkQueue graphicsQueue; C++ \u8bbe\u5907\u961f\u5217\u5728\u8bbe\u5907\u88ab\u9500\u6bc1\u7684\u65f6\u5019\u9690\u5f0f\u6e05\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u5728 cleanup \u51fd\u6570\u4e2d\u505a\u4efb\u4f55\u64cd\u4f5c\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 vkGetDeviceQueue \u51fd\u6570\u6765\u68c0\u6d4b\u6bcf\u4e2a\u961f\u5217\u7c07\u4e2d\u961f\u5217\u7684\u53e5\u67c4\u3002\u53c2\u6570\u662f\u903b\u8f91\u8bbe\u5907\uff0c\u961f\u5217\u7c07\uff0c\u961f\u5217\u7d22\u5f15\u548c\u5b58\u50a8\u83b7\u53d6\u961f\u5217\u53d8\u91cf\u53e5\u67c4\u7684\u6307\u9488\u3002\u56e0\u4e3a\u6211\u4eec\u53ea\u662f\u4ece\u8fd9\u4e2a\u961f\u5217\u7c07\u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u6240\u4ee5\u9700\u8981\u4f7f\u7528\u7d22\u5f15 0 \u3002 vkGetDeviceQueue(device, indices.graphicsFamily, 0, &graphicsQueue); C++ \u5728\u6210\u529f\u83b7\u53d6\u903b\u8f91\u8bbe\u5907\u548c\u961f\u5217\u53e5\u67c4\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u663e\u5361\u505a\u4e00\u4e9b\u5b9e\u9645\u7684\u4e8b\u60c5\u4e86\uff0c\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u4f1a\u8bbe\u7f6e\u8d44\u6e90\u5e76\u5c06\u76f8\u5e94\u7684\u7ed3\u679c\u63d0\u4ea4\u5230\u7a97\u4f53\u7cfb\u7edf\u3002","title":"\u68c0\u7d22\u961f\u5217\u5904\u7406"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_4","text":"Vulkan \u4ea4\u6362\u94fe \uff0c\u5728\u8fd9\u4e00\u7ae0\u8282\uff0c\u6211\u4eec\u4e86\u89e3\u4e00\u4e0b\u5c06\u6e32\u67d3\u56fe\u50cf\u63d0\u4ea4\u5230\u5c4f\u5e55\u7684\u57fa\u672c\u673a\u5236\u3002\u8fd9\u79cd\u673a\u5236\u79f0\u4e3a\u4ea4\u6362\u94fe\uff0c\u5e76\u4e14\u9700\u8981\u5728 Vulkan \u4e0a\u4e0b\u6587\u4e2d\u88ab\u660e\u786e\u521b\u5efa\u3002\u4ece\u5c4f\u5e55\u7684\u89d2\u5ea6\u89c2\u5bdf\uff0c\u4ea4\u6362\u94fe\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u56fe\u50cf\u961f\u5217\u3002\u5e94\u7528\u7a0b\u5e8f\u4f5c\u4e3a\u751f\u4ea7\u8005\u4f1a\u83b7\u53d6\u56fe\u50cf\u8fdb\u884c\u7ed8\u5236\uff0c\u7136\u540e\u5c06\u5176\u8fd4\u8fd8\u7ed9\u4ea4\u6362\u94fe\u56fe\u50cf\u961f\u5217\uff0c\u7b49\u5f85\u5c4f\u5e55\u6d88\u8d39\u3002\u4ea4\u6362\u94fe\u7684\u5177\u4f53\u914d\u7f6e\u4fe1\u606f\u51b3\u5b9a\u4e86\u5e94\u7528\u7a0b\u5e8f\u63d0\u4ea4\u7ed8\u5236\u56fe\u50cf\u5230\u961f\u5217\u7684\u6761\u4ef6\u4ee5\u53ca\u56fe\u50cf\u961f\u5217\u8868\u73b0\u7684\u6548\u679c\uff0c\u4f46\u4ea4\u6362\u94fe\u7684\u901a\u5e38\u4f7f\u7528\u76ee\u7684\u662f\u4f7f\u7ed8\u5236\u56fe\u50cf\u7684\u6700\u7ec8\u5448\u73b0\u4e0e\u5c4f\u5e55\u7684\u5237\u65b0\u9891\u7387\u540c\u6b65\u3002\u53ef\u4ee5\u7b80\u5355\u5c06\u4ea4\u6362\u94fe\u7406\u89e3\u4e3a\u4e00\u4e2a\u961f\u5217\uff0c\u540c\u6b65\u4ece\u751f\u4ea7\u8005\uff0c\u5373\u5e94\u7528\u7a0b\u5e8f\u7ed8\u5236\u56fe\u50cf\uff0c\u5230\u6d88\u8d39\u8005\uff0c\u5c4f\u5e55\u5237\u65b0\u7684 Produce-Consume \u5173\u7cfb\u3002\u5728\u6df1\u5165\u5185\u5bb9\u524d\u770b\u4e00\u4e0b\u5b98\u65b9\u7ed9\u51fa\u7684\u6574\u4f53\u4ea4\u6362\u94fe\u793a\u4f8b\u56fe\u3002 \u5f53\u7136\u56fe\u793a\u4e0a\u6709\u4e00\u4e9b\u964c\u751f\u7684\u5173\u952e\u5b57\u4f1a\u5728\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\u4e2d\u9010\u4e00\u4ecb\u7ecd\uff0c\u5728\u6b64\u6709\u4e00\u4e2a\u6574\u4f53\u6982\u5ff5\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u68c0\u67e5\u4ea4\u6362\u94fe\u652f\u6301 2 \u67e5\u8be2\u4ea4\u6362\u94fe\u652f\u6301\u7684\u8be6\u60c5 3 \u4e3a\u4ea4\u6362\u94fe\u9009\u62e9\u6b63\u786e\u7684\u8bbe\u7f6e 4 Surface \u683c\u5f0f 5 \u6f14\u793a\u6a21\u5f0f 6 \u4ea4\u6362\u8303\u56f4 7 \u521b\u5efa\u4ea4\u6362\u94fe 8 \u83b7\u53d6\u4ea4\u6362\u94fe\u56fe\u50cf","title":"Vulkan \u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_14","text":"\u5e76\u4e0d\u662f\u6240\u6709\u7684\u56fe\u5f62\u5361\u5177\u5907\u80fd\u529b\u5c06\u7ed8\u5236\u7684\u56fe\u50cf\u76f4\u63a5\u663e\u793a\u5230\u5c4f\u5e55\u4e0a\u3002\u6bd4\u5982\u4e00\u4e2aGPU\u5361\u662f\u4e3a\u670d\u52a1\u5668\u8bbe\u8ba1\u7684\uff0c\u90a3\u5c31\u4e0d\u4f1a\u5177\u5907\u4efb\u4f55\u6709\u5173\u663e\u793a\u7684\u8f93\u51fa\u3002\u5176\u6b21\uff0c\u56fe\u50cf\u5448\u73b0\u662f\u4e0e surface \u6253\u4ea4\u9053\uff0c\u800c surface \u53c8\u4e0e\u5177\u4f53\u7684\u7a97\u4f53\u7cfb\u7edf\u5f3a\u5173\u8054\uff0c\u4ece\u8fd9\u4e2a\u89d2\u5ea6\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u5b83\u4e0d\u662f Vulkan \u6838\u5fc3\u7684\u90e8\u5206\u3002\u5728\u67e5\u8be2\u56fe\u5f62\u5361\u662f\u5426\u652f\u6301\u540e\uff0c\u9700\u8981\u542f\u7528 VK_KHR_swapchain \u8bbe\u5907\u7ea7\u522b\u7684\u6269\u5c55\u3002 \u6240\u4ee5\u5462\uff0c\u6211\u4eec\u9996\u5148\u6269\u5c55\u4e4b\u524d\u7684 isDeviceSuitable \u51fd\u6570\uff0c\u786e\u8ba4\u8bbe\u5907\u662f\u5426\u652f\u6301\u3002\u4e4b\u524d\u6211\u4eec\u5df2\u7ecf\u4e86\u89e3\u5982\u4f55\u5217\u51fa VkPhysicalDevice \u652f\u6301\u7684\u6269\u5c55\u5217\u8868\uff0c\u5728\u6b64\u5c31\u4e0d\u5c55\u5f00\u5177\u4f53\u7ec6\u8282\u4e86\u3002\u8bf7\u6ce8\u610f\u7684\u662f\uff0cVulkan\u5934\u6587\u4ef6\u63d0\u4f9b\u7ed9\u4e86\u4e00\u4e2a\u65b9\u4fbf\u7684\u5b8f VK_KHR_SWAPCHAIN_EXTENSION_NAME \uff0c\u8be5\u5b8f\u5b9a\u4e49\u4e3a VK_KHR_swapchain \u3002\u4f7f\u7528\u5b8f\u7684\u4f18\u70b9\u5c31\u662f\u907f\u514d\u62fc\u5199\u9519\u8bef\u3002 \u9996\u5148\u58f0\u660e\u9700\u8981\u7684\u8bbe\u5907\u6269\u5c55\u6e05\u5355\uff0c\u4e0e\u4e4b\u524d\u5f00\u542f validation layers \u7684\u5217\u8868\u662f\u76f8\u4f3c\u7684\u3002 const std::vector<const char*> deviceExtensions = { VK_KHR_SWAPCHAIN_EXTENSION_NAME }; C++ \u63a5\u4e0b\u6765\uff0c\u521b\u5efa\u4e00\u4e2a\u4ece isDeviceSuitable \u8c03\u7528\u7684\u65b0\u51fd\u6570 checkDeviceExtensionSupport \u4f5c\u4e3a\u989d\u5916\u7684\u68c0\u67e5\u903b\u8f91: bool isDeviceSuitable(VkPhysicalDevice device) { QueueFamilyIndices indices = findQueueFamilies(device); bool extensionsSupported = checkDeviceExtensionSupport(device); return indices.isComplete() && extensionsSupported; } bool checkDeviceExtensionSupport(VkPhysicalDevice device) { return true; } C++ \u4fee\u6539\u51fd\u6570\u4f53\u4ee5\u4fbf\u4e8e\u679a\u4e3e\u8bbe\u5907\u6240\u6709\u96c6\u5408\uff0c\u5e76\u68c0\u6d4b\u662f\u5426\u6240\u6709\u9700\u8981\u7684\u6269\u5c55\u5728\u5176\u4e2d\u3002 bool checkDeviceExtensionSupport(VkPhysicalDevice device) { uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availableExtensions.data()); std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end()); for (const auto& extension : availableExtensions) { requiredExtensions.erase(extension.extensionName); } return requiredExtensions.empty(); } C++ \u9009\u62e9\u4e00\u7ec4\u5b57\u7b26\u4e32\u6765\u8868\u793a\u672a\u7ecf\u786e\u8ba4\u8fc7\u7684\u6269\u5c55\u540d\u3002\u8fd9\u6837\u505a\u53ef\u4ee5\u6bd4\u8f83\u5bb9\u6613\u7684\u8fdb\u884c\u589e\u5220\u53ca\u904d\u5386\u7684\u6b21\u5e8f\u3002\u5f53\u7136\u4e5f\u53ef\u4ee5\u50cf CheckValidationLayerSupport \u51fd\u6570\u90a3\u6837\u505a\u5d4c\u5957\u7684\u5faa\u73af\u3002\u6027\u80fd\u7684\u5dee\u5f02\u5728\u8fd9\u91cc\u662f\u4e0d\u5173\u7d27\u8981\u7684\u3002\u73b0\u5728\u8fd0\u884c\u4ee3\u7801\u9a8c\u8bc1\u56fe\u5f62\u5361\u662f\u5426\u80fd\u591f\u987a\u5229\u521b\u5efa\u4e00\u4e2a\u4ea4\u6362\u94fe\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u524d\u4e00\u4e2a\u7ae0\u8282\u4e2d\u9a8c\u8bc1\u8fc7\u7684 presentation \u961f\u5217\u6709\u6548\u6027\uff0c\u5e76\u6ca1\u6709\u660e\u786e\u6307\u51fa\u4ea4\u6362\u94fe\u6269\u5c55\u4e5f\u5fc5\u987b\u6709\u6548\u652f\u6301\u3002\u597d\u5728\u6269\u5c55\u5fc5\u987b\u660e\u786e\u7684\u5f00\u542f\u3002 \u542f\u7528\u6269\u5c55\u9700\u8981\u5bf9\u903b\u8f91\u8bbe\u5907\u7684\u521b\u5efa\u7ed3\u6784\u4f53\u505a\u4e00\u4e9b\u5c0f\u7684\u6539\u52a8: createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size()); createInfo.ppEnabledExtensionNames = deviceExtensions.data(); C++","title":"\u68c0\u67e5\u4ea4\u6362\u94fe\u652f\u6301"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_15","text":"\u5982\u679c\u4ec5\u4ec5\u662f\u4e3a\u4e86\u6d4b\u8bd5\u4ea4\u6362\u94fe\u7684\u6709\u6548\u6027\u662f\u8fdc\u8fdc\u4e0d\u591f\u7684\uff0c\u56e0\u4e3a\u5b83\u8fd8\u4e0d\u80fd\u5f88\u597d\u7684\u4e0e\u7a97\u4f53 surface \u517c\u5bb9\u3002\u521b\u5efa\u4ea4\u6362\u94fe\u540c\u6837\u4e5f\u9700\u8981\u5f88\u591a\u8bbe\u7f6e\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4e86\u89e3\u4e00\u4e9b\u6709\u5173\u8bbe\u7f6e\u7684\u7ec6\u8282\u3002 \u57fa\u672c\u4e0a\u6709\u4e09\u5927\u7c7b\u5c5e\u6027\u9700\u8981\u8bbe\u7f6e: \u57fa\u672c\u7684surface\u529f\u80fd\u5c5e\u6027(min/max number of images in swap chain, min/max width and height of images) Surface\u683c\u5f0f(pixel format, color space) \u6709\u6548\u7684presentation\u6a21\u5f0f \u4e0e findQueueFamilies \u7c7b\u4f3c\uff0c\u6211\u4eec\u4f7f\u7528\u7ed3\u6784\u4f53\u4e00\u6b21\u6027\u7684\u4f20\u9012\u8be6\u7ec6\u7684\u4fe1\u606f\u3002\u4e09\u7c7b\u5c5e\u6027\u5c01\u88c5\u5728\u5982\u4e0b\u7ed3\u6784\u4f53\u4e2d\uff1a struct SwapChainSupportDetails { VkSurfaceCapabilitiesKHR capabilities; std::vector<VkSurfaceFormatKHR> formats; std::vector<VkPresentModeKHR> presentModes; }; C++ \u73b0\u5728\u521b\u5efa\u65b0\u7684\u51fd\u6570 querySwapChainSupport \u586b\u5145\u8be5\u7ed3\u6784\u4f53\u3002 SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) { SwapChainSupportDetails details; return details; } C++ \u672c\u5c0f\u8282\u6d89\u53ca\u5982\u4f55\u67e5\u8be2\u5305\u542b\u6b64\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\uff0c\u8fd9\u4e9b\u7ed3\u6784\u4f53\u7684\u542b\u4e49\u53ca\u5305\u542b\u7684\u6570\u636e\u5c06\u5728\u4e0b\u4e00\u8282\u8ba8\u8bba\u3002 \u6211\u4eec\u73b0\u5728\u5f00\u59cb\u57fa\u672c\u7684 surface \u529f\u80fd\u8bbe\u7f6e\u90e8\u5206\u3002\u8fd9\u4e9b\u5c5e\u6027\u53ef\u4ee5\u901a\u8fc7\u7b80\u5355\u7684\u51fd\u6570\u8c03\u7528\u67e5\u8be2\uff0c\u5e76\u8fd4\u56de\u5230\u5355\u4e2a VkSurfaceCapabilitiesKHR \u7ed3\u6784\u4f53\u4e2d\u3002 vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &details.capabilities); C++ \u8fd9\u4e2a\u51fd\u6570\u9700\u8981 VkPhysicalDevice \u548c VkSurfaceKHR \u7a97\u4f53 surface \u51b3\u5b9a\u652f\u6301\u54ea\u4e9b\u5177\u4f53\u529f\u80fd\u3002\u6240\u6709\u7528\u4e8e\u67e5\u770b\u652f\u6301\u529f\u80fd\u7684\u51fd\u6570\u90fd\u9700\u8981\u8fd9\u4e24\u4e2a\u53c2\u6570\uff0c\u56e0\u4e3a\u5b83\u4eec\u662f\u4ea4\u6362\u94fe\u7684\u6838\u5fc3\u7ec4\u4ef6\u3002 \u4e0b\u4e00\u6b65\u67e5\u8be2\u652f\u6301\u7684 surface \u683c\u5f0f\u3002\u56e0\u4e3a\u83b7\u53d6\u5230\u7684\u662f\u4e00\u4e2a\u7ed3\u6784\u4f53\u5217\u8868\uff0c\u5177\u4f53\u5e94\u7528\u5f62\u5f0f\u5982\u4e0b: uint32_t formatCount; vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, nullptr); if (formatCount != 0) { details.formats.resize(formatCount); vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, details.formats.data()); } C++ \u786e\u4fdd\u96c6\u5408\u5bf9\u4e8e\u6240\u6709\u6709\u6548\u7684\u683c\u5f0f\u53ef\u6269\u5145\u3002\u6700\u540e\u67e5\u8be2\u652f\u6301\u7684 presentation \u6a21\u5f0f\uff0c\u540c\u6837\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528 vkGetPhysicalDeviceSurfacePresentModesKHR : uint32_t presentModeCount; vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, nullptr); if (presentModeCount != 0) { details.presentModes.resize(presentModeCount); vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, details.presentModes.data()); } C++ \u73b0\u5728\u7ed3\u6784\u4f53\u7684\u76f8\u5173\u7ec6\u8282\u4ecb\u7ecd\u5b8c\u6bd5\uff0c\u8ba9\u6211\u4eec\u6269\u5145 isDeviceSuitable \u51fd\u6570\uff0c\u4ece\u800c\u5229\u7528\u8be5\u51fd\u6570\u9a8c\u8bc1\u4ea4\u6362\u94fe\u8db3\u591f\u7684\u652f\u6301\u3002\u5728\u672c\u7ae0\u8282\u4e2d\u4ea4\u6362\u94fe\u7684\u652f\u6301\u662f\u8db3\u591f\u7684\uff0c\u56e0\u4e3a\u5bf9\u4e8e\u7ed9\u5b9a\u7684\u7a97\u4f53 surface \uff0c\u5b83\u81f3\u5c11\u652f\u6301\u4e00\u4e2a\u56fe\u50cf\u683c\u5f0f\uff0c\u4e00\u4e2a presentaion \u6a21\u5f0f\u3002 bool swapChainAdequate = false; if (extensionsSupported) { SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device); swapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty(); } C++ \u6bd4\u8f83\u91cd\u8981\u7684\u662f\u5c1d\u8bd5\u67e5\u8be2\u4ea4\u6362\u94fe\u7684\u652f\u6301\u662f\u5728\u9a8c\u8bc1\u5b8c\u6269\u5c55\u6709\u6548\u6027\u4e4b\u540e\u8fdb\u884c\u3002\u51fd\u6570\u7684\u6700\u540e\u4e00\u884c\u4ee3\u7801\u4fee\u6539\u4e3a: return indices.isComplete() && extensionsSupported && swapChainAdequate; C++","title":"\u67e5\u8be2\u4ea4\u6362\u94fe\u652f\u6301\u7684\u8be6\u60c5"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_16","text":"\u5982\u679c swapChainAdequate \u6761\u4ef6\u8db3\u591f\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u652f\u6301\u7684\u8db3\u591f\u7684\uff0c\u4f46\u662f\u6839\u636e\u4e0d\u540c\u7684\u6a21\u5f0f\u4ecd\u7136\u6709\u4e0d\u540c\u7684\u6700\u4f73\u9009\u62e9\u3002\u6211\u4eec\u7f16\u5199\u4e00\u7ec4\u51fd\u6570\uff0c\u901a\u8fc7\u8fdb\u4e00\u6b65\u7684\u8bbe\u7f6e\u67e5\u627e\u6700\u5339\u914d\u7684\u4ea4\u6362\u94fe\u3002\u8fd9\u91cc\u6709\u4e09\u79cd\u7c7b\u578b\u7684\u8bbe\u7f6e\u53bb\u786e\u5b9a: Surface\u683c\u5f0f (color depth) Presentation mode (conditions for \u201cswapping\u201d image to the screen) Swap extent (resolution of images in swap chain) \u9996\u5148\u5728\u8111\u6d77\u4e2d\u5bf9\u6bcf\u4e00\u4e2a\u8bbe\u7f6e\u90fd\u6709\u4e00\u4e2a\u7406\u60f3\u7684\u6570\u503c\uff0c\u5982\u679c\u8fbe\u6210\u4e00\u81f4\u6211\u4eec\u5c31\u4f7f\u7528\uff0c\u5426\u5219\u6211\u4eec\u4e00\u8d77\u521b\u5efa\u4e00\u4e9b\u903b\u8f91\u53bb\u627e\u5230\u66f4\u597d\u7684\u89c4\u5219\u3001\u6570\u503c\u3002","title":"\u4e3a\u4ea4\u6362\u94fe\u9009\u62e9\u6b63\u786e\u7684\u8bbe\u7f6e"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#surface","text":"\u8fd9\u4e2a\u51fd\u6570\u7528\u6765\u8bbe\u7f6esurface\u683c\u5f0f\u3002\u6211\u4eec\u4f20\u9012 formats \u4f5c\u4e3a\u51fd\u6570\u7684\u53c2\u6570\uff0c\u7c7b\u578b\u4e3a SwapChainSupportDetails \u3002 VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) { } C++ \u6bcf\u4e2a VkSurfaceFormatKHR \u7ed3\u6784\u90fd\u5305\u542b\u4e00\u4e2a format \u548c\u4e00\u4e2a colorSpace \u6210\u5458\u3002 format \u6210\u5458\u53d8\u91cf\u6307\u5b9a\u8272\u5f69\u901a\u9053\u548c\u7c7b\u578b\u3002\u6bd4\u5982\uff0c VK_FORMAT_B8G8R8A8_UNORM \u4ee3\u8868\u4e86\u6211\u4eec\u4f7f\u7528B,G,R\u548calpha\u6b21\u5e8f\u7684\u901a\u9053\uff0c\u4e14\u6bcf\u4e00\u4e2a\u901a\u9053\u4e3a\u65e0\u7b26\u53f78bit\u6574\u6570\uff0c\u6bcf\u4e2a\u50cf\u7d20\u603b\u8ba132bits\u3002 colorSpace \u6210\u5458\u63cf\u8ff0 SRGB \u989c\u8272\u7a7a\u95f4\u662f\u5426\u901a\u8fc7 VK_COLOR_SPACE_SRGB_NONLINEAR_KHR \u6807\u5fd7\u652f\u6301\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u5728\u8f83\u65e9\u7248\u672c\u7684\u89c4\u8303\u4e2d\uff0c\u8fd9\u4e2a\u6807\u5fd7\u540d\u4e3a VK_COLORSPACE_SRGB_NONLINEAR_KHR \u3002 \u5982\u679c\u53ef\u4ee5\u6211\u4eec\u5c3d\u53ef\u80fd\u4f7f\u7528SRGB(\u5f69\u8272\u8bed\u8a00\u534f\u8bae)\uff0c \u56e0\u4e3a\u5b83\u4f1a\u5f97\u5230\u66f4\u5bb9\u6613\u611f\u77e5\u7684\u3001\u7cbe\u786e\u7684\u8272\u5f69 \u3002\u76f4\u63a5\u4e0e SRGB \u989c\u8272\u6253\u4ea4\u9053\u662f\u6bd4\u8f83\u6709\u6311\u6218\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u4f7f\u7528\u6807\u51c6\u7684RGB\u4f5c\u4e3a\u989c\u8272\u683c\u5f0f\uff0c\u8fd9\u4e5f\u662f\u901a\u5e38\u4f7f\u7528\u7684\u4e00\u4e2a\u683c\u5f0f VK_FORMAT_B8G8R8A8_UNORM \u3002 \u6700\u7406\u60f3\u7684\u60c5\u51b5\u662fsurface\u6ca1\u6709\u8bbe\u7f6e\u4efb\u4f55\u504f\u5411\u6027\u7684\u683c\u5f0f\uff0c\u8fd9\u4e2a\u65f6\u5019Vulkan\u4f1a\u901a\u8fc7\u4ec5\u8fd4\u56de\u4e00\u4e2a VkSurfaceFormatKHR \u7ed3\u6784\u8868\u793a\uff0c\u4e14\u8be5\u7ed3\u6784\u7684 format \u6210\u5458\u8bbe\u7f6e\u4e3a VK_FORMAT_UNDEFINED \u3002 if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) { return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; } C++ \u5982\u679c\u4e0d\u80fd\u81ea\u7531\u7684\u8bbe\u7f6e\u683c\u5f0f\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u904d\u5386\u5217\u8868\u8bbe\u7f6e\u5177\u6709\u504f\u5411\u6027\u7684\u7ec4\u5408: for (const auto& availableFormat : availableFormats) { if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { return availableFormat; } } C++ \u5982\u679c\u4ee5\u4e0a\u4e24\u79cd\u65b9\u5f0f\u90fd\u5931\u6548\u4e86\uff0c\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u201c\u4f18\u826f\u201d\u8fdb\u884c\u6253\u5206\u6392\u5e8f\uff0c\u4f46\u662f\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4f1a\u9009\u62e9\u7b2c\u4e00\u4e2a\u683c\u5f0f\u4f5c\u4e3a\u7406\u60f3\u7684\u9009\u62e9\u3002 VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) { if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) { return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; } for (const auto& availableFormat : availableFormats) { if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { return availableFormat; } } return availableFormats[0]; } C++","title":"Surface \u683c\u5f0f"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_17","text":"presentation \u6a21\u5f0f\u5bf9\u4e8e\u4ea4\u6362\u94fe\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u56e0\u4e3a\u5b83\u4ee3\u8868\u4e86\u5728\u5c4f\u5e55\u5448\u73b0\u56fe\u50cf\u7684\u6761\u4ef6\u3002\u5728 Vulkan \u4e2d\u6709\u56db\u4e2a\u6a21\u5f0f\u53ef\u4ee5\u4f7f\u7528: VK_PRESENT_MODE_IMMEDIATE_KHR : \u5e94\u7528\u7a0b\u5e8f\u63d0\u4ea4\u7684\u56fe\u50cf\u88ab\u7acb\u5373\u4f20\u8f93\u5230\u5c4f\u5e55\u5448\u73b0\uff0c\u8fd9\u79cd\u6a21\u5f0f\u53ef\u80fd\u4f1a\u9020\u6210\u6495\u88c2\u6548\u679c\u3002 VK_PRESENT_MODE_FIFO_KHR : \u4ea4\u6362\u94fe\u88ab\u770b\u4f5c\u4e00\u4e2a\u961f\u5217\uff0c\u5f53\u663e\u793a\u5185\u5bb9\u9700\u8981\u5237\u65b0\u7684\u65f6\u5019\uff0c\u663e\u793a\u8bbe\u5907\u4ece\u961f\u5217\u7684\u524d\u9762\u83b7\u53d6\u56fe\u50cf\uff0c\u5e76\u4e14\u7a0b\u5e8f\u5c06\u6e32\u67d3\u5b8c\u6210\u7684\u56fe\u50cf\u63d2\u5165\u961f\u5217\u7684\u540e\u9762\u3002\u5982\u679c\u961f\u5217\u662f\u6ee1\u7684\u7a0b\u5e8f\u4f1a\u7b49\u5f85\u3002\u8fd9\u79cd\u89c4\u6a21\u4e0e\u89c6\u9891\u6e38\u620f\u7684\u5782\u76f4\u540c\u6b65\u5f88\u7c7b\u4f3c\u3002\u663e\u793a\u8bbe\u5907\u7684\u5237\u65b0\u65f6\u523b\u88ab\u6210\u4e3a\u201c\u5782\u76f4\u4e2d\u65ad\u201d\u3002 VK_PRESENT_MODE_FIFO_RELAXED_KHR : \u8be5\u6a21\u5f0f\u4e0e\u4e0a\u4e00\u4e2a\u6a21\u5f0f\u7565\u6709\u4e0d\u540c\u7684\u5730\u65b9\u4e3a\uff0c\u5982\u679c\u5e94\u7528\u7a0b\u5e8f\u5b58\u5728\u5ef6\u8fdf\uff0c\u5373\u63a5\u53d7\u6700\u540e\u4e00\u4e2a\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\u65f6\u961f\u5217\u7a7a\u4e86\uff0c\u5c06\u4e0d\u4f1a\u7b49\u5f85\u4e0b\u4e00\u4e2a\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\uff0c\u800c\u662f\u5c06\u56fe\u50cf\u76f4\u63a5\u4f20\u9001\u3002\u8fd9\u6837\u505a\u53ef\u80fd\u5bfc\u81f4\u53ef\u89c1\u7684\u6495\u88c2\u6548\u679c\u3002 VK_PRESENT_MODE_MAILBOX_KHR : \u8fd9\u662f\u7b2c\u4e8c\u79cd\u6a21\u5f0f\u7684\u53d8\u79cd\u3002\u5f53\u4ea4\u6362\u94fe\u961f\u5217\u6ee1\u7684\u65f6\u5019\uff0c\u9009\u62e9\u65b0\u7684\u66ff\u6362\u65e7\u7684\u56fe\u50cf\uff0c\u4ece\u800c\u66ff\u4ee3\u963b\u585e\u5e94\u7528\u7a0b\u5e8f\u7684\u60c5\u5f62\u3002\u8fd9\u79cd\u6a21\u5f0f\u901a\u5e38\u7528\u6765\u5b9e\u73b0\u4e09\u91cd\u7f13\u51b2\u533a\uff0c\u4e0e\u6807\u51c6\u7684\u5782\u76f4\u540c\u6b65\u53cc\u7f13\u51b2\u76f8\u6bd4\uff0c\u5b83\u53ef\u4ee5\u6709\u6548\u907f\u514d\u5ef6\u8fdf\u5e26\u6765\u7684\u6495\u88c2\u6548\u679c\u3002 \u903b\u8f91\u4e0a\u770b\u4ec5\u4ec5 VR_PRESENT_MODE_FIFO_KHR \u6a21\u5f0f\u4fdd\u8bc1\u53ef\u7528\u6027\uff0c\u6240\u4ee5\u6211\u4eec\u518d\u6b21\u589e\u52a0\u4e00\u4e2a\u51fd\u6570\u67e5\u627e\u6700\u4f73\u7684\u6a21\u5f0f: VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { return VK_PRESENT_MODE_FIFO_KHR; } C++ \u6211\u4e2a\u4eba\u8ba4\u4e3a\u4e09\u7ea7\u7f13\u51b2\u662f\u4e00\u4e2a\u975e\u5e38\u597d\u7684\u7b56\u7565\u3002\u5b83\u5141\u8bb8\u6211\u4eec\u907f\u514d\u6495\u88c2\uff0c\u540c\u65f6\u4ecd\u7136\u4fdd\u6301\u76f8\u5bf9\u4f4e\u7684\u5ef6\u8fdf\uff0c\u901a\u8fc7\u6e32\u67d3\u5c3d\u53ef\u80fd\u65b0\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u63a5\u53d7\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\u3002\u6240\u4ee5\u6211\u4eec\u770b\u4e00\u4e0b\u5217\u8868\uff0c\u5b83\u662f\u5426\u53ef\u7528: VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { for (const auto& availablePresentMode : availablePresentModes) { if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { return availablePresentMode; } } return VK_PRESENT_MODE_FIFO_KHR; } C++ \u9057\u61be\u7684\u662f\uff0c\u4e00\u4e9b\u9a71\u52a8\u7a0b\u5e8f\u76ee\u524d\u5e76\u4e0d\u652f\u6301 VK_PRESENT_MODE_FIFO_KHR ,\u9664\u6b64\u4e4b\u5916\u5982\u679c VK_PRESENT_MODE_MAILBOX_KHR \u4e5f\u4e0d\u53ef\u7528\uff0c\u6211\u4eec\u66f4\u503e\u5411\u4f7f\u7528 VK_PRESENT_MODE_IMMEDIATE_KHR : VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { VkPresentModeKHR bestMode = VK_PRESENT_MODE_FIFO_KHR; for (const auto& availablePresentMode : availablePresentModes) { if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { return availablePresentMode; } else if (availablePresentMode == VK_PRESENT_MODE_IMMEDIATE_KHR) { bestMode = availablePresentMode; } } return bestMode; } C++","title":"\u6f14\u793a\u6a21\u5f0f"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_18","text":"\u8fd8\u5269\u4e0b\u4e00\u4e2a\u5c5e\u6027\uff0c\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u51fd\u6570: VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) { } C++ \u4ea4\u6362\u8303\u56f4\u662f\u6307\u4ea4\u6362\u94fe\u56fe\u50cf\u7684\u5206\u8fa8\u7387\uff0c\u5b83\u51e0\u4e4e\u603b\u662f\u7b49\u4e8e\u6211\u4eec\u7ed8\u5236\u7a97\u4f53\u7684\u5206\u8fa8\u7387\u3002\u5206\u8fa8\u7387\u7684\u8303\u56f4\u88ab\u5b9a\u4e49\u5728 VkSurfaceCapabilitiesKHR \u7ed3\u6784\u4f53\u4e2d\u3002 Vulkan \u544a\u8bc9\u6211\u4eec\u901a\u8fc7\u8bbe\u7f6e currentExtent \u6210\u5458\u7684 width \u548c height \u6765\u5339\u914d\u7a97\u4f53\u7684\u5206\u8fa8\u7387\u3002\u7136\u800c\uff0c\u4e00\u4e9b\u7a97\u4f53\u7ba1\u7406\u5668\u5141\u8bb8\u4e0d\u540c\u7684\u8bbe\u7f6e\uff0c\u610f\u5473\u7740\u5c06 currentExtent \u7684width\u548cheight\u8bbe\u7f6e\u4e3a\u7279\u6b8a\u7684\u6570\u503c\u8868\u793a: uint32_t \u7684\u6700\u5927\u503c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53c2\u8003\u7a97\u4f53 minImageExtent \u548c maxImageExtent \u9009\u62e9\u6700\u5339\u914d\u7684\u5206\u8fa8\u7387\u3002 VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) { if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) { return capabilities.currentExtent; } else { VkExtent2D actualExtent = {WIDTH, HEIGHT}; actualExtent.width = std::max(capabilities.minImageExtent.width, std::min(capabilities.maxImageExtent.width, actualExtent.width)); actualExtent.height = std::max(capabilities.minImageExtent.height, std::min(capabilities.maxImageExtent.height, actualExtent.height)); return actualExtent; } } C++ max \u548c min \u51fd\u6570\u7528\u4e8e\u5c06 WIDTH \u548c HEIGHT \u6536\u655b\u5728\u5b9e\u9645\u652f\u6301\u7684 minimum \u548c maximum \u8303\u56f4\u4e2d\u3002\u5728\u8fd9\u91cc\u786e\u8ba4\u5305\u542b <algorithm> \u5934\u6587\u4ef6\u3002","title":"\u4ea4\u6362\u8303\u56f4"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_19","text":"\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6709\u4e86\u8fd9\u4e9b\u8f85\u52a9\u51fd\u6570\uff0c\u7528\u4ee5\u5728\u8fd0\u884c\u65f6\u5e2e\u52a9\u6211\u4eec\u505a\u51fa\u660e\u667a\u7684\u9009\u62e9\uff0c\u6700\u7ec8\u83b7\u5f97\u6709\u4e86\u521b\u5efa\u4ea4\u6362\u94fe\u6240\u9700\u8981\u7684\u6240\u6709\u4fe1\u606f\u3002 \u521b\u5efa\u4e00\u4e2a\u51fd\u6570 createSwapChain \uff0c\u5728 initVulkan \u51fd\u6570\u4e2d\uff0c\u8be5\u51fd\u6570\u4f1a\u5728\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u4e4b\u540e\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); } void createSwapChain() { SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice); VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats); VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes); VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities); } C++ \u5b9e\u9645\u4e0a\u8fd8\u6709\u4e00\u4e9b\u5c0f\u4e8b\u60c5\u9700\u8981\u786e\u5b9a\uff0c\u4f46\u662f\u6bd4\u8f83\u7b80\u5355\uff0c\u6240\u4ee5\u6ca1\u6709\u5355\u72ec\u521b\u5efa\u51fd\u6570\u3002\u7b2c\u4e00\u4e2a\u662f\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u53ef\u4ee5\u7406\u89e3\u4e3a\u961f\u5217\u7684\u957f\u5ea6\u3002\u5b83\u6307\u5b9a\u8fd0\u884c\u65f6\u56fe\u50cf\u7684\u6700\u5c0f\u6570\u91cf\uff0c\u6211\u4eec\u5c06\u5c1d\u8bd5\u5927\u4e8e1\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u4ee5\u5b9e\u73b0\u4e09\u91cd\u7f13\u51b2\u3002 uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1; if (swapChainSupport.capabilities.maxImageCount > 0 && imageCount > swapChainSupport.capabilities.maxImageCount) { imageCount = swapChainSupport.capabilities.maxImageCount; } C++ \u5bf9\u4e8e maxImageCount \u6570\u503c\u4e3a 0 \u4ee3\u8868\u9664\u4e86\u5185\u5b58\u4e4b\u5916\u6ca1\u6709\u9650\u5236\uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u9700\u8981\u68c0\u67e5\u3002 \u4e0eVulkan\u5176\u4ed6\u5bf9\u8c61\u7684\u521b\u5efa\u8fc7\u7a0b\u4e00\u6837\uff0c\u521b\u5efa\u4ea4\u6362\u94fe\u4e5f\u9700\u8981\u586b\u5145\u5927\u91cf\u7684\u7ed3\u6784\u4f53: VkSwapchainCreateInfoKHR createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; createInfo.surface = surface; C++ \u5728\u6307\u5b9a\u4ea4\u6362\u94fe\u7ed1\u5b9a\u5230\u5177\u4f53\u7684 surface \u4e4b\u540e\uff0c\u9700\u8981\u6307\u5b9a\u4ea4\u6362\u94fe\u56fe\u50cf\u6709\u5173\u7684\u8be6\u7ec6\u4fe1\u606f: createInfo.minImageCount = imageCount; createInfo.imageFormat = surfaceFormat.format; createInfo.imageColorSpace = surfaceFormat.colorSpace; createInfo.imageExtent = extent; createInfo.imageArrayLayers = 1; createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; C++ imageArrayLayers \u6307\u5b9a\u6bcf\u4e2a\u56fe\u50cf\u7ec4\u6210\u7684\u5c42\u6570\u3002\u9664\u975e\u6211\u4eec\u5f00\u53d13D\u5e94\u7528\u7a0b\u5e8f\uff0c\u5426\u5219\u59cb\u7ec8\u4e3a1\u3002 imageUsage \u4f4d\u5b57\u6bb5\u6307\u5b9a\u5728\u4ea4\u6362\u94fe\u4e2d\u5bf9\u56fe\u50cf\u8fdb\u884c\u7684\u5177\u4f53\u64cd\u4f5c\u3002\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u76f4\u63a5\u5bf9\u5b83\u4eec\u8fdb\u884c\u6e32\u67d3\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u4eec\u4f5c\u4e3a\u989c\u8272\u9644\u4ef6\u3002\u4e5f\u53ef\u4ee5\u9996\u5148\u5c06\u56fe\u50cf\u6e32\u67d3\u4e3a\u5355\u72ec\u7684\u56fe\u50cf\uff0c\u8fdb\u884c\u540e\u5904\u7406\u64cd\u4f5c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u53ef\u4ee5\u4f7f\u7528\u50cf VK_IMAGE_USAGE_TRANSFER_DST_BIT \u8fd9\u6837\u7684\u503c\uff0c\u5e76\u4f7f\u7528\u5185\u5b58\u64cd\u4f5c\u5c06\u6e32\u67d3\u7684\u56fe\u50cf\u4f20\u8f93\u5230\u4ea4\u6362\u94fe\u56fe\u50cf\u961f\u5217\u3002 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); uint32_t queueFamilyIndices[] = {(uint32_t) indices.graphicsFamily, (uint32_t) indices.presentFamily}; if (indices.graphicsFamily != indices.presentFamily) { createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT; createInfo.queueFamilyIndexCount = 2; createInfo.pQueueFamilyIndices = queueFamilyIndices; } else { createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; createInfo.queueFamilyIndexCount = 0; // Optional createInfo.pQueueFamilyIndices = nullptr; // Optional } C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u6307\u5b9a\u5982\u4f55\u5904\u7406\u8de8\u591a\u4e2a\u961f\u5217\u7c07\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u3002\u5982\u679cgraphics\u961f\u5217\u7c07\u4e0epresentation\u961f\u5217\u7c07\u4e0d\u540c\uff0c\u4f1a\u51fa\u73b0\u5982\u4e0b\u60c5\u5f62\u3002\u6211\u4eec\u5c06\u4ecegraphics\u961f\u5217\u4e2d\u7ed8\u5236\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\uff0c\u7136\u540e\u5728\u53e6\u4e00\u4e2apresentation\u961f\u5217\u4e2d\u63d0\u4ea4\u4ed6\u4eec\u3002\u591a\u961f\u5217\u5904\u7406\u56fe\u50cf\u6709\u4e24\u79cd\u65b9\u6cd5: VK_SHARING_MODE_EXCLUSIVE : \u540c\u4e00\u65f6\u95f4\u56fe\u50cf\u53ea\u80fd\u88ab\u4e00\u4e2a\u961f\u5217\u7c07\u5360\u7528\uff0c\u5982\u679c\u5176\u4ed6\u961f\u5217\u7c07\u9700\u8981\u5176\u6240\u6709\u6743\u9700\u8981\u660e\u786e\u6307\u5b9a\u3002\u8fd9\u79cd\u65b9\u5f0f\u63d0\u4f9b\u4e86\u6700\u597d\u7684\u6027\u80fd\u3002 VK_SHARING_MODE_CONCURRENT : \u56fe\u50cf\u53ef\u4ee5\u88ab\u591a\u4e2a\u961f\u5217\u7c07\u8bbf\u95ee\uff0c\u4e0d\u9700\u8981\u660e\u786e\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\u3002 \u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u5982\u679c\u961f\u5217\u7c07\u4e0d\u540c\uff0c\u5c06\u4f1a\u4f7f\u7528 concurrent \u6a21\u5f0f\uff0c\u907f\u514d\u5904\u7406\u56fe\u50cf\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\u7684\u5185\u5bb9\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u4f1a\u6d89\u53ca\u4e0d\u5c11\u6982\u5ff5\uff0c\u5efa\u8bae\u540e\u7eed\u7684\u7ae0\u8282\u8ba8\u8bba\u3002 Concurrent \u6a21\u5f0f\u9700\u8981\u9884\u5148\u6307\u5b9a\u961f\u5217\u7c07\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\uff0c\u901a\u8fc7 queueFamilyIndexCount \u548c pQueueFamilyIndices \u53c2\u6570\u8fdb\u884c\u5171\u4eab\u3002\u5982\u679c graphics \u961f\u5217\u7c07\u548cpresentation\u961f\u5217\u7c07\u76f8\u540c\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 exclusive \u6a21\u5f0f\uff0c\u56e0\u4e3a concurrent \u6a21\u5f0f\u9700\u8981\u81f3\u5c11\u4e24\u4e2a\u4e0d\u540c\u7684\u961f\u5217\u7c07\u3002 createInfo.preTransform = swapChainSupport.capabilities.currentTransform; C++ \u5982\u679c\u4ea4\u6362\u94fe\u652f\u6301( supportedTransforms in capabilities ),\u6211\u4eec\u53ef\u4ee5\u4e3a\u4ea4\u6362\u94fe\u56fe\u50cf\u6307\u5b9a\u67d0\u4e9b\u8f6c\u6362\u903b\u8f91\uff0c\u6bd4\u598290\u5ea6\u987a\u65f6\u9488\u65cb\u8f6c\u6216\u8005\u6c34\u5e73\u53cd\u8f6c\u3002\u5982\u679c\u4e0d\u9700\u8981\u4efb\u4f55 transoform \u64cd\u4f5c\uff0c\u53ef\u4ee5\u7b80\u5355\u7684\u8bbe\u7f6e\u4e3a currentTransoform \u3002 createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR; C++ \u6df7\u5408Alpha\u5b57\u6bb5\u6307\u5b9aalpha\u901a\u9053\u662f\u5426\u5e94\u7528\u4e0e\u4e0e\u5176\u4ed6\u7684\u7a97\u4f53\u7cfb\u7edf\u8fdb\u884c\u6df7\u5408\u64cd\u4f5c\u3002\u5982\u679c\u5ffd\u7565\u8be5\u529f\u80fd\uff0c\u7b80\u5355\u7684\u586b VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR \u3002 createInfo.presentMode = presentMode; createInfo.clipped = VK_TRUE; C++ presentMode \u6307\u5411\u81ea\u5df1\u3002\u5982\u679c clipped \u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u610f\u5473\u7740\u6211\u4eec\u4e0d\u5173\u5fc3\u88ab\u906e\u853d\u7684\u50cf\u7d20\u6570\u636e\uff0c\u6bd4\u5982\u7531\u4e8e\u5176\u4ed6\u7684\u7a97\u4f53\u7f6e\u4e8e\u524d\u65b9\u65f6\u6216\u8005\u6e32\u67d3\u7684\u90e8\u5206\u5185\u5bb9\u5b58\u5728\u4e8e\u53ef\u662f\u533a\u57df\u4e4b\u5916\uff0c\u9664\u975e\u771f\u7684\u9700\u8981\u8bfb\u53d6\u8fd9\u4e9b\u50cf\u7d20\u83b7\u6570\u636e\u8fdb\u884c\u5904\u7406\uff0c\u5426\u5219\u53ef\u4ee5\u5f00\u542f\u88c1\u526a\u83b7\u5f97\u6700\u4f73\u6027\u80fd\u3002 createInfo.oldSwapchain = VK_NULL_HANDLE; C++ \u6700\u540e\u4e00\u4e2a\u5b57\u6bb5 oldSwapChain \u3002Vulkan\u8fd0\u884c\u65f6\uff0c\u4ea4\u6362\u94fe\u53ef\u80fd\u5728\u67d0\u4e9b\u6761\u4ef6\u4e0b\u88ab\u66ff\u6362\uff0c\u6bd4\u5982\u7a97\u53e3\u8c03\u6574\u5927\u5c0f\u6216\u8005\u4ea4\u6362\u94fe\u9700\u8981\u91cd\u65b0\u5206\u914d\u66f4\u5927\u7684\u56fe\u50cf\u961f\u5217\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4ea4\u6362\u94fe\u5b9e\u9645\u4e0a\u9700\u8981\u91cd\u65b0\u5206\u914d\u521b\u5efa\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u6b64\u5b57\u6bb5\u4e2d\u6307\u5b9a\u5bf9\u65e7\u7684\u5f15\u7528\uff0c\u7528\u4ee5\u56de\u6536\u8d44\u6e90\u3002\u8fd9\u662f\u4e00\u4e2a\u6bd4\u8f83\u590d\u6742\u7684\u8bdd\u9898\uff0c\u6211\u4eec\u4f1a\u5728\u540e\u9762\u7684\u7ae0\u8282\u4e2d\u8be6\u7ec6\u4ecb\u7ecd\u3002\u73b0\u5728\u5047\u8bbe\u6211\u4eec\u53ea\u4f1a\u521b\u5efa\u4e00\u4e2a\u4ea4\u6362\u94fe\u3002 \u73b0\u5728\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u53d8\u91cf\u5b58\u50a8 VkSwapchainKHR \u5bf9\u8c61: VkSwapchainKHR swapChain; C++ \u521b\u5efa\u4ea4\u6362\u94fe\u53ea\u9700\u8981\u7b80\u5355\u7684\u8c03\u7528\u51fd\u6570: vkCreateSwapchainKHR : if (vkCreateSwapchainKHR(device, &createInfo, nullptr, &swapChain) != VK_SUCCESS) { throw std::runtime_error(\"failed to create swap chain!\"); } C++ \u53c2\u6570\u662f\u903b\u8f91\u8bbe\u5907\uff0c\u4ea4\u6362\u94fe\u521b\u5efa\u7684\u4fe1\u606f\uff0c\u53ef\u9009\u62e9\u7684\u5206\u914d\u5668\u548c\u4e00\u4e2a\u5b58\u50a8\u4ea4\u6362\u540e\u7684\u53e5\u67c4\u6307\u9488\u3002\u5b83\u4e5f\u9700\u8981\u5728\u8bbe\u5907\u88ab\u6e05\u7406\u524d\uff0c\u8fdb\u884c\u9500\u6bc1\u64cd\u4f5c\uff0c\u901a\u8fc7\u8c03\u7528 vkDestroySwapchainKHR \u3002 void cleanup() { vkDestroySwapchainKHR(device, swapChain, nullptr); ... } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\u786e\u4fdd\u4ea4\u6362\u94fe\u521b\u5efa\u6210\u529f\uff01 \u5c1d\u8bd5\u79fb\u9664 createInfo.imageExtent = extent; \u5e76\u5728validation layers\u5f00\u542f\u7684\u6761\u4ef6\u4e0b\uff0cvalidation layers\u4f1a\u7acb\u523b\u6355\u83b7\u5230\u6709\u5e2e\u52a9\u7684\u5f02\u5e38\u4fe1\u606f:","title":"\u521b\u5efa\u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_20","text":"\u4ea4\u6362\u94fe\u521b\u5efa\u540e\uff0c\u9700\u8981\u83b7\u53d6 VkImage \u76f8\u5173\u7684\u53e5\u67c4\u3002\u5b83\u4f1a\u5728\u540e\u7eed\u6e32\u67d3\u7684\u7ae0\u8282\u4e2d\u5f15\u7528\u3002\u6dfb\u52a0\u7c7b\u6210\u5458\u53d8\u91cf\u5b58\u50a8\u8be5\u53e5\u67c4: std::vector<VkImage> swapChainImages; C++ \u56fe\u50cf\u88ab\u4ea4\u6362\u94fe\u521b\u5efa\uff0c\u4e5f\u4f1a\u5728\u4ea4\u6362\u94fe\u9500\u6bc1\u7684\u540c\u65f6\u81ea\u52a8\u6e05\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u6dfb\u52a0\u4efb\u4f55\u6e05\u7406\u4ee3\u7801\u3002 \u6211\u4eec\u5728 createSwapChain \u51fd\u6570\u4e0b\u9762\u6dfb\u52a0\u4ee3\u7801\u83b7\u53d6\u53e5\u67c4\uff0c\u5728 vkCreateSwapchainKHR \u540e\u8c03\u7528\u3002\u83b7\u53d6\u53e5\u67c4\u7684\u64cd\u4f5c\u540c\u4e4b\u524d\u83b7\u53d6\u6570\u7ec4\u96c6\u5408\u7684\u64cd\u4f5c\u975e\u5e38\u7c7b\u4f3c\u3002\u9996\u5148\u901a\u8fc7\u8c03\u7528 vkGetSwapchainImagesKHR \u83b7\u53d6\u4ea4\u6362\u94fe\u4e2d\u56fe\u50cf\u7684\u6570\u91cf\uff0c\u5e76\u6839\u636e\u6570\u91cf\u8bbe\u7f6e\u5408\u9002\u7684\u5bb9\u5668\u5927\u5c0f\u4fdd\u5b58\u83b7\u53d6\u5230\u7684\u53e5\u67c4\u96c6\u5408\u3002 vkGetSwapchainImagesKHR(device, swapChain, &imageCount, nullptr); swapChainImages.resize(imageCount); vkGetSwapchainImagesKHR(device, swapChain, &imageCount, swapChainImages.data()); C++ \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e4b\u524d\u521b\u5efa\u4ea4\u6362\u94fe\u6b65\u9aa4\u4e2d\u6211\u4eec\u4f20\u9012\u4e86\u671f\u671b\u7684\u56fe\u50cf\u5927\u5c0f\u5230\u5b57\u6bb5 minImageCount \u3002\u800c\u5b9e\u9645\u7684\u8fd0\u884c\uff0c\u5141\u8bb8\u6211\u4eec\u521b\u5efa\u66f4\u591a\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u9700\u8981\u518d\u4e00\u6b21\u83b7\u53d6\u6570\u91cf\u3002 \u6700\u540e\uff0c\u5b58\u50a8\u4ea4\u6362\u94fe\u683c\u5f0f\u548c\u8303\u56f4\u5230\u6210\u5458\u53d8\u91cf\u4e2d\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7ae0\u8282\u4f7f\u7528\u3002 VkSwapchainKHR swapChain; std::vector<VkImage> swapChainImages; VkFormat swapChainImageFormat; VkExtent2D swapChainExtent; ... swapChainImageFormat = surfaceFormat.format; swapChainExtent = extent; C++ \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u56fe\u50cf\uff0c\u8fd9\u4e9b\u56fe\u50cf\u53ef\u4ee5\u88ab\u7ed8\u5236\uff0c\u5e76\u5448\u73b0\u5230\u7a97\u4f53\u3002 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u5f00\u59cb\u8ba8\u8bba\u5982\u4f55\u4e3a\u56fe\u50cf\u8bbe\u7f6e\u6e32\u67d3\u76ee\u6807\uff0c\u5e76\u4e86\u89e3\u5b9e\u9645\u7684\u56fe\u50cf\u7ba1\u7ebf\u548c\u7ed8\u5236\u547d\u4ee4\u3002","title":"\u83b7\u53d6\u4ea4\u6362\u94fe\u56fe\u50cf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan-window-surface","text":"Vulkan Window Surface \uff0c\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u4e86\u89e3\u5230 Vulkan \u662f\u4e00\u4e2a\u4e0e\u5e73\u53f0\u7279\u6027\u65e0\u5173\u8054\u7684 API \u96c6\u5408\u3002\u5b83\u4e0d\u80fd\u76f4\u63a5\u4e0e\u7a97\u53e3\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002\u4e3a\u4e86\u5c06\u6e32\u67d3\u7ed3\u679c\u5448\u73b0\u5230\u5c4f\u5e55\uff0c\u9700\u8981\u5efa\u7acb Vulkan \u4e0e\u7a97\u4f53\u7cfb\u7edf\u4e4b\u95f4\u7684\u8fde\u63a5\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 WSI (\u7a97\u4f53\u7cfb\u7edf\u96c6\u6210)\u6269\u5c55\u3002\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u8ba8\u8bba\u7b2c\u4e00\u4e2a\uff0c\u5373 VK_KHR_surface \u3002\u5b83\u66b4\u9732\u4e86 VkSurfaceKHR \uff0c\u5b83\u4ee3\u8868 surface \u7684\u4e00\u4e2a\u62bd\u8c61\u7c7b\u578b\uff0c\u7528\u4ee5\u5448\u73b0\u6e32\u67d3\u56fe\u50cf\u4f7f\u7528\u3002\u6211\u4eec\u7a0b\u5e8f\u4e2d\u5c06\u8981\u4f7f\u7528\u5230\u7684 surface \u662f\u7531\u6211\u4eec\u5df2\u7ecf\u5f15\u5165\u7684 GLFW \u6269\u5c55\u53ca\u5176\u6253\u5f00\u7684\u76f8\u5173\u7a97\u4f53\u652f\u6301\u7684\u3002\u7b80\u5355\u6765\u8bf4surface\u5c31\u662fVulkan\u4e0e\u7a97\u4f53\u7cfb\u7edf\u7684\u8fde\u63a5\u6865\u6881\u3002 VK_KHR_surface \u6269\u5c55\u662f\u4e00\u4e2ainstance\u7ea7\u6269\u5c55\uff0c\u6211\u4eec\u76ee\u524d\u4e3a\u6b62\u5df2\u7ecf\u542f\u7528\u8fc7\u5b83\uff0c\u5b83\u5305\u542b\u5728 glfwGetRequiredInstanceExtensions \u8fd4\u56de\u7684\u5217\u8868\u4e2d\u3002\u8be5\u5217\u8868\u8fd8\u5305\u62ec\u5c06\u5728\u63a5\u4e0b\u6765\u51e0\u5c0f\u8282\u4e2d\u4f7f\u7528\u7684\u4e00\u4e9b\u5176\u4ed6WSI\u6269\u5c55\u3002 \u9700\u8981\u5728 instance \u521b\u5efa\u4e4b\u540e\u7acb\u5373\u521b\u5efa\u7a97\u4f53 surface \uff0c\u56e0\u4e3a\u5b83\u4f1a\u5f71\u54cd\u7269\u7406\u8bbe\u5907\u7684\u9009\u62e9\u3002\u4e4b\u6240\u4ee5\u5728\u672c\u5c0f\u8282\u5c06 surface \u521b\u5efa\u903b\u8f91\u7eb3\u5165\u8ba8\u8bba\u8303\u56f4\uff0c\u662f\u56e0\u4e3a\u7a97\u4f53 surface \u5bf9\u4e8e\u6e32\u67d3\u3001\u5448\u73b0\u65b9\u5f0f\u662f\u4e00\u4e2a\u6bd4\u8f83\u5927\u7684\u8bfe\u9898\uff0c\u5982\u679c\u8fc7\u65e9\u7684\u5728\u521b\u5efa\u7269\u7406\u8bbe\u5907\u52a0\u5165\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u4f1a\u6df7\u6dc6\u57fa\u672c\u7684\u7269\u7406\u8bbe\u5907\u8bbe\u7f6e\u5de5\u4f5c\u3002\u53e6\u5916\u7a97\u4f53 surface \u672c\u8eab\u5bf9\u4e8e Vulkan \u4e5f\u662f\u975e\u5f3a\u5236\u7684\u3002 Vulkan \u5141\u8bb8\u8fd9\u6837\u505a\uff0c\u4e0d\u9700\u8981\u540c OpenGL \u4e00\u6837\u5fc5\u987b\u8981\u521b\u5efa\u7a97\u4f53 surface \u3002 \u6587\u7ae0\u76ee\u5f55 1 \u521b\u5efa Window Surface 2 \u67e5\u8be2\u6f14\u793a\u652f\u6301 3 \u521b\u5efa\u6f14\u793a\u961f\u5217","title":"Vulkan Window Surface"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#window-surface","text":"\u73b0\u5728\u5f00\u59cb\u7740\u624b\u521b\u5efa\u7a97\u4f53 surface \uff0c\u5728\u7c7b\u6210\u5458 debugCallback \u4e0b\u52a0\u5165\u6210\u5458\u53d8\u91cf surface \u3002 VkSurfaceKHR surface; C++ \u867d\u7136 VkSurfaceKHR \u5bf9\u8c61\u53ca\u5176\u7528\u6cd5\u4e0e\u5e73\u53f0\u65e0\u5173\u8054\uff0c\u4f46\u521b\u5efa\u8fc7\u7a0b\u9700\u8981\u4f9d\u8d56\u5177\u4f53\u7684\u7a97\u4f53\u7cfb\u7edf\u7684\u7ec6\u8282\u3002\u6bd4\u5982\uff0c\u5728 Windows \u5e73\u53f0\u4e2d\uff0c\u5b83\u9700\u8981 WIndows \u4e0a\u7684 HWND \u548c HMODULE \u53e5\u67c4\u3002\u56e0\u6b64\u9488\u5bf9\u7279\u5b9a\u5e73\u53f0\u63d0\u4f9b\u76f8\u5e94\u7684\u6269\u5c55\uff0c\u5728 Windows \u4e0a\u4e3a VK_KHR_win32_surface \uff0c\u5b83\u81ea\u52a8\u5305\u542b\u5728 glfwGetRequiredInstanceExtensions \u5217\u8868\u4e2d\u3002 \u6211\u4eec\u5c06\u4f1a\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u7279\u5b9a\u5e73\u53f0\u7684\u6269\u5c55\u6765\u521b\u5efa Windows \u4e0a\u7684 surface \u6865\uff0c\u4f46\u662f\u4e0d\u4f1a\u5728\u6559\u7a0b\u4e2d\u5b9e\u9645\u4f7f\u7528\u5b83\u3002\u4f7f\u7528GLFW\u8fd9\u6837\u7684\u5e93\u907f\u514d\u4e86\u7f16\u5199\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u7684\u8de8\u5e73\u53f0\u76f8\u5173\u4ee3\u7801\u3002 GLFW \u5b9e\u9645\u4e0a\u901a\u8fc7 glfwCreateWindowSurface \u5f88\u597d\u7684\u5904\u7406\u4e86\u5e73\u53f0\u5dee\u5f02\u6027\u3002\u5f53\u7136\u4e86\uff0c\u6bd4\u8f83\u7406\u60f3\u662f\u5728\u4f9d\u8d56\u5b83\u4eec\u5e2e\u52a9\u6211\u4eec\u5b8c\u6210\u5177\u4f53\u5de5\u4f5c\u4e4b\u524d\uff0c\u4e86\u89e3\u4e00\u4e0b\u80cc\u540e\u7684\u5b9e\u73b0\u662f\u6709\u5e2e\u52a9\u7684\u3002 \u56e0\u4e3a\u4e00\u4e2a\u7a97\u4f53 surface \u662f\u4e00\u4e2a Vulkan \u5bf9\u8c61\uff0c\u5b83\u9700\u8981\u586b\u5145 VkWin32SurfaceCreateInfoKHR \u7ed3\u6784\u4f53\uff0c\u8fd9\u91cc\u6709\u4e24\u4e2a\u6bd4\u8f83\u91cd\u8981\u7684\u53c2\u6570: hwnd \u548c hinstance \u3002\u5982\u679c\u719f\u6089 windows \u4e0b\u5f00\u53d1\u5e94\u8be5\u77e5\u9053\uff0c\u8fd9\u4e9b\u662f\u7a97\u53e3\u548c\u8fdb\u7a0b\u7684\u53e5\u67c4\u3002 VkWin32SurfaceCreateInfoKHR createInfo; createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR; createInfo.hwnd = glfwGetWin32Window(window); createInfo.hinstance = GetModuleHandle(nullptr); C++ glfwGetWin32Window \u51fd\u6570\u7528\u4e8e\u4eceGLFW\u7a97\u4f53\u5bf9\u8c61\u83b7\u53d6\u539f\u59cb\u7684 HWND \u3002 GetModuleHandle \u51fd\u6570\u8fd4\u56de\u5f53\u524d\u8fdb\u7a0b\u7684 HINSTANCE \u53e5\u67c4\u3002 \u586b\u5145\u5b8c\u7ed3\u6784\u4f53\u4e4b\u540e\uff0c\u53ef\u4ee5\u5229\u7528 vkCreateWin32SurfaceKHR \u521b\u5efasurface\u6865\uff0c\u548c\u4e4b\u524d\u83b7\u53d6\u521b\u5efa\u3001\u9500\u6bc1 DebugReportCallEXT \u4e00\u6837\uff0c\u8fd9\u91cc\u540c\u6837\u9700\u8981\u901a\u8fc7 instance \u83b7\u53d6\u521b\u5efa surface \u7528\u5230\u7684\u51fd\u6570\u3002\u8fd9\u91cc\u6d89\u53ca\u5230\u7684\u53c2\u6570\u5206\u522b\u4e3a instance , surface \u521b\u5efa\u7684\u4fe1\u606f\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u6700\u7ec8\u4fdd\u5b58 surface \u7684\u53e5\u67c4\u53d8\u91cf\u3002 auto CreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) vkGetInstanceProcAddr(instance, \"vkCreateWin32SurfaceKHR\"); if (!CreateWin32SurfaceKHR || CreateWin32SurfaceKHR(instance, &createInfo, nullptr, &surface) != VK_SUCCESS) { throw std::runtime_error(\"failed to create window surface!\"); } C++ \u8be5\u8fc7\u7a0b\u4e0e\u5176\u4ed6\u5e73\u53f0\u7c7b\u4f3c\uff0c\u6bd4\u5982 Linux \uff0c\u4f7f\u7528X11\u754c\u9762\u7a97\u4f53\u7cfb\u7edf\uff0c\u53ef\u4ee5\u901a\u8fc7 vkCreateXcbSurfaceKHR \u51fd\u6570\u5efa\u7acb\u8fde\u63a5\u3002 glfwCreateWindowSurface \u51fd\u6570\u6839\u636e\u4e0d\u540c\u5e73\u53f0\u7684\u5dee\u5f02\u6027\uff0c\u5728\u5b9e\u73b0\u7ec6\u8282\u4e0a\u4f1a\u6709\u6240\u4e0d\u540c\u3002\u6211\u4eec\u73b0\u5728\u5c06\u5176\u6574\u5408\u5230\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\u3002\u4ece initVulkan \u4e2d\u6dfb\u52a0\u4e00\u4e2a\u51fd\u6570 createSurface ,\u5b89\u6392\u5728 createInstnace \u548c setupDebugCallback \u51fd\u6570\u4e4b\u540e\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); } void createSurface() { } C++ GLFW \u6ca1\u6709\u4f7f\u7528\u7ed3\u6784\u4f53\uff0c\u800c\u662f\u9009\u62e9\u975e\u5e38\u76f4\u63a5\u7684\u53c2\u6570\u4f20\u9012\u6765\u8c03\u7528\u51fd\u6570\u3002 void createSurface() { if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) { throw std::runtime_error(\"failed to create window surface!\"); } } C++ \u53c2\u6570\u662f VkInstance , GLFW \u7a97\u4f53\u7684\u6307\u9488\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u7528\u4e8e\u5b58\u50a8 VkSurfaceKHR \u53d8\u91cf\u7684\u6307\u9488\u3002\u5bf9\u4e8e\u4e0d\u540c\u5e73\u53f0\u7edf\u4e00\u8fd4\u56de VkResult \u3002 GLFW \u6ca1\u6709\u63d0\u4f9b\u4e13\u7528\u7684\u51fd\u6570\u9500\u6bc1 surface ,\u4f46\u662f\u53ef\u4ee5\u7b80\u5355\u7684\u901a\u8fc7 Vulkan \u539f\u59cb\u7684 API \u5b8c\u6210: void cleanup() { ... vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); ... } C++ \u6700\u540e\u8bf7\u786e\u4fddsurface\u7684\u6e05\u7406\u662f\u5728instance\u9500\u6bc1\u4e4b\u524d\u5b8c\u6210\u3002","title":"\u521b\u5efa Window Surface"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_21","text":"\u867d\u7136 Vulkan \u7684\u5b9e\u73b0\u652f\u6301\u7a97\u4f53\u96c6\u6210\u529f\u80fd\uff0c\u4f46\u662f\u5e76\u4e0d\u610f\u5473\u7740\u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u90fd\u652f\u6301\u5b83\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u6269\u5c55 isDeviceSuitable \u51fd\u6570\uff0c\u786e\u4fdd\u8bbe\u5907\u53ef\u4ee5\u5c06\u56fe\u50cf\u5448\u73b0\u5230\u6211\u4eec\u521b\u5efa\u7684 surface \u3002\u7531\u4e8e presentation \u662f\u4e00\u4e2a\u961f\u5217\u7684\u7279\u6027\u529f\u80fd\uff0c\u56e0\u6b64\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6cd5\u5c31\u662f\u627e\u5230\u652f\u6301 presentation \u7684\u961f\u5217\u7c07\uff0c\u6700\u7ec8\u83b7\u53d6\u961f\u5217\u6ee1\u8db3 surface \u521b\u5efa\u7684\u9700\u8981\u3002 \u5b9e\u9645\u60c5\u51b5\u662f\uff0c\u652f\u6301 graphics \u547d\u4ee4\u7684\u7684\u961f\u5217\u7c07\u548c\u652f\u6301 presentation \u547d\u4ee4\u7684\u961f\u5217\u7c07\u53ef\u80fd\u4e0d\u662f\u540c\u4e00\u4e2a\u7c07\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u4fee\u6539 QueueFamilyIndices \u7ed3\u6784\u4f53\uff0c\u4ee5\u652f\u6301\u5dee\u5f02\u5316\u7684\u5b58\u50a8\u3002 struct QueueFamilyIndices { int graphicsFamily = -1; int presentFamily = -1; bool isComplete() { return graphicsFamily >= 0 && presentFamily >= 0; } }; C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4fee\u6539 findQueueFamilies \u51fd\u6570\u6765\u67e5\u627e\u5177\u5907 presentation \u529f\u80fd\u7684\u961f\u5217\u7c07\u3002\u51fd\u6570\u4e2d\u7528\u4e8e\u68c0\u67e5\u7684\u6838\u5fc3\u4ee3\u7801\u662f vkGetPhysicalDeviceSurfaceSupportKHR ,\u5b83\u5c06\u7269\u7406\u8bbe\u5907\u3001\u961f\u5217\u7c07\u7d22\u5f15\u548c surface \u4f5c\u4e3a\u53c2\u6570\u3002\u5728 VK_QUEUE_GRAPHICS_BIT \u76f8\u540c\u7684\u5faa\u73af\u4f53\u4e2d\u6dfb\u52a0\u51fd\u6570\u7684\u8c03\u7528: VkBool32 presentSupport = false; vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport); C++ \u7136\u540e\u4e4b\u9700\u8981\u68c0\u67e5\u5e03\u5c14\u503c\u5e76\u5b58\u50a8 presentation \u961f\u5217\u7c07\u7684\u7d22\u5f15: if (queueFamily.queueCount > 0 && presentSupport) { indices.presentFamily = i; } C++ \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e3a\u4e86\u652f\u6301 graphics \u548c presentation \u529f\u80fd\uff0c\u6211\u4eec\u5b9e\u9645\u73af\u5883\u4e2d\u5f97\u5230\u7684\u53ef\u80fd\u662f\u540c\u4e00\u4e2a\u961f\u5217\u7c07\uff0c\u4e5f\u53ef\u80fd\u4e0d\u540c\uff0c\u4e3a\u6b64\u5728\u6211\u4eec\u7684\u7a0b\u5e8f\u6570\u636e\u7ed3\u6784\u53ca\u9009\u62e9\u903b\u8f91\u4e2d\uff0c\u5c06\u6309\u7167\u5747\u6765\u81ea\u4e0d\u540c\u7684\u961f\u5217\u7c07\u5206\u522b\u5904\u7406\uff0c\u8fd9\u6837\u4fbf\u53ef\u4ee5\u7edf\u4e00\u5904\u7406\u4ee5\u4e0a\u4e24\u79cd\u60c5\u51b5\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u51fa\u4e8e\u6027\u80fd\u7684\u8003\u8651\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u903b\u8f91\u660e\u786e\u7684\u6307\u5b9a\u7269\u7406\u8bbe\u5907\u6240\u4f7f\u7528\u7684 graphics \u548c presentation \u529f\u80fd\u6765\u81ea\u540c\u4e00\u4e2a\u961f\u5217\u7c07\u3002","title":"\u67e5\u8be2\u6f14\u793a\u652f\u6301"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_22","text":"\u5269\u4e0b\u7684\u4e8b\u60c5\u662f\u4fee\u6539\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u8fc7\u7a0b\uff0c\u5728\u4e8e\u521b\u5efa presentation \u961f\u5217\u5e76\u83b7\u53d6 VkQueue \u7684\u53e5\u67c4\u3002\u6dfb\u52a0\u4fdd\u5b58\u961f\u5217\u53e5\u67c4\u7684\u6210\u5458\u53d8\u91cf: VkQueue presentQueue; C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u591a\u4e2a VkDeviceQueueCreateInfo \u7ed3\u6784\u6765\u521b\u5efa\u4e0d\u540c\u529f\u80fd\u7684\u961f\u5217\u3002\u4e00\u4e2a\u4f18\u96c5\u7684\u65b9\u5f0f\u662f\u9488\u5bf9\u4e0d\u540c\u529f\u80fd\u7684\u961f\u5217\u7c07\u521b\u5efa\u4e00\u4e2aset\u96c6\u5408\u786e\u4fdd\u961f\u5217\u7c07\u7684\u552f\u4e00\u6027: #include <set> ... QueueFamilyIndices indices = findQueueFamilies(physicalDevice); std::vector<VkDeviceQueueCreateInfo> queueCreateInfos; std::set<int> uniqueQueueFamilies = {indices.graphicsFamily, indices.presentFamily}; float queuePriority = 1.0f; for (int queueFamily : uniqueQueueFamilies) { VkDeviceQueueCreateInfo queueCreateInfo = {}; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = queueFamily; queueCreateInfo.queueCount = 1; queueCreateInfo.pQueuePriorities = &queuePriority; queueCreateInfos.push_back(queueCreateInfo); } C++ \u540c\u65f6\u8fd8\u8981\u4fee\u6539 VkDeviceCreateInfo \u6307\u5411\u961f\u5217\u96c6\u5408: createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size()); createInfo.pQueueCreateInfos = queueCreateInfos.data(); C++ \u5982\u679c\u961f\u5217\u7c07\u76f8\u540c\uff0c\u90a3\u4e48\u6211\u4eec\u4e4b\u9700\u8981\u4f20\u9012\u4e00\u6b21\u7d22\u5f15\u3002\u6700\u540e\uff0c\u6dfb\u52a0\u4e00\u4e2a\u8c03\u7528\u68c0\u7d22\u961f\u5217\u53e5\u67c4: vkGetDeviceQueue(device, indices.presentFamily, 0, &presentQueue); C++ \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u961f\u5217\u7c07\u662f\u76f8\u540c\u7684\uff0c\u4e24\u4e2a\u53e5\u67c4\u53ef\u80fd\u4f1a\u6709\u76f8\u540c\u7684\u503c\u3002\u5728 \u4e0b\u4e00\u4e2a\u7ae0\u8282 \u4e2d\u6211\u4eec\u4f1a\u770b\u770b\u4ea4\u6362\u94fe\uff0c\u4ee5\u53ca\u5b83\u4eec\u5982\u4f55\u4f7f\u6211\u4eec\u80fd\u591f\u5c06\u56fe\u50cf\u5448\u73b0\u7ed9 surface \u3002","title":"\u521b\u5efa\u6f14\u793a\u961f\u5217"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_5","text":"Vulkan \u56fe\u5f62\u7ba1\u7ebf \uff0c\u901a\u8fc7\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\uff0c\u6211\u4eec\u5c06\u4f1a\u5f00\u542f\u6709\u5173\u56fe\u5f62\u7ba1\u7ebf\u7684\u8bdd\u9898\uff0c\u901a\u8fc7\u5bf9\u56fe\u5f62\u6e32\u67d3\u7ba1\u7ebf\u7684\u914d\u7f6e\u5b8c\u6210\u6700\u540e\u7684\u4e09\u89d2\u5f62\u7ed8\u753b\u3002\u6240\u8c13\u56fe\u5f62\u7ba1\u7ebf\u5c31\u662f\u5c06 mesh \u4f7f\u7528\u5230\u7684 vertices \u5b9a\u70b9\u6570\u636e\u548c\u8d34\u56fe\u6570\u636e\uff0c\u8f6c\u5316\u4e3a\u6e32\u67d3 targets \u50cf\u7d20\u7684\u64cd\u4f5c\u5e8f\u5217\u3002\u7b80\u8981\u7684\u6982\u8ff0\u5982\u4e0b\u56fe\u6240\u793a: Input assembler \u6536\u96c6\u6700\u539f\u59cb\u7684\u9876\u70b9\u6570\u636e\uff0c\u5e76\u4e14\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7d22\u5f15\u7f13\u51b2\u533a\u590d\u7528\u8fd9\u4e9b\u6570\u636e\u5143\u7d20\uff0c\u800c\u4e0d\u5fc5\u590d\u5236\u5197\u4f59\u7684\u9876\u70b9\u6570\u636e\u526f\u672c\u3002 vertex shader \u4f1a\u5e94\u7528\u5728\u6bcf\u4e00\u4e2a\u9876\u70b9\u6570\u636e\uff0c\u901a\u5e38\u5e94\u7528\u53d8\u6362\u64cd\u4f5c\uff0c\u4ece\u800c\u5c06\u9876\u70b9\u7684\u4f4d\u7f6e\u5750\u6807\u6570\u636e\u4ece\u6a21\u578b\u7a7a\u95f4\u8f6c\u6362\u4e3a\u5c4f\u5e55\u7a7a\u95f4\u3002\u5728\u5904\u7406\u5b8c\u6bd5\u4e4b\u540e\u4f1a\u5c06\u6570\u636e\u7ee7\u7eed\u5728\u7ba1\u7ebf\u4f20\u9012\u4e0b\u53bb\u3002 tessellation shader \u66f2\u9762\u7740\u8272\u5668\u5141\u8bb8\u57fa\u4e8e\u67d0\u4e9b\u89c4\u5219\u8fdb\u4e00\u6b65\u7ec6\u5206\u51e0\u4f55\u6570\u636e\u589e\u52a0\u7f51\u683c\u7684\u8d28\u91cf\u3002\u7ecf\u5e38\u5e94\u7528\u4e0e\u5899\u9762\u548c\u697c\u68af\u8868\u9762\uff0c\u4f7f\u9644\u8fd1\u770b\u8d77\u6765\u4e0d\u662f\u90a3\u4e48\u5e73\u5766\u3002 geometry shader \u96c6\u5408\u7740\u8272\u5668\u5e94\u7528\u5728\u6bcf\u4e00\u4e2a\u56fe\u5143\u4e0a\uff0c\u53ef\u7528\u4e8e\u589e\u51cf\u56fe\u5143\uff0c\u5b83\u4e0e\u66f2\u9762\u7740\u8272\u5668\u7c7b\u4f3c\uff0c\u4f46\u66f4\u52a0\u7075\u6d3b\u3002\u7136\u800c\uff0c\u5b83\u5728\u4eca\u5929\u7684\u5e94\u7528\u4e2d\u5e76\u6ca1\u6709\u592a\u591a\u7684\u5e94\u7528\u60c5\u666f\uff0c\u56e0\u4e3a\u9664\u4e86 Intel \u7684\u96c6\u6210\u663e\u5361\u5916\uff0c\u5927\u591a\u6570\u663e\u5361\u6027\u80fd\u652f\u6301\u90fd\u4e0d\u7406\u60f3\u3002 \u5149\u6805\u5316\u9636\u6bb5\u5c06\u56fe\u5143\u5206\u89e3\u4e3a\u7247\u5143\u3002\u8fd9\u4e9b\u662f\u586b\u5145\u5728\u5e27\u7f13\u51b2\u533a\u4e0a\u7684\u50cf\u7d20\u5143\u7d20\u3002\u5c4f\u5e55\u5916\u533a\u57df\u7684\u7247\u5143\u4f1a\u88ab\u4e22\u5f03\uff0c\u9876\u70b9\u7740\u8272\u5668\u8f93\u51fa\u7684\u6570\u636e\u5728\u4f20\u9012\u5230\u7247\u5143\u7740\u8272\u5668\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u5982\u56fe\u6240\u793a\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u6839\u636e\u6df1\u5ea6\u6d4b\u8bd5\u7684\u7ed3\u679c\u4e5f\u4f1a\u5bf9\u7247\u5143\u8fdb\u884c\u4e22\u5f03\u3002 fragment shader \u5e94\u7528\u4e8e\u6bcf\u4e2a\u7247\u5143\uff0c\u786e\u5b9a\u6bcf\u4e2a\u5e27\u7f13\u51b2\u533a\u4e2d\u5199\u5165\u7684\u7247\u5143\u6570\u636e\u7684\u989c\u8272\u548c\u6df1\u5ea6\u503c\u3002\u7247\u5143\u7740\u8272\u5668\u53ef\u4ee5\u4f7f\u7528\u9876\u70b9\u7740\u8272\u5668\u7684\u63d2\u503c\u6570\u636e\uff0c\u8d34\u56fe\u7684UV\u5750\u6807\u548c\u5149\u6e90\u6cd5\u7ebf\u6570\u636e\u3002 \u6df7\u8272\u64cd\u4f5c\u9636\u6bb5\u4f1a\u5bf9\u4e0d\u540c\u7247\u5143\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\uff0c\u6700\u7ec8\u6620\u5c04\u5230\u5e27\u7f13\u51b2\u533a\u7684\u540c\u4e00\u4e2a\u50cf\u7d20\u4e0a\u3002\u7247\u5143\u4e5f\u53ef\u4ee5\u7b80\u5355\u7684\u4e92\u76f8\u91cd\u5199\uff0c\u53e0\u52a0\u6216\u8005\u6839\u636e\u900f\u660e\u5ea6\u6df7\u5408\u3002 \u7eff\u8272\u7684\u9636\u6bb5\u88ab\u79f0\u4e3a\u56fa\u5b9a\u6d41\u6c34\u7ebf\u3002\u8fd9\u4e2a\u9636\u6bb5\u5141\u8bb8\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684\u53c2\u6570\u6570\u503c\uff0c\u4f46\u662f\u5b83\u5185\u90e8\u7684\u5de5\u4f5c\u903b\u8f91\u662f\u9884\u5236\u597d\u7684\u3002 \u6a59\u8272\u7684\u9636\u6bb5\u88ab\u79f0\u4e3a\u53ef\u7f16\u7a0b\u9636\u6bb5 programmable \uff0c\u6211\u4eec\u53ef\u4ee5\u5411GPU\u63d0\u4ea4\u81ea\u5df1\u7f16\u5199\u7684\u4ee3\u7801\u6267\u884c\u5177\u4f53\u7684\u903b\u8f91\u3002\u6bd4\u5982\u5728\u4f7f\u7528 fragment shader \u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u5b9e\u73b0\u4efb\u4f55\u4ece\u8d34\u56fe\u5230\u706f\u5149\u7684\u5149\u7ebf\u8ffd\u8e2a\u3002\u8fd9\u4e9b\u7a0b\u5e8f\u540c\u65f6\u8fd0\u884c\u5728\u591a\u6838GPU\u4e0a\u5904\u7406\u8bb8\u591a\u5bf9\u8c61\uff0c\u6bd4\u5982\u5e76\u884c\u7684\u9876\u70b9\u548c\u7247\u6bb5\u7a0b\u5e8f\u3002 \u5982\u679c\u4e4b\u524d\u4f7f\u7528\u8fc7\u65e7\u7684API( OpenGL \u548c Direct3D ),\u90a3\u4e48\u5c06\u53ef\u4ee5\u968f\u610f\u901a\u8fc7 glBlendFunc \u548c OMSetBlendState \u8c03\u7528\u66f4\u6539\u7ba1\u7ebf\u8bbe\u7f6e\u3002 Vulkan\u4e2d \u7684\u56fe\u5f62\u7ba1\u7ebf\u51e0\u4e4e\u4e0d\u53ef\u6539\u53d8\uff0c\u56e0\u6b64\u5982\u679c\u9700\u8981\u66f4\u6539\u7740\u8272\u5668\uff0c\u7ed1\u5b9a\u5230\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u533a\u6216\u8005\u66f4\u6539\u6df7\u5408\u51fd\u6570\uff0c\u5219\u5fc5\u987b\u4ece\u5934\u521b\u5efa\u7ba1\u7ebf\u3002\u7f3a\u70b9\u662f\u5fc5\u987b\u521b\u5efa\u4e00\u4e9b\u7ba1\u7ebf\uff0c\u8fd9\u4e9b\u7ba1\u7ebf\u4ee3\u8868\u5728\u6e32\u67d3\u64cd\u4f5c\u4e2d\u4f7f\u7528\u7684\u4e0d\u540c\u7684\u7ec4\u5408\u72b6\u6001\u3002\u4f46\u662f\u7531\u4e8e\u6240\u6709\u7ba1\u7ebf\u7684\u64cd\u4f5c\u90fd\u662f\u63d0\u524d\u77e5\u9053\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7\u9a71\u52a8\u7a0b\u5e8f\u66f4\u597d\u7684\u4f18\u5316\u5b83\u3002 \u4e00\u4e9b\u53ef\u7f16\u7a0b\u9636\u6bb5\u662f\u57fa\u4e8e\u6253\u7b97\u505a\u4ec0\u4e48\u800c\u51b3\u5b9a\u7684\u3002\u6bd4\u5982\uff0c\u5982\u679c\u53ea\u662f\u7b80\u5355\u7684\u7ed8\u5236\u51e0\u4f55\u56fe\u5f62\uff0c\u5219\u53ef\u4ee5\u7981\u7528 tessellation \u548c geometry \u7740\u8272\u5668\u3002\u5982\u679c\u53ea\u5bf9\u6df1\u5ea6\u503c\u611f\u5174\u8da3\uff0c\u5219\u53ef\u4ee5\u7981\u7528 fragment \u7740\u8272\u5668\uff0c\u8fd9\u5bf9\u4e8e\u751f\u6210 shadow map \u751f\u6210\u5f88\u6709\u7528\u3002 \u5728\u4e0b\u4e00\u4e2a\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u9996\u5148\u521b\u5efa\u5c06\u4e09\u89d2\u5f62\u653e\u5728\u5c4f\u5e55\u4e0a\u6240\u9700\u8981\u7684\u4e24\u4e2a\u53ef\u7f16\u7a0b\u9636\u6bb5: vertice shader \u548c fragment shader \u3002\u56fa\u5b9a\u529f\u80fd\u7684\u8bbe\u7f6e\u5305\u62ec blending mode , viewport , rasterization \u5c06\u5728\u4e4b\u540e\u7684\u7ae0\u8282\u4e2d\u8bbe\u7f6e\u3002\u5728 Vulkan \u4e2d\u8bbe\u7f6e\u56fe\u5f62\u6d41\u6c34\u7ebf\u7684\u6700\u540e\u4e00\u90e8\u5206\u5185\u5bb9\u6d89\u53ca\u8f93\u5165\u548c\u8f93\u51fa\u5e27\u7f13\u51b2\u533a\u3002 \u5728 initVulkan \u4e2d\u521b\u5efa\u51fd\u6570 createGraphicsPipeline \u5e76\u5728 createImageViews \u540e\u7acb\u5373\u8c03\u7528\u3002\u6211\u4eec\u5728\u4e0b\u4e00\u7ae0\u8282\u4ecb\u7ecd\u51fd\u6570\u529f\u80fd\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createGraphicsPipeline(); } ... void createGraphicsPipeline() { } C++ \u5728\u7ed3\u5c3e\u5904\u5206\u4eab\u4e00\u4e0b Vulkan \u5b98\u65b9\u7684\u56fe\u5f62\u7ba1\u7ebf\u7ed3\u6784\u56fe\uff0c\u5982\u4e0b:","title":"Vulkan \u56fe\u5f62\u7ba1\u7ebf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_6","text":"Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe \uff0c\u4f7f\u7528\u4efb\u4f55\u7684 VkImage \uff0c\u5305\u62ec\u5728\u4ea4\u6362\u94fe\u6216\u8005\u6e32\u67d3\u7ba1\u7ebf\u4e2d\u7684\uff0c\u6211\u4eec\u90fd\u9700\u8981\u521b\u5efa VkImageView \u5bf9\u8c61\u3002\u4ece\u5b57\u9762\u4e0a\u7406\u89e3\u5b83\u5c31\u662f\u4e00\u4e2a\u9488\u5bf9\u56fe\u50cf\u7684\u89c6\u56fe\u6216\u5bb9\u5668\uff0c\u901a\u8fc7\u5b83\u5177\u4f53\u7684\u6e32\u67d3\u7ba1\u7ebf\u624d\u80fd\u591f\u8bfb\u5199\u6e32\u67d3\u6570\u636e\uff0c\u6362\u53e5\u8bdd\u8bf4 VkImage \u4e0d\u80fd\u4e0e\u6e32\u67d3\u7ba1\u7ebf\u8fdb\u884c\u4ea4\u4e92\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u56fe\u50cf\u89c6\u56fe\u53ef\u4ee5\u8fdb\u4e00\u6b65\u5b9a\u4e49\u5177\u4f53 Image \u7684\u683c\u5f0f\uff0c\u6bd4\u5982\u5b9a\u4e49\u4e3a2D\u8d34\u56fe\uff0c\u90a3\u4e48\u672c\u8d28\u4e0a\u5c31\u4e0d\u9700\u8981\u4efb\u4f55\u7ea7\u522b\u7684 mipmapping \u3002 \u5728\u672c\u7ae0\u8282\u6211\u4eec\u4f1a\u65b0\u589e\u4e00\u4e2a createImageViews \u51fd\u6570\uff0c\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u521b\u5efa\u57fa\u672c\u7684\u89c6\u56fe\uff0c\u8fd9\u4e9b\u89c6\u56fe\u5728\u540e\u9762\u7684\u5185\u5bb9\u4e2d\u4f1a\u88ab\u4f5c\u4e3a\u989c\u8272\u76ee\u6807\u4e0e\u6e32\u67d3\u7ba1\u7ebf\u914d\u5408\u4f7f\u7528\u3002 \u9996\u5148\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u7528\u4e8e\u4fdd\u5b58\u56fe\u50cf\u89c6\u56fe\u7684\u53e5\u67c4\u96c6: std::vector<VkImageView> swapChainImageViews; C++ \u521b\u5efa createImagesViews \u51fd\u6570\uff0c\u5e76\u5728\u521b\u5efa\u4ea4\u6362\u94fe\u5b8c\u6210\u4e4b\u540e\u8c03\u7528: void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); } void createImageViews() { } C++ \u6211\u4eec\u9700\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u9700\u8981\u5b9a\u4e49\u4fdd\u5b58\u56fe\u50cf\u89c6\u56fe\u96c6\u5408\u7684\u5927\u5c0f: void createImageViews() { swapChainImageViews.resize(swapChainImages.size()); } C++ \u4e0b\u4e00\u6b65\uff0c\u5faa\u73af\u8fed\u4ee3\u6240\u6709\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u3002 for (size_t i = 0; i < swapChainImages.size(); i++) { } C++ \u521b\u5efa\u56fe\u50cf\u89c6\u56fe\u7684\u53c2\u6570\u88ab\u5b9a\u4e49\u5728 VkImageViewCreateInfo \u7ed3\u6784\u4f53\u4e2d\u3002\u524d\u51e0\u4e2a\u53c2\u6570\u7684\u586b\u5145\u975e\u5e38\u7b80\u5355\u3001\u76f4\u63a5\u3002 VkImageViewCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; createInfo.image = swapChainImages[i]; C++ \u5176\u4e2d viewType \u548c format \u5b57\u6bb5\u7528\u4e8e\u63cf\u8ff0\u56fe\u50cf\u6570\u636e\u8be5\u88ab\u5982\u4f55\u89e3\u91ca\u3002 viewType \u53c2\u6570\u5141\u8bb8\u5c06\u56fe\u50cf\u5b9a\u4e49\u4e3a 1D textures , 2D textures , 3D textures \u548c cube maps \u3002 createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; createInfo.format = swapChainImageFormat; C++ components \u5b57\u6bb5\u5141\u8bb8\u8c03\u6574\u989c\u8272\u901a\u9053\u7684\u6700\u7ec8\u7684\u6620\u5c04\u903b\u8f91\u3002\u6bd4\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6240\u6709\u989c\u8272\u901a\u9053\u6620\u5c04\u4e3a\u7ea2\u8272\u901a\u9053\uff0c\u4ee5\u5b9e\u73b0\u5355\u8272\u7eb9\u7406\u3002\u6211\u4eec\u4e5f\u53ef\u4ee5\u5c06\u901a\u9053\u6620\u5c04\u5177\u4f53\u7684\u5e38\u91cf\u6570\u503c 0 \u548c 1 \u3002\u5728\u7ae0\u8282\u4e2d\u6211\u4eec\u4f7f\u7528\u9ed8\u8ba4\u7684\u6620\u5c04\u7b56\u7565\u3002 createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY; C++ subresourceRangle \u5b57\u6bb5\u7528\u4e8e\u63cf\u8ff0\u56fe\u50cf\u7684\u4f7f\u7528\u76ee\u6807\u662f\u4ec0\u4e48\uff0c\u4ee5\u53ca\u53ef\u4ee5\u88ab\u8bbf\u95ee\u7684\u6709\u6548\u533a\u57df\u3002\u6211\u4eec\u7684\u56fe\u50cf\u5c06\u4f1a\u4f5c\u4e3a color targets \uff0c\u6ca1\u6709\u4efb\u4f55 mipmapping levels \u6216\u662f\u591a\u5c42 multiple layers \u3002 createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; createInfo.subresourceRange.baseMipLevel = 0; createInfo.subresourceRange.levelCount = 1; createInfo.subresourceRange.baseArrayLayer = 0; createInfo.subresourceRange.layerCount = 1; C++ \u5982\u679c\u5728\u7f16\u5199\u6c89\u6d78\u5f0f\u7684 3D \u5e94\u7528\u7a0b\u5e8f\uff0c\u6bd4\u5982 VR \uff0c\u5c31\u9700\u8981\u521b\u5efa\u652f\u6301\u591a\u5c42\u7684\u4ea4\u6362\u94fe\u3002\u5e76\u4e14\u901a\u8fc7\u4e0d\u540c\u7684\u5c42\u4e3a\u6bcf\u4e00\u4e2a\u56fe\u50cf\u521b\u5efa\u591a\u4e2a\u89c6\u56fe\uff0c\u4ee5\u6ee1\u8db3\u4e0d\u540c\u5c42\u7684\u56fe\u50cf\u5728\u5de6\u53f3\u773c\u6e32\u67d3\u65f6\u5bf9\u89c6\u56fe\u7684\u9700\u8981\u3002 \u521b\u5efa\u56fe\u50cf\u89c6\u56fe\u8c03\u7528 vkCreateImageView \u51fd\u6570: if (vkCreateImageView(device, &createInfo, nullptr, &swapChainImageViews[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to create image views!\"); } C++ \u4e0e\u56fe\u50cf\u4e0d\u540c\u7684\u662f\uff0c\u56fe\u50cf\u89c6\u56fe\u9700\u8981\u660e\u786e\u7684\u521b\u5efa\u8fc7\u7a0b\uff0c\u6240\u4ee5\u5728\u7a0b\u5e8f\u9000\u51fa\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a\u5faa\u73af\u53bb\u9500\u6bc1\u4ed6\u4eec\u3002 void cleanup() { for (size_t i = 0; i < swapChainImageViews.size(); i++) { vkDestroyImageView(device, swapChainImageViews[i], nullptr); } ... } C++ \u62e5\u6709\u4e86\u56fe\u50cf\u89c6\u56fe\u540e\uff0c\u4f7f\u7528\u56fe\u50cf\u4f5c\u4e3a\u8d34\u56fe\u5df2\u7ecf\u8db3\u591f\u4e86\uff0c\u4f46\u662f\u5b83\u8fd8\u6ca1\u6709\u51c6\u5907\u597d\u4f5c\u4e3a\u6e32\u67d3\u7684 target \u3002\u5b83\u9700\u8981\u66f4\u591a\u7684\u95f4\u63a5\u6b65\u9aa4\u53bb\u51c6\u5907\uff0c\u5176\u4e2d\u4e00\u4e2a\u5c31\u662f framebuffer \uff0c\u88ab\u79f0\u4f5c\u5e27\u7f13\u51b2\u533a\u3002\u4f46\u9996\u5148\u6211\u4eec\u8981\u8bbe\u7f6e\u56fe\u5f62\u7ba1\u7ebf\u3002","title":"Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_7","text":"Vulkan \u7740\u8272\u5668\u6a21\u5757 \uff0c\u4e0e\u4e4b\u524d\u7684\u56fe\u50cf API \u4e0d\u540c\uff0c Vulkan \u4e2d\u7684\u7740\u8272\u5668\u4ee3\u7801\u5fc5\u987b\u4ee5\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u7684\u683c\u5f0f\u4f7f\u7528\uff0c\u800c\u4e0d\u662f\u50cf GLSL \u548c HLSL \u8fd9\u6837\u5177\u6709\u6bd4\u8f83\u597d\u7684\u53ef\u8bfb\u6027\u7684\u8bed\u6cd5\u3002\u6b64\u5b57\u8282\u683c\u5f0f\u6210\u4e3a SPIR-V \uff0c\u5b83\u53ef\u4ee5\u4e0e Vulkan \u548c OpenCL \u4e00\u540c\u4f7f\u7528\u3002\u8fd9\u662f\u4e00\u79cd\u53ef\u4ee5\u7f16\u5199\u56fe\u5f62\u548c\u8ba1\u7b97\u7740\u8272\u5668\u7684\u683c\u5f0f\uff0c\u4f46\u6211\u4eec\u91cd\u70b9\u4ecb\u7ecd\u672c\u6559\u7a0b\u4e2d Vulkan \u56fe\u5f62\u6d41\u6c34\u7ebf\u4f7f\u7528\u7684\u7740\u8272\u5668\u3002 \u4f7f\u7528\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u683c\u5f0f\u7684\u4f18\u70b9\u4e4b\u4e00\u662f \u4f7f\u5f97 GPU \u5382\u5546\u7f16\u5199\u5c06\u7740\u8272\u5668\u4ee3\u7801\u8f6c\u6362\u4e3a\u672c\u5730\u4ee3\u7801\u7684\u7f16\u8bd1\u5668\u590d\u6742\u5ea6\u51cf\u5c11\u4e86\u5f88\u591a\u3002\u7ecf\u9a8c\u8868\u660e\u4f7f\u7528\u53ef\u8bfb\u6027\u6bd4\u8f83\u5f3a\u7684\u8bed\u6cd5\uff0c\u6bd4\u5982 GLSL \u4e00\u4e9b GPU \u5382\u5546\u76f8\u5f53\u7075\u6d3b\u5730\u7406\u89e3\u8fd9\u4e2a\u6807\u51c6\u3002\u8fd9\u5bfc\u81f4\u4e00\u79cd\u60c5\u51b5\u4f1a\u53d1\u751f\uff0c\u6bd4\u5982\u7f16\u5199\u597d\uff0c\u5e76\u5728\u4e00\u4e2a\u5382\u5546\u7684 GPU \u8fd0\u884c\u7684\u4e0d\u9519\u7684\u7740\u8272\u5668\u7a0b\u5e8f\uff0c\u53ef\u80fd\u5728\u5176\u4ed6\u7684 GPU \u5382\u5546\u7684 GPU \u9a71\u52a8\u7a0b\u5e8f\u8fd0\u884c\u5f02\u5e38\uff0c\u53ef\u80fd\u662f\u8bed\u6cd5\u7684\u95ee\u9898\uff0c\u6216\u8005\u66f4\u7cdf\u7684\u662f\u4e0d\u540c GPU \u5382\u5546\u7f16\u5199\u7684\u7f16\u8bd1\u5668\u5dee\u5f02\uff0c\u5bfc\u81f4\u7740\u8272\u5668\u8fd0\u884c\u9519\u8bef\u3002\u5982\u679c\u76f4\u63a5\u4f7f\u7528\u7f16\u8bd1\u597d\u7684\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u683c\u5f0f\uff0c\u53ef\u4ee5\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\u3002 \u4f46\u662f\uff0c\u5e76\u4e0d\u610f\u5473\u7740\u6211\u4eec\u8981\u624b\u5199\u5b57\u8282\u7801\u3002 Khronos \u53d1\u5e03\u4e86\u4e0e\u5382\u5546\u65e0\u5173\u7684\u7f16\u8bd1\u5668\uff0c\u5b83\u5c06 GLSL \u7f16\u8bd1\u6210 SPIR-V \u3002\u8be5\u7f16\u8bd1\u5668\u7528\u4e8e\u9a8c\u8bc1\u7740\u8272\u5668\u4ee3\u7801\u662f\u5426\u7b26\u5408\u6807\u51c6\uff0c\u5e76\u751f\u6210\u4e0e Vulkan \u529f\u80fd\u8fd0\u884c\u7684 SPRIR-V \u4e8c\u8fdb\u5236\u6587\u4ef6\u3002\u9664\u6b64\u4e4b\u5916\u8fd8\u53ef\u4ee5\u5c06\u6b64\u7f16\u8bd1\u5668\u4f5c\u4e3a\u5e93\u5728\u8fd0\u884c\u65f6\u7f16\u8bd1\u751f\u6210 SPRI-V \uff0c\u4f46\u5728\u672c\u6559\u7a0b\u4e2d\u4e0d\u4f1a\u8fd9\u6837\u64cd\u4f5c\u3002\u7f16\u8bd1\u5668 glslangValidator.exe \u5305\u542b\u5728 LunarG SDK \u4e2d\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u4e0b\u8f7d\u4efb\u4f55\u989d\u5916\u7684\u5185\u5bb9\u3002 GLSL \u662f\u5177\u6709C\u98ce\u683c\u8bed\u6cd5\u7684\u7740\u8272\u8bed\u8a00\u3002\u5728\u7a0b\u5e8f\u4e2d\u9700\u8981\u5b9a\u4e49\u7f16\u5199 main \u51fd\u6570\u4f5c\u4e3a\u5165\u53e3\u3002 GLSL \u4e0d\u4f1a\u4f7f\u7528\u8f93\u5165\u53c2\u6570\u548c\u8fd4\u56de\u503c\u4f5c\u4e3a\u8f93\u51fa\uff0c\u800c\u662f\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\u6765\u5904\u7406\u8f93\u5165\u548c\u8f93\u51fa\u3002\u8be5\u8bed\u8a00\u5305\u62ec\u5f88\u591a\u529f\u80fd\u7b80\u5316\u56fe\u5f62\u7f16\u7a0b\uff0c\u6bd4\u5982\u5185\u7f6e\u7684\u57fa\u4e8e\u5411\u91cf\u548c\u77e9\u9635\u7684\u53c9\u79ef\u64cd\u4f5c\u51fd\u6570\uff0c\u77e9\u9635\u548c\u77e2\u91cf\u4e58\u6cd5\u64cd\u4f5c\u51fd\u6570\u3002\u77e2\u91cf\u7c7b\u578b\u4e3a vec \uff0c\u6570\u5b57\u8868\u793a\u5206\u91cf\u7684\u6570\u91cf\u3002\u4f8b\u59823D\u4f4d\u7f6e\u5b58\u50a8\u5728 vec3 \u4e2d\u3002\u53ef\u4ee5\u901a\u8fc7\u8bf8\u5982 .x \u4e4b\u7c7b\u7684\u6210\u5458\u8bbf\u95ee\u5355\u4e2a\u5206\u91cf\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u591a\u4e2a\u5206\u91cf\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5411\u91cf\u3002\u6bd4\u5982\uff0c\u8868\u8fbe\u5f0f vec3(1.0, 2.0, 3.0).xy \u622a\u53d6\u524d\u4e24\u4e2a\u5206\u91cf\uff0c\u5e76\u8d4b\u4e88\u65b0\u7684 vec2 \u4e2d\u3002\u5411\u91cf\u7684\u6784\u9020\u51fd\u6570\u4e5f\u53ef\u4ee5\u91c7\u7528\u77e2\u91cf\u5bf9\u8c61\u548c\u6807\u91cf\u503c\u7684\u7ec4\u5408\u3002\u6bd4\u5982 vec3 \u53ef\u4ee5\u7528 vec3(vec2(1.0, 2.0), 3.0) \u6784\u9020\u3002 \u5982\u524d\u9762\u63d0\u5230\u7684\u4e00\u6837\uff0c\u6211\u4eec\u9700\u8981\u7f16\u5199\u4e00\u4e2a vertex shader \u548c\u4e00\u4e2a fragment shader \u7ed8\u5236\u4e09\u89d2\u5f62\u5728\u5c4f\u5e55\u3002\u4e0b\u9762\u4e24\u4e2a\u5c0f\u8282\u4f1a\u63a2\u8ba8\u4e0e\u4e4b\u76f8\u5173\u7684 GLSL \u4ee3\u7801\uff0c\u5e76\u5c55\u793a\u5982\u4f55\u751f\u6210\u4e24\u4e2a SPIR-V \u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u6700\u540e\u52a0\u8f7d\u5230\u7a0b\u5e8f\u4e2d\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9876\u70b9\u7740\u8272\u5668 2 \u7247\u5143\u7740\u8272\u5668 3 \u9876\u70b9\u989c\u8272\u7ec4 4 \u7f16\u8bd1\u7740\u8272\u5668 5 \u52a0\u8f7d\u7740\u8272\u5668 6 \u521b\u5efa\u7740\u8272\u5668\u6a21\u578b 7 \u7740\u8272\u5668\u9636\u6bb5\u521b\u5efa","title":"Vulkan \u7740\u8272\u5668\u6a21\u5757"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_23","text":"\u9876\u70b9\u7740\u8272\u5668\u5904\u7406\u6bcf\u4e00\u4e2a\u9876\u70b9\u6570\u636e\u3002\u5b83\u7684\u5c5e\u6027\uff0c\u5982\u4e16\u754c\u5750\u6807\uff0c\u989c\u8272\uff0c\u6cd5\u7ebf\u548c\u7eb9\u7406UV\u5750\u6807\u4f5c\u4e3a\u8f93\u5165\u3002\u8f93\u51fa\u7684\u662f\u6700\u7ec8\u7684clip coordinates \u88c1\u526a\u5750\u6807\u548c\u9700\u8981\u4f20\u9012\u5230\u7247\u5143\u7740\u8272\u5668\u7684\u5c5e\u6027\uff0c\u5305\u62ec\u989c\u8272\u548c\u7eb9\u7406UV\u5750\u6807\u3002\u8fd9\u4e9b\u503c\u4f1a\u5728\u5149\u6805\u5316\u9636\u6bb5\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u4ee5\u4ea7\u751f\u5e73\u6ed1\u7684\u8fc7\u5ea6\u3002 \u88c1\u526a\u5750\u6807 clip coordinate \u662f\u4e00\u4e2a\u6765\u6b64\u9876\u70b9\u7740\u8272\u5668\u7684\u601d\u7ef4\u5411\u91cf\uff0c\u968f\u540e\u901a\u8fc7\u77e2\u91cf\u6700\u540e\u4e00\u4e2a\u5206\u91cf\u8fdb\u884c\u6574\u4f53\u5f52\u4e00\u5316\u64cd\u4f5c\u3002\u8fd9\u4e9b\u5f52\u4e00\u5316\u540e\u7684\u8bbe\u5907\u5750\u6807\u662f homogeneous coordinates ****\u6700\u7ec8\u6620\u5c04\u5230\u7f13\u51b2\u533a\u8303\u56f4\u4e3a [-1, 1] \u7684 [-1, 1] \u5750\u6807\u7cfb\u7edf\uff0c\u5982\u4e0b\u6240\u793a: \u5982\u679c\u4e4b\u524d\u7684\u8ba1\u7b97\u673a\u56fe\u5f62\u6bd4\u8f83\u719f\u6089\u7684\u8bdd\uff0c\u5bf9\u8fd9\u90e8\u5206\u4f1a\u6bd4\u8f83\u719f\u6089\u3002\u5982\u679c\u4f60\u4e4b\u524d\u4f7f\u7528\u8fc7 OpenGL \uff0c\u4f60\u4f1a\u6ce8\u610f\u5230Y\u5750\u6807\u8f74\u662f\u53cd\u8f6c\u7684\uff0cZ\u5750\u6807\u8f74\u7684\u8303\u56f4\u4e0e Direct3D \u662f\u4e00\u81f4\u7684\u8303\u56f4\uff0c\u4ece0\u52301. \u5bf9\u4e8e\u7b2c\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u6211\u4eec\u4e0d\u4f1a\u505a\u4efb\u4f55\u8f6c\u6362\u64cd\u4f5c\uff0c\u6211\u4eec\u5c06\u4e09\u4e2a\u9876\u70b9\u7684\u4f4d\u7f6e\u6307\u5b9a\u4e3a\u5f52\u4e00\u5316\u8bbe\u5907\u5750\u6807\uff0c\u521b\u5efa\u5982\u4e0b\u56fe\u5f62: \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5c06\u5176\u8f93\u51fa\u4e3a\u88c1\u526a\u5750\u6807\u76f4\u63a5\u8f93\u51fa\u5f52\u4e00\u5316\u7684\u8bbe\u5907\u5750\u6807\uff0c\u9876\u70b9\u7740\u8272\u5668\u7684\u5750\u6807\u4e0e\u6700\u540e\u4e00\u4e2a\u5206\u91cf\u8bbe\u7f6e\u4e3a 1 \u3002\u5c06\u88c1\u526a\u5750\u6807\u8f6c\u6362\u4e3a\u5f52\u4e00\u5316\u7684\u8bbe\u5907\u5750\u6807\u6ca1\u6709\u6539\u53d8\u4efb\u4f55\u4e1c\u897f\u3002 \u901a\u5e38\u60c5\u51b5\u4e0b\u9876\u70b9\u5750\u6807\u6570\u636e\u662f\u5b58\u50a8\u5728\u4e00\u4e2a\u9876\u70b9\u7f13\u51b2\u533a\u4e2d\uff0c\u4f46\u662f\u5728 Vulkan \u4e2d\u521b\u5efa\u4e00\u4e2a\u9876\u70b9\u7f13\u51b2\u533a\u5e76\u586b\u5145\u6570\u636e\u7684\u8fc7\u7a0b\u5e76\u4e0d\u662f\u76f4\u63a5\u7684\u3002\u6240\u4ee5\u6211\u4eec\u540e\u7f6e\u8fd9\u4e9b\u6b65\u9aa4\uff0c\u76f4\u5230\u6211\u4eec\u6ee1\u610f\u7684\u770b\u5230\u4e00\u4e2a\u4e09\u89d2\u5f62\u51fa\u73b0\u5728\u5c4f\u5e55\u4e0a\u3002\u540c\u65f6\u6211\u4eec\u9700\u8981\u505a\u4e00\u4e9b\u975e\u6b63\u7edf\u7684\u4e8b\u60c5:\u5c06\u5750\u6807\u76f4\u63a5\u5305\u542b\u5728\u9876\u70b9\u7740\u8272\u5668\u7684\u5185\u90e8\u3002\u4ee3\u7801\u5982\u4e0b\u6240\u793a: #version 450 #extension GL_ARB_separate_shader_objects : enable out gl_PerVertex { vec4 gl_Position; }; vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); } C++ main \u51fd\u6570\u7684\u6267\u884c\u5e94\u7528\u4e8e\u6bcf\u4e2a\u9876\u70b9\uff0c\u5185\u7f6e\u7684 gl_VertexIndex \u53d8\u91cf\u5305\u542b\u4e86\u5f53\u524d\u9876\u70b9\u7684\u7d22\u5f15\u4fe1\u606f\u3002\u901a\u5e38\u662f\u9876\u70b9\u7f13\u51b2\u533a\u7684\u7d22\u5f15\uff0c\u4f46\u662f\u5728\u8fd9\u91cc\u6211\u4eec\u786c\u7f16\u7801\u5230\u9876\u70b9\u6570\u636e\u7684\u96c6\u5408\u4e2d\u3002\u6bcf\u4e2a\u9876\u70b9\u7684\u4f4d\u7f6e\u4ece\u5e38\u91cf\u6570\u7ec4\u4e2d\u8bbf\u95ee\uff0c\u5e76\u4e0e z \u548c w \u5206\u91cf\u7ec4\u5408\u4f7f\u7528\uff0c\u4ee5\u4ea7\u751f\u88c1\u526a\u5750\u6807\u4e2d\u7684\u6709\u6548\u4f4d\u7f6e\u4fe1\u606f\u3002\u5185\u7f6e\u7684 gl_Position \u53d8\u91cf\u4f5c\u4e3a\u8f93\u51fa\u3002\u6700\u540eVulkan\u4e2d\u4f7f\u7528shader\uff0c\u9700\u8981\u786e\u4fdd GL_ARG_separate_shader_objects \u6269\u5c55\u5f00\u542f\u3002","title":"\u9876\u70b9\u7740\u8272\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_24","text":"\u7531\u9876\u70b9\u7740\u8272\u5668\u7684\u4f4d\u7f6e\u6570\u636e\u5f62\u6210\u7684\u4e09\u89d2\u5f62\u7528\u7247\u6bb5\u7740\u8272\u5668\u586b\u5145\u5c4f\u5e55\u4e0a\u7684\u533a\u57df\u4e2d\u3002\u7247\u6bb5\u7740\u8272\u5668\u9488\u5bf9\u4e00\u4e2a\u6216\u8005\u591a\u4e2aframebuffer\u5e27\u7f13\u51b2\u533a\u7684\u6bcf\u4e2a\u7247\u5143\u4ea7\u751f\u5177\u4f53\u7684\u989c\u8272\u548c\u6df1\u5ea6\u4fe1\u606f\u3002\u4e00\u4e2a\u7b80\u5355\u7684\u7247\u6bb5\u7740\u8272\u5668\u4e3a\u5b8c\u6210\u7684\u4e09\u89d2\u5f62\u8f93\u51fa\u7ea2\u8272\u4fe1\u606f\u7684\u4ee3\u7801\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable layout(location = 0) out vec4 outColor; void main() { outColor = vec4(1.0, 0.0, 0.0, 1.0); } C++ fragment sahder\u4e2d\u7684 main \u51fd\u6570\u4e0e vertex shader \u4e2d\u7684 main \u51fd\u6570\u7c7b\u4f3c\uff0c\u4f1a\u4e3a\u6bcf\u4e00\u4e2a\u7247\u5143\u8c03\u7528\u5904\u7406\u3002\u989c\u8272\u7684\u4fe1\u606f\u5728GLSL\u4e2d\u662f4\u4e2a\u5206\u91cf\u7ec4\u6210\u7684\u77e2\u91cf\uff0c\u5305\u62ecR,G,B\u548cAlpha\u901a\u9053\uff0c\u503c\u57df\u6536\u655b\u5728[0, 1]\u8303\u56f4\u5185\u3002\u4e0d\u50cf\u9876\u70b9\u7740\u8272\u5668\u7684 gl_Position \uff0c\u5b83\u6ca1\u6709\u5185\u7f6e\u7684\u53d8\u91cf\u4e3a\u5f53\u524d\u7247\u5143\u8f93\u51fa\u989c\u8272\u4fe1\u606f\u3002\u5728\u8fd9\u91cc\u5fc5\u987b\u4e3aframebuffer\u5b9a\u4e49\u8f93\u51fa\u53d8\u91cf\uff0c layout(location = 0) \u4fee\u9970\u7b26\u660e\u786eframebuffer\u7684\u7d22\u5f15\u3002\u7ea2\u8272\u4fe1\u606f\u5199\u8fdb outColor \u53d8\u91cf\u4e2d\uff0c\u8be5\u53d8\u91cf\u94fe\u63a5\u7b2c\u4e00\u4e2aframebuffer\u4e2d\uff0c\u7d22\u5f15\u4e3a 0 \u3002","title":"\u7247\u5143\u7740\u8272\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_25","text":"\u4e00\u4e2a\u7eaf\u7ea2\u8272\u7684\u4e09\u89d2\u5f62\u770b\u8d77\u6765\u5e76\u4e0d\u662f\u5f88\u9177\u70ab\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u8bd5\u7740\u9177\u70ab\u4e00\u4e9b\u5462? \u6211\u4eec\u9488\u5bf9\u4e24\u4e2a\u7c7b\u578b\u7684\u7740\u8272\u5668\u5c1d\u8bd5\u505a\u4e00\u4e9b\u6539\u53d8\uff0c\u5b8c\u6210\u4e0a\u56fe\u7684\u6548\u679c\u3002\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u6bcf\u4e2a\u9876\u70b9\u8bbe\u7f6e\u5dee\u5f02\u5316\u7684\u989c\u8272\u3002\u9876\u70b9\u7740\u8272\u5668\u5e94\u8be5\u5305\u542b\u4e00\u4e2a\u989c\u8272\u6570\u7ec4\uff0c\u5c31\u50cf\u4f4d\u7f6e\u4fe1\u606f\u7684\u6570\u7ec4\u4e00\u6837: vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) ); C++ \u73b0\u5728\u6211\u4eec\u9700\u8981\u628a\u6bcf\u4e2a\u9876\u70b9\u7684\u989c\u8272\u4f20\u9012\u5230\u7247\u6bb5\u7740\u8272\u5668\u4e2d\uff0c\u4ece\u800c\u8f93\u51fa\u7ecf\u8fc7\u63d2\u503c\u540e\u7684\u989c\u8272\u4fe1\u606f\u5230 framebuffer \u4e2d\u3002\u4e3a\u9876\u70b9\u7740\u8272\u5668\u6dfb\u589e\u52a0\u8f93\u51fa\u989c\u8272\u652f\u6301\uff0c\u5728 main \u51fd\u6570\u4e2d\u5b9a\u4e49\u5982\u4e0b: layout(location = 0) out vec3 fragColor; void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex]; } C++ \u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u9700\u8981\u5c06\u7247\u6bb5\u7740\u8272\u5668\u7684\u8f93\u5165\u5339\u914d\u9876\u70b9\u7740\u8272\u5668\u7684\u8f93\u51fa: layout(location = 0) in vec3 fragColor; void main() { outColor = vec4(fragColor, 1.0); } C++ \u8f93\u5165\u7684\u53d8\u91cf\u4e0d\u4e00\u5b9a\u8981\u540c\u540d\uff0c\u5b83\u4eec\u5c06\u901a\u8fc7 location \u7d22\u5f15\u6307\u4ee4\u94fe\u63a5\u5728\u4e00\u8d77\u3002 main \u51fd\u6570\u4e2d\u4fee\u6539\u5c06\u8981\u8f93\u51fa\u7684\u989c\u8272alpha\u503c\u3002\u5c31\u50cf\u4e4b\u524d\u8ba8\u8bba\u7684\u4e00\u6837\uff0c fragColor \u5c06\u4f1a\u4e3a\u4e09\u4e2a\u9876\u70b9\u6240\u5c5e\u7684\u7247\u5143\u81ea\u52a8\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u5f62\u6210\u5e73\u6ed1\u7684\u989c\u8272\u8fc7\u5ea6\u3002","title":"\u9876\u70b9\u989c\u8272\u7ec4"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_26","text":"\u5728\u9879\u76ee\u6839\u76ee\u5f55\u4e0b\u521b\u5efa\u4e00\u4e2a\u5b50\u76ee\u5f55\uff0c\u540d shaders \u7528\u4e8e\u5b58\u50a8\u9876\u70b9\u7740\u8272\u5668\u6587\u4ef6 shader.vert \u548c\u7247\u6bb5\u7740\u8272\u5668\u6587\u4ef6 shader.frag \u3002GLSL\u7740\u8272\u5668\u5b98\u65b9\u6ca1\u6709\u7ea6\u5b9a\u7684\u6269\u5c55\u540d\uff0c\u4f46\u662f\u8fd9\u4e24\u4e2a\u6269\u5c55\u540d\u662f\u6bd4\u8f83\u666e\u904d\u901a\u7528\u7684\u3002 shader.vert \u5185\u5bb9\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable out gl_PerVertex { vec4 gl_Position; }; layout(location = 0) out vec3 fragColor; vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex]; } C++ shader.frag \u6587\u4ef6\u5185\u5bb9\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable layout(location = 0) in vec3 fragColor; layout(location = 0) out vec4 outColor; void main() { outColor = vec4(fragColor, 1.0); } C++ \u73b0\u5728\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 glslangValidator \u7a0b\u5e8f\u7f16\u8bd1SPIR-V\u4e8c\u8fdb\u5236\u7801\u3002 \u521b\u5efa\u4e00\u4e2acompile.bat\u6279\u5904\u7406\u6587\u4ef6\uff0c\u5185\u5bb9\u5982\u4e0b: C:/VulkanSDK/1.0.17.0/Bin32/glslangValidator.exe -V shader.vert C:/VulkanSDK/1.0.17.0/Bin32/glslangValidator.exe -V shader.frag pause C++ \u5c06 glslangValidator.exe \u7684path\u8def\u5f84\u66ff\u6362\u4e3a\u4f60\u7684VulkanSDK\u5b89\u88c5\u8def\u5f84\uff0c\u7136\u540e\u53cc\u51fb\u8be5\u6587\u4ef6\u8fd0\u884c\u3002 \u8fd9\u4e24\u4e2a\u547d\u4ee4\u4f7f\u7528 -V \u6807\u5fd7\u8c03\u7528\u7f16\u8bd1\u5668\uff0c\u8be5\u6807\u5fd7\u544a\u8bc9\u5b83\u5c06GLSL\u6e90\u6587\u4ef6\u7f16\u8bd1\u4e3aSPIR-V\u5b57\u8282\u7801\u3002\u8fd0\u884c\u7f16\u8bd1\u811a\u672c\u65f6\uff0c\u4f1a\u770b\u5230\u521b\u5efa\u4e86\u4e24\u4e2aSPIR-V\u4e8c\u8fdb\u5236\u6587\u4ef6: vert.spv \u548c frag.spv \u3002\u8fd9\u4e9b\u540d\u79f0\u4ece\u7740\u8272\u5668\u4e2d\u6d3e\u751f\u800c\u6765\uff0c\u4f46\u662f\u53ef\u4ee5\u91cd\u547d\u540d\u4e3a\u4efb\u4f55\u540d\u5b57\u3002\u5728\u7f16\u8bd1\u7740\u8272\u5668\u65f6\uff0c\u53ef\u80fd\u6536\u5230\u5173\u4e8e\u67d0\u4e9b\u529f\u80fd\u7f3a\u5931\u7684\u8b66\u544a\u4fe1\u606f\uff0c\u5728\u8fd9\u91cc\u653e\u5fc3\u7684\u5ffd\u7565\u5b83\u4eec\u3002 \u5982\u679c\u7740\u8272\u5668\u5305\u542b\u8bed\u6cd5\u9519\u8bef\uff0c\u90a3\u4e48\u7f16\u8bd1\u5668\u4f1a\u6309\u7167\u60a8\u7684\u9884\u671f\u544a\u8bc9\u5177\u4f53\u7684\u884c\u53f7\u548c\u95ee\u9898\u3002\u5c1d\u8bd5\u7701\u7565\u4e00\u4e2a\u5206\u53f7\uff0c\u7136\u540e\u91cd\u65b0\u8fd0\u884c\u7f16\u8bd1\u811a\u672c\u3002\u8fd8\u53ef\u4ee5\u5c1d\u8bd5\u8fd0\u884c\u7f16\u8bd1\u5668\uff0c\u800c\u65e0\u9700\u4efb\u4f55\u53c2\u6570\u6765\u67e5\u770b\u5b83\u652f\u6301\u54ea\u4e9b\u7c7b\u578b\u7684\u6807\u5fd7\u3002\u4f8b\u5982\uff0c\u5b83\u53ef\u4ee5\u5c06\u5b57\u8282\u7801\u8f93\u51fa\u4e3a\u53ef\u8bfb\u7684\u683c\u5f0f\uff0c\u4ee5\u4fbf\u51c6\u786e\u4e86\u89e3\u7740\u8272\u5668\u6b63\u5728\u6267\u884c\u7684\u64cd\u4f5c\u4ee5\u53ca\u5728\u6b64\u9636\u6bb5\u5e94\u7528\u7684\u4efb\u4f55\u4f18\u5316\u3002","title":"\u7f16\u8bd1\u7740\u8272\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_27","text":"\u73b0\u5728\u6211\u4eec\u6709\u4e00\u79cd\u4ea7\u751fSPIR-V\u7740\u8272\u5668\u7684\u65b9\u6cd5\uff0c\u662f\u65f6\u5019\u52a0\u8f7d\u5b83\u4eec\u5230\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\uff0c\u4ee5\u4fbf\u5728\u9002\u5f53\u7684\u65f6\u5019\u63d2\u5165\u5230\u56fe\u5f62\u7ba1\u7ebf\u4e2d\u3002\u9996\u5148\u6211\u4eec\u7f16\u5199\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\u7528\u4ee5\u52a0\u8f7d\u4e8c\u8fdb\u5236\u6570\u636e\u6587\u4ef6\u3002 #include <fstream> ... static std::vector<char> readFile(const std::string& filename) { std::ifstream file(filename, std::ios::ate | std::ios::binary); if (!file.is_open()) { throw std::runtime_error(\"failed to open file!\"); } } C++ readFile \u51fd\u6570\u5c06\u4f1a\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6240\u6709\u7684\u4e8c\u8fdb\u5236\u6570\u636e\uff0c\u5e76\u7528 std::vector \u5b57\u8282\u96c6\u5408\u7ba1\u7406\u3002\u6211\u4eec\u4f7f\u7528\u4e24\u4e2a\u6807\u5fd7\u7528\u4ee5\u6253\u5f00\u6587\u4ef6: ate :\u5728\u6587\u4ef6\u672b\u5c3e\u5f00\u59cb\u8bfb\u53d6 binary :\u4ee5\u4e8c\u8fdb\u5236\u683c\u5f0f\u53bb\u8bfb\u6587\u4ef6(\u907f\u514d\u5b57\u7b26\u683c\u5f0f\u7684\u8f6c\u4e49) \u4ece\u6587\u4ef6\u672b\u5c3e\u5f00\u59cb\u8bfb\u53d6\u7684\u4f18\u70b9\u662f\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u8bfb\u53d6\u4f4d\u7f6e\u6765\u786e\u5b9a\u6587\u4ef6\u7684\u5927\u5c0f\u5e76\u5206\u914d\u7f13\u51b2\u533a: size_t fileSize = (size_t) file.tellg(); std::vector<char> buffer(fileSize); C++ \u4e4b\u540e\u6211\u4eec\u53ef\u4ee5\u8ffd\u6eaf\u5230\u6587\u4ef6\u7684\u5f00\u5934\uff0c\u540c\u65f6\u8bfb\u53d6\u6240\u6709\u7684\u5b57\u8282: file.seekg(0); file.read(buffer.data(), fileSize); C++ \u6700\u540e\u5173\u95ed\u6587\u4ef6\uff0c\u8fd4\u56de\u5b57\u8282\u6570\u636e: file.close(); return buffer; C++ \u6211\u4eec\u8c03\u7528\u51fd\u6570createGraphicsPipeline\u52a0\u8f7d\u4e24\u4e2a\u7740\u8272\u5668\u7684\u4e8c\u8fdb\u5236\u7801: void createGraphicsPipeline() { auto vertShaderCode = readFile(\"shaders/vert.spv\"); auto fragShaderCode = readFile(\"shaders/frag.spv\"); } C++ \u786e\u4fdd\u7740\u8272\u5668\u6b63\u786e\u52a0\u8f7d\uff0c\u5e76\u6253\u5370\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u662f\u5426\u4e0e\u6587\u4ef6\u5b9e\u9645\u5927\u5c0f\u4e00\u81f4\u3002","title":"\u52a0\u8f7d\u7740\u8272\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_28","text":"\u5728\u5c06\u4ee3\u7801\u4f20\u9012\u7ed9\u6e32\u67d3\u7ba1\u7ebf\u4e4b\u524d\uff0c\u6211\u4eec\u5fc5\u987b\u5c06\u5176\u5c01\u88c5\u5230 VkShaderModule \u5bf9\u8c61\u4e2d\u3002\u8ba9\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570 createShaderModule \u5b9e\u73b0\u8be5\u903b\u8f91\u3002 VkShaderModule createShaderModule(const std::vector<char>& code) { } C++ \u8be5\u51fd\u6570\u9700\u8981\u5b57\u8282\u7801\u7684\u7f13\u51b2\u533a\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u901a\u8fc7\u7f13\u51b2\u533a\u521b\u5efa VkShaderModule \u3002 \u521b\u5efashader module\u662f\u6bd4\u8f83\u7b80\u5355\u7684\uff0c\u6211\u4eec\u4ec5\u4ec5\u9700\u8981\u6307\u5b9a\u4e8c\u8fdb\u5236\u7801\u7f13\u51b2\u533a\u7684\u6307\u9488\u548c\u5b83\u7684\u5177\u4f53\u957f\u5ea6\u3002\u8fd9\u4e9b\u4fe1\u606f\u88ab\u586b\u5145\u5728 VkShaderModuleCreateInfo \u7ed3\u6784\u4f53\u4e2d\u3002\u9700\u8981\u7559\u610f\u7684\u662f\u5b57\u8282\u7801\u7684\u5927\u5c0f\u662f\u4ee5\u5b57\u8282\u6307\u5b9a\u7684\uff0c\u4f46\u662f\u5b57\u8282\u7801\u6307\u9488\u662f\u4e00\u4e2a uint32_t \u7c7b\u578b\u7684\u6307\u9488\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a char \u6307\u9488\u3002\u6240\u4ee5\u6211\u4eec\u4f7f\u7528 reinterpret_cast \u8fdb\u884c\u8f6c\u6362\u6307\u9488\u3002\u5982\u4e0b\u6240\u793a\uff0c\u5f53\u9700\u8981\u8f6c\u6362\u65f6\uff0c\u8fd8\u9700\u8981\u786e\u4fdd\u6570\u636e\u6ee1\u8db3 uint32_t \u7684\u5bf9\u9f50\u8981\u6c42\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u6570\u636e\u5b58\u50a8\u5728 std::vector \u4e2d\uff0c\u9ed8\u8ba4\u5206\u914d\u5668\u5df2\u7ecf\u786e\u4fdd\u6570\u636e\u6ee1\u8db3\u6700\u5dee\u60c5\u51b5\u4e0b\u7684\u5bf9\u9f50\u8981\u6c42\u3002 VkShaderModuleCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; createInfo.codeSize = code.size(); createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data()); C++ \u8c03\u7528 vkCreateShaderMoudle \u521b\u5efa VkShaderModule : VkShaderModule shaderModule; if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) { throw std::runtime_error(\"failed to create shader module!\"); } C++ \u53c2\u6570\u4e0e\u4e4b\u524d\u521b\u5efa\u5bf9\u8c61\u529f\u80fd\u7c7b\u4f3c:\u903b\u8f91\u8bbe\u5907\uff0c\u521b\u5efa\u5bf9\u8c61\u4fe1\u606f\u7ed3\u6784\u4f53\u7684\u6307\u9488\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u4fdd\u5b58\u7ed3\u679c\u7684\u53e5\u67c4\u53d8\u91cf\u3002\u5728shader module\u521b\u5efa\u5b8c\u6bd5\u540e\uff0c\u53ef\u4ee5\u5bf9\u4e8c\u8fdb\u5236\u7801\u7684\u7f13\u51b2\u533a\u8fdb\u884c\u7acb\u5373\u7684\u91ca\u653e\u3002\u6700\u540e\u4e0d\u8981\u5fd8\u8bb0\u8fd4\u56de\u521b\u5efa\u597d\u7684shader module\u3002 return shaderModule; C++ shader module\u5bf9\u8c61\u4ec5\u4ec5\u5728\u6e32\u67d3\u7ba1\u7ebf\u5904\u7406\u8fc7\u7a0b\u4e2d\u9700\u8981\uff0c\u6240\u4ee5\u6211\u4eec\u4f1a\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u5b9a\u4e49\u672c\u5730\u53d8\u91cf\u4fdd\u5b58\u5b83\u4eec\uff0c\u800c\u4e0d\u662f\u5b9a\u4e49\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709\u5b83\u4eec\u7684\u53e5\u67c4: VkShaderModule vertShaderModule; VkShaderModule fragShaderModule; C++ \u8c03\u7528\u52a0\u8f7dshader module\u7684\u8f85\u52a9\u51fd\u6570: vertShaderModule = createShaderModule(vertShaderCode); fragShaderModule = createShaderModule(fragShaderCode); C++ \u5728\u56fe\u5f62\u7ba1\u7ebf\u521b\u5efa\u5b8c\u6210\u4e14 createGraphicsPipeline \u51fd\u6570\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u5b83\u4eec\u5e94\u8be5\u88ab\u6e05\u7406\u6389\uff0c\u6240\u4ee5\u5728\u8be5\u51fd\u6570\u540e\u5220\u9664\u5b83\u4eec: ... vkDestroyShaderModule(device, fragShaderModule, nullptr); vkDestroyShaderModule(device, vertShaderModule, nullptr); } C++","title":"\u521b\u5efa\u7740\u8272\u5668\u6a21\u578b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_29","text":"VkShaderModule \u5bf9\u8c61\u53ea\u662f\u5b57\u8282\u7801\u7f13\u51b2\u533a\u7684\u4e00\u4e2a\u5305\u88c5\u5bb9\u5668\u3002\u7740\u8272\u5668\u5e76\u6ca1\u6709\u5f7c\u6b64\u94fe\u63a5\uff0c\u751a\u81f3\u6ca1\u6709\u7ed9\u51fa\u76ee\u7684\u3002\u901a\u8fc7 VkPipelineShaderStageCreateInfo \u7ed3\u6784\u5c06\u7740\u8272\u5668\u6a21\u5757\u5206\u914d\u5230\u7ba1\u7ebf\u4e2d\u7684\u9876\u70b9\u6216\u8005\u7247\u6bb5\u7740\u8272\u5668\u9636\u6bb5\u3002VkPipelineShaderStageCreateInfo\u7ed3\u6784\u4f53\u662f\u5b9e\u9645\u7ba1\u7ebf\u521b\u5efa\u8fc7\u7a0b\u7684\u4e00\u90e8\u5206\u3002 \u6211\u4eec\u9996\u5148\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u586b\u5199\u9876\u70b9\u7740\u8272\u5668\u7ed3\u6784\u4f53\u3002 VkPipelineShaderStageCreateInfo vertShaderStageInfo = {}; vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; C++ \u9664\u4e86\u5f3a\u5236\u7684 sType \u6210\u5458\u5916\uff0c\u7b2c\u4e00\u4e2a\u9700\u8981\u544a\u77e5Vulkan\u5c06\u5728\u54ea\u4e2a\u6d41\u6c34\u7ebf\u9636\u6bb5\u4f7f\u7528\u7740\u8272\u5668\u3002\u5728\u4e0a\u4e00\u4e2a\u7ae0\u8282\u7684\u6bcf\u4e2a\u53ef\u7f16\u7a0b\u9636\u6bb5\u90fd\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u679a\u4e3e\u503c\u3002 vertShaderStageInfo.module = vertShaderModule; vertShaderStageInfo.pName = \"main\"; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u6210\u5458\u6307\u5b9a\u5305\u542b\u4ee3\u7801\u7684\u7740\u8272\u5668\u6a21\u5757\u548c\u8c03\u7528\u7684\u4e3b\u51fd\u6570\u3002\u8fd9\u610f\u5473\u7740\u53ef\u4ee5\u5c06\u591a\u4e2a\u7247\u6bb5\u7740\u8272\u5668\u7ec4\u5408\u5230\u5355\u4e2a\u7740\u8272\u5668\u6a21\u5757\u4e2d\uff0c\u5e76\u4f7f\u7528\u4e0d\u540c\u7684\u5165\u53e3\u70b9\u6765\u533a\u5206\u5b83\u4eec\u7684\u884c\u4e3a\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u575a\u6301\u4f7f\u7528\u6807\u51c6 main \u51fd\u6570\u4f5c\u4e3a\u5165\u53e3\u3002 \u8fd8\u6709\u4e00\u4e2a\u53ef\u9009\u6210\u5458\uff0c pSpecializationInfo ,\u5728\u8fd9\u91cc\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u5b83\uff0c\u4f46\u662f\u503c\u5f97\u8ba8\u8bba\u4e00\u4e0b\u3002\u5b83\u5141\u8bb8\u4e3a\u7740\u8272\u5668\u6307\u5b9a\u5e38\u91cf\u503c\u3002\u4f7f\u7528\u5355\u4e2a\u7740\u8272\u5668\u6a21\u5757\uff0c\u901a\u8fc7\u4e3a\u5176\u4e2d\u4f7f\u7528\u4e0d\u540c\u7684\u5e38\u91cf\u503c\uff0c\u53ef\u4ee5\u5728\u6d41\u6c34\u7ebf\u521b\u5efa\u65f6\u5bf9\u884c\u4e3a\u8fdb\u884c\u914d\u7f6e\u3002\u8fd9\u6bd4\u5728\u6e32\u67d3\u65f6\u4f7f\u7528\u53d8\u91cf\u914d\u7f6e\u7740\u8272\u5668\u66f4\u6709\u6548\u7387\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u53ef\u4ee5\u8fdb\u884c\u4f18\u5316\uff0c\u4f8b\u5982\u6d88\u9664 if \u503c\u5224\u65ad\u7684\u8bed\u53e5\u3002\u5982\u679c\u6ca1\u6709\u8fd9\u6837\u7684\u5e38\u91cf\uff0c\u53ef\u4ee5\u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a nullptr \uff0c\u6211\u4eec\u7684struct\u7ed3\u6784\u4f53\u521d\u59cb\u5316\u81ea\u52a8\u8fdb\u884c\u3002 \u4fee\u6539\u7ed3\u6784\u4f53\u6ee1\u8db3\u7247\u6bb5\u7740\u8272\u5668\u7684\u9700\u8981: VkPipelineShaderStageCreateInfo fragShaderStageInfo = {}; fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; fragShaderStageInfo.module = fragShaderModule; fragShaderStageInfo.pName = \"main\"; C++ \u5b8c\u6210\u4e24\u4e2a\u7ed3\u6784\u4f53\u7684\u521b\u5efa\uff0c\u5e76\u901a\u8fc7\u6570\u7ec4\u4fdd\u5b58\uff0c\u8fd9\u90e8\u5206\u5f15\u7528\u5c06\u4f1a\u5728\u5b9e\u9645\u7684\u7ba1\u7ebf\u521b\u5efa\u5f00\u59cb\u3002 VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo}; C++ \u5230\u6b64\u4e3a\u6b62\uff0c\u5c31\u662f\u6240\u6709\u5173\u4e8e\u53ef\u7f16\u7a0b\u7ba1\u7ebf\u9636\u6bb5\u7684\u903b\u8f91\u3002\u5728 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u4f1a\u770b\u4e00\u4e0b\u56fa\u5b9a\u7ba1\u7ebf\u5404\u4e2a\u9636\u6bb5\u3002","title":"\u7740\u8272\u5668\u9636\u6bb5\u521b\u5efa"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_8","text":"Vulkan \u56fa\u6709\u529f\u80fd \uff0c\u65e9\u8d77\u7684\u56fe\u5f62API\u5728\u56fe\u5f62\u6e32\u67d3\u7ba1\u7ebf\u7684\u8bb8\u591a\u9636\u6bb5\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u7684\u72b6\u6001\u3002\u5728 Vulkan \u4e2d\uff0c\u4ece viewport \u7684\u5927\u5c0f\u5230\u6df7\u8272\u51fd\u6570\uff0c\u9700\u8981\u51e1\u4e8b\u505a\u5230\u4eb2\u5386\u4eb2\u4e3a\u3002\u5728\u672c\u7ae0\u8282\u4e2d\u6211\u4eec\u4f1a\u586b\u5145\u6709\u5173\u56fa\u6709\u529f\u80fd\u64cd\u4f5c\u7684\u6240\u6709\u7ed3\u6784\u4f53\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9876\u70b9\u8f93\u5165 2 \u8f93\u5165\u7ec4\u4ef6 3 \u89c6\u7a97\u548c\u88c1\u526a 4 \u5149\u6805\u5316 5 \u91cd\u91c7\u6837 6 \u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5 7 \u989c\u8272\u6df7\u5408 8 \u52a8\u6001\u4fee\u6539 9 \u7ba1\u9053\u5e03\u5c40 10 \u7ed3\u8bba","title":"Vulkan \u56fa\u6709\u529f\u80fd"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_30","text":"VkPipelineVertexInputStateCreateInfo \u7ed3\u6784\u4f53\u63cf\u8ff0\u4e86\u9876\u70b9\u6570\u636e\u7684\u683c\u5f0f\uff0c\u8be5\u7ed3\u6784\u4f53\u6570\u636e\u4f20\u9012\u5230 vertex shader \u4e2d\u3002\u5b83\u4ee5\u4e24\u79cd\u65b9\u5f0f\u8fdb\u884c\u63cf\u8ff0: Bindings :\u6839\u636e\u6570\u636e\u7684\u95f4\u9699\uff0c\u786e\u5b9a\u6570\u636e\u662f\u6bcf\u4e2a\u9876\u70b9\u6216\u8005\u662f\u6bcf\u4e2ainstance( instancing ) Attribute \u63cf\u8ff0:\u63cf\u8ff0\u5c06\u8981\u8fdb\u884c\u7ed1\u5b9a\u53ca\u52a0\u8f7d\u5c5e\u6027\u7684\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684\u76f8\u5173\u5c5e\u6027\u7c7b\u578b\u3002 \u56e0\u4e3a\u6211\u4eec\u5c06\u9876\u70b9\u6570\u636e\u786c\u7f16\u7801\u5230 vertex shader \u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u5c06\u8981\u586b\u5145\u7684\u7ed3\u6784\u4f53\u6ca1\u6709\u9876\u70b9\u6570\u636e\u53bb\u52a0\u8f7d\u3002\u6211\u4eec\u5c06\u4f1a\u5728 vertex buffer \u7ae0\u8282\u4e2d\u56de\u6765\u64cd\u4f5c\u3002 VkPipelineVertexInputStateCreateInfo vertexInputInfo = {}; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.pVertexBindingDescriptions = nullptr; // Optional vertexInputInfo.vertexAttributeDescriptionCount = 0; vertexInputInfo.pVertexAttributeDescriptions = nullptr; // Optional C++ pVertexBindingDescriptions \u548c pVertexAttributeDescriptions \u6210\u5458\u6307\u5411\u7ed3\u6784\u4f53\u6570\u7ec4\uff0c\u7528\u4e8e\u8fdb\u4e00\u6b65\u63cf\u8ff0\u52a0\u8f7d\u7684\u9876\u70b9\u6570\u636e\u4fe1\u606f\u3002\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u7684 shaderStages \u6570\u7ec4\u540e\u6dfb\u52a0\u8be5\u7ed3\u6784\u4f53\u3002","title":"\u9876\u70b9\u8f93\u5165"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_31","text":"VkPipelineInputAssemblyStateCreateInfo \u7ed3\u6784\u4f53\u63cf\u8ff0\u4e24\u4ef6\u4e8b\u60c5:\u9876\u70b9\u6570\u636e\u4ee5\u4ec0\u4e48\u7c7b\u578b\u7684\u51e0\u4f55\u56fe\u5143\u62d3\u6251\u8fdb\u884c\u7ed8\u5236\u53ca\u662f\u5426\u542f\u7528\u9876\u70b9\u7d22\u91cd\u65b0\u5f00\u59cb\u56fe\u5143\u3002\u56fe\u5143\u7684\u62d3\u6251\u7ed3\u6784\u7c7b\u578b topology \u679a\u4e3e\u503c\u5982\u4e0b: VK_PRIMITIVE_TOPOLOGY_POINT_LIST : \u9876\u70b9\u5230\u70b9 VK_PRIMITIVE_TOPOLOGY_LINE_LIST : \u4e24\u70b9\u6210\u7ebf\uff0c\u9876\u70b9\u4e0d\u5171\u7528 VK_PRIMITIVE_TOPOLOGY_LINE_STRIP : \u4e24\u70b9\u6210\u7ebf\uff0c\u6bcf\u4e2a\u7ebf\u6bb5\u7684\u7ed3\u675f\u9876\u70b9\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u7ebf\u6bb5\u7684\u5f00\u59cb\u9876\u70b9 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST : \u4e09\u70b9\u6210\u9762\uff0c\u9876\u70b9\u4e0d\u5171\u7528 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP : \u6bcf\u4e2a\u4f46\u6559\u8bad\u7684\u7b2c\u4e8c\u4e2a\u3001\u7b2c\u4e09\u4e2a\u9876\u70b9\u90fd\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u4e09\u89d2\u5f62\u7684\u524d\u4e24\u4e2a\u9876\u70b9 \u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u9876\u70b9\u6570\u636e\u6309\u7167\u7f13\u51b2\u533a\u4e2d\u7684\u5e8f\u5217\u4f5c\u4e3a\u7d22\u5f15\uff0c\u4f46\u662f\u4e5f\u53ef\u4ee5\u901a\u8fc7element buffer\u7f13\u51b2\u533a\u81ea\u884c\u6307\u5b9a\u9876\u70b9\u6570\u636e\u7684\u7d22\u5f15\u3002\u901a\u8fc7\u590d\u7528\u9876\u70b9\u6570\u636e\u63d0\u5347\u6027\u80fd\u3002\u5982\u679c\u8bbe\u7f6e primitiveRestartEnable \u6210\u5458\u4e3a VK_TRUE \uff0c\u53ef\u4ee5\u901a\u8fc7 0xFFFF \u6216\u8005 0xFFFFFFFF \u4f5c\u4e3a\u7279\u6b8a\u7d22\u5f15\u6765\u5206\u89e3\u7ebf\u548c\u4e09\u89d2\u5f62\u5728 _STRIP \u6a21\u5f0f\u4e0b\u7684\u56fe\u5143\u62d3\u6251\u7ed3\u6784\u3002 \u901a\u8fc7\u672c\u6559\u7a0b\u7ed8\u5236\u4e09\u89d2\u5f62\uff0c\u6240\u4ee5\u6211\u4eec\u575a\u6301\u6309\u7167\u5982\u4e0b\u683c\u5f0f\u586b\u5145\u6570\u636e\u7ed3\u6784: VkPipelineInputAssemblyStateCreateInfo inputAssembly = {}; inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; inputAssembly.primitiveRestartEnable = VK_FALSE; C++","title":"\u8f93\u5165\u7ec4\u4ef6"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_32","text":"Viewport\u7528\u4e8e\u63cf\u8ff0framebuffer\u4f5c\u4e3a\u6e32\u67d3\u8f93\u51fa\u7ed3\u679c\u76ee\u6807\u533a\u57df\u3002\u5b83\u7684\u6570\u503c\u5728\u672c\u6559\u7a0b\u4e2d\u603b\u662f\u8bbe\u7f6e\u5728 (0, 0) \u548c (width, height) \u3002 VkViewport viewport = {}; viewport.x = 0.0f; viewport.y = 0.0f; viewport.width = (float) swapChainExtent.width; viewport.height = (float) swapChainExtent.height; viewport.minDepth = 0.0f; viewport.maxDepth = 1.0f; C++ \u8bb0\u5f97\u4ea4\u6362\u94fe\u548c\u5b83\u7684images\u56fe\u50cf\u5927\u5c0f WIDTH \u548c HEIGHT \u4f1a\u6839\u636e\u4e0d\u540c\u7684\u7a97\u4f53\u800c\u4e0d\u540c\u3002\u4ea4\u6362\u94fe\u56fe\u50cf\u5c06\u4f1a\u5728\u5e27\u7f13\u51b2\u533aframebuffers\u4f7f\u7528\uff0c\u6240\u4ee5\u6211\u4eec\u5e94\u8be5\u575a\u6301\u5b83\u4eec\u7684\u5927\u5c0f\u3002 minDepth \u548c maxDepth \u6570\u503c\u6307\u5b9aframebuffer\u4e2d\u6df1\u5ea6\u7684\u8303\u56f4\u3002\u8fd9\u4e9b\u6570\u503c\u5fc5\u987b\u6536\u655b\u5728 [0.0f, 1.0f] \u533a\u95f4\u51b2\uff0c\u4f46\u662f minDepth \u53ef\u80fd\u4f1a\u5927\u4e8e maxDepth \u3002\u5982\u679c\u4f60\u4e0d\u505a\u4efb\u4f55\u6307\u5b9a\uff0c\u5efa\u8bae\u4f7f\u7528\u6807\u51c6\u7684\u6570\u503c 0.0 f\u548c 1.0f \u3002 viewports \u5b9a\u4e49\u4e86image\u56fe\u50cf\u5230framebuffer\u5e27\u7f13\u51b2\u533a\u7684\u8f6c\u6362\u5173\u7cfb\uff0c\u88c1\u526a\u77e9\u5f62\u5b9a\u4e49\u4e86\u54ea\u4e9b\u533a\u57df\u7684\u50cf\u7d20\u88ab\u5b58\u50a8\u3002\u4efb\u4f55\u5728\u88c1\u526a\u5de8\u578b\u5916\u7684\u50cf\u7d20\u90fd\u4f1a\u5728\u5149\u6805\u5316\u9636\u6bb5\u4e22\u5f03\u3002\u5b83\u4eec\u7684\u529f\u80fd\u66f4\u50cf\u8fc7\u6ee4\u5668\u800c\u4e0d\u662f\u5b9a\u4e49\u8f6c\u6362\u5173\u7cfb\u3002\u8fd9\u4e2a\u533a\u522b\u5982\u4e0b\u56fe\u6240\u793a\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5bf9\u4e8e\u56fe\u50cf\u6bd4 viewport \u5c3a\u5bf8\u5927\u7684\u60c5\u5f62\uff0c\u5de6\u4fa7\u7684\u88c1\u526a\u77e9\u5f62\u53ea\u662f\u4f17\u591a\u53ef\u80fd\u7684\u4e00\u4e2a\u8868\u73b0\u3002 \u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u9700\u8981\u5c06\u56fe\u50cf\u7ed8\u5236\u5230\u5b8c\u6574\u7684\u5e27\u7f13\u51b2\u533a framebuffer \u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u5b9a\u4e49\u88c1\u526a\u77e9\u5f62\u8986\u76d6\u5230\u6574\u4f53\u56fe\u50cf: VkRect2D scissor = {}; scissor.offset = {0, 0}; scissor.extent = swapChainExtent; C++ viewport\u548c\u88c1\u526a\u77e9\u5f62\u9700\u8981\u501f\u52a9 VkPipelineViewportStateCreateInfo \u7ed3\u6784\u4f53\u8054\u5408\u4f7f\u7528\u3002\u53ef\u4ee5\u4f7f\u7528\u591a viewports \u548c\u88c1\u526a\u77e9\u5f62\u5728\u4e00\u4e9b\u56fe\u5f62\u5361\uff0c\u901a\u8fc7\u6570\u7ec4\u5f15\u7528\u3002\u4f7f\u7528\u8be5\u7279\u6027\u9700\u8981GPU\u652f\u6301\u8be5\u529f\u80fd\uff0c\u5177\u4f53\u770b\u903b\u8f91\u8bbe\u5907\u7684\u521b\u5efa\u3002 VkPipelineViewportStateCreateInfo viewportState = {}; viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; viewportState.pScissors = &scissor; C++","title":"\u89c6\u7a97\u548c\u88c1\u526a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_33","text":"\u5149\u6805\u5316\u901a\u8fc7\u9876\u70b9\u7740\u8272\u5668\u53ca\u5177\u4f53\u7684\u51e0\u4f55\u7b97\u6cd5\u5c06\u9876\u70b9\u8fdb\u884c\u5851\u5f62\uff0c\u5e76\u5c06\u56fe\u5f62\u4f20\u9012\u5230\u7247\u6bb5\u7740\u8272\u5668\u8fdb\u884c\u7740\u8272\u5de5\u4f5c\u3002\u5b83\u4e5f\u4f1a\u6267\u884c\u6df1\u5ea6\u6d4b\u8bd5 depth testing \u3001\u9762\u88c1\u5207 face culling \u548c\u88c1\u526a\u6d4b\u8bd5\uff0c\u5b83\u53ef\u4ee5\u5bf9\u8f93\u51fa\u7684\u7247\u5143\u8fdb\u884c\u914d\u7f6e\uff0c\u51b3\u5b9a\u662f\u5426\u8f93\u51fa\u6574\u4e2a\u56fe\u5143\u62d3\u6251\u6216\u8005\u662f\u8fb9\u6846(\u7ebf\u6846\u6e32\u67d3)\u3002\u6240\u6709\u7684\u914d\u7f6e\u901a\u8fc7 VkPipelineRasterizationStateCreateInfo \u7ed3\u6784\u4f53\u5b9a\u4e49\u3002 VkPipelineRasterizationStateCreateInfo rasterizer = {}; rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterizer.depthClampEnable = VK_FALSE; C++ \u5b83\u7684 depthClampEnable \u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u8d85\u8fc7\u8fdc\u8fd1\u88c1\u526a\u9762\u7684\u7247\u5143\u4f1a\u8fdb\u884c\u6536\u655b\uff0c\u800c\u4e0d\u662f\u4e22\u5f03\u5b83\u4eec\u3002\u5b83\u5728\u7279\u6b8a\u7684\u60c5\u51b5\u4e0b\u6bd4\u8f83\u6709\u7528\uff0c\u50cf\u9634\u5f71\u8d34\u56fe\u3002\u4f7f\u7528\u8be5\u529f\u80fd\u9700\u8981\u5f97\u5230 GPU \u7684\u652f\u6301\u3002 rasterizer.rasterizerDiscardEnable = VK_FALSE; C++ \u5982\u679c rasterizerDiscardEnable \u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u90a3\u4e48\u51e0\u4f55\u56fe\u5143\u6c38\u8fdc\u4e0d\u4f1a\u4f20\u9012\u5230\u5149\u6805\u5316\u9636\u6bb5\u3002\u8fd9\u662f\u57fa\u672c\u7684\u7981\u6b62\u4efb\u4f55\u8f93\u51fa\u5230framebuffer\u5e27\u7f13\u51b2\u533a\u7684\u65b9\u6cd5\u3002 rasterizer.polygonMode = VK_POLYGON_MODE_FILL; C++ polygonMode \u51b3\u5b9a\u51e0\u4f55\u4ea7\u751f\u56fe\u7247\u7684\u5185\u5bb9\u3002\u4e0b\u5217\u6709\u6548\u6a21\u5f0f: VK_POLYGON_MODE_FILL : \u591a\u8fb9\u5f62\u533a\u57df\u586b\u5145 VK_POLYGON_MODE_LINE : \u591a\u8fb9\u5f62\u8fb9\u7f18\u7ebf\u6846\u7ed8\u5236 VK_POLYGON_MODE_POINT : \u591a\u8fb9\u5f62\u9876\u70b9\u4f5c\u4e3a\u63cf\u70b9\u7ed8\u5236 \u4f7f\u7528\u4efb\u4f55\u6a21\u5f0f\u586b\u5145\u9700\u8981\u5f00\u542fGPU\u529f\u80fd\u3002 rasterizer.lineWidth = 1.0f; C++ lineWidth \u6210\u5458\u662f\u76f4\u63a5\u586b\u5145\u7684\uff0c\u6839\u636e\u7247\u5143\u7684\u6570\u91cf\u63cf\u8ff0\u7ebf\u7684\u5bbd\u5ea6\u3002\u6700\u5927\u7684\u7ebf\u5bbd\u652f\u6301\u53d6\u51b3\u4e8e\u786c\u4ef6\uff0c\u4efb\u4f55\u5927\u4e8e 1.0 \u7684\u7ebf\u5bbd\u9700\u8981\u5f00\u542fGPU\u7684 wideLines \u7279\u6027\u652f\u6301\u3002 rasterizer.cullMode = VK_CULL_MODE_BACK_BIT; rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; C++ cullMode \u53d8\u91cf\u7528\u4e8e\u51b3\u5b9a\u9762\u88c1\u526a\u7684\u7c7b\u578b\u65b9\u5f0f\u3002\u53ef\u4ee5\u7981\u6b62 culling \uff0c\u88c1\u526a front faces \uff0c cull back faces \u6216\u8005\u5168\u90e8\u3002 frontFace \u7528\u4e8e\u63cf\u8ff0\u4f5c\u4e3a front-facing \u9762\u7684\u9876\u70b9\u7684\u987a\u5e8f\uff0c\u53ef\u4ee5\u662f\u987a\u65f6\u9488\u4e5f\u53ef\u4ee5\u662f\u9006\u65f6\u9488\u3002 rasterizer.depthBiasEnable = VK_FALSE; rasterizer.depthBiasConstantFactor = 0.0f; // Optional rasterizer.depthBiasClamp = 0.0f; // Optional rasterizer.depthBiasSlopeFactor = 0.0f; // Optional C++ \u5149\u6805\u5316\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u5e38\u91cf\u6216\u8005\u57fa\u4e8e\u7247\u5143\u7684\u659c\u7387\u6765\u66f4\u6539\u6df1\u5ea6\u503c\u3002\u4e00\u4e9b\u65f6\u5019\u5bf9\u4e8e\u9634\u5f71\u8d34\u56fe\u662f\u6709\u7528\u7684\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u4f1a\u5728\u7ae0\u8282\u4e2d\u4f7f\u7528\uff0c\u8bbe\u7f6e depthBiasEnable \u4e3a VK_FALSE \u3002","title":"\u5149\u6805\u5316"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_34","text":"VkPipelineMultisampleStateCreateInfo \u7ed3\u6784\u4f53\u7528\u4e8e\u914d\u7f6e\u591a\u91cd\u91c7\u6837\u3002\u6240\u8c13\u591a\u91cd\u91c7\u6837\u662f\u6297\u952f\u9f7f anti-aliasing \u7684\u4e00\u79cd\u5b9e\u73b0\u3002\u5b83\u901a\u8fc7\u7ec4\u5408\u591a\u4e2a\u591a\u8fb9\u5f62\u7684\u7247\u6bb5\u7740\u8272\u5668\u7ed3\u679c\uff0c\u5149\u6805\u5316\u5230\u540c\u4e00\u4e2a\u50cf\u7d20\u3002\u8fd9\u4e3b\u8981\u53d1\u751f\u5728\u8fb9\u7f18\uff0c\u8fd9\u4e5f\u662f\u6700\u5f15\u4eba\u6ce8\u76ee\u7684\u952f\u9f7f\u51fa\u73b0\u7684\u5730\u65b9\u3002\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u591a\u8fb9\u5f62\u6620\u5c04\u5230\u50cf\u7d20\u662f\u4e0d\u9700\u8981\u591a\u6b21\u8fd0\u884c\u7247\u6bb5\u7740\u8272\u5668\u8fdb\u884c\u91c7\u6837\u7684\uff0c\u76f8\u6bd4\u9ad8\u5206\u8fa8\u7387\u6765\u8bf4\uff0c\u5b83\u4f1a\u82b1\u8d39\u8f83\u4f4e\u7684\u5f00\u9500\u3002\u5f00\u542f\u8be5\u529f\u80fd\u9700\u8981GPU\u652f\u6301\u3002 VkPipelineMultisampleStateCreateInfo multisampling = {}; multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampling.sampleShadingEnable = VK_FALSE; multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; multisampling.minSampleShading = 1.0f; // Optional multisampling.pSampleMask = nullptr; // Optional multisampling.alphaToCoverageEnable = VK_FALSE; // Optional multisampling.alphaToOneEnable = VK_FALSE; // Optional C++ \u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u591a\u91cd\u91c7\u6837\uff0c\u4f46\u662f\u53ef\u4ee5\u968f\u610f\u7684\u5c1d\u8bd5\uff0c\u5177\u4f53\u7684\u53c2\u6570\u8bf7\u53c2\u9605\u89c4\u8303\u3002","title":"\u91cd\u91c7\u6837"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_35","text":"\u5982\u679c\u4f7f\u7528depth \u6216\u8005 stencil\u7f13\u51b2\u533a\uff0c\u9700\u8981\u4f7f\u7528 VkPipelineDepthStencilStateCreateInfo \u914d\u7f6e\u3002\u6211\u4eec\u73b0\u5728\u4e0d\u9700\u8981\u4f7f\u7528\uff0c\u6240\u4ee5\u7b80\u5355\u7684\u4f20\u9012 nullptr \uff0c\u5173\u4e8e\u8fd9\u90e8\u5206\u4f1a\u4e13\u95e8\u5728\u6df1\u5ea6\u7f13\u51b2\u533a\u7ae0\u8282\u4e2d\u8ba8\u8bba\u3002","title":"\u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_36","text":"\u7247\u6bb5\u7740\u8272\u5668\u8f93\u51fa\u5177\u4f53\u7684\u989c\u8272\uff0c\u5b83\u9700\u8981\u4e0e\u5e27\u7f13\u51b2\u533a framebuffer \u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\u3002\u8fd9\u4e2a\u8f6c\u6362\u7684\u8fc7\u7a0b\u6210\u4e3a\u6df7\u8272\uff0c\u5b83\u6709\u4e24\u79cd\u65b9\u5f0f: \u5c06old\u548cnew\u989c\u8272\u8fdb\u884c\u6df7\u5408\u4ea7\u51fa\u4e00\u4e2a\u6700\u7ec8\u7684\u989c\u8272 \u4f7f\u7528\u6309\u4f4d\u64cd\u4f5c\u6df7\u5408old\u548cnew\u989c\u8272\u7684\u503c \u6709\u4e24\u4e2a\u7ed3\u6784\u4f53\u7528\u4e8e\u914d\u7f6e\u989c\u8272\u6df7\u5408\u3002\u7b2c\u4e00\u4e2a\u7ed3\u6784\u4f53 VkPipelineColorBlendAttachmentState \u5305\u62ec\u4e86\u6bcf\u4e2a\u9644\u52a0\u5230\u5e27\u7f13\u51b2\u533a\u7684\u914d\u7f6e\u3002\u7b2c\u4e8c\u4e2a\u7ed3\u6784\u4f53 VkPipelineColorBlendStateCreateInfo \u5305\u542b\u4e86\u5168\u5c40\u6df7\u8272\u7684\u8bbe\u7f6e\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u4ec5\u4f7f\u7528\u7b2c\u4e00\u79cd\u65b9\u5f0f: VkPipelineColorBlendAttachmentState colorBlendAttachment = {}; colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; colorBlendAttachment.blendEnable = VK_FALSE; colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; // Optional colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; // Optional colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; // Optional colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; // Optional C++ \u8fd9\u79cd\u9488\u5bf9\u6bcf\u4e2a\u5e27\u7f13\u51b2\u533a\u914d\u7f6e\u6df7\u8272\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528\u5982\u4e0b\u4f2a\u4ee3\u7801\u8fdb\u884c\u8bf4\u660e: if (blendEnable) { finalColor.rgb = (srcColorBlendFactor * newColor.rgb) <colorBlendOp> (dstColorBlendFactor * oldColor.rgb); finalColor.a = (srcAlphaBlendFactor * newColor.a) <alphaBlendOp> (dstAlphaBlendFactor * oldColor.a); } else { finalColor = newColor; } finalColor = finalColor & colorWriteMask; C++ \u5982\u679c blendEnable \u8bbe\u7f6e\u4e3a VK_FALSE ,\u90a3\u4e48\u4ece\u7247\u6bb5\u7740\u8272\u5668\u8f93\u51fa\u7684\u65b0\u989c\u8272\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u5426\u5219\u4e24\u4e2a\u6df7\u8272\u64cd\u4f5c\u4f1a\u8ba1\u7b97\u65b0\u7684\u989c\u8272\u3002\u6240\u5f97\u5230\u7684\u7ed3\u679c\u4e0e colorWriteMask \u8fdb\u884cAND\u8fd0\u7b97\uff0c\u4ee5\u786e\u5b9a\u5b9e\u9645\u4f20\u9012\u7684\u901a\u9053\u3002 \u5927\u591a\u6570\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u6df7\u8272\u7528\u4e8e\u5b9e\u73b0 alpha blending \uff0c\u65b0\u7684\u989c\u8272\u4e0e\u65e7\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\u4f1a\u57fa\u4e8e\u5b83\u4eec\u7684 opacity \u900f\u660e\u901a\u9053\u3002 finalColor \u4f5c\u4e3a\u6700\u7ec8\u7684\u8f93\u51fa: finalColor.rgb = newAlpha * newColor + (1 - newAlpha) * oldColor; finalColor.a = newAlpha.a; C++ \u53ef\u4ee5\u901a\u8fc7\u4e00\u4e0b\u53c2\u6570\u5b8c\u6210: colorBlendAttachment.blendEnable = VK_TRUE; colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA; colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; C++ \u53ef\u4ee5\u5728\u89c4\u8303\u4e2d\u627e\u5230\u6240\u6709\u6709\u5173 VkBlendFactor \u548c VkBlendOp \u7684\u679a\u4e3e\u503c\u3002 \u7b2c\u4e8c\u4e2a\u7ed3\u6784\u4f53\u6301\u6709\u6240\u6709\u5e27\u7f13\u51b2\u533a\u7684\u5f15\u7528\uff0c\u5b83\u5141\u8bb8\u8bbe\u7f6e\u6df7\u5408\u64cd\u4f5c\u7684\u5e38\u91cf\uff0c\u8be5\u5e38\u91cf\u53ef\u4ee5\u4f5c\u4e3a\u540e\u7eed\u8ba1\u7b97\u7684\u6df7\u5408\u56e0\u5b50: VkPipelineColorBlendStateCreateInfo colorBlending = {}; colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; colorBlending.logicOpEnable = VK_FALSE; colorBlending.logicOp = VK_LOGIC_OP_COPY; // Optional colorBlending.attachmentCount = 1; colorBlending.pAttachments = &colorBlendAttachment; colorBlending.blendConstants[0] = 0.0f; // Optional colorBlending.blendConstants[1] = 0.0f; // Optional colorBlending.blendConstants[2] = 0.0f; // Optional colorBlending.blendConstants[3] = 0.0f; // Optional C++ \u5982\u679c\u9700\u8981\u4f7f\u7528\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u8bbe\u7f6e\u6df7\u5408\u64cd\u4f5c( bitwise combination ), \u9700\u8981\u8bbe\u7f6e logicOpEnable \u4e3a VK_TURE \u3002\u4e8c\u8fdb\u5236\u4f4d\u64cd\u4f5c\u5728 logicOp \u5b57\u6bb5\u4e2d\u6307\u5b9a\u3002\u5728\u7b2c\u4e00\u79cd\u65b9\u5f0f\u4e2d\u4f1a\u81ea\u52a8\u7981\u6b62\uff0c\u7b49\u540c\u4e8e\u4e3a\u6bcf\u4e00\u4e2a\u9644\u52a0\u7684\u5e27\u7f13\u51b2\u533aframebuffer\u5173\u95ed\u6df7\u5408\u64cd\u4f5c\uff0c blendEnable \u4e3a VK_FALSE \u3002 colorWriteMask \u63a9\u7801\u4f1a\u7528\u786e\u5b9a\u5e27\u7f13\u51b2\u533a\u4e2d\u5177\u4f53\u54ea\u4e2a\u901a\u9053\u7684\u989c\u8272\u53d7\u5230\u5f71\u54cd\u3002\u5b83\u4e5f\u53ef\u4ee5\u5728\u4e24\u79cd\u65b9\u5f0f\u4e0b\u7981\u6b62\uff0c\u622a\u81f3\u76ee\u524d\uff0c\u7247\u6bb5\u7f13\u51b2\u533a\u5411\u5e27\u7f13\u51b2\u533a\u4e2d\u8f93\u51fa\u7684\u989c\u8272\u4e0d\u4f1a\u8fdb\u884c\u4efb\u4f55\u53d8\u5316\u3002","title":"\u989c\u8272\u6df7\u5408"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_37","text":"\u4e4b\u524d\u521b\u5efa\u7684\u4e00\u4e9b\u7ed3\u6784\u4f53\u7684\u72b6\u6001\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u52a8\u6001\u4fee\u6539\uff0c\u800c\u4e0d\u5fc5\u91cd\u65b0\u521b\u5efa\u3002\u6bd4\u5982 viewport \u7684\u5927\u5c0f, line width \u548c blend constants \u3002\u5982\u679c\u9700\u8981\u8fdb\u884c\u8fd9\u6837\u7684\u64cd\u4f5c\uff0c\u9700\u8981\u586b\u5145 VkPipelineDynamicStateCreateInfo \u7ed3\u6784\u4f53: VkDynamicState dynamicStates[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_LINE_WIDTH }; VkPipelineDynamicStateCreateInfo dynamicState = {}; dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO; dynamicState.dynamicStateCount = 2; dynamicState.pDynamicStates = dynamicStates; C++ \u5728\u7ed8\u5236\u7684\u8fc7\u7a0b\u4e2d\u6307\u5b9a\u8fd9\u4e9b\u6570\u636e\uff0c\u8fd9\u4f1a\u5bfc\u81f4\u5ffd\u7565\u4e4b\u524d\u7684\u76f8\u5173\u6570\u503c\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7684\u7ae0\u8282\u4e2d\u56de\u8fc7\u5934\u6765\u8ba8\u8bba\u3002\u5982\u679c\u6ca1\u6709\u4efb\u4f55\u9700\u8981\u52a8\u6001\u4fee\u6539\u7684\u6570\u503c\u6e05\u8bbe\u7f6e\u4e3a nullptr \u3002","title":"\u52a8\u6001\u4fee\u6539"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_38","text":"\u53ef\u4ee5\u5728\u7740\u8272\u5668\u4e2d\u4f7f\u7528 uniform \uff0c\u5b83\u662f\u7c7b\u4f3c\u4e0e\u52a8\u6001\u72b6\u6001\u53d8\u91cf\u7684\u5168\u5c40\u53d8\u91cf\uff0c\u53ef\u4ee5\u5728\u7ed8\u753b\u65f6\u4fee\u6539\uff0c\u53ef\u4ee5\u66f4\u6539\u7740\u8272\u5668\u7684\u884c\u4e3a\u800c\u65e0\u9700\u91cd\u65b0\u521b\u5efa\u5b83\u4eec\u3002\u5b83\u4eec\u901a\u5e38\u7528\u4e8e\u5c06\u53d8\u6362\u77e9\u9635\u4f20\u9012\u5230\u9876\u70b9\u7740\u8272\u5668\u6216\u8005\u5728\u7247\u6bb5\u7740\u8272\u5668\u51b2\u521b\u5efa\u7eb9\u7406\u91c7\u6837\u5668\u3002 \u8fd9\u4e9b uniform \u6570\u503c\u9700\u8981\u5728\u7ba1\u7ebf\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u901a\u8fc7 VkPipelineLayout \u5bf9\u8c61\u6307\u5b9a\u3002\u5373\u4f7f\u5728\u540e\u7eed\u5185\u5bb9\u4e2d\u7528\u5230\uff0c\u6211\u4eec\u4e5f\u4ecd\u7136\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u7a7a\u7684 pipeline layout \u3002 \u521b\u5efa\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709\u8be5\u5bf9\u8c61\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u540e\u7eed\u7ae0\u8282\u4e2d\u7684\u51fd\u6570\u4e2d\u5f15\u7528\u5b83: VkPipelineLayout pipelineLayout; C++ \u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u521b\u5efa\u5bf9\u8c61: VkPipelineLayoutCreateInfo pipelineLayoutInfo = {}; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; // Optional pipelineLayoutInfo.pSetLayouts = nullptr; // Optional pipelineLayoutInfo.pushConstantRangeCount = 0; // Optional pipelineLayoutInfo.pPushConstantRanges = 0; // Optional if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) { throw std::runtime_error(\"failed to create pipeline layout!\"); } C++ \u8be5\u7ed3\u6784\u4f53\u8fd8\u6307\u5b9a\u4e86 push \u5e38\u91cf\uff0c\u8fd9\u662f\u5c06\u52a8\u6001\u503c\u4f20\u9012\u7ed9\u7740\u8272\u5668\u7684\u62ce\u4e00\u4e2a\u65b9\u5f0f\u3002 pipeline layout \u53ef\u4ee5\u5728\u6574\u4e2a\u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\u5185\u5f15\u7528\uff0c\u6240\u4ee5\u5b83\u5728\u7a0b\u5e8f\u9000\u51fa\u7684\u65f6\u5019\u8fdb\u884c\u9500\u6bc1\u3002 void cleanup() { vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ... } C++","title":"\u7ba1\u9053\u5e03\u5c40"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_39","text":"\u8fd9\u5c31\u662f\u6240\u6709\u6709\u5173 fixed-function \u7684\u5185\u5bb9\uff0c\u770b\u8d77\u6765\u6709\u5f88\u591a\u7684\u5de5\u4f5c\u53bb\u505a\uff0c\u503c\u5f97\u5e86\u5e78\u7684\u662f\u6211\u4eec\u51e0\u4e4e\u4e86\u89e3\u4e86\u6240\u6709\u6709\u5173\u6e32\u67d3\u7ba1\u7ebf\u7684\u5185\u5bb9\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u51cf\u5c11\u4e86\u56e0\u4e3a\u4e0d\u4e86\u89e3\u67d0\u4e9b\u7ec4\u4ef6\u7684\u9ed8\u8ba4\u72b6\u6001\uff0c\u800c\u9020\u6210\u8fd0\u884c\u65f6\u78b0\u5230\u672a\u77e5\u884c\u4e3a\u7684\u53ef\u80fd\u6027\u3002 \u7136\u800c\uff0c\u5728\u6211\u4eec\u53ef\u4ee5\u6700\u7ec8\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u4e4b\u524d\uff0c\u8fd8\u6709\u4e00\u4e2a\u5bf9\u8c61\u9700\u8981\u521b\u5efa\uff0c\u5b83\u5c31\u662f render pass \u3002","title":"\u7ed3\u8bba"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_9","text":"Vulkan \u5e27\u7f13\u51b2\u533a \uff0c\u6211\u4eec\u5728\u524d\u9762\u7684\u7ae0\u8282\u4e2d\u5df2\u7ecf\u8ba8\u8bba\u4e86\u5f88\u591a\u6b21 framebuffers \u5e27\u7f13\u51b2\u533a\uff0c\u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u914d\u7f6e\u4e86 render pass \u6e32\u67d3\u901a\u9053\u5e76\u5e0c\u671b\u8f93\u51fa\u4e00\u4e2a\u4e0e\u4ea4\u6362\u94fe\u56fe\u50cf\u683c\u5f0f\u4e00\u81f4\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u4f46\u662f\u6211\u4eec\u5b9e\u9645\u4e0a\u8fd8\u6ca1\u6709\u521b\u5efa\u3002 \u5728 render pass \u521b\u5efa\u9636\u6bb5\u6211\u4eec\u6307\u5b9a\u4e86\u5177\u4f53\u7684\u9644\u4ef6\uff0c\u5e76\u901a\u8fc7 VkFramebuffer \u5bf9\u8c61\u5305\u88c5\u7ed1\u5b9a\u3002\u5e27\u7f13\u51b2\u533a\u5bf9\u8c61\u5f15\u7528\u8868\u793a\u4e3a\u9644\u4ef6\u7684\u6240\u6709\u7684 VkImageView \u5bf9\u8c61\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u53ea\u4f1a\u4f7f\u7528\u4e00\u4e2a\u5e27\u7f13\u51b2\u533a: color attachment \u3002\u7136\u800c\u6211\u4eec\u4f5c\u4e3a\u9644\u4ef6\u7684\u56fe\u50cf\u4f9d\u8d56\u4ea4\u6362\u94fe\u7528\u4e8e\u5448\u73b0\u65f6\u8fd4\u56de\u7684\u56fe\u50cf\u3002\u8fd9\u610f\u5473\u7740\u6211\u4eec\u5fc5\u987b\u4e3a\u4ea4\u6362\u94fe\u4e2d\u7684\u6240\u6709\u56fe\u50cf\u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u5728\u7ed8\u5236\u7684\u65f6\u5019\u4f7f\u7528\u5bf9\u5e94\u7684\u56fe\u50cf\u3002 \u6700\u540e\uff0c\u5728\u7c7b\u6210\u5458\u4e2d\u521b\u5efa\u53e6\u4e00\u4e2a std::vector \u7528\u4e8e\u4fdd\u5b58 framebuffers : std::vector<VkFramebuffer> swapChainFramebuffers; C++ \u6211\u4eec\u5728\u65b0\u7684\u51fd\u6570 createFramebuffers \u4e2d\u4e3a\u6570\u7ec4\u521b\u5efa\u5bf9\u8c61\u96c6\u5408\uff0c\u8fd9\u4e2a\u51fd\u6570\u5728 initVulkan \u521b\u5efa\u5b8c\u7ba1\u7ebf\u540e\u8c03\u7528: void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); } ... void createFramebuffers() { } C++ \u52a8\u6001\u8c03\u6574\u7528\u4e8e\u4fdd\u5b58 framebuffers \u7684\u5bb9\u5668\u5927\u5c0f: void createFramebuffers() { swapChainFramebuffers.resize(swapChainImageViews.size()); } C++ \u6211\u4eec\u63a5\u4e0b\u6765\u8fed\u4ee3\u5de6\u53f3\u7684\u56fe\u50cf\u89c6\u56fe\u5e76\u901a\u8fc7\u5b83\u4eec\u521b\u5efa\u5bf9\u5e94\u7684 framebuffers : for (size_t i = 0; i < swapChainImageViews.size(); i++) { VkImageView attachments[] = { swapChainImageViews[i] }; VkFramebufferCreateInfo framebufferInfo = {}; framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; framebufferInfo.renderPass = renderPass; framebufferInfo.attachmentCount = 1; framebufferInfo.pAttachments = attachments; framebufferInfo.width = swapChainExtent.width; framebufferInfo.height = swapChainExtent.height; framebufferInfo.layers = 1; if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &swapChainFramebuffers[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to create framebuffer!\"); } } C++ \u5982\u4f60\u6240\u89c1\uff0c\u521b\u5efa framebuffers \u662f\u975e\u5e38\u76f4\u63a5\u7684\u3002\u9996\u5148\u9700\u8981\u6307\u5b9a framebuffer \u9700\u8981\u517c\u5bb9\u7684 renderPass \u3002\u6211\u4eec\u53ea\u80fd\u4f7f\u7528\u4e0e\u5176\u517c\u5bb9\u7684\u6e32\u67d3\u901a\u9053\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u8fd9\u5927\u4f53\u4e0a\u610f\u5473\u7740\u5b83\u4eec\u4f7f\u7528\u76f8\u540c\u7684\u9644\u4ef6\u6570\u91cf\u548c\u7c7b\u578b\u3002 attachmentCount \u548c pAttachments \u53c2\u6570\u6307\u5b9a\u5728\u6e32\u67d3\u901a\u9053\u7684 pAttachment \u6570\u7ec4\u4e2d\u7ed1\u5b9a\u5230\u76f8\u5e94\u7684\u9644\u4ef6\u63cf\u8ff0\u7684 VkImageView \u5bf9\u8c61\u3002 width \u548c height \u53c2\u6570\u662f\u5bb9\u6613\u7406\u89e3\u7684\uff0c layer \u662f\u6307\u5b9a\u56fe\u50cf\u6570\u7ec4\u4e2d\u7684\u5c42\u6570\u3002\u6211\u4eec\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u662f\u5355\u4e2a\u56fe\u50cf\uff0c\u56e0\u6b64\u5c42\u6570\u4e3a 1 \u3002 \u6211\u4eec\u5728\u56fe\u50cf\u89c6\u56fe\u548c\u6e32\u67d3\u901a\u9053\u6e32\u67d3\u5b8c\u6bd5\u4e4b\u540e\uff0c\u5220\u9664\u5bf9\u5e94\u7684\u5e27\u7f13\u51b2\u533a: void cleanup() { for (size_t i = 0; i < swapChainFramebuffers.size(); i++) { vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); } ... } C++ \u6211\u4eec\u5df2\u7ecf\u8fbe\u5230\u4e86\u4e00\u4e2a\u91cc\u7a0b\u7891\uff0c\u6211\u4eec\u62e5\u6709\u6e32\u67d3\u9700\u8981\u7684\u6240\u6709\u5bf9\u8c61\u3002\u5728\u4e0b\u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u7f16\u5199\u7b2c\u4e00\u4e2a\u5b9e\u9645\u7ed8\u5236\u7684\u547d\u4ee4\u3002","title":"Vulkan \u5e27\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_10","text":"Vulkan \u6e32\u67d3\u901a\u9053 \uff0c\u5728\u6211\u4eec\u5b8c\u6210\u7ba1\u7ebf\u7684\u521b\u5efa\u5de5\u4f5c\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9 Vulkan \u6e32\u67d3\u65f6\u5019\u4f7f\u7528\u7684 framebuffer \u5e27\u7f13\u51b2\u533a\u9644\u4ef6\u76f8\u5173\u4fe1\u606f\u3002\u6211\u4eec\u9700\u8981\u6307\u5b9a\u591a\u5c11\u4e2a\u989c\u8272\u548c\u6df1\u5ea6\u7f13\u51b2\u533a\u5c06\u4f1a\u88ab\u4f7f\u7528\uff0c\u6307\u5b9a\u591a\u5c11\u4e2a\u91c7\u6837\u5668\u88ab\u7528\u5230\u53ca\u5728\u6574\u4e2a\u6e32\u67d3\u64cd\u4f5c\u4e2d\u76f8\u5173\u7684\u5185\u5bb9\u5982\u4f55\u5904\u7406\u3002\u6240\u6709\u7684\u8fd9\u4e9b\u4fe1\u606f\u90fd\u88ab\u5c01\u88c5\u5728\u4e00\u4e2a\u53eb\u505a render pass \u7684\u5bf9\u8c61\u4e2d\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u8bbe\u7f6e 2 \u9644\u4ef6\u63cf\u8ff0 3 \u5b50\u901a\u9053\u548c\u9644\u4ef6\u5f15\u7528 4 \u6e32\u67d3\u901a\u9053","title":"Vulkan \u6e32\u67d3\u901a\u9053"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_40","text":"\u6211\u4eec\u65b0\u6dfb\u52a0\u4e00\u4e2a createRenderPass \u51fd\u6570\uff0c\u5728 initVulkan \u51fd\u6570\u4e2d\u786e\u4fdd createGraphicsPipeline \u8c03\u7528\u4e4b\u524d\uff0c\u8c03\u7528\u5b83\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); } ... void createRenderPass() { } C++","title":"\u8bbe\u7f6e"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_41","text":"\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u5c06\u53ea\u6709\u4e00\u4e2a\u989c\u8272\u7f13\u51b2\u533a\u9644\u4ef6\uff0c\u5b83\u7531\u4ea4\u6362\u94fe\u4e2d\u7684\u4e00\u4e2a\u56fe\u50cf\u6240\u8868\u793a\u3002 void createRenderPass() { VkAttachmentDescription colorAttachment = {}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; } C++ format \u662f\u989c\u8272\u9644\u4ef6\u7684\u683c\u5f0f\uff0c\u5b83\u5e94\u8be5\u4e0e\u4ea4\u6362\u94fe\u4e2d\u56fe\u50cf\u7684\u683c\u5f0f\u76f8\u5339\u914d\uff0c\u540c\u65f6\u6211\u4eec\u4e0d\u4f1a\u505a\u4efb\u4f55\u591a\u91cd\u91c7\u6837\u7684\u5de5\u4f5c\uff0c\u6240\u4ee5\u91c7\u6837\u5668\u8bbe\u7f6e\u4e3a1\u3002 colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; C++ loadOp \u548c storeOp \u51b3\u5b9a\u4e86\u6e32\u67d3\u524d\u548c\u6e32\u67d3\u540e\u6570\u636e\u5728\u5bf9\u5e94\u9644\u4ef6\u7684\u64cd\u4f5c\u884c\u4e3a\u3002\u5bf9\u4e8e loadOp \u6211\u4eec\u6709\u5982\u4e0b\u9009\u9879\uff1a VK_ATTACHMENT_LOAD_OP_LOAD : \u4fdd\u5b58\u5df2\u7ecf\u5b58\u5728\u4e8e\u5f53\u524d\u9644\u4ef6\u7684\u5185\u5bb9 VK_ATTACHMENT_LOAD_OP_CLEAR : \u8d77\u59cb\u9636\u6bb5\u4ee5\u4e00\u4e2a\u5e38\u91cf\u6e05\u7406\u9644\u4ef6\u5185\u5bb9 VK_ATTACHMENT_LOAD_OP_DONT_CARE : \u5b58\u5728\u7684\u5185\u5bb9\u672a\u5b9a\u4e49\uff0c\u5ffd\u7565\u5b83\u4eec \u5728\u7ed8\u5236\u65b0\u7684\u4e00\u5e27\u5185\u5bb9\u4e4b\u524d\uff0c\u6211\u4eec\u8981\u505a\u7684\u662f\u4f7f\u7528\u6e05\u7406\u64cd\u4f5c\u6765\u6e05\u7406\u5e27\u7f13\u51b2\u533aframebuffer\u4e3a\u9ed1\u8272\u3002\u540c\u65f6\u5bf9\u4e8e storeOp \u4ec5\u6709\u4e24\u4e2a\u9009\u9879\uff1a VK_ATTACHMENT_STORE_OP_STORE : \u6e32\u67d3\u7684\u5185\u5bb9\u4f1a\u5b58\u50a8\u5728\u5185\u5b58\uff0c\u5e76\u5728\u4e4b\u540e\u8fdb\u884c\u8bfb\u53d6\u64cd\u4f5c VK_ATTACHMENT_STORE_OP_DONT_CARE : \u5e27\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u5728\u6e32\u67d3\u64cd\u4f5c\u5b8c\u6bd5\u540e\u8bbe\u7f6e\u4e3aundefined \u6211\u4eec\u8981\u505a\u7684\u662f\u6e32\u67d3\u4e00\u4e2a\u4e09\u89d2\u5f62\u5728\u5c4f\u5e55\u4e0a\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u5b58\u50a8\u64cd\u4f5c\u3002 colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; C++ loadOp \u548c storeOp \u5e94\u7528\u5728\u989c\u8272\u548c\u6df1\u5ea6\u6570\u636e\uff0c\u540c\u65f6 stencilLoadOp / stencilStoreOp \u5e94\u7528\u5728\u6a21\u7248\u6570\u636e\u3002\u6211\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u4e0d\u4f1a\u505a\u4efb\u4f55\u6a21\u7248\u7f13\u51b2\u533a\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u5b83\u7684loading\u548cstoring\u65e0\u5173\u7d27\u8981\u3002 colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; C++ \u7eb9\u7406\u548c\u5e27\u7f13\u51b2\u533a\u5728Vulkan\u4e2d\u901a\u5e38\u7528 VkImage \u5bf9\u8c61\u914d\u4ee5\u67d0\u79cd\u50cf\u7d20\u683c\u5f0f\u6765\u4ee3\u8868\u3002\u4f46\u662f\u50cf\u7d20\u5728\u5185\u5b58\u4e2d\u7684\u5e03\u5c40\u53ef\u4ee5\u57fa\u4e8e\u9884\u8981\u5bf9image\u56fe\u50cf\u8fdb\u884c\u7684\u64cd\u4f5c\u53d1\u751f\u5185\u5b58\u5e03\u5c40\u7684\u53d8\u5316\u3002 \u4e00\u4e9b\u5e38\u7528\u7684\u5e03\u5c40: VK_IMAGE_LAYOUT_COLOR_ATTACHMET_OPTIMAL : \u56fe\u50cf\u4f5c\u4e3a\u989c\u8272\u9644\u4ef6 VK_IMAGE_LAYOUT_PRESENT_SRC_KHR : \u56fe\u50cf\u5728\u4ea4\u6362\u94fe\u4e2d\u88ab\u5448\u73b0 VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL : \u56fe\u50cf\u4f5c\u4e3a\u76ee\u6807\uff0c\u7528\u4e8e\u5185\u5b58COPY\u64cd\u4f5c \u6211\u4eec\u4f1a\u6df1\u5165\u8ba8\u8bba\u8fd9\u4e9b\u5185\u5bb9\u5728\u7eb9\u7406\u7ae0\u8282\uff0c\u73b0\u5728\u6700\u91cd\u8981\u7684\u662f\u4e3a\u9700\u8981\u8f6c\u53d8\u7684\u56fe\u50cf\u6307\u5b9a\u5408\u9002\u7684layout\u5e03\u5c40\u8fdb\u884c\u64cd\u4f5c\u3002 initialLayout \u6307\u5b9a\u56fe\u50cf\u5728\u5f00\u59cb\u8fdb\u5165\u6e32\u67d3\u901a\u9053render pass\u524d\u5c06\u8981\u4f7f\u7528\u7684\u5e03\u5c40\u7ed3\u6784\u3002 finalLayout \u6307\u5b9a\u5f53\u6e32\u67d3\u901a\u9053\u7ed3\u675f\u81ea\u52a8\u53d8\u6362\u65f6\u4f7f\u7528\u7684\u5e03\u5c40\u3002\u4f7f\u7528 VK_IMAGE_LAYOUT_UNDEFINED \u8bbe\u7f6e initialLayout \uff0c\u610f\u4e3a\u4e0d\u5173\u5fc3\u56fe\u50cf\u4e4b\u524d\u7684\u5e03\u5c40\u3002\u7279\u6b8a\u503c\u8868\u660e\u56fe\u50cf\u7684\u5185\u5bb9\u4e0d\u786e\u5b9a\u4f1a\u88ab\u4fdd\u7559\uff0c\u4f46\u662f\u8fd9\u5e76\u4e0d\u603b\u8981\uff0c\u56e0\u4e3a\u65e0\u8bba\u5982\u4f55\u6211\u4eec\u90fd\u8981\u6e05\u7406\u5b83\u3002\u6211\u4eec\u5e0c\u671b\u56fe\u50cf\u6e32\u67d3\u5b8c\u6bd5\u540e\u4f7f\u7528\u4ea4\u6362\u94fe\u8fdb\u884c\u5448\u73b0\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48 finalLayout \u8981\u8bbe\u7f6e\u4e3a VK_IMAGE_LAYOUT_PRESENT_SRC_KHR \u3002 \u5982\u679c\u6ca1\u6709\u641e\u6e05\u695a\u5e03\u5c40\u5b58\u5728\u7684\u610f\u4e49\uff0c\u8fdb\u4e00\u6b65\u89e3\u91calayout\u8bf7\u770b\u5982\u4e0b\u56fe\u793a: \u4e00\u822c\u610f\u4e49\u4e0a\uff0c\u6211\u4eec\u7406\u89e3 CPU \u8fdb\u884c\u5185\u5b58\u4e2d\u7684\u6570\u636e\u8bfb\u5199\u5f80\u5f80\u90fd\u662f\u7ebf\u6027\u6392\u5e8f\u7684 linear memory layout \uff0c\u53ef\u4ee5\u770b\u5230 AB \u4e0e CD \u4f5c\u4e3a\u6765\u4e2a\u8fde\u7eed\u7684\u884c\u6765\u8fdb\u884c\u8bfb\u53d6\u3002\u4f46\u662f\u5728\u5f88\u591a\u65f6\u5019\u5bf9\u4e8e\u50cf\u7d20\u7eb9\u7406\u6570\u636e\u7684\u64cd\u4f5c\u662f\u975e\u7ebf\u6027\u8fde\u7eed\u7684\uff0c\u8fd9\u79cd\u60c5\u666f\u66f4\u591a\u53d1\u751f\u5728 GPU \u64cd\u4f5c\u4e2d\uff0c\u6240\u4ee5 GPU \u786c\u4ef6\u66f4\u591a\u7684\u652f\u6301\u57fa\u4e8e( Tiled )\u5e73\u94fa\u7684\u6216\u8005\u6210\u4e3a\u6700\u4f73\u7684\u5185\u5b58\u5e03\u5c40\u7ed3\u6784\uff0c\u6765\u63d0\u964d\u4f4e GPU \u5904\u7406\u6570\u636e\u7684\u5f00\u9500\u3002 \u6240\u4ee5\u4ece CPU linear layout \u5185\u5b58\u6570\u636e \u5230 GPU optimal layout \u663e\u5b58\u6570\u636e\u7684\u8bfb\u5199 \u5f80\u8fd4\u4e4b\u95f4\u5b58\u5728\u6570\u636e\u5b58\u50a8\u683c\u5f0f\u7684\u4f18\u5316\u8f6c\u53d8\u6b65\u9aa4\u3002","title":"\u9644\u4ef6\u63cf\u8ff0"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_42","text":"\u4e00\u4e2a\u5355\u72ec\u7684\u6e32\u67d3\u901a\u9053\u53ef\u4ee5\u7531\u591a\u4e2a\u5b50\u901a\u9053\u7ec4\u6210\u3002\u5b50\u901a\u9053\u662f\u6e32\u67d3\u64cd\u4f5c\u7684\u4e00\u4e2a\u5e8f\u5217\u3002\u5b50\u901a\u9053\u4f5c\u7528\u4e0e\u540e\u7eed\u7684\u6e32\u67d3\u64cd\u4f5c\uff0c\u5e76\u4f9d\u8d56\u4e4b\u524d\u6e32\u67d3\u901a\u9053\u8f93\u51fa\u5230\u5e27\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u3002\u6bd4\u5982\u8bf4\u540e\u5904\u7406\u6548\u679c\u7684\u5e8f\u5217\u901a\u5e38\u6bcf\u4e00\u6b65\u90fd\u4f9d\u8d56\u4e4b\u524d\u7684\u64cd\u4f5c\u3002\u5982\u679c\u5c06\u8fd9\u4e9b\u6e32\u67d3\u64cd\u4f5c\u5206\u7ec4\u5230\u4e00\u4e2a\u6e32\u67d3\u901a\u9053\u4e2d\uff0c\u901a\u8fc7 Vulkan \u5c06\u901a\u9053\u4e2d\u7684\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u91cd\u6392\u5e8f\uff0c\u53ef\u4ee5\u8282\u7701\u5185\u5b58\u4ece\u800c\u83b7\u5f97\u66f4\u597d\u7684\u6027\u80fd\u3002\u5bf9\u4e8e\u6211\u4eec\u8981\u7ed8\u5236\u7684\u4e09\u89d2\u5f62\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4e00\u4e2a\u5b50\u901a\u9053\u3002 \u6bcf\u4e2a\u5b50\u901a\u9053\u5f15\u7528\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\u4e4b\u524d\u4f7f\u7528\u7ed3\u6784\u4f53\u63cf\u8ff0\u7684\u9644\u4ef6\u3002\u8fd9\u4e9b\u5f15\u7528\u672c\u8eab\u5c31\u662f VkAttachmentReference \u7ed3\u6784\u4f53: VkAttachmentReference colorAttachmentRef = {}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; C++ attachment \u9644\u4ef6\u53c2\u6570\u901a\u8fc7\u9644\u4ef6\u63cf\u8ff0\u7b26\u96c6\u5408\u4e2d\u7684\u7d22\u5f15\u6765\u6301\u6709\u3002\u6211\u4eec\u7684\u96c6\u5408\u662f\u7531\u4e00\u4e2a VkAttachmentDesription \u7ec4\u6210\u7684\uff0c\u6240\u4ee5\u5b83\u7684\u7d22\u5f15\u4e3a 0 \u3002 layout \u4e3a\u9644\u4ef6\u6307\u5b9a\u5b50\u901a\u9053\u5728\u6301\u6709\u5f15\u7528\u65f6\u5019\u7684layout\u3002\u5f53\u5b50\u901a\u9053\u5f00\u59cb\u7684\u65f6\u5019Vulkan\u4f1a\u81ea\u52a8\u8f6c\u53d8\u9644\u4ef6\u5230\u8fd9\u4e2alayout\u3002\u56e0\u4e3a\u6211\u4eec\u671f\u671b\u9644\u4ef6\u8d77\u5230\u989c\u8272\u7f13\u51b2\u533a\u7684\u4f5c\u7528\uff0clayout\u8bbe\u7f6e\u4e3a VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL \u4f1a\u7ed9\u6211\u4eec\u6700\u597d\u7684\u6027\u80fd\u3002 \u5b50\u901a\u9053\u4f7f\u7528 VkSubpassDescription \u7ed3\u6784\u4f53\u63cf\u8ff0: VkSubpassDescription subpass = {}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; C++ Vulkan\u5728\u672a\u6765\u53ef\u80fd\u4f1a\u652f\u6301\u5173\u4e8e compute subpasses \u7684\u529f\u80fd\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u4eec\u660e\u786e\u6307\u5b9a graphics subpass \u56fe\u5f62\u5b50\u901a\u9053\u3002\u4e0b\u4e00\u6b65\u4e3a\u5b83\u6307\u5b9a\u989c\u8272\u9644\u4ef6\u7684\u5f15\u7528: subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; C++ \u9644\u4ef6\u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15\u76f4\u63a5\u4ece\u7247\u6bb5\u7740\u8272\u5668\u5f15\u7528\uff0c\u5176 layout(location = 0) out vec4 outColor \u6307\u4ee4! \u53ef\u4ee5\u88ab\u5b50\u901a\u9053\u5f15\u7528\u7684\u9644\u4ef6\u7c7b\u578b\u5982\u4e0b: pInputAttachments : \u9644\u4ef6\u4ece\u7740\u8272\u5668\u4e2d\u8bfb\u53d6 pResolveAttachments : \u9644\u4ef6\u7528\u4e8e\u989c\u8272\u9644\u4ef6\u7684\u591a\u91cd\u91c7\u6837 pDepthStencilAttachment : \u9644\u4ef6\u7528\u4e8e\u6df1\u5ea6\u548c\u6a21\u7248\u6570\u636e pPreserveAttachments : \u9644\u4ef6\u4e0d\u88ab\u5b50\u901a\u9053\u4f7f\u7528\uff0c\u4f46\u662f\u6570\u636e\u88ab\u4fdd\u5b58","title":"\u5b50\u901a\u9053\u548c\u9644\u4ef6\u5f15\u7528"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_43","text":"\u73b0\u5728\u9644\u4ef6\u548c\u57fa\u672c\u7684\u5b50\u901a\u9053\u5df2\u7ecf\u4ecb\u7ecd\u8fc7\u4e86\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u6e32\u67d3\u901a\u9053\u4e86\u3002\u9996\u5148\u65b0\u5efa\u4e00\u4e2a\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709 VkRenderPass \u5bf9\u8c61\uff0c\u8be5\u53d8\u91cf\u5728 pipelineLayout \u4e0a\u5b9a\u4e49: VkRenderPass renderPass; VkPipelineLayout pipelineLayout; C++ \u6e32\u67d3\u901a\u9053\u5bf9\u8c61\u521b\u5efa\u901a\u8fc7\u586b\u5145 VkRenderPassCreateInfo \u7ed3\u6784\u4f53\uff0c\u5e76\u914d\u5408\u76f8\u5173\u9644\u4ef6\u548c\u5b50\u901a\u9053\u6765\u5b8c\u6210\u3002 VkAttachmentReference \u5bf9\u8c61\u5f15\u7528\u9644\u4ef6\u6570\u7ec4\u3002 VkRenderPassCreateInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } C++ \u5c31\u50cf pipeline layout \u4e00\u6837\uff0c\u6e32\u67d3\u901a\u9053\u5728\u6574\u4e2a\u7a0b\u5e8f\u751f\u547d\u5468\u671f\u5185\u90fd\u88ab\u4f7f\u7528\uff0c\u6240\u4ee5\u9700\u8981\u5728\u9000\u51fa\u9636\u6bb5\u8fdb\u884c\u6e05\u7406\uff1a void cleanup() { vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); ... } C++ \u8fd9\u770b\u8d77\u6765\u5f88\u591a\u5de5\u4f5c\u91cf\uff0c\u4f46\u662f\u5728 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u4f1a\u628a\u6240\u6709\u7684\u7ec4\u4ef6\u6574\u5408\u8d77\u6765\uff0c\u521b\u5efa\u6700\u7ec8\u7684\u56fe\u5f62\u7ba1\u7ebf\u5bf9\u8c61\u3002","title":"\u6e32\u67d3\u901a\u9053"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_11","text":"ulkan \u96c6\u6210\u7ba1\u7ebf \uff0c\u6211\u4eec\u73b0\u5728\u6574\u5408\u524d\u51e0\u7ae0\u8282\u7684\u7ed3\u6784\u4f53\u548c \u5bf9\u8c61\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf \uff01\u4ee5\u4e0b\u662f\u6211\u4eec\u73b0\u5728\u7528\u5230\u7684\u5bf9\u8c61\u7c7b\u578b\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u5feb\u901f\u56de\u987e: Shader stages : \u7740\u8272\u5668\u6a21\u5757\u5b9a\u4e49\u4e86\u56fe\u5f62\u7ba1\u7ebf\u53ef\u7f16\u7a0b\u9636\u6bb5\u7684\u529f\u80fd Fixed-function state : \u7ed3\u6784\u4f53\u5b9a\u4e49\u56fa\u5b9a\u7ba1\u7ebf\u529f\u80fd\uff0c\u6bd4\u5982\u8f93\u5165\u88c5\u914d\u3001\u5149\u6805\u5316\u3001viewport\u548ccolor blending Pipeline layout : \u7ba1\u7ebf\u5e03\u5c40\u5b9a\u4e49uniform \u548c push values\uff0c\u88ab\u7740\u8272\u5668\u6bcf\u4e00\u6b21\u7ed8\u5236\u7684\u65f6\u5019\u5f15\u7528 Render pass : \u6e32\u67d3\u901a\u9053\u901a\u8fc7\u7ba1\u7ebf\u9636\u6bb5\u5f15\u7528\u9644\u4ef6\uff0c\u5e76\u5b9a\u4e49\u5b83\u7684\u4f7f\u7528\u65b9\u5f0f \u6240\u6709\u8fd9\u4e9b\u51b3\u5b9a\u4e86\u56fe\u5f62\u7ba1\u7ebf\u7684\u6700\u7ec8\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u5728 createGraphicsPipeline \u51fd\u6570\u7684\u6700\u540e\u586b\u5145 VkGraphicsPipelineCreateInfo \u7ed3\u6784\u4f53\u3002 VkGraphicsPipelineCreateInfo pipelineInfo = {}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 2; pipelineInfo.pStages = shaderStages; C++ \u73b0\u5728\u5f00\u59cb\u5f15\u7528\u4e4b\u524d\u7684 VkPipelineShaderStageCreateInfo \u7ed3\u6784\u4f53\u6570\u7ec4\u3002 pipelineInfo.pVertexInputState = &vertexInputInfo; pipelineInfo.pInputAssemblyState = &inputAssembly; pipelineInfo.pViewportState = &viewportState; pipelineInfo.pRasterizationState = &rasterizer; pipelineInfo.pMultisampleState = &multisampling; pipelineInfo.pDepthStencilState = nullptr; // Optional pipelineInfo.pColorBlendState = &colorBlending; pipelineInfo.pDynamicState = nullptr; // Optional C++ \u5e76\u5f15\u7528\u4e4b\u524d\u63cf\u8ff0\u56fa\u5b9a\u7ba1\u7ebf\u529f\u80fd\u7684\u7ed3\u6784\u4f53\u3002 pipelineInfo.layout = pipelineLayout; C++ \u5b8c\u6210\u4e4b\u540e\uff0c pipeline layout \u7ba1\u7ebf\u5e03\u5c40\uff0c\u5b83\u662f\u4e00\u4e2a Vulkan \u53e5\u67c4\u800c\u4e0d\u662f\u7ed3\u6784\u4f53\u6307\u9488\u3002 pipelineInfo.renderPass = renderPass; pipelineInfo.subpass = 0; C++ \u6700\u540e\u6211\u4eec\u9700\u8981\u5f15\u7528 render pass \u548c\u56fe\u5f62\u7ba1\u7ebf\u5c06\u8981\u4f7f\u7528\u7684\u5b50\u901a\u9053 sub pass \u7684\u7d22\u5f15\u3002 pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; // Optional pipelineInfo.basePipelineIndex = -1; // Optional C++ \u5b9e\u9645\u4e0a\u8fd8\u6709\u4e24\u4e2a\u53c2\u6570: basePipelineHandle \u548c basePipelineIndex \u3002Vulkan\u5141\u8bb8\u60a8\u901a\u8fc7\u5df2\u7ecf\u5b58\u5728\u7684\u7ba1\u7ebf\u521b\u5efa\u65b0\u7684\u56fe\u5f62\u7ba1\u7ebf\u3002\u8fd9\u79cd\u884d\u751f\u51fa\u65b0\u7ba1\u7ebf\u7684\u60f3\u6cd5\u5728\u4e8e\uff0c\u5f53\u8981\u521b\u5efa\u7684\u7ba1\u7ebf\u4e0e\u73b0\u6709\u7ba1\u9053\u529f\u80fd\u76f8\u540c\u65f6\uff0c\u83b7\u5f97\u8f83\u4f4e\u7684\u5f00\u9500\uff0c\u540c\u65f6\u4e5f\u53ef\u4ee5\u66f4\u5feb\u7684\u5b8c\u6210\u7ba1\u7ebf\u5207\u6362\uff0c\u5f53\u5b83\u4eec\u6765\u81ea\u540c\u4e00\u4e2a\u7236\u7ba1\u7ebf\u3002\u53ef\u4ee5\u901a\u8fc7 basePipelineHandle \u6307\u5b9a\u73b0\u6709\u7ba1\u7ebf\u7684\u53e5\u67c4\uff0c\u4e5f\u53ef\u4ee5\u5f15\u7528\u7531 basePipelineIndex \u6240\u4ee5\u521b\u5efa\u7684\u53e6\u4e00\u4e2a\u7ba1\u7ebf\u3002\u76ee\u524d\u53ea\u6709\u4e00\u4e2a\u7ba1\u7ebf\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u6307\u5b9a\u4e00\u4e2a\u7a7a\u53e5\u67c4\u548c\u4e00\u4e2a\u65e0\u6548\u7684\u7d22\u5f15\u3002\u53ea\u6709\u5728 VkGraphicsPipelineCreateInfo \u7684 flags \u5b57\u6bb5\u4e2d\u4e5f\u6307\u5b9a\u4e86 VK_PIPELINE_CREATE_DERIVATIVE_BIT \u6807\u5fd7\u65f6\uff0c\u624d\u9700\u8981\u4f7f\u7528\u8fd9\u4e9b\u503c\u3002 \u73b0\u5728\u51c6\u5907\u6700\u540e\u4e00\u6b65\uff0c\u521b\u5efa\u4e00\u4e2a\u7c7b\u6210\u5458\u4fdd\u5b58 VkPipeline \u5bf9\u8c61: VkPipeline graphicsPipeline; C++ \u6700\u540e\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf: if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline) != VK_SUCCESS) { throw std::runtime_error(\"failed to create graphics pipeline!\"); } C++ vkCreateGraphicsPipelines \u51fd\u6570\u5728Vulkan\u4e2d\u6bd4\u8d77\u4e00\u822c\u7684\u521b\u5efa\u5bf9\u8c61\u51fd\u6570\u9700\u8981\u66f4\u591a\u7684\u53c2\u6570\u3002\u5b83\u53ef\u4ee5\u7528\u6765\u4f20\u9012\u591a\u4e2a VkGraphicsPipelineCreateInfo \u5bf9\u8c61\u5e76\u521b\u5efa\u591a\u4e2a VkPipeline \u5bf9\u8c61\u3002 \u6211\u4eec\u4f20\u9012 VK_NULL_HANDLE \u53c2\u6570\u4f5c\u4e3a\u7b2c\u4e8c\u4e2a\u53c2\u6570\uff0c\u4f5c\u4e3a\u53ef\u9009 VkPipelineCache \u5bf9\u8c61\u7684\u5f15\u7528\u3002\u7ba1\u7ebf\u7f13\u5b58\u53ef\u4ee5\u7528\u4e8e\u5b58\u50a8\u548c\u590d\u7528\u4e0e\u901a\u8fc7\u591a\u6b21\u8c03\u7528 vkCreateGraphicsPipelines \u51fd\u6570\u76f8\u5173\u7684\u6570\u636e\uff0c\u751a\u81f3\u5728\u7a0b\u5e8f\u6267\u884c\u7684\u65f6\u5019\u7f13\u5b58\u5230\u4e00\u4e2a\u6587\u4ef6\u4e2d\u3002\u8fd9\u6837\u53ef\u4ee5\u52a0\u901f\u540e\u7eed\u7684\u7ba1\u7ebf\u521b\u5efa\u903b\u8f91\u3002\u5177\u4f53\u7684\u5185\u5bb9\u6211\u4eec\u4f1a\u5728\u7ba1\u7ebf\u7f13\u5b58\u7ae0\u8282\u4ecb\u7ecd\u3002 \u56fe\u5f62\u7ba1\u7ebf\u5bf9\u4e8e\u5e38\u89c1\u7684\u7ed8\u56fe\u64cd\u4f5c\u662f\u5fc5\u987b\u7684\uff0c\u6240\u4ee5\u5b83\u4e5f\u5e94\u8be5\u5728\u7a0b\u5e8f\u7ed3\u675f\u65f6\u9500\u6bc1: void cleanup() { vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ... } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\uff0c\u786e\u8ba4\u6240\u6709\u5de5\u4f5c\u6b63\u5e38\uff0c\u5e76\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u6210\u529f\uff01\u6211\u4eec\u5df2\u7ecf\u65e0\u6bd4\u63a5\u8fd1\u5728\u5c4f\u5e55\u4e0a\u7ed8\u5236\u51fa\u4e1c\u897f\u6765\u4e86\u3002\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u4e2a\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4ece\u4ea4\u6362\u94fe\u56fe\u50cf\u4e2d\u8bbe\u7f6e\u5b9e\u9645\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u51c6\u5907\u7ed8\u5236\u547d\u4ee4\u3002","title":"Vulkan \u96c6\u6210\u7ba1\u7ebf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_12","text":"Vulkan \u547d\u4ee4\u7f13\u51b2\u533a \uff0c\u8bf8\u5982\u7ed8\u5236\u548c\u5185\u5b58\u64cd\u4f5c\u76f8\u5173\u547d\u4ee4\uff0c\u5728 Vulkan \u4e2d\u4e0d\u662f\u901a\u8fc7\u51fd\u6570\u76f4\u63a5\u8c03\u7528\u7684\u3002\u6211\u4eec\u9700\u8981\u5728\u547d\u4ee4\u7f13\u51b2\u533a\u5bf9\u8c61\u4e2d\u8bb0\u5f55\u6211\u4eec\u671f\u671b\u7684\u4efb\u4f55\u64cd\u4f5c\u3002\u8fd9\u6837\u505a\u7684\u4f18\u70b9\u662f\u53ef\u4ee5\u63d0\u524d\u5728\u591a\u7ebf\u7a0b\u4e2d\u5b8c\u6210\u6240\u6709\u7ed8\u5236\u547d\u4ee4\u76f8\u5173\u7684\u88c5\u914d\u5de5\u4f5c\uff0c\u5e76\u5728\u4e3b\u7ebf\u7a0b\u5faa\u73af\u7ed3\u6784\u4e2d\u901a\u77e5 Vulkan \u6267\u884c\u5177\u4f53\u7684\u547d\u4ee4\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u547d\u4ee4\u6c60 2 \u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a 3 \u542f\u52a8\u547d\u4ee4\u7f13\u51b2\u8bb0\u5f55 4 \u542f\u52a8\u6e32\u67d3\u901a\u9053 5 \u57fa\u672c\u7ed8\u56fe\u547d\u4ee4 6 \u7ed3\u675f\u6e32\u67d3","title":"Vulkan \u547d\u4ee4\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_44","text":"\u6211\u4eec\u5728\u4f7f\u7528\u4efb\u4f55 command buffers \u4e4b\u524d\u9700\u8981\u521b\u5efa\u547d\u4ee4\u5bf9\u8c61\u6c60 command pool \u3002 Command pools \u7ba1\u7406\u7528\u4e8e\u5b58\u50a8\u7f13\u51b2\u533a\u7684\u5185\u5b58\uff0c\u5e76\u4ece\u4e2d\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u6dfb\u52a0\u65b0\u7684\u7c7b\u6210\u5458\u4fdd\u5b58 VkCommandPool : VkCommandPool commandPool; \u521b\u5efa\u65b0\u7684\u51fd\u6570 createCommandPool \u5e76\u5728 initVulkan \u51fd\u6570\u521b\u5efa\u5b8c framebuffers \u540e\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); } ... void createCommandPool() { } \u547d\u4ee4\u5bf9\u8c61\u6c60\u521b\u5efa\u4ec5\u4ec5\u9700\u8981\u4e24\u4e2a\u53c2\u6570: QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice); VkCommandPoolCreateInfo poolInfo = {}; poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily; poolInfo.flags = 0; // Optional \u547d\u4ee4\u7f13\u51b2\u533a\u901a\u8fc7\u5c06\u5176\u63d0\u4ea4\u5230\u5176\u4e2d\u4e00\u4e2a\u8bbe\u5907\u961f\u5217\u4e0a\u6765\u6267\u884c\uff0c\u5982\u6211\u4eec\u68c0\u7d22\u7684 graphics \u548c presentation \u961f\u5217\u3002\u6bcf\u4e2a\u547d\u4ee4\u5bf9\u8c61\u6c60\u53ea\u80fd\u5206\u914d\u5728\u5355\u4e00\u7c7b\u578b\u7684\u961f\u5217\u4e0a\u63d0\u4ea4\u7684\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u6362\u53e5\u8bdd\u8bf4\u8981\u5206\u914d\u7684\u547d\u4ee4\u9700\u8981\u4e0e\u961f\u5217\u7c7b\u578b\u4e00\u81f4\u3002\u6211\u4eec\u8981\u8bb0\u5f55\u7ed8\u5236\u7684\u547d\u4ee4\uff0c\u8fd9\u5c31\u8bf4\u660e\u4e3a\u4ec0\u4e48\u8981\u9009\u62e9\u56fe\u5f62\u961f\u5217\u7c07\u7684\u539f\u56e0\u3002 \u6709\u4e24\u4e2a\u6807\u5fd7\u4f4d\u7528\u4e8e command pools : VK_COMMAND_POOL_CREATE_TRANSIENT_BIT : \u63d0\u793a\u547d\u4ee4\u7f13\u51b2\u533a\u975e\u5e38\u9891\u7e41\u7684\u91cd\u65b0\u8bb0\u5f55\u65b0\u547d\u4ee4(\u53ef\u80fd\u4f1a\u6539\u53d8\u5185\u5b58\u5206\u914d\u884c\u4e3a) VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT : \u5141\u8bb8\u547d\u4ee4\u7f13\u51b2\u533a\u5355\u72ec\u91cd\u65b0\u8bb0\u5f55\uff0c\u6ca1\u6709\u8fd9\u4e2a\u6807\u5fd7\uff0c\u6240\u6709\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u90fd\u5fc5\u987b\u4e00\u8d77\u91cd\u7f6e \u6211\u4eec\u4ec5\u4ec5\u5728\u7a0b\u5e8f\u5f00\u59cb\u7684\u65f6\u5019\u8bb0\u5f55\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u5e76\u5728\u4e3b\u5faa\u73af\u4f53 main loop \u4e2d\u591a\u6b21\u6267\u884c\uff0c\u56e0\u6b64\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u8fd9\u4e9b\u6807\u5fd7\u3002 if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) { throw std::runtime_error(\"failed to create command pool!\"); } \u901a\u8fc7 vkCreateCommandPool \u51fd\u6570\u5b8c\u6210 command pool \u521b\u5efa\u5de5\u4f5c\u3002\u5b83\u4e0d\u9700\u8981\u4efb\u4f55\u7279\u6b8a\u7684\u53c2\u6570\u8bbe\u7f6e\u3002\u547d\u4ee4\u5c06\u88ab\u6574\u4e2a\u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\u4f7f\u7528\u4ee5\u5b8c\u6210\u5c4f\u5e55\u7684\u7ed8\u5236\u5de5\u4f5c\uff0c\u6240\u4ee5\u5bf9\u8c61\u6c60\u5e94\u8be5\u88ab\u5728\u6700\u540e\u9500\u6bc1: void cleanup() { vkDestroyCommandPool(device, commandPool, nullptr); ... }","title":"\u547d\u4ee4\u6c60"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_45","text":"\u73b0\u5728\u6211\u4eec\u5f00\u59cb\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a\u5e76\u901a\u8fc7\u5b83\u4eec\u8bb0\u5f55\u7ed8\u5236\u6307\u4ee4\u3002\u56e0\u4e3a\u5176\u4e2d\u4e00\u4e2a\u7ed8\u56fe\u547d\u4ee4\u9700\u8981\u6b63\u786e\u7ed1\u5b9a VkFrameBuffer \uff0c\u6211\u4eec\u5b9e\u9645\u4e0a\u9700\u8981\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u8bb0\u5f55\u4e00\u4e2a\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u6700\u540e\u521b\u5efa\u4e00\u4e2a VkCommandBuffer \u5bf9\u8c61\u5217\u8868\u4f5c\u4e3a\u6210\u5458\u53d8\u91cf\u3002\u547d\u4ee4\u7f13\u51b2\u533a\u4f1a\u5728 common pool \u9500\u6bc1\u7684\u65f6\u5019\u81ea\u52a8\u91ca\u653e\u7cfb\u7edf\u8d44\u6e90\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u660e\u786e\u7f16\u5199 cleanup \u903b\u8f91\u3002 std::vector<VkCommandBuffer> commandBuffers; \u73b0\u5728\u5f00\u59cb\u4f7f\u7528\u4e00\u4e2a createCommandBuffers \u51fd\u6570\u6765\u5206\u914d\u548c\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u56fe\u50cf\u5c06\u8981\u5e94\u7528\u7684\u547d\u4ee4\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); } ... void createCommandBuffers() { commandBuffers.resize(swapChainFramebuffers.size()); } \u547d\u4ee4\u7f13\u51b2\u533a\u901a\u8fc7 vkAllocateCommandBuffers \u51fd\u6570\u5206\u914d\uff0c\u5b83\u9700\u8981 VkCommandBufferAllocateInfo \u7ed3\u6784\u4f53\u4f5c\u4e3a\u53c2\u6570\uff0c\u7528\u4ee5\u6307\u5b9a command pool \u548c\u7f13\u51b2\u533a\u5c06\u4f1a\u5206\u914d\u7684\u5927\u5c0f: VkCommandBufferAllocateInfo allocInfo = {}; allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; allocInfo.commandPool = commandPool; allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; allocInfo.commandBufferCount = (uint32_t) commandBuffers.size(); if (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.data()) != VK_SUCCESS) { throw std::runtime_error(\"failed to allocate command buffers!\"); } level \u53c2\u6570\u6307\u5b9a\u5206\u914d\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u4e3b\u4ece\u5173\u7cfb\u3002 VK_COMMAND_BUFFER_LEVEL_PRIMARY : \u53ef\u4ee5\u63d0\u4ea4\u5230\u961f\u5217\u6267\u884c\uff0c\u4f46\u4e0d\u80fd\u4ece\u5176\u4ed6\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u8c03\u7528\u3002 VK_COMMAND_BUFFER_LEVEL_SECONDARY : \u65e0\u6cd5\u76f4\u63a5\u63d0\u4ea4\uff0c\u4f46\u662f\u53ef\u4ee5\u4ece\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u8c03\u7528\u3002 \u6211\u4eec\u4e0d\u4f1a\u5728\u8fd9\u91cc\u4f7f\u7528\u8f85\u52a9\u7f13\u51b2\u533a\u529f\u80fd\uff0c\u4f46\u662f\u53ef\u4ee5\u60f3\u50cf\uff0c\u5bf9\u4e8e\u590d\u7528\u4e3b\u7f13\u51b2\u533a\u7684\u5e38\u7528\u64cd\u4f5c\u5f88\u6709\u5e2e\u52a9\u3002","title":"\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_46","text":"\u901a\u8fc7 vkBeginCommandBuffer \u6765\u5f00\u542f\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u8bb0\u5f55\u529f\u80fd\uff0c\u8be5\u51fd\u6570\u9700\u8981\u4f20\u9012 VkCommandBufferBeginInfo \u7ed3\u6784\u4f53\u4f5c\u4e3a\u53c2\u6570\uff0c\u7528\u4ee5\u6307\u5b9a\u547d\u4ee4\u7f13\u51b2\u533a\u5728\u4f7f\u7528\u8fc7\u7a0b\u4e2d\u7684\u4e00\u4e9b\u5177\u4f53\u4fe1\u606f\u3002 for (size_t i = 0; i < commandBuffers.size(); i++) { VkCommandBufferBeginInfo beginInfo = {}; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT; beginInfo.pInheritanceInfo = nullptr; // Optional vkBeginCommandBuffer(commandBuffers[i], &beginInfo); } flags \u6807\u5fd7\u4f4d\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u5982\u4f55\u4f7f\u7528\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u53ef\u9009\u7684\u53c2\u6570\u7c7b\u578b\u5982\u4e0b: VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT : \u547d\u4ee4\u7f13\u51b2\u533a\u5c06\u5728\u6267\u884c\u4e00\u6b21\u540e\u7acb\u5373\u91cd\u65b0\u8bb0\u5f55\u3002 VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT : \u8fd9\u662f\u4e00\u4e2a\u8f85\u52a9\u7f13\u51b2\u533a\uff0c\u5b83\u9650\u5236\u5728\u5728\u4e00\u4e2a\u6e32\u67d3\u901a\u9053\u4e2d\u3002 VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT : \u547d\u4ee4\u7f13\u51b2\u533a\u4e5f\u53ef\u4ee5\u91cd\u65b0\u63d0\u4ea4\uff0c\u540c\u65f6\u5b83\u4e5f\u5728\u7b49\u5f85\u6267\u884c\u3002 \u6211\u4eec\u4f7f\u7528\u4e86\u6700\u540e\u4e00\u4e2a\u6807\u5fd7\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u80fd\u5df2\u7ecf\u5728\u4e0b\u4e00\u5e27\u7684\u65f6\u5019\u5b89\u6392\u4e86\u7ed8\u5236\u547d\u4ee4\uff0c\u800c\u6700\u540e\u4e00\u5e27\u5c1a\u672a\u5b8c\u6210\u3002 pInheritanceInfo \u53c2\u6570\u4e0e\u8f85\u52a9\u7f13\u51b2\u533a\u76f8\u5173\u3002\u5b83\u6307\u5b9a\u4ece\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u7ee7\u627f\u7684\u72b6\u6001\u3002 \u5982\u679c\u547d\u4ee4\u7f13\u51b2\u533a\u5df2\u7ecf\u88ab\u8bb0\u5f55\u4e00\u6b21\uff0c\u90a3\u4e48\u8c03\u7528 vkBeginCommandBuffer \u4f1a\u9690\u5f0f\u5730\u91cd\u7f6e\u5b83\u3002\u5426\u5219\u5c06\u547d\u4ee4\u9644\u52a0\u5230\u7f13\u51b2\u533a\u662f\u4e0d\u53ef\u80fd\u7684\u3002","title":"\u542f\u52a8\u547d\u4ee4\u7f13\u51b2\u8bb0\u5f55"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_47","text":"\u7ed8\u5236\u5f00\u59cb\u4e8e\u8c03\u7528 vkCmdBeginRenderPass \u5f00\u542f\u6e32\u67d3\u901a\u9053\u3002render pass\u4f7f\u7528 VkRenderPassBeginInfo \u7ed3\u6784\u4f53\u586b\u5145\u914d\u7f6e\u4fe1\u606f\u4f5c\u4e3a\u8c03\u7528\u65f6\u4f7f\u7528\u7684\u53c2\u6570\u3002 VkRenderPassBeginInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; renderPassInfo.renderPass = renderPass; renderPassInfo.framebuffer = swapChainFramebuffers[i]; \u7ed3\u6784\u4f53\u7b2c\u4e00\u4e2a\u53c2\u6570\u4f20\u9012\u4e3a\u7ed1\u5b9a\u5230\u5bf9\u5e94\u9644\u4ef6\u7684\u6e32\u67d3\u901a\u9053\u672c\u8eab\u3002\u6211\u4eec\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u521b\u5efa\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u6307\u5b9a\u4e3a\u989c\u8272\u9644\u4ef6\u3002 renderPassInfo.renderArea.offset = {0, 0}; renderPassInfo.renderArea.extent = swapChainExtent; \u540e\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u4e86\u6e32\u67d3\u533a\u57df\u7684\u5927\u5c0f\u3002\u6e32\u67d3\u533a\u57df\u5b9a\u4e49\u7740\u8272\u5668\u52a0\u8f7d\u548c\u5b58\u50a8\u5c06\u8981\u53d1\u751f\u7684\u4f4d\u7f6e\u3002\u533a\u57df\u5916\u7684\u50cf\u7d20\u5c06\u5177\u6709\u672a\u5b9a\u7684\u503c\u3002\u4e3a\u4e86\u6700\u4f73\u7684\u6027\u80fd\u5b83\u7684\u5c3a\u5bf8\u5e94\u8be5\u4e0e\u9644\u4ef6\u5339\u914d\u3002 VkClearValue clearColor = {0.0f, 0.0f, 0.0f, 1.0f}; renderPassInfo.clearValueCount = 1; renderPassInfo.pClearValues = &clearColor; \u6700\u540e\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u4e86\u7528\u4e8e VK_ATTACHMENT_LOAD_OP_CLEAR \u7684\u6e05\u9664\u503c\uff0c\u6211\u4eec\u5c06\u5176\u7528\u4f5c\u989c\u8272\u9644\u4ef6\u7684\u52a0\u8f7d\u64cd\u4f5c\u3002\u4e3a\u4e86\u7b80\u5316\u64cd\u4f5c\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86 clear color \u4e3a100%\u9ed1\u8272\u3002 vkCmdBeginRenderPass(commandBuffers[i], &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE); \u6e32\u67d3\u901a\u9053\u73b0\u5728\u53ef\u4ee5\u542f\u7528\u3002\u6240\u6709\u53ef\u4ee5\u88ab\u8bb0\u5f55\u7684\u547d\u4ee4\uff0c\u88ab\u8bc6\u522b\u7684\u524d\u63d0\u662f\u4f7f\u7528 vkCmd \u524d\u7f00\u3002\u5b83\u4eec\u5168\u90e8\u8fd4\u56de void \uff0c\u6240\u4ee5\u5728\u7ed3\u675f\u8bb0\u5f55\u4e4b\u524d\u4e0d\u4f1a\u6709\u4efb\u4f55\u9519\u8bef\u5904\u7406\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u547d\u4ee4\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u603b\u662f\u8bb0\u5f55\u8be5\u547d\u4ee4\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u7b2c\u4e8c\u4e2a\u53c2\u6570\u6307\u5b9a\u6211\u4eec\u4f20\u9012\u7684\u6e32\u67d3\u901a\u9053\u7684\u5177\u4f53\u4fe1\u606f\u3002\u6700\u540e\u7684\u53c2\u6570\u63a7\u5236\u5982\u4f55\u63d0\u4f9b render pass \u5c06\u8981\u5e94\u7528\u7684\u7ed8\u5236\u547d\u4ee4\u3002\u5b83\u4f7f\u7528\u4ee5\u4e0b\u6570\u503c\u4efb\u610f\u4e00\u4e2a: VK_SUBPASS_CONTENTS_INLINE : \u6e32\u67d3\u8fc7\u7a0b\u547d\u4ee4\u88ab\u5d4c\u5165\u5728\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u4e2d\uff0c\u6ca1\u6709\u8f85\u52a9\u7f13\u51b2\u533a\u6267\u884c\u3002 VK_SUBPASS_CONTENTS_SECONDARY_COOMAND_BUFFERS : \u6e32\u67d3\u901a\u9053\u547d\u4ee4\u5c06\u4f1a\u4ece\u8f85\u52a9\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u3002 \u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u8f85\u52a9\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u7b2c\u4e00\u4e2a\u3002","title":"\u542f\u52a8\u6e32\u67d3\u901a\u9053"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_48","text":"\u73b0\u5728\u6211\u4eec\u7ed1\u5b9a\u56fe\u5f62\u7ba1\u7ebf: vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline); \u7b2c\u4e8c\u4e2a\u53c2\u6570\u6307\u5b9a\u5177\u4f53\u7ba1\u7ebf\u7c7b\u578b\uff0c graphics or compute pipeline \u3002\u6211\u4eec\u544a\u8bc9Vulkan\u5728\u56fe\u5f62\u7ba1\u7ebf\u4e2d\u6bcf\u4e00\u4e2a\u64cd\u4f5c\u5982\u4f55\u6267\u884c\u53ca\u54ea\u4e2a\u9644\u4ef6\u5c06\u4f1a\u5728\u7247\u6bb5\u7740\u8272\u5668\u4e2d\u4f7f\u7528\uff0c\u6240\u4ee5\u5269\u4e0b\u7684\u5c31\u662f\u544a\u8bc9\u5b83\u7ed8\u5236\u4e09\u89d2\u5f62\u3002 vkCmdDraw(commandBuffers[i], 3, 1, 0, 0); C++ \u5b9e\u9645\u7684 vkCmdDraw \u51fd\u6570\u6709\u70b9\u4e0e\u5b57\u9762\u610f\u601d\u4e0d\u4e00\u81f4\uff0c\u5b83\u662f\u5982\u6b64\u7b80\u5355\uff0c\u4ec5\u56e0\u4e3a\u6211\u4eec\u63d0\u524d\u6307\u5b9a\u6240\u6709\u6e32\u67d3\u76f8\u5173\u7684\u4fe1\u606f\u3002\u5b83\u6709\u5982\u4e0b\u7684\u53c2\u6570\u9700\u8981\u6307\u5b9a\uff0c\u9664\u4e86\u547d\u4ee4\u7f13\u51b2\u533a: vertexCount : \u5373\u4f7f\u6211\u4eec\u6ca1\u6709\u9876\u70b9\u7f13\u51b2\u533a\uff0c\u4f46\u662f\u6211\u4eec\u4ecd\u7136\u67093\u4e2a\u5b9a\u70b9\u9700\u8981\u7ed8\u5236\u3002 instanceCount : \u7528\u4e8einstanced \u6e32\u67d3\uff0c\u5982\u679c\u6ca1\u6709\u4f7f\u7528\u8bf7\u586b1\u3002 firstVertex : \u4f5c\u4e3a\u9876\u70b9\u7f13\u51b2\u533a\u7684\u504f\u79fb\u91cf\uff0c\u5b9a\u4e49gl_VertexIndex\u7684\u6700\u5c0f\u503c\u3002 firstInstance : \u4f5c\u4e3ainstanced \u6e32\u67d3\u7684\u504f\u79fb\u91cf\uff0c\u5b9a\u4e49\u4e86gl_InstanceIndex\u7684\u6700\u5c0f\u503c\u3002","title":"\u57fa\u672c\u7ed8\u56fe\u547d\u4ee4"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_49","text":"render pass \u6267\u884c\u5b8c\u7ed8\u5236\uff0c\u53ef\u4ee5\u7ed3\u675f\u6e32\u67d3\u4f5c\u4e1a: vkCmdEndRenderPass(commandBuffers[i]); C++ \u5e76\u505c\u6b62\u8bb0\u5f55\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u5de5\u4f5c: if (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to record command buffer!\"); } C++ \u5728\u4e0b\u4e00\u7ae0\u8282\u6211\u4eec\u4f1a\u5c1d\u8bd5\u5728 main loop \u4e2d\u7f16\u5199\u4ee3\u7801\uff0c\u7528\u4e8e\u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u56fe\u50cf\uff0c\u6267\u884c\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u547d\u4ee4\uff0c\u518d\u5c06\u6e32\u67d3\u540e\u7684\u56fe\u50cf\u8fd4\u8fd8\u7ed9\u4ea4\u6362\u94fe\u3002","title":"\u7ed3\u675f\u6e32\u67d3"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_13","text":"Vulkan \u6e32\u67d3\u548c\u663e\u793a \uff0c\u8fd9\u4e00\u7ae0\u8282\u4f1a\u628a\u4e4b\u524d\u7684\u6240\u6709\u5185\u5bb9\u8fdb\u884c\u6574\u5408\uff0c\u6211\u4eec\u5c06\u4f1a\u7f16\u5199 drawFrame \u51fd\u6570\uff0c\u901a\u8fc7\u4e3b\u5faa\u73af main loop \u5c06\u4e09\u89d2\u5f62\u7ed8\u5236\u5230\u5c4f\u5e55\u3002 drawFrame \u51fd\u6570\u5c06\u4f1a\u6267\u884c\u5982\u4e0b\u64cd\u4f5c: \u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u4e00\u4e2a\u56fe\u50cf \u5728\u5e27\u7f13\u51b2\u533a\u4e2d\uff0c\u4f7f\u7528\u4f5c\u4e3a\u9644\u4ef6\u7684\u56fe\u50cf\u6765\u6267\u884c\u547d\u4ee4\u7f13\u51b2\u533a\u4e2d\u7684\u547d\u4ee4 \u4e3a\u4e86\u6700\u7ec8\u5448\u73b0\uff0c\u5c06\u56fe\u50cf\u8fd4\u8fd8\u5230\u4ea4\u6362\u94fe \u6bcf\u4e2a\u4e8b\u4ef6\u6d3e\u53d1\u90fd\u6709\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u6765\u5bf9\u5e94\uff0c\u4f46\u5b83\u4eec\u7684\u6267\u884c\u662f\u5f02\u6b65\u7684\u3002\u51fd\u6570\u8c03\u7528\u5c06\u5728\u64cd\u4f5c\u5b9e\u9645\u5b8c\u6210\u4e4b\u524d\u8fd4\u56de\uff0c\u5e76\u4e14\u6267\u884c\u987a\u5e8f\u4e5f\u662f\u672a\u5b9a\u4e49\u7684\u3002\u8fd9\u662f\u4e0d\u7406\u60f3\u7684\uff0c\u56e0\u4e3a\u6bcf\u4e00\u4e2a\u64cd\u4f5c\u90fd\u53d6\u51b3\u4e8e\u524d\u4e00\u4e2a\u64cd\u4f5c\u3002 \u5728 mainLoop \u51fd\u6570\u8c03\u7528: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); drawFrame(); } } ... void drawFrame() { } C++ \u540c\u6b65\u4ea4\u6362\u94fe\u4e8b\u4ef6\u6709\u4e24\u79cd\u65b9\u6cd5:\u6805\u680f\u548c\u4fe1\u53f7\u91cf\u3002\u5b83\u4eec\u90fd\u662f\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u4e00\u4e2a\u64cd\u4f5c\u4fe1\u53f7\uff0c\u8d1f\u8d23\u534f\u8c03\u64cd\u4f5c\u7684\u5bf9\u8c61\u3002\u53e6\u4e00\u4e2a\u64cd\u4f5c\u7b49\u5f85\u6805\u680f\u6216\u8005\u4fe1\u53f7\u91cf\u4ece\u65e0\u4fe1\u53f7\u72b6\u6001\u8f6c\u53d8\u5230\u6709\u4fe1\u53f7\u72b6\u6001\u3002 \u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u53ef\u4ee5\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u8c03\u7528 vkWaitForFence \u8fdb\u5165\u6805\u680f\u72b6\u6001\uff0c\u800c\u4fe1\u53f7\u91cf\u4e0d\u53ef\u4ee5\u3002\u6805\u680f\u4e3b\u8981\u7528\u4e8e\u5e94\u7528\u7a0b\u5e8f\u81ea\u8eab\u4e0e\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u540c\u6b65\uff0c\u800c\u4fe1\u53f7\u91cf\u7528\u4e8e\u5728\u547d\u4ee4\u961f\u5217\u5185\u6216\u8005\u8de8\u547d\u4ee4\u961f\u5217\u540c\u6b65\u64cd\u4f5c\u3002\u6211\u4eec\u671f\u671b\u540c\u6b65\u7ed8\u5236\u4e0e\u5448\u73b0\u7684\u961f\u5217\u64cd\u4f5c\uff0c\u6240\u4ee5\u4f7f\u7528\u4fe1\u53f7\u91cf\u6700\u5408\u9002\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u4fe1\u53f7\u91cf 2 \u4ece\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf 3 \u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a 4 Subpass \u4f9d\u8d56\u6027 5 \u5448\u73b0 6 \u5185\u5b58\u6cc4\u6f0f 7 \u7ed3\u8bba","title":"Vulkan \u6e32\u67d3\u548c\u663e\u793a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_50","text":"\u5728\u83b7\u5f97\u4e00\u4e2a\u56fe\u50cf\u65f6\uff0c\u6211\u4eec\u9700\u8981\u53d1\u51fa\u4e00\u4e2a\u4fe1\u53f7\u91cf\u51c6\u5907\u8fdb\u884c\u6e32\u67d3\uff0c\u53e6\u4e00\u4e2a\u4fe1\u53f7\u91cf\u7684\u53d1\u51fa\u7528\u4e8e\u6e32\u67d3\u7ed3\u675f\uff0c\u51c6\u5907\u8fdb\u884c\u5448\u73b0presentation\u3002\u521b\u5efa\u4e24\u4e2a\u6210\u5458\u53d8\u91cf\u5b58\u50a8\u4fe1\u53f7\u91cf\u5bf9\u8c61: VkSemaphore imageAvailableSemaphore; VkSemaphore renderFinishedSemaphore; C++ \u4e3a\u4e86\u521b\u5efa\u4fe1\u53f7\u91cfsemaphores\uff0c\u6211\u4eec\u5c06\u8981\u65b0\u589e\u672c\u7cfb\u5217\u6559\u7a0b\u6700\u540e\u4e00\u4e2a\u51fd\u6570: createSemaphores : void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); createSemaphores(); } ... void createSemaphores() { } C++ \u521b\u5efa\u4fe1\u53f7\u91cf\u5bf9\u8c61\u9700\u8981\u586b\u5145 VkSemaphoreCreateInfo \u7ed3\u6784\u4f53\uff0c\u4f46\u662f\u5728\u5f53\u524d\u7248\u672c\u7684 API \u4e2d\uff0c\u5b9e\u9645\u4e0a\u4e0d\u9700\u8981\u586b\u5145\u4efb\u4f55\u5b57\u6bb5\uff0c\u9664 sType : void createSemaphores() { VkSemaphoreCreateInfo semaphoreInfo = {}; semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; } C++ Vulkan API\u672a\u6765\u7248\u672c\u6216\u8005\u6269\u5c55\u4e2d\u6216\u8bb8\u4f1a\u4e3a flags \u548c pNext \u53c2\u6570\u589e\u52a0\u529f\u80fd\u9009\u9879\u3002\u521b\u5efa\u4fe1\u53f7\u91cf\u5bf9\u8c61\u7684\u8fc7\u7a0b\u5f88\u719f\u6089\u4e86\uff0c\u5728\u8fd9\u91cc\u4f7f\u7528 vkCreateSemaphore : if (vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphore) != VK_SUCCESS || vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphore) != VK_SUCCESS) { throw std::runtime_error(\"failed to create semaphores!\"); } C++ \u5728\u7a0b\u5e8f\u7ed3\u675f\u65f6\uff0c\u5f53\u6240\u6709\u547d\u4ee4\u5b8c\u6210\u5e76\u4e0d\u9700\u8981\u540c\u6b65\u65f6\uff0c\u5e94\u8be5\u6e05\u9664\u4fe1\u53f7\u91cf: void cleanup() { vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); C++","title":"\u4fe1\u53f7\u91cf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_51","text":"\u5c31\u50cf\u4e4b\u524d\u8bf4\u5230\u7684\uff0c drawFrame \u51fd\u6570\u9700\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u56fe\u50cf\u3002\u56de\u60f3\u4e00\u4e0b\u4ea4\u6362\u94fe\u662f\u4e00\u4e2a\u6269\u5c55\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u4f7f\u7528\u5177\u6709vk*KHR\u547d\u540d\u7ea6\u5b9a\u7684\u51fd\u6570: void drawFrame() { uint32_t imageIndex; vkAcquireNextImageKHR(device, swapChain, std::numeric_limits<uint64_t>::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex); } C++ vkAcquireNextImageKHR \u51fd\u6570\u524d\u4e24\u4e2a\u53c2\u6570\u662f\u6211\u4eec\u5e0c\u671b\u83b7\u53d6\u5230\u56fe\u50cf\u7684\u903b\u8f91\u8bbe\u5907\u548c\u4ea4\u6362\u94fe\u3002\u7b2c\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u83b7\u53d6\u6709\u6548\u56fe\u50cf\u7684\u64cd\u4f5ctimeout\uff0c\u5355\u4f4d\u7eb3\u79d2\u3002\u6211\u4eec\u4f7f\u752864\u4f4d\u65e0\u7b26\u53f7\u6700\u5927\u503c\u7981\u6b62 timeout \u3002 \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u4f7f\u7528\u7684\u540c\u6b65\u5bf9\u8c61\uff0c\u5f53 presentation \u5f15\u64ce\u5b8c\u6210\u4e86\u56fe\u50cf\u7684\u5448\u73b0\u540e\u4f1a\u4f7f\u7528\u8be5\u5bf9\u8c61\u53d1\u8d77\u4fe1\u53f7\u3002\u8fd9\u5c31\u662f\u5f00\u59cb\u7ed8\u5236\u7684\u65f6\u95f4\u70b9\u3002\u5b83\u53ef\u4ee5\u6307\u5b9a\u4e00\u4e2a\u4fe1\u53f7\u91cf semaphore \u6216\u8005\u6805\u680f\u6216\u8005\u4e24\u8005\u3002\u51fa\u4e8e\u76ee\u7684\u6027\uff0c\u6211\u4eec\u4f1a\u4f7f\u7528 imageAvailableSemaphore \u3002 \u6700\u540e\u7684\u53c2\u6570\u6307\u5b9a\u4ea4\u6362\u94fe\u4e2d\u6210\u4e3a available \u72b6\u6001\u7684\u56fe\u50cf\u5bf9\u5e94\u7684\u7d22\u5f15\u3002\u5176\u4e2d\u7d22\u5f15\u4f1a\u5f15\u7528\u4ea4\u6362\u94fe\u56fe\u50cf\u6570\u7ec4 swapChainImages \u7684\u56fe\u50cf VkImage \u3002\u6211\u4eec\u4f7f\u7528\u8fd9\u4e2a\u7d22\u5f15\u9009\u62e9\u6b63\u786e\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002","title":"\u4ece\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_52","text":"\u961f\u5217\u63d0\u4ea4\u548c\u540c\u6b65\u901a\u8fc7 VkSubmitInfo \u7ed3\u6784\u4f53\u8fdb\u884c\u53c2\u6570\u914d\u7f6e\u3002 VkSubmitInfo submitInfo = {}; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; VkSemaphore waitSemaphores[] = {imageAvailableSemaphore}; VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT}; submitInfo.waitSemaphoreCount = 1; submitInfo.pWaitSemaphores = waitSemaphores; submitInfo.pWaitDstStageMask = waitStages; C++ \u524d\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u5728\u6267\u884c\u5f00\u59cb\u4e4b\u524d\u8981\u7b49\u5f85\u7684\u54ea\u4e2a\u4fe1\u53f7\u91cf\u53ca\u8981\u7b49\u5f85\u7684\u901a\u9053\u7684\u54ea\u4e2a\u9636\u6bb5\u3002\u4e3a\u4e86\u5411\u56fe\u50cf\u5199\u5165\u989c\u8272\uff0c\u6211\u4eec\u4f1a\u7b49\u5f85\u56fe\u50cf\u72b6\u6001\u53d8\u4e3a available \uff0c\u6240\u6211\u4eec\u6307\u5b9a\u5199\u5165\u989c\u8272\u9644\u4ef6\u7684\u56fe\u5f62\u7ba1\u7ebf\u9636\u6bb5\u3002\u7406\u8bba\u4e0a\u8fd9\u610f\u5473\u7740\uff0c\u5177\u4f53\u7684\u9876\u70b9\u7740\u8272\u5668\u5f00\u59cb\u6267\u884c\uff0c\u800c\u56fe\u50cf\u4e0d\u53ef\u7528\u3002 waitStages \u6570\u7ec4\u5bf9\u5e94 pWaitSemaphores \u4e2d\u5177\u6709\u76f8\u540c\u7d22\u5f15\u7684\u4fe1\u53f7\u91cf\u3002 submitInfo.commandBufferCount = 1; submitInfo.pCommandBuffers = &commandBuffers[imageIndex]; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u54ea\u4e2a\u547d\u4ee4\u7f13\u51b2\u533a\u88ab\u5b9e\u9645\u63d0\u4ea4\u6267\u884c\u3002\u5982\u521d\u671f\u63d0\u5230\u7684\uff0c\u6211\u4eec\u5e94\u8be5\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u5b83\u5c06\u6211\u4eec\u521a\u83b7\u53d6\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u505a\u4e3a\u989c\u8272\u9644\u4ef6\u8fdb\u884c\u7ed1\u5b9a\u3002 VkSemaphore signalSemaphores[] = {renderFinishedSemaphore}; submitInfo.signalSemaphoreCount = 1; submitInfo.pSignalSemaphores = signalSemaphores; C++ signalSemaphoreCount \u548c pSignalSemaphores \u53c2\u6570\u6307\u5b9a\u4e86\u5f53\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u7ed3\u675f\u5411\u54ea\u4e9b\u4fe1\u53f7\u91cf\u53d1\u51fa\u4fe1\u53f7\u3002\u6839\u636e\u6211\u4eec\u7684\u9700\u8981\u4f7f\u7528 renderFinishedSemaphore \u3002 if (vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE) != VK_SUCCESS) { throw std::runtime_error(\"failed to submit draw command buffer!\"); } C++ \u4f7f\u7528 vkQueueSubmit \u51fd\u6570\u5411\u56fe\u50cf\u961f\u5217\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u5f53\u5f00\u9500\u8d1f\u8f7d\u6bd4\u8f83\u5927\u7684\u65f6\u5019\uff0c\u5904\u4e8e\u6548\u7387\u8003\u8651\uff0c\u51fd\u6570\u53ef\u4ee5\u6301\u6709 VkSubmitInfo \u7ed3\u6784\u4f53\u6570\u7ec4\u3002\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u5f15\u7528\u4e86\u4e00\u4e2a\u53ef\u9009\u7684\u6805\u680f\uff0c\u5f53\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u5b8c\u6bd5\u65f6\u5019\u5b83\u4f1a\u88ab\u53d1\u9001\u4fe1\u53f7\u3002\u6211\u4eec\u4f7f\u7528\u4fe1\u53f7\u91cf\u8fdb\u884c\u540c\u6b65\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4f20\u9012 VK_NULL_HANDLE \u3002","title":"\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#subpass","text":"\u8bf7\u8bb0\u4f4f\uff0c\u6e32\u67d3\u901a\u9053\u4e2d\u7684\u5b50\u901a\u9053\u4f1a\u81ea\u52a8\u5904\u7406\u5e03\u5c40\u7684\u53d8\u6362\u3002\u8fd9\u4e9b\u53d8\u6362\u901a\u8fc7\u5b50\u901a\u9053\u7684\u4f9d\u8d56\u5173\u7cfb\u8fdb\u884c\u63a7\u5236\uff0c\u5b83\u4eec\u6307\u5b9a\u4e86\u5f7c\u6b64\u4e4b\u95f4\u5185\u5b58\u548c\u6267\u884c\u7684\u4f9d\u8d56\u5173\u7cfb\u3002\u73b0\u5728\u53ea\u6709\u4e00\u4e2a\u5b50\u901a\u9053\uff0c\u4f46\u662f\u5728\u6b64\u5b50\u901a\u9053\u4e4b\u524d\u548c\u4e4b\u540e\u7684\u64cd\u4f5c\u4e5f\u88ab\u89c6\u4e3a\u9690\u5f0f\u201c\u5b50\u901a\u9053\u201d\u3002 \u6709\u4e24\u4e2a\u5185\u7f6e\u7684\u4f9d\u8d56\u5173\u7cfb\u5728\u6e32\u67d3\u901a\u9053\u5f00\u59cb\u548c\u6e32\u67d3\u901a\u9053\u7ed3\u675f\u5904\u7406\u8f6c\u6362\uff0c\u4f46\u662f\u524d\u8005\u4e0d\u4f1a\u5728\u5f53\u4e0b\u53d1\u751f\u3002\u5047\u8bbe\u8f6c\u6362\u53d1\u751f\u5728\u7ba1\u7ebf\u7684\u8d77\u59cb\u9636\u6bb5\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u83b7\u53d6\u56fe\u50cf\uff01\u6709\u4e24\u4e2a\u65b9\u6cd5\u5904\u7406\u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u5c06 imageAvailableSemaphore \u7684 waitStages \u66f4\u6539\u4e3a VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT \uff0c\u786e\u4fdd\u56fe\u50cf\u6709\u6548\u4e4b\u524d\u6e32\u67d3\u901a\u9053\u4e0d\u4f1a\u5f00\u59cb\uff0c\u6216\u8005\u6211\u4eec\u8ba9\u6e32\u67d3\u901a\u9053\u7b49\u5f85 VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT \u9636\u6bb5\u3002\u6211\u89c9\u5f97\u4f7f\u7528\u7b2c\u4e8c\u4e2a\u9009\u9879\uff0c\u56e0\u4e3a\u53ef\u4ee5\u6bd4\u8f83\u5168\u9762\u7684\u4e86\u89e3 subpass \u4f9d\u8d56\u5173\u7cfb\u53ca\u5176\u5de5\u4f5c\u65b9\u5f0f\u3002 \u5b50\u901a\u9053\u4f9d\u8d56\u5173\u7cfb\u53ef\u4ee5\u901a\u8fc7 VkSubpassDependency \u7ed3\u6784\u4f53\u6307\u5b9a\uff0c\u5728 createRenderPass \u51fd\u6570\u4e2d\u6dfb\u52a0: VkSubpassDependency dependency = {}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; C++ \u524d\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u4f9d\u8d56\u7684\u5173\u7cfb\u548c\u4ece\u5c5e\u5b50\u901a\u9053\u7684\u7d22\u5f15\u3002\u7279\u6b8a\u503c VK_SUBPASS_EXTERNAL \u662f\u6307\u5728\u6e32\u67d3\u901a\u9053\u4e4b\u524d\u6216\u8005\u4e4b\u540e\u7684\u9690\u5f0f\u5b50\u901a\u9053\uff0c\u53d6\u51b3\u4e8e\u5b83\u662f\u5426\u5728 srcSubpass \u6216\u8005 dstSubPass \u4e2d\u6307\u5b9a\u3002\u7d22\u5f150\u6307\u5b9a\u6211\u4eec\u7684\u5b50\u901a\u9053\uff0c\u8fd9\u662f\u7b2c\u4e00\u4e2a\u4e5f\u662f\u552f\u4e00\u7684\u3002 dstSubpass \u5fc5\u987b\u59cb\u7ec8\u9ad8\u4e8e srcSubPass \u4ee5\u9632\u6b62\u4f9d\u8d56\u5173\u7cfb\u51fa\u73b0\u5faa\u73af\u3002 dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u5b57\u6bb5\u6307\u5b9a\u8981\u7b49\u5f85\u7684\u64cd\u4f5c\u548c\u8fd9\u4e9b\u64cd\u4f5c\u53d1\u751f\u7684\u9636\u6bb5\u3002\u5728\u6211\u4eec\u53ef\u4ee5\u8bbf\u95ee\u5bf9\u8c61\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u7b49\u5f85\u4ea4\u6362\u94fe\u5b8c\u6210\u5bf9\u5e94\u56fe\u50cf\u7684\u8bfb\u53d6\u64cd\u4f5c\u3002\u8fd9\u53ef\u4ee5\u901a\u8fc7\u7b49\u5f85\u989c\u8272\u9644\u4ef6\u8f93\u51fa\u7684\u9636\u6bb5\u6765\u5b9e\u73b0\u3002 dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; C++ \u5728\u989c\u8272\u9644\u4ef6\u9636\u6bb5\u7684\u64cd\u4f5c\u53ca\u6d89\u53ca\u989c\u8272\u9644\u4ef6\u7684\u8bfb\u53d6\u548c\u5199\u5165\u7684\u64cd\u4f5c\u5e94\u8be5\u7b49\u5f85\u3002\u8fd9\u4e9b\u8bbe\u7f6e\u5c06\u963b\u6b62\u8f6c\u6362\u53d1\u751f\uff0c\u76f4\u5230\u5b9e\u9645\u9700\u8981(\u5e76\u5141\u8bb8):\u5f53\u6211\u4eec\u9700\u8981\u5199\u5165\u989c\u8272\u65f6\u5019\u3002 renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; C++ VkRenderPassCreateInfo \u7ed3\u6784\u4f53\u6709\u4e24\u4e2a\u5b57\u6bb5\u6307\u5b9a\u4f9d\u8d56\u7684\u6570\u7ec4\u3002","title":"Subpass \u4f9d\u8d56\u6027"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_53","text":"\u7ed8\u5236\u5e27\u6700\u540e\u4e00\u4e2a\u6b65\u9aa4\u662f\u5c06\u7ed3\u679c\u63d0\u4ea4\u5230\u4ea4\u6362\u94fe\uff0c\u4f7f\u5176\u6700\u7ec8\u663e\u793a\u5728\u5c4f\u5e55\u4e0a\u3002 Presentation \u901a\u8fc7 VkPresentInfoKHR \u7ed3\u6784\u4f53\u914d\u7f6e\uff0c\u5177\u4f53\u4f4d\u7f6e\u5728 drawFrame \u51fd\u6570\u6700\u540e\u3002 VkPresentInfoKHR presentInfo = {}; presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR; presentInfo.waitSemaphoreCount = 1; presentInfo.pWaitSemaphores = signalSemaphores; C++ \u524d\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u5728\u8fdb\u884cpresentation\u4e4b\u524d\u8981\u7b49\u5f85\u7684\u4fe1\u53f7\u91cf\uff0c\u5c31\u50cf VkSubmitInfo \u4e00\u6837\u3002 VkSwapchainKHR swapChains[] = {swapChain}; presentInfo.swapchainCount = 1; presentInfo.pSwapchains = swapChains; presentInfo.pImageIndices = &imageIndex; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u7528\u4e8e\u63d0\u4ea4\u56fe\u50cf\u7684\u4ea4\u6362\u94fe\u548c\u6bcf\u4e2a\u4ea4\u6362\u94fe\u56fe\u50cf\u7d22\u5f15\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4ec5\u4e00\u4e2a\u3002 presentInfo.pResults = nullptr; // Optional C++ \u6700\u540e\u4e00\u4e2a\u53ef\u9009\u53c2\u6570 pResults \uff0c\u5b83\u5141\u8bb8\u6307\u5b9a\u4e00\u7ec4 VkResult \u503c\uff0c\u4ee5\u4fbf\u5728 presentation \u6210\u529f\u65f6\u68c0\u67e5\u6bcf\u4e2a\u72ec\u7acb\u7684\u4ea4\u6362\u94fe\u3002\u5982\u679c\u53ea\u4f7f\u7528\u5355\u4e2a\u4ea4\u6362\u94fe\uff0c\u5219\u4e0d\u9700\u8981\uff0c\u56e0\u4e3a\u53ef\u4ee5\u7b80\u5355\u7684\u4f7f\u7528\u5f53\u524d\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002 vkQueuePresentKHR(presentQueue, &presentInfo); C++ vkQueuePresentKHR \u51fd\u6570\u63d0\u4ea4\u8bf7\u6c42\u5448\u73b0\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u3002\u6211\u4eec\u5728\u4e0b\u4e00\u4e2a\u7ae0\u8282\u4e3a vkAcquireNextImageKHR \u548c vkQueuePresentKHR \u53ef\u4ee5\u6dfb\u52a0\u9519\u8bef\u5904\u7406\u3002\u56e0\u4e3a\u5b83\u4eec\u5931\u8d25\u5e76\u4e0d\u4e00\u5b9a\u610f\u5473\u7740\u7a0b\u5e8f\u5e94\u8be5\u7ec8\u6b62\uff0c\u4e0e\u6211\u4eec\u8fc4\u4eca\u4e3a\u6b62\u770b\u5230\u7684\u529f\u80fd\u4e0d\u540c\u3002 \u5982\u679c\u4e00\u5207\u987a\u5229\uff0c\u5f53\u518d\u6b21\u8fd0\u884c\u7a0b\u5e8f\u65f6\u5019\uff0c\u5e94\u8be5\u53ef\u4ee5\u770b\u5230\u4e00\u4e0b\u5185\u5bb9: \u9057\u61be\u7684\u662f\uff0c\u53ea\u8981\u7a0b\u5e8f\u5173\u95ed\uff0c\u7531\u4e8e\u5f00\u542f\u4e86validation layers\u4f60\u5c06\u4f1a\u770b\u5230\u7a0b\u5e8f\u5d29\u6e83\u7684\u4fe1\u606f\u3002\u4ece\u7ec8\u7aef\u63a7\u5236\u53f0\u6253\u5370\u7684\u4fe1\u606f\u6765\u6e90 debugCallback \uff0c\u544a\u8bc9\u4e86\u6211\u4eec\u5177\u4f53\u7684\u539f\u56e0: \u9700\u8981\u4e86\u89e3\u7684\u662f drawFrame \u51fd\u6570\u4e2d\u6240\u6709\u7684\u64cd\u4f5c\u90fd\u662f\u5f02\u6b65\u7684\u3002\u610f\u5473\u7740\u5f53\u7a0b\u5e8f\u9000\u51fa mainLoop \uff0c\u7ed8\u5236\u548c\u5448\u73b0\u64cd\u4f5c\u53ef\u80fd\u4ecd\u7136\u5728\u6267\u884c\u3002\u6240\u4ee5\u6e05\u7406\u8be5\u90e8\u5206\u7684\u8d44\u6e90\u662f\u4e0d\u53cb\u597d\u7684\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u5e94\u8be5\u5728\u9000\u51fa mainLoop \u9500\u6bc1\u7a97\u4f53\u524d\u7b49\u5f85\u903b\u8f91\u8bbe\u5907\u7684\u64cd\u4f5c\u5b8c\u6210: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); drawFrame(); } vkDeviceWaitIdle(device); } C++ \u4e5f\u53ef\u4ee5\u4f7f\u7528 vkQueueWaitIdle \u7b49\u5f85\u7279\u5b9a\u547d\u4ee4\u961f\u5217\u4e2d\u7684\u64cd\u4f5c\u5b8c\u6210\u3002\u8fd9\u4e9b\u529f\u80fd\u53ef\u4ee5\u4f5c\u4e3a\u4e00\u4e2a\u975e\u5e38\u57fa\u672c\u7684\u65b9\u5f0f\u6765\u6267\u884c\u540c\u6b65\u3002\u8fd9\u4e2a\u65f6\u5019\u7a97\u4f53\u5173\u95ed\u540e\u8be5\u95ee\u9898\u4e0d\u4f1a\u51fa\u73b0\u3002","title":"\u5448\u73b0"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_54","text":"\u5982\u679c\u8fd0\u884c\u65f6\u542f\u7528\u4e86 validation layers \u5e76\u76d1\u89c6\u5e94\u7528\u7a0b\u5e8f\u7684\u5185\u5b58\u4f7f\u7528\u60c5\u51b5\uff0c\u4f60\u4f1a\u53d1\u73b0\u5b83\u5728\u6162\u6162\u589e\u52a0\u3002\u539f\u56e0\u662f validation layers \u7684\u5b9e\u73b0\u671f\u671b\u4e0e GPU \u540c\u6b65\u3002\u867d\u7136\u5728\u6280\u672f\u4e0a\u662f\u4e0d\u9700\u8981\u7684\uff0c\u4f46\u662f\u4e00\u65e6\u8fd9\u6837\u505a\uff0c\u6bcf\u4e00\u9488\u5e27\u4e0d\u4f1a\u51fa\u73b0\u660e\u663e\u7684\u6027\u80fd\u5f71\u54cd\u3002 \u6211\u4eec\u53ef\u4ee5\u5728\u5f00\u59cb\u7ed8\u5236\u4e0b\u4e00\u5e27\u4e4b\u524d\u660e\u786e\u7684\u7b49\u5f85 presentation \u5b8c\u6210: void drawFrame() { ... vkQueuePresentKHR(presentQueue, &presentInfo); vkQueueWaitIdle(presentQueue); } C++ \u5728\u5f88\u591a\u5e94\u7528\u7a0b\u5e8f\u7684\u7684\u72b6\u6001\u4e5f\u4f1a\u5728\u6bcf\u4e00\u5e27\u66f4\u65b0\u3002\u4e3a\u6b64\u66f4\u9ad8\u6548\u7684\u7ed8\u5236\u4e00\u9635\u7684\u65b9\u5f0f\u5982\u4e0b\uff1a void drawFrame() { updateAppState(); vkQueueWaitIdle(presentQueue); vkAcquireNextImageKHR(...) submitDrawCommands(); vkQueuePresentKHR(presentQueue, &presentInfo); } C++ \u8be5\u65b9\u6cd5\u5141\u8bb8\u6211\u4eec\u66f4\u65b0\u5e94\u7528\u7a0b\u5e8f\u7684\u72b6\u6001\uff0c\u6bd4\u5982\u8fd0\u884c\u6e38\u620f\u7684AI\u534f\u540c\u7a0b\u5e8f\uff0c\u800c\u524d\u4e00\u5e27\u88ab\u6e32\u67d3\u3002\u8fd9\u6837\uff0c\u59cb\u7ec8\u4fdd\u6301 CPU \u548c GPU \u5904\u4e8e\u5de5\u4f5c\u72b6\u6001\u3002","title":"\u5185\u5b58\u6cc4\u6f0f"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_55","text":"\u5927\u7ea6800\u884c\u4ee3\u7801\u4e4b\u540e\uff0c\u6211\u4eec\u7ec8\u4e8e\u770b\u5230\u4e86\u4e09\u89d2\u5f62\u7ed8\u5236\u5728\u5c4f\u5e55\u4e0a\uff01 Vulkan \u5f15\u5bfc\u7a0b\u5e8f\u9700\u8981\u5f88\u591a\u7684\u5de5\u4f5c\u8981\u53bb\u505a\uff0c\u4f46\u597d\u5904\u662f Vulkan \u901a\u8fc7\u8981\u6c42\u6bcf\u4e00\u4e2a\u660e\u786e\u7684\u5b9e\u73b0\uff0c\u5e26\u6765\u4e86\u4e86\u5de8\u5927\u7684\u63a7\u5236\u6743\u3002\u5efa\u8bae\u82b1\u8d39\u4e00\u4e9b\u65f6\u95f4\u91cd\u65b0\u8bfb\u4ee3\u7801\uff0c\u5e76\u5efa\u7acb\u4e00\u4e2a\u601d\u7ef4\u5bfc\u56fe\u6a21\u578b\uff0c\u76ee\u7684\u5728\u4e8e\u4e86\u89e3 Vulkan \u4e2d\u6bcf\u4e00\u4e2a\u5bf9\u8c61\uff0c\u4ee5\u53ca\u5b83\u4eec\u7684\u4e92\u76f8\u7684\u5173\u7cfb\u3002\u4e4b\u540e\u6211\u4eec\u5c06\u4f1a\u57fa\u4e8e\u8fd9\u4e2a\u57fa\u7840\u6784\u5efa\u6269\u5c55\u7a0b\u5e8f\u529f\u80fd\u3002 \u5728\u4e0b\u4e00\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u7ec6\u5316 Vulkan \u7a0b\u5e8f\u4e2d\u7684\u4e00\u4e9b\u7ec6\u8282\uff0c\u4f7f\u5176\u8868\u73b0\u66f4\u7a33\u5b9a\u3002","title":"\u7ed3\u8bba"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_14","text":"Vulkan \u91cd\u6784\u4ea4\u6362\u94fe \uff0c\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6210\u529f\u7684\u5728\u5c4f\u5e55\u4e0a\u7ed8\u5236\u51fa\u4e09\u89d2\u5f62\uff0c\u4f46\u662f\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5b83\u4f1a\u51fa\u73b0\u5f02\u5e38\u60c5\u51b5\u3002\u7a97\u4f53 surface \u4f1a\u53d1\u751f\u6539\u53d8\uff0c\u4f7f\u5f97\u4ea4\u6362\u94fe\u4e0d\u5728\u4e0e\u5176\u517c\u5bb9\u3002\u53ef\u80fd\u5bfc\u81f4\u8fd9\u79cd\u60c5\u51b5\u53d1\u751f\u7684\u539f\u56e0\u4e4b\u4e00\u662f\u7a97\u4f53\u7684\u5927\u5c0f\u53d8\u5316\u3002\u6211\u4eec\u5fc5\u987b\u5728\u8fd9\u4e2a\u65f6\u673a\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe 2 \u7a97\u53e3\u5927\u5c0f\u8c03\u6574 3 \u6b21\u4f18\u6216\u8fc7\u671f\u7684\u4ea4\u6362\u94fe","title":"Vulkan \u91cd\u6784\u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_56","text":"\u6dfb\u52a0\u65b0\u7684\u51fd\u6570 recreateSwapChain \u5e76\u8c03\u7528 createSwapChain \u53ca\u4f9d\u8d56\u4e8e\u4ea4\u6362\u94fe\u6216\u8005\u7a97\u4f53\u5927\u5c0f\u7684\u5bf9\u8c61\u76f8\u5173\u7684\u6240\u6709\u521b\u5efa\u51fd\u6570\u3002 void recreateSwapChain() { vkDeviceWaitIdle(device); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers(); } \u6211\u4eec\u9996\u5148\u8c03\u7528 vkDeviceIdle ,\u5c31\u50cf\u524d\u4e00\u4e2a\u7ae0\u8282\u63d0\u5230\u7684\uff0c\u6211\u4eec\u4e0d\u80fd\u89e6\u78b0\u6b63\u5728\u4f7f\u7528\u4e2d\u7684\u8d44\u6e90\u3002\u5f88\u660e\u663e\uff0c\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u672c\u8eab\u3002\u56fe\u50cf\u89c6\u56fe\u4e5f\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4eec\u76f4\u63a5\u5efa\u7acb\u5728\u4ea4\u6362\u94fe\u56fe\u50cf\u57fa\u7840\u4e0a\u3002\u6e32\u67d3\u901a\u9053\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4f9d\u8d56\u4ea4\u6362\u94fe\u56fe\u50cf\u7684\u683c\u5f0f\u3002\u5728\u7a97\u4f53\u8c03\u6574\u5927\u5c0f\u7684\u64cd\u4f5c\u671f\u95f4\uff0c\u4ea4\u6362\u94fe\u56fe\u50cf\u683c\u5f0f\u5f88\u5c11\u53d1\u751f\u53d8\u5316\uff0c\u4f46\u4ecd\u5e94\u8be5\u88ab\u5904\u7406\u3002\u5728\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u671f\u95f4\u6307\u5b9a Viewport \u548c scissor \u77e9\u5f62\u5927\u5c0f\uff0c\u6240\u4ee5\u7ba1\u7ebf\u9700\u8981\u91cd\u65b0\u6784\u5efa\u3002\u53ef\u4ee5\u4f7f\u7528\u52a8\u6001\u72b6\u6001\u6539\u53d8 viewports \u548c scissor rectangles \uff0c\u907f\u514d\u91cd\u65b0\u521b\u5efa\u3002\u6700\u540e\u5e27\u7f13\u51b2\u533a\u548c\u547d\u4ee4\u7f13\u51b2\u533a\u4e5f\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4eec\u4e5f\u4f9d\u8d56\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u3002 \u4e3a\u4e86\u786e\u4fdd\u91cd\u65b0\u521b\u5efa\u76f8\u5173\u7684\u5bf9\u8c61\u4e4b\u524d\uff0c\u8001\u7248\u672c\u7684\u5bf9\u8c61\u88ab\u7cfb\u7edf\u6b63\u786e\u56de\u6536\u6e05\u7406\uff0c\u6211\u4eec\u9700\u8981\u79fb\u52a8\u4e00\u4e9bcleanup\u4ee3\u7801\u5230\u4e0d\u540c\u7684\u51fd\u6570\u4e2d\uff0c\u8fd9\u6837\u53ef\u4ee5\u5728 recreateSwapChain \u51fd\u6570\u8c03\u7528\u3002\u8be5\u51fd\u6570\u5b9a\u4e49\u4e3a cleanupSwapChain : void cleanupSwapChain() { } void recreateSwapChain() { vkDeviceWaitIdle(device); cleanupSwapChain() createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers(); } \u6211\u4eec\u4ece cleanup \u4e2d\u5c06\u9700\u8981\u88ab\u91cd\u65b0\u521b\u5efa\u7684\u5bf9\u8c61\u6240\u5bf9\u5e94\u7684\u6e05\u7406\u4ee3\u7801\u79fb\u52a8\u5230 cleanupSwapChain \u4e2d: void cleanupSwapChain() { for (size_t i = 0; i < swapChainFramebuffers.size(); i++) { vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); } vkFreeCommandBuffers(device, commandPool, static_cast<uint32_t>(commandBuffers.size()), commandBuffers.data()); vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); for (size_t i = 0; i < swapChainImageViews.size(); i++) { vkDestroyImageView(device, swapChainImageViews[i], nullptr); } vkDestroySwapchainKHR(device, swapChain, nullptr); } void cleanup() { cleanupSwapChain(); vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); vkDestroyCommandPool(device, commandPool, nullptr); vkDestroyDevice(device, nullptr); DestroyDebugReportCallbackEXT(instance, callback, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate(); } \u6211\u4eec\u91cd\u5934\u521b\u5efa\u547d\u4ee4\u5bf9\u8c61\u6c60 command pool \uff0c\u4f46\u662f\u6bd4\u8f83\u6d6a\u8d39\u770b\u8d77\u6765\u3002\u76f8\u53cd\u7684\uff0c\u6211\u4eec\u9009\u62e9\u501f\u52a9 vkFreeCommandBuffers \u51fd\u6570\u6e05\u7406\u5df2\u7ecf\u5b58\u5728\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u8fd9\u79cd\u65b9\u5f0f\u53ef\u4ee5\u91cd\u7528\u5bf9\u8c61\u6c60\u4e2d\u5df2\u7ecf\u5206\u914d\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002 \u4ee5\u4e0a\u90e8\u5206\u5c31\u662f\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u7684\u5de5\u4f5c\uff01\u7136\u800c\u8fd9\u6837\u505a\u7684\u7f3a\u70b9\u5c31\u662f\u5728\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u5b8c\u6bd5\u4e4b\u524d\uff0c\u4f1a\u9020\u6210\u6e32\u67d3\u505c\u6b62\u3002\u521b\u5efa\u65b0\u4ea4\u6362\u94fe\u7684\u540c\u65f6\u5141\u8bb8\u5728\u65e7\u7684\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u4e0a\u7ee7\u7eed\u7ed8\u5236\u547d\u4ee4\u3002\u9700\u8981\u5c06\u4e4b\u524d\u7684\u4ea4\u6362\u94fe\u4f20\u9012\u5230 VkSwapchainCreateInfoKHR \u7ed3\u6784\u4f53\u4e2d\u7684 oldSwapChain \u5b57\u6bb5\uff0c\u5e76\u5728\u4f7f\u7528\u4e4b\u540e\u7acb\u5373\u9500\u6bc1\u3002","title":"\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_57","text":"\u73b0\u5728\u6211\u4eec\u9700\u8981\u641e\u6e05\u695a\u54ea\u4e9b\u60c5\u51b5\u4e0b\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u662f\u5fc5\u8981\u7684\uff0c\u5e76\u8c03\u7528 recreateSwapChain \u51fd\u6570\u3002\u4e00\u4e2a\u901a\u5e38\u7684\u6761\u4ef6\u662f\u7a97\u4f53\u7684\u5927\u5c0f\u53d8\u5316\u3002\u8ba9\u6211\u4eec\u8c03\u6574\u7a97\u4f53\u7684\u5927\u5c0f\uff0c\u5e76\u89c2\u5bdf\u6355\u6349\u5230\u7684\u4e8b\u4ef6\u3002\u4fee\u6539 initWindow \u51fd\u6570\u4e0d\u518d\u5305\u542b GLFW_RESIZABLE \u884c\uff0c\u6216\u8005\u5c06\u5176\u53c2\u6570\u4ece GLFW_FALSE \u4fee\u6539\u4e3a GLFW_TRUE \u3002 void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); glfwSetWindowUserPointer(window, this); glfwSetWindowSizeCallback(window, HelloTriangleApplication::onWindowResized); } ... static void onWindowResized(GLFWwindow* window, int width, int height) { if (width == 0 || height == 0) return; HelloTriangleApplication* app = reinterpret_cast<HelloTriangleApplication*>(glfwGetWindowUserPointer(window)); app->recreateSwapChain(); } C++ glfwSetWindowSizeCallback \u51fd\u6570\u4f1a\u5728\u7a97\u4f53\u53d1\u751f\u5927\u5c0f\u53d8\u5316\u7684\u65f6\u5019\u88ab\u4e8b\u4ef6\u56de\u8c03\u3002\u9057\u61be\u7684\u662f\uff0c\u5b83\u53ea\u80fd\u63a5\u53d7\u4e00\u4e2a\u6307\u9488\u4f5c\u4e3a\u53c2\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u76f4\u63a5\u4f7f\u7528\u6210\u5458\u51fd\u6570\u3002\u4f46\u5e78\u8fd0\u7684\u662f\uff0cGLFW\u5141\u8bb8\u6211\u4eec\u4f7f\u7528 glfwSetWindowUserPointer \u5c06\u4efb\u610f\u6307\u9488\u5b58\u50a8\u5728\u7a97\u4f53\u5bf9\u8c61\u4e2d\uff0c\u56e0\u6b64\u53ef\u4ee5\u6307\u5b9a\u9759\u6001\u7c7b\u6210\u5458\u8c03\u7528 glfwGetWindowUserPointer \u8fd4\u56de\u539f\u59cb\u7684\u5b9e\u4f8b\u5bf9\u8c61\u3002\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528 recreateSwapChain \uff0c\u8fd9\u79cd\u60c5\u51b5\u901a\u5e38\u53d1\u751f\u5728\uff0c\u7a97\u4f53\u6700\u5c0f\u5316\u5e76\u4e14\u5bfc\u81f4\u4ea4\u6362\u94fe\u521b\u5efa\u5931\u8d25\u65f6. chooseSwapExtent \u51fd\u6570\u5e94\u8be5\u589e\u52a0\u66f4\u65b0\u903b\u8f91\uff0c\u4f7f\u7528\u7a97\u4f53\u6700\u65b0\u7684 width \u548c height \u4ee3\u66ff\u6700\u521d\u7684 WIDTH \u548c HEIGHT : int width, height; glfwGetWindowSize(window, &width, &height); VkExtent2D actualExtent = {width, height}; C++","title":"\u7a97\u53e3\u5927\u5c0f\u8c03\u6574"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_58","text":"\u6709\u4e9b\u65f6\u5019 Vulkan \u53ef\u80fd\u544a\u8bc9\u6211\u4eec\u5f53\u524d\u7684\u4ea4\u6362\u94fe\u5728 presentation \u65f6\u4e0d\u518d\u517c\u5bb9\u3002 vkAcquireNextImageKHR \u548c vkQueuePresentKHR \u51fd\u6570\u53ef\u4ee5\u8fd4\u56de\u5177\u4f53\u7684\u503c\u660e\u786e\u3002 VK_ERROR_OUT_DATE_KHR : \u4ea4\u6362\u94fe\u4e0esurface\u4e0d\u518d\u517c\u5bb9\uff0c\u4e0d\u53ef\u8fdb\u884c\u6e32\u67d3 VK_SUBOPTIMAL_KHR : \u4ea4\u6362\u94fe\u4ecd\u7136\u53ef\u4ee5\u5411surface\u63d0\u4ea4\u56fe\u50cf\uff0c\u4f46\u662fsurface\u7684\u5c5e\u6027\u4e0d\u518d\u5339\u914d\u51c6\u786e\u3002\u6bd4\u5982\u5e73\u53f0\u53ef\u80fd\u91cd\u65b0\u8c03\u6574\u56fe\u50cf\u7684\u5c3a\u5bf8\u9002\u5e94\u7a97\u4f53\u5927\u5c0f\u3002 VkResult result = vkAcquireNextImageKHR(device, swapChain, std::numeric_limits<uint64_t>::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex); if (result == VK_ERROR_OUT_OF_DATE_KHR) { recreateSwapChain(); return; } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) { throw std::runtime_error(\"failed to acquire swap chain image!\"); } C++ \u5982\u679c\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf timeout \uff0c\u8868\u660e\u4e0d\u518d\u53ef\u7528\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u7acb\u5373\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\uff0c\u5e76\u5728\u4e0b\u4e00\u6b21 drawFrame \u8c03\u7528\u4e2d\u5c1d\u8bd5\u83b7\u53d6\u3002 \u4f60\u4e5f\u53ef\u4ee5\u9009\u62e9\u5728\u4ea4\u6362\u94fe\u4e0d\u662f\u6700\u4f73\u72b6\u6001\u7684\u65f6\u5019\uff0c\u9009\u62e9\u91cd\u65b0\u521b\u5efa\uff0c\u6bd4\u5982\u521a\u624d\u8bf4\u7684\u5927\u5c0f\u4e0d\u5339\u914d\u95ee\u9898\u3002\u5728\u8fd9\u91cc\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u83b7\u5f97\u4e86\u4e00\u4e2a\u56fe\u50cf\uff0c\u6240\u4ee5\u7ee7\u7eed\u8fdb\u884c\u3002 VK_SUCCESS \u548c VK_SUBOPTIMAL_KHR \u90fd\u88ab\u8ba4\u4e3a\u662f\u201c\u6210\u529f\u201d\u8fd4\u56de\u7801\u3002 result = vkQueuePresentKHR(presentQueue, &presentInfo); if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) { recreateSwapChain(); } else if (result != VK_SUCCESS) { throw std::runtime_error(\"failed to present swap chain image!\"); } vkQueueWaitIdle(presentQueue); vkQueuePresentKHR \u51fd\u6570\u8fd4\u56de\u540c\u6837\u7684\u503c\u3002\u5728\u6211\u4eec\u7684\u6848\u4f8b\u4e2d\u6211\u4eec\uff0c\u5982\u679c\u662f\u975e\u6700\u4f73\u72b6\u6001\uff0c\u4e5f\u9009\u62e9\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u3002\u56e0\u4e3a\u6211\u4eec\u9700\u8981\u6700\u597d\u7684\u6548\u679c\u3002\u5c1d\u8bd5\u8c03\u6574\u7a97\u4f53\u7684\u5927\u5c0f\uff0c\u5e27\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u53d8\u5316\u4e0e\u7a97\u4f53\u5339\u914d\u3002 Congratulations \uff0c\u6211\u4eec\u5b8c\u7ed3\u4e86\u7b2c\u4e00\u4e2a\u8fd0\u884c\u6bd4\u8f83\u5b8c\u6574\u7684 Vulkan \u7a0b\u5e8f\uff0c\u5728\u4e0b\u9762\u7684\u7ae0\u8282\u4e2d\u6211\u4eec\u5c1d\u8bd5\u6446\u8131\u4e4b\u524d\u7684\u786c\u7f16\u7801\uff0c\u4f7f\u7528\u9876\u70b9\u7f13\u51b2\u533a\u4ee3\u66ff vertex shader \u4e2d\u5199\u6b7b\u9876\u70b9\u6570\u636e\u3002","title":"\u6b21\u4f18\u6216\u8fc7\u671f\u7684\u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_59","text":"","title":"\u7b2c\u4e8c\u7ae0"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_15","text":"","title":"Vulkan \u9876\u70b9\u8f93\u5165"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_16","text":"","title":"Vulkan \u521b\u5efa\u9876\u70b9\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_17","text":"","title":"Vulkan \u4e34\u65f6\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_18","text":"","title":"Vulkan \u7d22\u5f15\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_19","text":"","title":"Vulkan \u63cf\u8ff0\u7b26\u5e03\u5c40\u548c\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_20","text":"","title":"Vulkan \u63cf\u8ff0\u7b26\u6c60\u548c\u96c6\u5408"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan-images","text":"","title":"Vulkan \u56fe\u50cf(Images)"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_21","text":"","title":"Vulkan \u56fe\u50cf\u89c6\u56fe\u548c\u91c7\u6837\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_22","text":"","title":"Vulkan \u7ec4\u5408\u56fe\u50cf\u53d6\u6837\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_23","text":"","title":"Vulkan \u6df1\u5ea6\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_24","text":"","title":"Vulkan \u52a0\u8f7d\u6a21\u578b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan-mipmap","text":"","title":"Vulkan \u751f\u6210\u8d34\u56fe(mipmap)"}]}
{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"documents \u4e2a\u4eba\u6587\u6863\u8bb0\u5f55","title":"documents"},{"location":"#documents","text":"\u4e2a\u4eba\u6587\u6863\u8bb0\u5f55","title":"documents"},{"location":"Typora%20Diagram/","text":"st=>start: Start op=>operation: Your Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op \u7537\u4e3b->\u5973\u4e3b: \u76f8\u9047 \u5973\u4e3b-->\u95e8\u6d3e: \u641e\u4e8b\u60c5 classDiagram Animal <|-- Duck Animal <|-- Fish Animal <|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() }","title":"Typora Diagram"},{"location":"ANGLE/136%20ANGLE_FBO/","text":"1. GLES Framebuffers 1.1. \u5b9a\u4e49 1.1.1. \u5e94\u7528 1.2. \u76f8\u5173\u5b9a\u4e49 1.3. \u521b\u5efa\u5e27\u7f13\u51b2 1.4. \u7eb9\u7406\u9644\u7740 1.5. Renderbuffer \u9644\u7740 1.6. Texture VS. Renderbuffer 1.7. \u793a\u4f8b: \u573a\u666f\u6ee4\u955c 1.7.1. \u521b\u5efa\u9636\u6bb5 1.7.2. \u7ed8\u5236\u9636\u6bb5 1.8. \u79bb\u5c4fMSAA 1.9. \u66f4\u591a\u7528\u4f8b: 1.10. Framebuffer \u76f8\u5173 API \u6c47\u603b 2. Vulkan Framebuffer 2.1. VkRenderPass 2.2. VkFramebuffers 2.3. VK \u79bb\u5c4f\u6e32\u67d3\u793a\u4f8b: 2.3.1. VkRenderPass 2.3.2. VkImageView 2.3.3. VkFrameBuffer 2.3.4. \u8bbe\u7f6e ImageView \u5230 DescriptorSet 2.3.5. \u7ed8\u5236: CommandBuffers 2.3.5.1. \u79bb\u5c4f\u6e32\u67d3 2.3.5.2. \u4e3b\u5c4f\u6e32\u67d3 3. GLES \u4e0e Vk \u5bf9\u6bd4 3.1. \u6982\u5ff5\u5bf9\u5e94 3.2. \u6d41\u7a0b\u5bf9\u5e94 3.2.1. \u5927\u81f4\u5bf9\u5e94\u6d41\u7a0b 3.3. \u5b9e\u4f8b\u4ee3\u7801\u5bf9\u6bd4 3.4. \u603b\u7ed3 4. ANGLE \u5bf9\u4e8e FBO \u7684\u7ba1\u7406 4.1. \u524d\u7aef Framebuffer 4.2. \u540e\u7aef FramebufferVk 4.3. API \u5b9e\u73b0 4.3.1. \u521b\u5efa\u9636\u6bb5 4.3.2. ResourceManager 4.3.3. \u7eb9\u7406\u9644\u7740 4.3.4. Renderbuffer \u9644\u7740 4.4. \u72b6\u6001\u540c\u6b65 4.4.1. FramebufferVk.syncState() 4.4.2. \u5207\u6362 Framebuffer \u65f6\u4fee\u6539 Pipeline 1. GLES Framebuffers \u672c\u7ae0\u4e3b\u8981\u6765\u81ea LearnOpenGL \u53ca GLES 3.0 \u7f16\u7a0b\u6307\u5357 1.1. \u5b9a\u4e49 \u901a\u5e38\u6211\u4eec\u7684\u64cd\u4f5c\u90fd\u662f\u5728 \u9ed8\u8ba4 \u5e27\u7f13\u51b2 (Default Framebuffer ) \u7684\u6e32\u67d3\u7f13\u51b2\u4e0a\u8fdb\u884c\u7684\u3002\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u662f\u5728\u4f60\u521b\u5efa\u7a97\u53e3\u7684\u65f6\u5019\u751f\u6210\u548c\u914d\u7f6e\u7684\uff08EGL\uff09\u3002 \u5728GL\u4e2d\u4f1a\u4f7f\u7528\u51e0\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u5c4f\u5e55\u7f13\u51b2\uff1a\u7528\u4e8e\u5199\u5165\u989c\u8272\u503c\u7684 \u989c\u8272\u7f13\u51b2 \uff0c\u7528\u4e8e\u5199\u5165\u6df1\u5ea6\u4fe1\u606f\u7684 \u6df1\u5ea6\u7f13\u51b2 \uff0c\u4ee5\u53ca\u5141\u8bb8\u6211\u4eec\u57fa\u4e8e\u4e00\u4e9b\u6761\u4ef6\u4e22\u5f03\u6307\u5b9a\u7247\u6bb5\u7684 \u6a21\u677f\u7f13\u51b2 \u3002\u628a\u8fd9\u51e0\u79cd\u7f13\u51b2\u7ed3\u5408\u8d77\u6765\u53eb\u505a\u5e27\u7f13\u51b2(Framebuffer)\u3002 \u800c\u4f7f\u7528 \u5e27\u7f13\u51b2\u5bf9\u8c61 (Framebuffer Object) \u5141\u8bb8\u7528\u6237 \u81ea\u5b9a\u4e49\u5e27\u7f13\u51b2 \uff0cFramebuffer \u5b9e\u9645\u662f\u4e00\u4e2a\u53ef\u6dfb\u52a0 \u7f13\u51b2\u7684\u5bb9\u5668 . \u7528\u6237\u53ef\u4ee5\u4e3a\u5176\u6dfb\u52a0 \u7eb9\u7406 (Textures ) \u6216 \u6e32\u67d3\u7f13\u51b2\u533a \u5bf9\u8c61\uff08Renderbuffer), \u6765\u5b9a\u4e49\u81ea\u5df1\u7684\u989c\u8272\u7f13\u51b2\uff0c\u6df1\u5ea6\u7f13\u51b2, \u548c\u6a21\u677f\u7f13\u51b2\u3002 1.1.1. \u5e94\u7528 \u6e32\u67d3\u5230\u4e00\u4e2a\u975e\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u88ab\u53eb\u505a \u79bb\u5c4f\u6e32\u67d3 (Off-screen Rendering) \u6216 \u6e32\u67d3\u5230\u7eb9\u7406 (Render to Texture)\u3002 \u901a\u8fc7\u81ea\u5b9a\u4e49\u5e27\u7f13\u51b2\u53ef\u4ee5\u5c06\u4f60\u7684\u573a\u666f\u6e32\u67d3\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u4e2d, \u53ef\u4ee5\u4f7f\u6211\u4eec\u80fd\u591f\u5728\u5f53\u524d\u573a\u666f\u4e2d\u521b\u5efa \u955c\u5b50, \u5012\u5f71 \u8fd9\u6837\u7684\u6548\u679c. \u8fd8\u6709\u5f88\u591a\u5e38\u89c1\u7279\u6548\u9700\u8981\u7528\u5230\u5e27\u7f13\u51b2, \u4f8b\u5982: \u9634\u5f71\u8d34\u56fe, \u52a8\u6001\u53cd\u5c04\u548c\u73af\u5883\u8d34\u56fe, \u591a\u9053\u666f\u6df1\u6280\u672f, \u52a8\u6001\u6a21\u7cca, \u548c\u540e\u671f\u5904\u7406\u7279\u6548\u7b49. 1.2. \u76f8\u5173\u5b9a\u4e49 \u9ed8\u8ba4\u5e27\u7f13\u51b2 Default Framebuffers \u5728\u8fdb\u884cGLES\u6307\u4ee4\u64cd\u4f5c\u524d, \u9700\u8981\u521b\u5efa\u4e00\u4e2a Context \u548c \u7ed8\u56fe\u8868\u9762 (\u9ed8\u8ba4 Framebuffer), \u8fd9\u901a\u5e38\u7531\u539f\u751f\u7a97\u53e3\u7cfb\u7edf\u901a\u8fc7 EGL \u7b49\u5b8c\u6210. \u521b\u5efa EGL \u7ed8\u5236\u8868\u9762\u7684\u8c03\u7528\u65f6, \u4ee5\u50cf\u7d20\u5f62\u5f0f\u6307\u5b9a \u5bbd\u5ea6,\u9ad8\u5ea6, \u662f\u5426\u4f7f\u7528 \u989c\u8272\u7f13\u51b2, \u6df1\u5ea6\u7f13\u51b2, \u6a21\u677f\u7f13\u51b2, \u53ca\u8fd9\u4e9b\u7f13\u51b2\u533a\u7684\u4f4d\u6df1. \u4e0d\u80fd\u5bf9\u5176\u8fdb\u884c\u4fee\u6539\u6216\u67e5\u8be2\u72b6\u6001\u64cd\u4f5c glViewport \u63a7\u5236\u5e27\u7f13\u51b2\u7684\u5927\u5c0f, \u4ee5\u53ca\u63a7\u5236\u9634\u5f71\u6df1\u5ea6\u8d34\u56fe\u5927\u5c0f\u7b49\u7b49 \u5e27\u7f13\u51b2\u5bf9\u8c61 Framebuffers Objects (FBOs) \u9644\u7740 Attachment FBO \u4ec5\u88ab\u89c6\u4e3a\u7f13\u5b58\u7684\u5bb9\u5668, \u56e0\u6b64\u4f7f\u7528 FBO \u4f5c\u4e3a\u6e32\u67d3\u76ee\u6807\u65f6\uff0c\u9996\u5148\u9700\u8981\u4e3a FBO \u7684\u9644\u7740\u8fde\u63a5\u5bf9\u8c61\uff0c \u9644\u7740\u662f\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\uff0c\u5b83\u80fd\u591f\u4f5c\u4e3a\u5e27\u7f13\u51b2\u7684\u4e00\u4e2a\u7f13\u51b2\uff0c\u53ef\u4ee5\u5c06\u5b83\u60f3\u8c61\u4e3a\u4e00\u4e2a\u56fe\u50cf\u3002 \u521b\u5efa\u4e00\u4e2a\u9644\u4ef6\u65b9\u5f0f\u6709\u4e24\u79cd\uff1a \u7eb9\u7406 \u6216 \u6e32\u67d3\u7f13\u51b2 \u5bf9\u8c61(Renderbuffer)\u3002 \u5e27\u7f13\u51b2\u76843\u4e2a\u9644\u7740 \u989c\u8272\u9644\u7740 Color Attachment \u6df1\u5ea6\u9644\u7740 Depth Attachment \u6a21\u677f\u9644\u7740 Stencil Attachment \u7eb9\u7406\u9644\u4ef6 Textures \u5373\u666e\u901a\u7684 Texture, \u6839\u636e Format\u7684\u4e0d\u540c, \u53ef\u4ee5\u5206\u522b\u7528\u4f5c FBO \u4e2d\u7684\u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u9644\u7740\u3002 \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 Renderbuffer Objects \u662f\u4e00\u4e2a\u7531\u5e94\u7528\u7a0b\u5e8f\u5206\u914d\u7684 2D \u56fe\u50cf\u7f13\u51b2\u533a\u3002 \u6e32\u67d3\u7f13\u51b2\u533a\u53ef\u4ee5\u7528\u4e8e\u5206\u914d\u548c\u5b58\u50a8 \u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u503c\uff0c\u53ef\u4ee5\u7528\u4f5c FBO \u4e2d\u7684\u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u9644\u7740\u3002 \u4f7f\u7528 \u7eb9\u7406 \u548c Renderbuffer \u5bf9\u8c61, \u90fd\u652f\u6301\u4e3a FBO \u5206\u522b\u6dfb\u52a0\u4e09\u79cd\u9644\u7740. \u4f46\u901a\u5e38\u4f7f\u7528 Texture \u6dfb\u52a0\u989c\u8272\u9644\u7740, \u7528 Renderbuffer \u6765\u6dfb\u52a0\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740. \u539f\u56e0\u5728\u540e\u9762\u8ba8\u8bba. (OpenGL ES 3.0 \u7f16\u7a0b\u6307\u5357) 1.3. \u521b\u5efa\u5e27\u7f13\u51b2 \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61 glGenFramebuffers(1, &fbo); \u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684(Active)\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, fbo); \u5728\u7ed1\u5b9a\u5230GL_FRAMEBUFFER\u76ee\u6807\u4e4b\u540e\uff0c\u6240\u6709\u7684 \u8bfb\u53d6 \u548c \u5199\u5165 \u5e27\u7f13\u51b2\u7684\u64cd\u4f5c\u5c06\u4f1a\u5f71\u54cd\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u3002 \u6211\u4eec\u4e5f\u53ef\u4ee5\u4f7f\u7528 GL_READ_FRAMEBUFFER \u6216 GL_DRAW_FRAMEBUFFER \uff0c\u5c06\u4e00\u4e2a\u5e27\u7f13\u51b2\u5206\u522b\u7ed1\u5b9a\u5230\u8bfb\u53d6\u76ee\u6807\u6216\u5199\u5165\u76ee\u6807\u3002 \u7ed1\u5b9a\u5230 GL_READ_FRAMEBUFFER \u7684\u5e27\u7f13\u51b2\u5c06\u4f1a\u4f7f\u7528\u5728\u6240\u6709\u50cf\u662f glReadPixels \u7684\u8bfb\u53d6\u64cd\u4f5c\u4e2d\uff0c \u7ed1\u5b9a\u5230 GL_DRAW_FRAMEBUFFER \u7684\u5e27\u7f13\u51b2\u5c06\u4f1a\u88ab\u7528\u4f5c\u6e32\u67d3\u3001\u6e05\u9664\u7b49\u5199\u5165\u64cd\u4f5c\u7684\u76ee\u6807\u3002 \u901a\u5e38\u90fd \u4e0d\u9700\u8981\u533a\u5206 \u5b83\u4eec\uff0c\u4f7f\u7528 GL_FRAMEBUFFER \uff0c\u7ed1\u5b9a\u5230\u4e24\u4e2a\u4e0a\u3002 \u6dfb\u52a0\u9644\u7740: \u5728\u8fd9\u4e00\u9636\u6bb5, \u4f7f\u7528Texture\u6216Renderbuffer\u5bf9FBO\u6dfb\u52a0\u9644\u7740, \u4ee3\u7801\u5728\u4e0b\u4e24\u8282\u79cd\u5c55\u793a. \u6dfb\u52a0\u9644\u7740\u540e, \u68c0\u67e5\u5e27\u7f13\u51b2\u7684\u5b8c\u6574\u6027 if( glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE) \u4e00\u4e2a\u5b8c\u6574\u7684\u5e27\u7f13\u51b2\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u7684\u6761\u4ef6\uff1a \u9644\u52a0\u81f3\u5c11\u4e00\u4e2a\u9644\u7740\uff08\u989c\u8272\u3001\u6df1\u5ea6\u6216\u6a21\u677f\u9644\u7740\uff09\u3002 \u81f3\u5c11\u6709\u4e00\u4e2a\u989c\u8272\u9644\u4ef6(Attachment)\u3002TODO: check angle \u6240\u6709\u7684\u9644\u4ef6\u90fd\u5fc5\u987b\u662f\u5b8c\u6574\u7684\uff08\u4fdd\u7559\u4e86\u5185\u5b58\uff09\u3002 \u6bcf\u4e2a\u7f13\u51b2\u90fd\u5e94\u8be5\u6709\u76f8\u540c\u7684\u9ad8\u5ea6\u548c\u5bbd\u5ea6\u3002 \u5982\u679c\u5b58\u5728\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740, \u5b83\u4eec\u5fc5\u987b\u662f\u76f8\u540c\u7684\u56fe\u50cf. \u6240\u6709\u9644\u7740\u7684 GL_RENDERBUFFER_SAMPLES \u6837\u672c\u503c\u76f8\u540c. \u82e5\u9644\u7740\u5bf9\u8c61\u662f\u7eb9\u7406, \u5219\u6b64\u503c\u4e3a0. \u89e3\u7ed1FBO / \u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u6e32\u67d3\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u88ab\u53eb\u505a \u79bb\u5c4f\u6e32\u67d3 (Off-screen Rendering)\u3002\u8981\u4fdd\u8bc1\u6240\u6709\u7684\u6e32\u67d3\u64cd\u4f5c\u5728\u4e3b\u7a97\u53e3\u4e2d\u6709\u89c6\u89c9\u6548\u679c\uff0c\u6211\u4eec\u9700\u8981\u518d\u6b21\u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2\uff0c\u5c06\u5b83\u7ed1\u5b9a\u5230 0 \u3002 1.4. \u7eb9\u7406\u9644\u7740 \u666e\u901a\u7684\u521b\u5efa\u7eb9\u7406\u7684\u65b9\u5f0f unsigned int texture; glGenTextures(1, &texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); \u5982\u679c\u4f60\u60f3\u5c06\u4f60\u7684\u5c4f\u5e55\u6e32\u67d3\u5230\u4e00\u4e2a\u66f4\u5c0f\u6216\u66f4\u5927\u7684\u7eb9\u7406\u4e0a\uff0c\u4f60\u9700\u8981\uff08\u5728\u6e32\u67d3\u5230\u4f60\u7684\u5e27\u7f13\u51b2\u4e4b\u524d\uff09\u518d\u6b21\u8c03\u7528 glViewport \uff0c\u4f7f\u7528\u7eb9\u7406\u7684\u65b0\u7ef4\u5ea6\u4f5c\u4e3a\u53c2\u6570\uff0c\u5426\u5219\u53ea\u6709\u4e00\u5c0f\u90e8\u5206\u7684\u7eb9\u7406\u6216\u5c4f\u5e55\u4f1a\u88ab\u6e32\u67d3\u5230\u8fd9\u4e2a\u7eb9\u7406\u4e0a\u3002(?) \u5c06\u7eb9\u7406\u9644\u52a0\u5728\u5e27\u7f13\u51b2\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); target \uff1a\u5e27\u7f13\u51b2\u7684\u76ee\u6807\uff08\u7ed8\u5236\u3001\u8bfb\u53d6\u6216\u8005\u4e24\u8005\u7686\u6709\uff09 attachment \uff1a\u6211\u4eec\u60f3\u8981\u9644\u52a0\u7684\u9644\u4ef6\u7c7b\u578b\u3002\u5f53\u524d\u6211\u4eec\u6b63\u5728\u9644\u52a0\u4e00\u4e2a \u989c\u8272\u9644\u4ef6 \u3002\u6ce8\u610f\u6700\u540e\u7684 0 \u610f\u5473\u7740\u53ef\u4ee5\u9644\u52a0\u591a\u4e2a\u989c\u8272\u9644\u4ef6\u3002 GL_COLOR_ATTACHMENT i , GL_DEPTH_ATTACHMENT , GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMENT . textarget \uff1a\u4f60\u5e0c\u671b\u9644\u52a0\u7684\u7eb9\u7406\u7c7b\u578b texture \uff1a\u8981\u9644\u52a0\u7684\u7eb9\u7406\u672c\u8eab level \uff1a\u591a\u7ea7\u6e10\u8fdc\u7eb9\u7406\u7684\u7ea7\u522b\u3002\u6211\u4eec\u5c06\u5b83\u4fdd\u7559\u4e3a0 \u7eb9\u7406\u5bf9\u8c61\u5141\u8bb8\u9644\u52a0\u4e00\u4e2a\u6df1\u5ea6\u6216\u6a21\u677f\u7f13\u51b2\u7eb9\u7406\u5230\u5e27\u7f13\u51b2\u5bf9\u8c61\u4e2d\u3002 \u8981\u9644\u52a0\u6df1\u5ea6\u7f13\u51b2\u7684\u8bdd\uff0c\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e\u4e3a GL_DEPTH_ATTACHMENT \u3002\u5e76\u5c06\u7eb9\u7406\u7684\u683c\u5f0f(Format)\u548c\u5185\u90e8\u683c\u5f0f(Internalformat)\u7c7b\u578b\u53d8\u4e3a GL_DEPTH_COMPONENT \uff0c\u6765\u53cd\u6620\u6df1\u5ea6\u7f13\u51b2\u7684\u50a8\u5b58\u683c\u5f0f\u3002 \u8981\u9644\u52a0\u6a21\u677f\u7f13\u51b2\u7684\u8bdd\uff0c\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e\u4e3a GL_STENCIL_ATTACHMENT \uff0c\u5e76\u5c06\u7eb9\u7406\u7684\u683c\u5f0f\u8bbe\u5b9a\u4e3a GL_STENCIL_INDEX \u3002 \u4e5f\u53ef\u4ee5\u5c06\u6df1\u5ea6\u7f13\u51b2\u548c\u6a21\u677f\u7f13\u51b2\u5408\u5e76\u9644\u52a0\u4e3a\u4e00\u4e2a\u7eb9\u7406\u3002\u7eb9\u7406\u7684\u6bcf32\u4f4d\u6570\u503c\u5c06\u5305\u542b24\u4f4d\u7684\u6df1\u5ea6\u4fe1\u606f\u548c8\u4f4d\u7684\u6a21\u677f\u4fe1\u606f\u3002\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e GL_DEPTH_STENCIL_ATTACHMENT \u7c7b\u578b\uff0c\u5e76\u914d\u7f6e\u7eb9\u7406\u7684\u683c\u5f0f\uff0c\u8ba9\u5b83\u5305\u542b\u5408\u5e76\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u503c\u3002 ``` glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL ); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0); ``` 1.5. Renderbuffer \u9644\u7740 \u521b\u5efa\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u7684\u4ee3\u7801 glGenRenderbuffers(1, &rbo); \u7ed1\u5b9a\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\uff0c\u8ba9\u4e4b\u540e\u6240\u6709\u7684\u6e32\u67d3\u7f13\u51b2\u64cd\u4f5c\u5f71\u54cd\u5f53\u524d\u7684 RBO\uff1a glBindRenderbuffer(GL_RENDERBUFFER, rbo); \u521b\u5efa\u4e00\u4e2a\u6df1\u5ea6\u548c\u6a21\u677f\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); \u521b\u5efa\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u548c\u7eb9\u7406\u5bf9\u8c61\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u662f\u8fd9\u4e2a\u5bf9\u8c61\u662f\u4e13\u95e8\u88ab\u8bbe\u8ba1\u4f5c\u4e3a\u56fe\u50cf\u4f7f\u7528\u7684\uff0c\u800c\u4e0d\u662f\u7eb9\u7406\u90a3\u6837\u7684\u901a\u7528\u6570\u636e\u7f13\u51b2(General Purpose Data Buffer)\u3002 \u8fd9\u91cc\u6211\u4eec\u9009\u62e9 GL_DEPTH24_STENCIL8 \u4f5c\u4e3a\u5185\u90e8\u683c\u5f0f\uff0c\u5b83\u5c01\u88c5\u4e8624\u4f4d\u7684\u6df1\u5ea6\u548c8\u4f4d\u7684\u6a21\u677f\u7f13\u51b2\u3002 \u9644\u52a0\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5230 FBO\uff1a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); \u4f7f\u7528 GL_DEPTH_STENCIL_ATTACHMENT \u8868\u793a\u540c\u65f6\u5305\u542b\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740 1.6. Texture VS. Renderbuffer \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61(Renderbuffer Object) \u662f\u5728\u7eb9\u7406\u4e4b\u540e\u5f15\u5165\u5230OpenGL\u4e2d\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u53ef\u7528\u7684\u5e27\u7f13\u51b2\u9644\u4ef6\u7c7b\u578b\u7684\uff0c\u6240\u4ee5\u5728\u8fc7\u53bb\u7eb9\u7406\u662f\u552f\u4e00\u53ef\u7528\u7684\u9644\u4ef6\u3002 Renderbuffer : \u548c\u7eb9\u7406\u56fe\u50cf\u4e00\u6837\uff0c\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u662f\u4e00\u4e2a\u771f\u6b63\u7684\u7f13\u51b2\uff0c\u5373\u4e00\u7cfb\u5217\u7684\u5b57\u8282\u3001\u6574\u6570\u3001\u50cf\u7d20\u7b49\u3002 \u4f18\u70b9: Renderbuffer \u4f1a\u5c06\u6570\u636e\u50a8\u5b58\u4e3aOpenGL\u539f\u751f\u7684\u6e32\u67d3\u683c\u5f0f\uff0c\u5b83\u662f\u4e3a\u79bb\u5c4f\u6e32\u67d3\u5230\u5e27\u7f13\u51b2\u4f18\u5316\u8fc7\u7684\u3002 Renderbuffer \u76f4\u63a5\u5c06\u6240\u6709\u7684\u6e32\u67d3\u6570\u636e\u50a8\u5b58\u5230\u5b83\u7684\u7f13\u51b2\u4e2d\uff0c\u4e0d\u4f1a\u505a\u4efb\u4f55\u9488\u5bf9\u7eb9\u7406\u683c\u5f0f\u7684\u8f6c\u6362\uff0c\u8ba9\u5b83\u53d8\u4e3a\u4e00\u4e2a\u66f4\u5feb\u7684\u53ef\u5199\u50a8\u5b58\u4ecb\u8d28\u3002 \u7f3a\u70b9: Renderbuffer \u4e0d\u80fd\u505a\u7eb9\u7406: \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u901a\u5e38\u90fd\u662f \u53ea\u5199 \u7684\uff0c\u6240\u4ee5\u4f60\u4e0d\u80fd\u8bfb\u53d6\u5b83\u4eec, \u6bd4\u5982\u4f7f\u7528\u7eb9\u7406\u8bbf\u95ee\u3002 \u5f53\u7136\u4f60\u4ecd\u7136\u8fd8\u662f\u80fd\u591f\u4f7f\u7528 glReadPixels \u6765\u8bfb\u53d6\u5b83\uff0c\u8fd9\u4f1a\u4ece\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2(\u800c\u4e0d\u662f\u9644\u4ef6\u672c\u8eab)\u4e2d\u8fd4\u56de\u7279\u5b9a\u533a\u57df\u7684\u50cf\u7d20\u3002 \u56e0\u6b64\u901a\u5e38\u7684\u89c4\u5219\u662f: \u5982\u679c\u4f60 \u4e0d\u9700\u8981\u4ece\u4e00\u4e2a\u7f13\u51b2\u4e2d\u91c7\u6837 \u6570\u636e\uff0c\u90a3\u4e48\u5bf9\u8fd9\u4e2a\u7f13\u51b2\u4f7f\u7528 \u6e32\u67d3\u7f13\u51b2 \u5bf9\u8c61\u4f1a\u662f\u660e\u667a\u7684\u9009\u62e9\u3002 \u800c\u5982\u679c\u4f60 \u9700\u8981\u4ece\u7f13\u51b2\u4e2d\u91c7\u6837\u989c\u8272\u6216\u6df1\u5ea6 \u503c\u7b49\u6570\u636e\uff0c\u90a3\u4e48\u4f60\u5e94\u8be5\u9009\u62e9 \u7eb9\u7406 \u9644\u4ef6\u3002\u6027\u80fd\u65b9\u9762\u5b83\u4e0d\u4f1a\u4ea7\u751f\u975e\u5e38\u5927\u7684\u5f71\u54cd\u7684\u3002 Renderbuffer \u5bf9\u8c61\u901a\u5e38\u7528\u4e8e \u6df1\u5ea6\u548c\u6a21\u677f \u9644\u4ef6\uff0c\u56e0\u4e3a\u5927\u90e8\u5206\u65f6\u95f4\u6211\u4eec\u90fd\u4e0d\u9700\u8981\u4ece\u6df1\u5ea6\u548c\u6a21\u677f\u7f13\u51b2\u4e2d\u8bfb\u53d6\u503c\uff0c\u53ea\u5173\u5fc3\u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5, \u4f46\u4e0d\u9700\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u91c7\u6837. \u5bf9\u5e94\u5230\u573a\u666f\u4e2d: \u9009\u62e9 Texture \u6e32\u67d3\u5230\u4e00\u4e2a\u7528\u4f5c\u989c\u8272\u7eb9\u7406\u7684\u989c\u8272\u7f13\u51b2\u533a \u6e32\u67d3\u5230\u4e00\u4e2a\u7528\u4f5c\u9634\u5f71\u7684\u6df1\u5ea6\u7eb9\u7406\u7684\u6df1\u5ea6\u7f13\u51b2\u533a \u9009\u62e9 Renderbuffer \u591a\u91cd\u91c7\u6837(? \u6765\u81ea\"3.0 \u7f16\u7a0b\u6307\u5357\" \u4f46 Texture \u4e5f\u6709MS, \u7248\u672c\u539f\u56e0?) \u5982\u679c\u56fe\u50cf\u4e0d\u88ab\u4f5c\u4e3a\u7eb9\u7406, \u5219 Renderbuffer \u53ef\u80fd\u5e26\u6765\u6027\u80fd\u4f18\u52bf: GLES \u53ef\u80fd\u4ee5\u66f4\u9ad8\u6548\u7684\u683c\u5f0f\u5b58\u50a8 Renderbuffer, \u6bd4\u7eb9\u7406\u66f4\u9002\u5408\u6e32\u67d3 \u4f8b\u5982: \u5229\u7528\u5176\u5199\u5165\u6216\u8005\u590d\u5236\u5230\u5176\u5b83\u7f13\u51b2\u5feb\u7684\u7279\u70b9\u3002 \u4ea4\u6362\u7f13\u51b2 \u8fd9\u6837\u7684\u64cd\u4f5c\u5728\u4f7f\u7528\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u65f6\u4f1a\u975e\u5e38\u5feb\u3002 \u5728\u6bcf\u4e2a\u6e32\u67d3\u8fed\u4ee3\u6700\u540e\u4f7f\u7528\u7684 glfwSwapBuffers \uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5b9e\u73b0\uff1a\u53ea\u9700\u8981\u5199\u5165\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u56fe\u50cf\uff0c\u5e76\u5728\u6700\u540e\u4ea4\u6362\u5230\u53e6\u5916\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5c31\u53ef\u4ee5\u4e86\u3002 1.7. \u793a\u4f8b: \u573a\u666f\u6ee4\u955c 1.7.1. \u521b\u5efa\u9636\u6bb5 // \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61\uff0c\u5e76\u7ed1\u5b9a unsigned int framebuffer; glGenFramebuffers(1, &framebuffer); glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); // \u4f7f\u7528 Texture \u6dfb\u52a0\u989c\u8272\u9644\u7740 // \u751f\u6210\u7eb9\u7406 unsigned int texColorBuffer; glGenTextures(1, &texColorBuffer); glBindTexture(GL_TEXTURE_2D, texColorBuffer); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glBindTexture(GL_TEXTURE_2D, 0); // \u5c06\u7eb9\u7406\u5bf9\u8c61, \u9644\u52a0\u5230\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u5bf9\u8c61\u989c\u8272(color)\u9644\u4ef6\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, 0); // \u4f7f\u7528 Renderbuffer \u6dfb\u52a0\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740 // \u6df1\u5ea6\uff08\u548c\u6a21\u677f\uff09\u6d4b\u8bd5 // \u6dfb\u52a0\u4e00\u4e2a\u6df1\u5ea6\uff08\u548c\u6a21\u677f\uff09\u9644\u4ef6\u5230\u5e27\u7f13\u51b2\u4e2d unsigned int rbo; glGenRenderbuffers(1, &rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); // GL_DEPTH24_STENCIL8 glBindRenderbuffer(GL_RENDERBUFFER, 0); // \u5c06\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61, \u9644\u52a0\u5230\u5230\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u7684 depth \u548c stencil \u9644\u4ef6\u4e0a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); // \u68c0\u67e5\u5e27\u7f13\u51b2\u662f\u5426\u662f\u5b8c\u6574\u7684 if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) std::cout << \"ERROR::FRAMEBUFFER:: Framebuffer is not complete!\" << std::endl; // \u89e3\u7ed1\u5e27\u7f13\u51b2/\u7ed1\u5b9a\u56de\u9ed8\u8ba4 glBindFramebuffer(GL_FRAMEBUFFER, 0); 1.7.2. \u7ed8\u5236\u9636\u6bb5 \u8981\u60f3\u7ed8\u5236\u573a\u666f\u5230\u4e00\u4e2a\u7eb9\u7406\u4e0a\uff0c\u6211\u4eec\u9700\u8981\u91c7\u53d6\u4ee5\u4e0b\u7684\u6b65\u9aa4\uff1a \u5c06\u65b0\u7684\u5e27\u7f13\u51b2\u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684\u5e27\u7f13\u51b2 \u548c\u5f80\u5e38\u4e00\u6837\u6e32\u67d3\u573a\u666f \u6b64\u65f6\u573a\u666f\u4f1a\u6e32\u67d3\u5230\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2, \u800c\u4e0d\u662f\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u3002 \u6240\u6709\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u64cd\u4f5c\u90fd\u4f1a\u4ece\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u4ef6\u4e2d\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u8bfb\u53d6\u3002 \u7ed1\u5b9a\u56de\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2 \u7ed8\u5236\u4e00\u4e2a\u6574\u5c4f\u5e55\u7684\u56db\u8fb9\u5f62\uff0c\u7136\u540e\u5c06\u5e27\u7f13\u51b2\u7684\u989c\u8272\u7f13\u51b2\u4f5c\u4e3a\u56db\u8fb9\u5f62\u7684\u7eb9\u7406\u3002 // \u7b2c\u4e00\u5904\u7406\u9636\u6bb5: \u7ed8\u5236\u5230FBO glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // \u6211\u4eec\u73b0\u5728\u4e0d\u4f7f\u7528\u6a21\u677f\u7f13\u51b2 glEnable(GL_DEPTH_TEST); DrawScene(); // \u7ed8\u5236\u539f\u59cb 3D \u573a\u666f // Load VAO, bind Textures, uniform data, call glDrawArrays or glDrawElements // \u7b2c\u4e8c\u5904\u7406\u9636\u6bb5: \u7ed8\u5236\u5230\u5c4f\u5e55 glBindFramebuffer(GL_FRAMEBUFFER, 0); // \u8fd4\u56de\u9ed8\u8ba4 glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); screenShader.use(); // \u4f7f\u7528\u53e6\u4e00\u5957 shader glBindVertexArray(quadVAO); // \u7ed8\u5236\u4e00\u4e2a\u56db\u8fb9\u5f62 glDisable(GL_DEPTH_TEST); glBindTexture(GL_TEXTURE_2D, textureColorbuffer); // \u5c06 Color Buffer \u4f5c\u4e3a\u7eb9\u7406\u7ed8\u5236\u5230\u56db\u8fb9\u5f62\u4e0a glDrawArrays(GL_TRIANGLES, 0, 6); \u5982\u679c screenShader \u4e0d\u505a\u7279\u6b8a\u5904\u7406, \u6b64\u65f6\u753b\u9762\u4f1a\u548c DrawScene \u7ed8\u5236\u7684\u539f\u59cb3D\u573a\u666f\u4e00\u81f4. \u6b64\u65f6\u7ed8\u5236\u7684\u56db\u8fb9\u5f62\u7c7b\u4f3c\u4e00\u4e2a\u663e\u793a\u5c4f\u5e55, \u5229\u7528\u8d34\u56fe\u663e\u793a\u539f\u59cb\u573a\u666f. \u4f46\u5982\u679c\u5bf9 screenShader \u4e2d\u7eb9\u7406\u7684color\u8fdb\u884c\u4fee\u6539, \u5c31\u53ef\u7528\u5b9e\u73b0\u6ee4\u955c\u6548\u679c. void main() { // \u53cd\u8272\u7279\u6548 FragColor = vec4(vec3(1.0 - texture(screenTexture, TexCoords)), 1.0); } \u753b\u9762\u6548\u679c\u548c\u66f4\u591a\u7279\u6548\u5904\u7406, \u53c2\u89c1 LearnOpenGL 1.8. \u79bb\u5c4fMSAA \u79bb\u5c4fMSAA \u5728\u9ed8\u8ba4\u5e27\u7f13\u51b2\u4e2d\u542f\u7528MASS, \u53ea\u9700\u8981 glEnable(GL_MULTISAMPLE); \u542f\u7528\u5373\u53ef. \u4f46\u5bf9\u4e8e\u79bb\u5c4f\u6e32\u67d3, \u9700\u8981\u624b\u52a8\u521b\u5efa\u591a\u91cd\u91c7\u6837\u7684\u9644\u7740. Texture: \u521b\u5efaMS Texture: \u4f7f\u7528 glTexImage2DMultisample \u6765\u66ff\u4ee3 glTexImage2D glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex); glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE); glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0); \u9644\u52a0\u5230\u5e27\u7f13\u51b2: \u4f7f\u7528 glFramebufferTexture2D \u5c06\u591a\u91cd\u91c7\u6837\u7eb9\u7406\u4e0a\uff0c\u4f46\u8fd9\u91cc\u7eb9\u7406\u7c7b\u578b\u4f7f\u7528\u7684\u662f GL_TEXTURE_2D_MULTISAMPLE \u3002 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0); Renderbuffer : \u521b\u5efa\u8fc7\u7a0b\u4e0d\u53d8 \u9644\u52a0\u5230\u5e27\u7f13\u51b2: \u5c06 glRenderbufferStorage \u7684\u8c03\u7528\u6539\u4e3a glRenderbufferStorageMultisample \u5c31\u53ef\u4ee5\u4e86 glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, width, height); \u7b2c\u4e8c\u53c2\u6570 4 \u4e3a\u91c7\u6837\u6b21\u6570 \u7ed8\u5236: void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); \u5c06\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u7684\u50cf\u7d20\u503c, \u4ece\u4e00\u4e2a\u5e27\u7f13\u51b2\u590d\u5236\u5230\u53e6\u4e00\u4e2a\u5e27\u7f13\u51b2. \u901a\u8fc7 glBlitFramebuffer \u5c06\u591a\u91cd\u91c7\u6837\u7684\u5e27\u7f13\u51b2, \u590d\u5236\u5230\u4e00\u4e2a\u4e2d\u4ecb\u5e27\u7f13\u51b2\u7684\u989c\u8272\u9644\u7740\u7684\u7eb9\u7406, \u5b9e\u73b0\u591a\u91cd\u91c7\u6837. glBindFramebuffer(multisampledFBO); ClearFrameBuffer(); DrawScene(); // \u5c06\u591a\u91cd\u91c7\u6837\u7f13\u51b2\u8fd8\u539f\u5230\u4e2d\u4ecbFBO\u4e0a glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO); glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO); glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST); // \u73b0\u5728\u573a\u666f\u662f\u4e00\u4e2a2D\u7eb9\u7406\u7f13\u51b2\uff0c\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u56fe\u50cf\u7528\u6765\u540e\u671f\u5904\u7406 glBindFramebuffer(GL_FRAMEBUFFER, 0); ClearFramebuffer(); glBindTexture(GL_TEXTURE_2D, screenTexture); DrawPostProcessingQuad(); 1.9. \u66f4\u591a\u7528\u4f8b: \u6cdb\u5149 \u591a\u6e32\u67d3\u76ee\u6807(Multiple Render Targets) \u4e0e \u5ef6\u8fdf\u7740\u8272\u6cd5 \u5176\u4ed6\u5f85\u8865\u5145\u5185\u5bb9: Framebuffer \u4e0e mipmaps \u53ca Cube_map \u76f8\u5173\u8d44\u6599 1.10. Framebuffer \u76f8\u5173 API \u6c47\u603b API ES Ver. Notes void glGenFramebuffers ( sizei n, uint *framebuffers ); 2 void glBindFramebuffer ( enum target, uint framebuffer ); 2 void glGenRenderbuffers ( sizei n, uint *renderbuffers ); 2 void glBindRenderbuffer ( enum target, uint renderbuffer ); 2 void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); 2 \u521b\u5efa\u4e00\u4e2a Renderbuffer internalformat : \u6307\u5b9a\u7f13\u51b2\u683c\u5f0f: depth \u548c stencil GL_DEPTH24_STENCIL8; GL_DEPTH32F_STENCIL8 GL_DEPTH_COMPONENT16 GL_DEPTH_COMPONENT24 GL_DEPTH_COMPONENT32F GL_STENCIL_INDEX8 void glRenderbufferStorageMultisample ( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); 3.0 \u521b\u5efa\u4e00\u4e2a\u591a\u91cd\u91c7\u6837 Renderbuffer, \u4e0eglRenderbufferStorage\u7684\u533a\u522b\u4ec5\u4e3a\u540e\u8005samples=0 GLenum glCheckFramebufferStatus (GLenum target); \u68c0\u67e5fbo\u5b8c\u6574\u6027 void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); \u5c06\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u7684\u50cf\u7d20\u503c, \u4ece\u4e00\u4e2afb\u590d\u5236\u5230\u53e6\u4e00\u4e2afb. \u5e94\u7528\u4e3e\u4f8b: 1. \u590d\u5236\u591a\u4e2a\u7eb9\u7406\u5230\u5c4f\u5e55 2. \u5c06\u591a\u91cd\u91c7\u6837\u6e32\u67d3\u89e3\u6790\u4e3a\u4e00\u4e2a\u7eb9\u7406 \u7ed1\u5b9a void glFramebufferRenderbuffer ( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); 2 void glFramebufferTexture ( GLenum target, GLenum attachment, GLuint texture, GLint level); 3.2 void glFramebufferTexture2D ( enum target, enum attachment, enum textarget, uint texture, int level ); 2.0 void glFramebufferTextureLayer ( enum target, enum attachment, uint texture, int level, int layer ); 3.0 \u7ed1\u5b9a 3D Texture \u65e0\u6548\u5316/\u5220\u9664 void glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments); 3.0 \u901a\u77e5\u9a71\u52a8\u4e0d\u518d\u9700\u8981fb\u5185\u5bb9. \u4f7f\u9a71\u52a8\u53ef\u7528\u8fdb\u884c\u4f18\u5316: \u5982\u8df3\u8fc7TBR\u67b6\u6784\u4e2d\u4e0d\u5fc5\u8981\u7684\u56fe\u5757\u5185\u5bb9\u6062\u590d \u8df3\u8fc7\u5b9e\u73b0\u4e2d\u4e3a\u6539\u8fdb\u6027\u80fd\u800c\u505a\u7684\u7f13\u5b58\u5237\u65b0 void glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height); 3.0 void glDeleteRenderbuffers (GLsizei n, const GLuint *renderbuffers); 2 void glDeleteFramebuffers (GLsizei n, const GLuint *framebuffers); 2 \u5176\u4ed6 void glFramebufferParameteri (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params); boolean IsRenderbuffer ( uint renderbuffer ); boolean IsFramebuffer ( uint framebuffer ); \u5176\u4ed6\u9488\u5bf9\u8bfb\u5e27\u7f13\u51b2\u7684\u547d\u4ee4: glReadPixels, glCopyTexImage, and glCopyTexSubImage, 2. Vulkan Framebuffer \u9996\u5148, Vulkan \u4e2d\u6ca1\u6709\u7c7b\u4f3c GLES\u4e2d\u5185\u7f6e\u7684\u9884\u5b9a\u4e49 Framebuffer, \u4e3b\u5c4f\u7684\u6e32\u67d3\u8fc7\u7a0b\u4e5f\u5168\u9700\u8981\u663e\u5f0f\u7684\u5b9a\u4e49. \u5176\u6b21, \u5bf9\u4e8e\u79bb\u5c4f\u6e32\u67d3, \u5176\u6d41\u7a0b\u4e0e\u4e3b\u5c4f\u6e32\u67d3\u57fa\u672c\u4e00\u81f4, \u5e76\u901a\u8fc7\u5c06\u79bb\u5c4f\u6e32\u67d3\u7684 Attachments \u901a\u8fc7 DescriptorSet \u7ed1\u5b9a\u5230\u4e3b\u5c4f\u4f5c\u4e3a\u7eb9\u7406\u6e32\u67d3. 2.1. VkRenderPass // RenderPass VkRenderPassCreateInfo renderPassInfo = {}; renderPassInfo.pAttachments = attachmentDescs.data(); // attachment descriptions renderPassInfo.pSubpasses = &subpassDescription; // subpass renderPassInfo.pDependencies = dependencies.data(); // dependencies ... \u6e32\u67d3\u8fc7\u7a0b Renderpass \u9644\u7740\u63cf\u8ff0 Attachments Descriptions \u6e32\u67d3\u8fc7\u7a0b \u63cf\u8ff0 \u6e32\u67d3\u64cd\u4f5c\u6240\u9700\u7684\u4e00\u7ec4\u6570\u636e\u3002\u5728Vulkan\u4e2d\uff0c\u63cf\u8ff0\u7684\u662f\u4e00\u7ec4\u5c06\u5728\u6e32\u67d3\u671f\u95f4\u4f7f\u7528\u7684 \u5e27\u7f13\u51b2\u533a\u9644\u7740 \u3002 \u8fd9\u4e9b\u9644\u7740\u5305\u62ec\u5728\u6e32\u67d3\u8fc7\u7a0b\u4e2d\u4f1a\u8bfb\u53d6\u6216\u5199\u5165\u7684\u4efb\u4f55\u7f13\u51b2\u533a\uff0c\u4f8b\u5982 \u989c\u8272\uff0c\u6df1\u5ea6\u548c\u6a21\u677f\u7f13\u51b2\u533a \u3002 \u8fd9\u4e5f\u53ef\u4ee5\u5305\u62ec\u8f93\u5165\u9644\u4ef6\uff0c\u8fd9\u4e9b\u8f93\u5165\u9644\u4ef6\u662f\u4e2d\u95f4\u7f13\u51b2\u533a\uff0c\u5b83\u4eec\u88ab\u5199\u5165\u4e00\u4e2a\u5b50\u901a\u9053\u4e2d\uff0c\u7136\u540e\u88ab\u53e6\u4e00\u4e2a\u5b50\u901a\u9053\u8bfb\u51fa\u3002 \u5728\u521b\u5efa\u6e32\u67d3\u901a\u9053\u65f6\u5fc5\u987b\u660e\u786e\u5b9a\u4e49\u8fd9\u4e9b\u9644\u4ef6\uff0c\u5e76\u6307\u5b9a\u8bf8\u5982\u56fe\u50cf\u683c\u5f0f\uff0c\u6837\u672c\u6570\u91cf\u4ee5\u53ca\u6307\u5b9a\u7684\u52a0\u8f7d\u548c\u5b58\u50a8\u884c\u4e3a\u7b49\u4fe1\u606f\u3002\u8fd9\u6837\u5c31\u51cf\u5c11\u4e86\u9a71\u52a8\u7a0b\u5e8f\u5728\u8fd0\u884c\u65f6\u7684\u5de5\u4f5c\u91cf\uff0c\u56e0\u4e3a\u5b83\u4e0d\u5fc5\u63a8\u65ad\u6b64\u4fe1\u606f\u672c\u8eab\u3002 \u5b50\u8fc7\u7a0b Sub-pass \u6e32\u67d3\u8fc7\u7a0b\u5305\u542b\u4e00\u4e2a\u6216\u591a\u4e2a\u5b50\u8fc7\u7a0b subpass\uff0c\u8fd9\u4e9b\u5b50\u8fc7\u7a0b\u5bf9\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u6392\u5e8f\u3002 \u5b50\u9636\u6bb5\u672c\u8d28\u4e0a\u8868\u793a\u6e32\u67d3\u7684\u9636\u6bb5\uff0c\u5176\u4e2d\u6e32\u67d3\u5de5\u4f5c\u662f\u901a\u8fc7\u6e32\u67d3\u9636\u6bb5\u4e2d\u7684\u9644\u4ef6\u7684\u5b50\u96c6\u5b8c\u6210\u7684\u3002\u4e00\u7ec4\u547d\u4ee4\u8bb0\u5f55\u5728\u6bcf\u4e2a\u5b50\u901a\u9053\u4e2d\uff0c\u4ee5\u63cf\u8ff0\u5728\u8be5\u5b50\u901a\u9053\u4e2d\u9700\u8981\u5b8c\u6210\u7684\u5de5\u4f5c\u3002 \u5b50\u8fc7\u7a0b\u4f9d\u8d56 Sub-pass Dependencies \u6e32\u67d3\u8fc7\u7a0b\u5b9a\u4e49\u4e86\u4e00\u7ec4\u5b50\u8fc7\u7a0b\u4f9d\u8d56\u5173\u7cfb(sub-pass dependencies)\uff0c\u8fd9\u4e9b\u4f9d\u8d56\u5173\u7cfb\u786e\u5b9a\u4e86\u6210\u5bf9\u5b50\u8fc7\u7a0b\u7684\u6267\u884c\u987a\u5e8f\u3002 \u5b83\u4eec\u5145\u5f53\u6267\u884c\u548c\u5185\u5b58\u4f9d\u8d56\u9879\u3002\u5f53\u4e24\u4e2a\u6216\u591a\u4e2a\u5b50\u901a\u9053\u8bbf\u95ee\u540c\u4e00\u9644\u4ef6\u65f6\uff0c\u4f9d\u8d56\u5173\u7cfb\u81f3\u5173\u91cd\u8981\uff0c\u56e0\u4e3aVulkan\u4e0d\u4fdd\u8bc1GPU\u6267\u884c\u5b50\u901a\u9053\u7684\u987a\u5e8f\u3002 \u6ce8\u610f : \u5c3d\u7ba1 RenderPass \u63cf\u8ff0\u4e86\u6240\u6709\u4f7f\u7528\u7684\u9644\u4ef6\u7684 \u7279\u5f81 \u4ee5\u53ca \u5982\u4f55\u5904\u7406 \u9644\u4ef6\uff0c\u4f46\u5b83\u5e76\u4e0d\u6307\u5411\u4efb\u4f55\u5b9e\u9645\u5bf9\u8c61\u3002\u8fd9\u7531 Framebuffers \u5904\u7406\u3002 2.2. VkFramebuffers \u5728 Vulkan \u4e2d\uff0cVkFramebuffer \u7684\u4f5c\u7528\u4ec5\u662f\u5c06\u5305\u542b \u9644\u7740\u63cf\u8ff0 \u7684 RenderPass \u4e0e ImageView \u5b9a\u4e49\u7684 \u9644\u7740\u5bf9\u8c61 \u5173\u8054\u8d77\u6765. VkFramebufferCreateInfo frameBufferCreateInfo = {}; frameBufferCreateInfo.renderPass = renderPass; frameBufferCreateInfo.pAttachments = attachments; // VkImageView* ... \u62c6\u5206\u6e32\u67d3\u901a\u9053\u7684\u9644\u7740\u63cf\u8ff0, \u548c\u5e27\u7f13\u51b2\u533a\u7684\u9644\u7740\u5b9a\u4e49, \u6709\u52a9\u4e8e\u603b\u4f53\u4e0a\u4f18\u5316GPU\u4e0a\u7684\u64cd\u4f5c. \u5e76\u4e14\u53ea\u8981\u5e27\u7f13\u51b2\u533a\u4e0e\u6e32\u67d3\u901a\u9053\u517c\u5bb9\uff0c\u5c31\u53ef\u4ee5\u5141\u8bb8\u5728\u4e0d\u66f4\u6539\u6e32\u67d3\u901a\u9053\u7684\u60c5\u51b5\u4e0b\u4ea4\u6362\u5e27\u7f13\u51b2\u533a\u5bf9\u8c61\u3002(\u6765\u81ea imgtec ) \u7591\u95ee: RenderPass \u5728\u521b\u5efa\u540e\u88ab\u4e09\u5904\u5f15\u7528: Pipeline, Framebuffer, \u548c \u6267\u884c CommandBuffer \u9636\u6bb5\u7684 BeginRenderpass. \u800c\u4e14 BeginRenderpass \u540c\u65f6\u518d\u6b21\u6307\u5b9a\u4e86 Framebuffer. \u56e0\u6b64 Renderpass, Framebuffer, BeginRenderpass \u51fa\u73b0\u4e86\u7c7b\u4f3c\u5faa\u73af\u6307\u5b9a. \u4e3a\u4ec0\u4e48\u9700\u8981\u72ec\u7acb\u51fa Framebuffer \u800c\u4e0d\u662f\u628a Attachment \u548c AttachmentDescription \u4e00\u8d77\u90fd\u653e\u4e8e Renderpass \u4e2d ? \u4e3a\u4ec0\u4e48 Pipeline \u8981\u5f15\u7528 Renderpass ? \u731c\u6d4b: \u521b\u5efa Pipeline \u524d\u9700\u8981\u5b9a\u4e49\u597d\u7684 Renderpass\u83b7\u53d6 \"\u8bf8\u5982\u56fe\u50cf\u683c\u5f0f\uff0c\u6837\u672c\u6570\u91cf\u4ee5\u53ca\u6307\u5b9a\u7684\u52a0\u8f7d\u548c\u5b58\u50a8\u884c\u4e3a\u7b49\u4fe1\u606f\" \u6765\u8fdb\u884c\u4f18\u5316? 2.3. VK \u79bb\u5c4f\u6e32\u67d3\u793a\u4f8b: 2.3.1. VkRenderPass Renderpass \u4e2d, \u4f7f\u7528 VkAttachmentDescription \u5b9a\u4e49\u4e86 \u5404 Attachment \u7684\u7c7b\u578b, \u884c\u4e3a\u7b49. \u521b\u5efa Render Pass \u793a\u4f8b: // RenderPass VkRenderPassCreateInfo renderPassInfo = {}; renderPassInfo.pAttachments = attachmentDescs.data(); // attachment descriptions renderPassInfo.pSubpasses = &subpassDescription; // subpass renderPassInfo.pDependencies = dependencies.data(); // dependencies \u5176\u4e2d, Attachment Description, \u63cf\u8ff0\u9644\u7740\u7684\u7c7b\u578b, \u7279\u5f81\u548c\u5904\u7406\u65b9\u5f0f std::array<VkAttachmentDescription, 2> attachmentDescs = {}; // Color attachment attachmentDescs[0].format = swapChain.colorFormat; attachmentDescs[0].samples = VK_SAMPLE_COUNT_1_BIT; attachmentDescs[0].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; attachmentDescs[0].storeOp = VK_ATTACHMENT_STORE_OP_STORE; attachmentDescs[0].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; attachmentDescs[0].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; attachmentDescs[0].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; attachmentDescs[0].finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; // Depth attachment attachmentDescs[1].format = depthFormat; attachmentDescs[1].samples = VK_SAMPLE_COUNT_1_BIT; attachmentDescs[1].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; attachmentDescs[1].storeOp = VK_ATTACHMENT_STORE_OP_STORE; attachmentDescs[1].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; attachmentDescs[1].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; attachmentDescs[1].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; attachmentDescs[1].finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL; Subpass \u4e2d\u5305\u542b\u4e86\u5bf9\u9644\u7740\u7684\u5f15\u7528 VkAttachmentReference colorReference = {}; colorReference.attachment = 0; colorReference.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkAttachmentReference depthReference = {}; depthReference.attachment = 1; depthReference.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL; VkSubpassDescription subpassDescription = {}; subpassDescription.pColorAttachments = &colorReference; subpassDescription.pDepthStencilAttachment = &depthReference; 2.3.2. VkImageView \u4f7f\u7528 ImageView \u5bf9\u8c61\u5b9a\u4e49\u9644\u7740, \u5305\u62ec \u989c\u8272\u9644\u7740\u548c \u6df1\u5ea6/\u6a21\u677f\u9644\u7740, \u540e\u8005\u901a\u5e38\u4e3a\u540c\u4e00\u4e2a\u9644\u7740. VkImageView attachments[2]; // Color attachement attachments[0] = color.view; // Depth/Stencil attachment is the same for all frame buffers attachments[1] = depthStencil.view; 2.3.3. VkFrameBuffer FrameBuffer \u5c06 ImageView \u4f5c\u4e3a Attachment, \u5e76\u5c06\u5176\u4e0e Renderpass \u8fde\u63a5\u8d77\u6765. VkFramebufferCreateInfo frameBufferCreateInfo = {}; frameBufferCreateInfo.renderPass = renderPass; frameBufferCreateInfo.pAttachments = attachments; // VkImageView* ... 2.3.4. \u8bbe\u7f6e ImageView \u5230 DescriptorSet \u4e3a\u5c4f\u5e55\u6e32\u67d3\u7684 Framebuffer \u8bbe\u7f6e DescriptorSet, \u5c06\u79bb\u5c4f\u6e32\u67d3\u7684 ImageView \u4f5c\u4e3a Texture \u4f20\u9012\u7ed9 Shader. // Image descriptors for the offscreen color attachments VkDescriptorImageInfo imageInfo{}; imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL; imageInfo.imageView = color.view; // color attachments in Framebuffer imageInfo.sampler = textureSampler; std::array<VkWriteDescriptorSet, 2> descriptorWrites{}; descriptorWrites[0].dstSet = descriptorSet; descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER; descriptorWrites[0].pBufferInfo = &imageInfo; vkUpdateDescriptorSets(device, static_cast<uint32_t>(descriptorWrites.size()), descriptorWrites.data(), 0, nullptr); 2.3.5. \u7ed8\u5236: CommandBuffers 2.3.5.1. \u79bb\u5c4f\u6e32\u67d3 \u6307\u5b9a\u6e32\u67d3\u6d41\u7a0b Renderbuffer \u548c Framebuffer VkRenderPassBeginInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; renderPassBeginInfo.renderPass = offScreenFrameBuf.renderPass; renderPassBeginInfo.framebuffer = offScreenFrameBuf.frameBuffer; renderPassBeginInfo.renderArea.extent.width = offScreenFrameBuf.width; renderPassBeginInfo.renderArea.extent.height = offScreenFrameBuf.height; renderPassBeginInfo.clearValueCount = static_cast<uint32_t>(clearValues.size()); renderPassBeginInfo.pClearValues = clearValues.data(); \u5728\u79bb\u5c4f\u6e32\u67d3\u4e2d, \u6e32\u67d3\u6a21\u578b\u7b49 vkCmdBeginRenderPass(offScreenCmdBuffer, &ofsRenderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE); vkCmdBindPipeline(offScreenCmdBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.offscreen); // \u7ed8\u5236Background, \u80cc\u666f\u6a21\u578b vkCmdBindDescriptorSets(offScreenCmdBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &descriptorSets.floor, 0, nullptr); models.floor.draw(offScreenCmdBuffer); // \u7ed8\u5236\u5b9e\u4f8b\u6a21\u578b vkCmdBindDescriptorSets(offScreenCmdBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &descriptorSets.model, 0, nullptr); models.model.bindBuffers(offScreenCmdBuffer); vkCmdDrawIndexed(offScreenCmdBuffer, models.model.indices.count, 3, 0, 0, 0); vkCmdEndRenderPass(offScreenCmdBuffer); 2.3.5.2. \u4e3b\u5c4f\u6e32\u67d3 \u540c\u6837\u5148\u6307\u5b9a\u4e3b\u5c4f\u7684 Renderbuffer \u548c Framebuffer, \u7136\u540e\u5f00\u59cb\u6e32\u67d3 \u8f93\u51fa\u5230\u5c4f\u5e55\u65f6, \u53d6 descriptorSet \u4e2d\u7684\u7eb9\u7406, \u7ed8\u5236\u5230\u56db\u8fb9\u5f62\u4e0a. vkCmdBeginRenderPass(drawCmdBuffers[i], &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE); // \u542b Attachment \u7684 descriptorSet vkCmdBindDescriptorSets(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &descriptorSet, 0, nullptr); vkCmdBindPipeline(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.composition); // \u7ed8\u5236\u5168\u5c4f\u5e55\u7684\u56db\u8fb9\u5f62 vkCmdDraw(drawCmdBuffers[i], 3, 1, 0, 0); vkCmdEndRenderPass(drawCmdBuffers[i]); 3. GLES \u4e0e Vk \u5bf9\u6bd4 3.1. \u6982\u5ff5\u5bf9\u5e94 \u6982\u5ff5 GLES \u5bf9\u8c61 Vk\u5bf9\u8c61 Color/Depth/Stencil Attachment Texture / Renderbuffer ImageView Framebuffer \u5bb9\u5668 Framebuffer Framebuffer & Renderpass \u7eb9\u7406\u7ed1\u5b9a\u5230 Shader glBindTexture \u8bbe\u7f6e ImageView \u5230 DescriptorSets 3.2. \u6d41\u7a0b\u5bf9\u5e94 GLES \u4e32\u884c\u6e32\u67d3: \u7528 Bindframebuffer \u8fdb\u884c\u4e24\u6b21\u6e32\u67d3\u7684\u5207\u6362, \u5229\u7528 Texture \u5bf9\u8c61\u4f20\u9012\u6e32\u67d3\u753b\u9762 Vulkan \u884c\u4e3a\u9884\u5b9a\u4e49\u5f0f: \u4e0d\u540c\u4e24\u5957 Commandbuffer \u6267\u884c\u8fc7\u7a0b, \u5bf9\u5e94\u4e24\u5957 Pipeline, Renderpass, \u548c DescriptionSet \u5229\u7528 DescriptionSet \u7ed1\u5b9a ImageView (Attachment) \u4f20\u9012\u753b\u9762 3.2.1. \u5927\u81f4\u5bf9\u5e94\u6d41\u7a0b \u4e24\u79cd\u6d41\u7a0b\u7684\u987a\u5e8f\u5dee\u5f02\u8f83\u5927, \u8fd9\u91cc\u5bf9 gles api \u64cd\u4f5c\u505a\u4e00\u4e2a\u6982\u5ff5\u4e0a\u7684\u5bf9\u5e94 GLES Vulkan \u521b\u5efa: \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61\uff0c\u5e76\u7ed1\u5b9a unsigned int framebuffer; glGenFramebuffers(1, &framebuffer); glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); \u8bbe\u7f6e\u5e76\u521b\u5efa Pipeline, RenderPass \u548c Framebuffer \u5bf9\u8c61 \u521b\u5efa Texture \u989c\u8272\u9644\u7740 glGenTextures(1, &texColorBuffer); glBindTexture(GL_TEXTURE_2D, texColorBuffer); \u8bbe\u7f6e\u5e76\u521b\u5efa Image \u548c ImageView \u5bf9\u8c61. \u5bf9\u5e94\u914d\u7f6e VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT \u4e3a\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740\u521b\u5efa Renderbuffer unsigned int rbo; glGenRenderbuffers(1, &rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); \u8bbe\u7f6e\u5e76\u521b\u5efa Image \u548c ImageView \u5bf9\u8c61. \u5bf9\u5e94\u914d\u7f6e DEPTH_STENCIL_ATTACHMENT_BIT \u7ed1\u5b9a\u9644\u7740\u5bf9\u8c61\u5230 Framebuffer glFramebufferTexture2D glBindRenderbuffer \u7528 Framebuffer \u5bf9\u8c61\u5c06 ImageView \u4e0e RenderPass \u5173\u8054 \u7ed8\u5236: \u7b2c\u4e00\u7ed8\u5236\u9636\u6bb5: \u7ed8\u5236\u5230FBO glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); \u4e3a\u79bb\u5c4f\u6e32\u67d3\u914d\u7f6e\u4e00\u4e2a CommandBuffer \u7ed8\u5236\u573a\u666f, \u5305\u62ec\u9876\u70b9, \u7eb9\u7406, Shader\u53c2\u6570\u7b49 DrawScene(); \u4f7f\u7528\u4e3a\u79bb\u5c4f\u6e32\u67d3\u914d\u7f6e\u7684 Pipeline \u548cRenderPass, Framebuffer \u5e76\u8bfb\u53d6 DescriptorSet \u6765\u6267\u884c CommandBuffer \u4e2d\u4e00\u7cfb\u5217\u6307\u4ee4 \u7b2c\u4e8c\u7ed8\u5236\u9636\u6bb5: \u7ed8\u5236\u5230\u5c4f\u5e55 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u4e3a\u4e3b\u5c4f\u6e32\u67d3\u914d\u7f6e CommandBuffer \u5c06\u4e00\u9636\u6bb5\u79bb\u5c4f\u6e32\u67d3\u7684\u7eb9\u7406, \u5728\u4e8c\u9636\u6bb5\u542f\u7528 glBindTexture(GL_TEXTURE_2D, textureColorbuffer); \u5c06\u79bb\u5c4f\u6e32\u67d3\u4e2d\u7684 ImageView \u914d\u7f6e\u5230 \u4e3b\u5c4f\u6e32\u67d3\u7684 DescriptorSet \u4e2d \u7ed8\u5236\u4e3b\u5c4f glDrawArrays(GL_TRIANGLES, 0, 6); \u4f7f\u7528\u4e3a\u4e3b\u5c4f\u6e32\u67d3\u914d\u7f6e\u7684 Pipeline \u548cRenderPass, Framebuffer \u5e76\u8bfb\u53d6 DescriptorSet \u6765\u6267\u884c CommandBuffer \u4e2d\u4e00\u7cfb\u5217\u6307\u4ee4 3.3. \u5b9e\u4f8b\u4ee3\u7801\u5bf9\u6bd4 GL \u5ef6\u8fdf\u6e32\u67d3 \u4e0e Vulkan\u5ef6\u8fdf\u6e32\u67d3 ( \u5b8c\u6574\u4ee3\u7801: Vulkan Example: \u5ef6\u8fdf\u6e32\u67d3 ) 3.4. \u603b\u7ed3 Framebuffer \u5bf9\u8c61 \u5c31 Framebuffer Object \u672c\u8eab\u800c\u8a00, \u5b83\u5728 gles \u548c vk \u4e2d\u90fd\u4ec5\u4ec5\u62c5\u5f53\u4e86\u5bb9\u5668\u7684\u4f5c\u7528, \u5bf9\u5e94\u7684 Attachment \u4e5f\u7c7b\u4f3c: \u591a\u4e2aColor \u548c\u4e00\u4e2a depth, stencil. \u4f46 Framebuffer \u5728 gles \u7684\u6e32\u67d3\u8fc7\u7a0b\u4e2d, \u4f5c\u4e3a\u9690\u85cf\u7684\u6e32\u67d3\u7684\u76ee\u6807\u800c\u5b58\u5728, \u867d\u7136\u4e0d\u5bf9\u5b83\u76f4\u63a5\u64cd\u4f5c, \u4f46\u5b83\u8d2f\u7a7f\u6bcf\u4e2a\u6e32\u67d3\u6d41\u7a0b, \u540c\u65f6\u4fdd\u5b58\u6e32\u67d3\u7684\u7ed3\u679c. \u5728 Vulkan \u4e2d, \u6e32\u67d3\u5904\u7406\u6307\u4ee4\u88ab\u5206\u6563\u5728\u521b\u5efa\u7684 Pipeline, RenderPass \u7b49\u4e00\u4f17\u914d\u7f6e\u9879\u4e2d, \u800c\u5176\u540d\u4e3aFramebuffer\u5bf9\u8c61\u7684\u804c\u8d23\u5f88\u8f7b. \u79bb\u5c4f\u6e32\u67d3 \u5bf9\u4e8e Framebuffer \u5728 gles \u63d0\u4f9b\u7684\u79bb\u5c4f\u6e32\u67d3\u529f\u80fd, Vulkan \u662f\u901a\u8fc7\u914d\u7f6e\u591a\u5957\u6e32\u67d3\u6d41\u7a0b\u6765\u5b9e\u73b0, \u6bcf\u5957\u5305\u542b Pipeline, RenderPass, CommandBuffer\u7b49\u914d\u7f6e. \u4e0d\u540c\u6e32\u67d3\u76f4\u63a5\u7684\u5171\u4eab, gles \u901a\u8fc7\u7ed1\u5b9a\u5b58\u50a8\u4e86\u989c\u8272\u9644\u7740\u7684\u7eb9\u7406\u5b9e\u73b0, Vulkan\u901a\u8fc7\u5c06\u7eb9\u7406\u9644\u7740\u914d\u7f6e\u7ed9 descriptorSet \u7684\u65b9\u5f0f\u5b9e\u73b0. \u56e0\u6b64\u6240\u4ee5\u5bf9\u4e8e FBO, \u5b9e\u73b0 gles on Vulkan \u5b9e\u5219\u662f\u5b9e\u73b0\u6e32\u67d3 \u6d41\u7a0b\u7684\u5bf9\u5e94 . \u53c2\u8003\u5176\u4ed6\u5206\u6790\u6587\u6863\u4e2d\u5173\u4e8e angle \u4e2d\u6d41\u7a0b\u5bf9\u5e94\u5206\u6790, \u5305\u62ec: CommandBuffer (PCB, SCB) \u7684\u914d\u7f6e\u548c Flush \u65f6\u673a. gles \u72b6\u6001\u66f4\u65b0\u4e0e Pipeline \u7b49\u914d\u7f6e\u66f4\u65b0\u7684\u5173\u8054\u65b9\u5f0f. 4. ANGLE \u5bf9\u4e8e FBO \u7684\u7ba1\u7406 4.1. \u524d\u7aef Framebuffer @startuml hide method class State { Framebuffer *mReadFramebuffer; Framebuffer *mDrawFramebuffer; BindingPointer<Renderbuffer> mRenderbuffer; } class Framebuffer { FramebufferImpl *mImpl; //FramebufferVk mutable Optional<GLenum> mCachedStatus; vector<ObserverBinding> mDirtyColorAttachmentBindings; ObserverBinding mDirtyDepthAttachmentBinding; ObserverBinding mDirtyStencilAttachmentBinding; } class FramebufferState { vector<FramebufferAttachment> mColorAttachments; FramebufferAttachment mDepthAttachment; FramebufferAttachment mStencilAttachment; DrawBufferMask mColorAttachmentsMask; } Context *-- State State --> Framebuffer FramebufferState --* Framebuffer FramebufferAttachment --* FramebufferState FramebufferAttachmentRenderTarget --* FramebufferAttachment @enduml 4.2. \u540e\u7aef FramebufferVk @startuml skinparam classAttributeIconSize 0 class ContextVk { FramebufferVk *mDrawFramebuffer } class FramebufferVk { - WindowSurfaceVk *mBackbuffer syncState() startNewRenderPass() &getRenderPassDesc() getFramebuffer() } class RenderPassDesc { -DrawBufferMask mColorResolveAttachmentMask; -DrawBufferMask mColorUnresolveAttachmentMask; -FramebufferNonResolveAttachmentArray mAttachmentFormats; } class RenderTargetVk { ImageHelper *mImage; ImageViewHelper *mImageViews; } class FramebufferDesc { updateColor() updateDepthStencil() attachmentCount() } ContextVk --> RenderPassCache ContextVk ..> FramebufferVk FramebufferVk *-- RenderPassDesc FramebufferVk *-- RenderTargetCache RenderTargetVk ..> RenderTargetCache FramebufferVk *-- FramebufferDesc RenderPassCache ..> RenderPassDesc @enduml FramebufferDesc , RenderPassDesc \u7528\u4e8e\u6700\u7ec8\u751f\u6210 vk \u539f\u751f\u5bf9\u8c61\u7684\u5b57\u6bb5. RenderTargetVk \u5b9e\u73b0\u524d\u7aef\u7684 FramebufferAttachmentRenderTarget\u63a5\u53e3, \u4e3a\u5404\u9644\u7740\u7684\u5bf9\u8c61\u7c7b 4.3. API \u5b9e\u73b0 4.3.1. \u521b\u5efa\u9636\u6bb5 \u521b\u5efa\u9ed8\u8ba4 Framebuffer @startuml APP -> EGLWindow : initializeContext() EGLWindow -> Display : makeCurrent() Display -> Context : makeCurrent() Context -> Context : setDefaultFramebuffer(\\ndrawSurface = readSurface) Context -> Surface : createDefaultFramebuffer() Surface -> Framebuffer : Framebuffer() Framebuffer -> SurfaceVk : createDefaultFramebuffer() SurfaceVk -> FramebufferVk : CreateDefaultFBO() @enduml CreateDefaultFBO vs. CreateUserFBO \u521b\u5efa\u65f6, \u4e8c\u8005\u533a\u522b\u4ec5\u4e3a\u9ed8\u8ba4FBO\u4f1a\u5305\u542b\u4e00\u4e2aWindowSurfaceVk // static FramebufferVk *FramebufferVk::CreateUserFBO(RendererVk *renderer, const gl::FramebufferState &state) // static FramebufferVk *FramebufferVk::CreateDefaultFBO(RendererVk *renderer, const gl::FramebufferState &state, WindowSurfaceVk *backbuffer) \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61 glGenFramebuffers(1, &fbo); @startuml APP -> Context :createFramebuffer() Context -> FramebufferManager : createFramebuffer() Context -> FramebufferManager : AllocateEmptyObject() @startuml 4.3.2. ResourceManager ANGLE \u7684 gles \u524d\u7aef\u4e2d, \u4f7f\u7528\u4e00\u7cfb\u5217 ResourceManager \u6765\u5173\u8054\u6ce8\u518c\u7684 id \u4e0e\u7c7b\u7684\u5bf9\u5e94\u60c5\u51b5.\u5176\u6709\u4e24\u4e2a\u529f\u80fd: \u521b\u5efa\u65b0\u5bf9\u8c61, \u5e76\u7528\u4e00\u4e2ahash\u8868\u628a id\u4e0e\u5bf9\u8c61\u5b58\u50a8\u8d77\u6765\u4ee5\u4f9b\u67e5\u8be2. @startuml hide method class ResourceManagerBase { HandleAllocator mHandleAllocator; } class TypedResourceManager { ResourceMap<ResourceType, IDType> mObjectMap; } class ShaderProgramManager { ResourceMap<Shader, ShaderProgramID> mShaders; ResourceMap<Program, ShaderProgramID> mPrograms; } TypedResourceManager --|> ResourceManagerBase ShaderProgramManager --|> ResourceManagerBase @enduml TypedResourceManager \u7684\u5b50\u7c7b: BufferManager ShaderProgramManager TextureManager RenderbufferManager SamplerManager SyncManager FramebufferManager ProgramPipelineManager MemoryObjectManager SemaphoreManager \u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684(Active)\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, fbo); GL_READ_FRAMEBUFFER \u548c GL_DRAW_FRAMEBUFFER \u5206\u5f00\u5904\u7406, \u82e5\u4e3aGL_FRAMEBUFFER\u5219\u4e24\u4e2a\u5206\u652f\u90fd\u8d70\u4e00\u904d. \u5148\u53bbFramebufferManager\u7684Hash\u4e2d\u67e5\u627e, \u65e0\u5219\u521b\u5efa. GL_READ_FRAMEBUFFER @startuml EntryPoint -> Context : bindReadFramebuffer box \"if(query(fbID) == null)\" Context -> FramebufferManager : checkFramebufferAllocation (ShareGroup) FramebufferManager -> FramebufferManager : AllocateNewObject FramebufferManager -> Framebuffer : new Framebuffer Framebuffer -> FramebufferVk : CreateUserFBO end box Context -> State : setReadFramebufferBinding(framebuffer) Context -> ObserverBinding : bind(framebuffer) @enduml Context \u4e2d mDrawFramebufferObserverBinding: ObserverBinding.bind \u4e3a\u89c2\u5bdf\u8005\u7ed1\u5b9a\u5355\u4e00\u89c2\u5bdf\u5bf9\u8c61. GL_DRAW_FRAMEBUFFER (\u7701\u7565\u521b\u5efa\u90e8\u5206) @startuml EntryPoint -> Context: bindDrawFramebuffer Context -> State : setDrawFramebufferBinding Context -> ObserverBinding : bind(framebuffer) Context -> StateCache : onDrawFramebufferChange( context ) \\n \u9519\u8bef\u6821\u9a8c\u7528 @enduml \u89e3\u7ed1FBO / \u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u540c\u7ed1\u5b9aFBO 4.3.3. \u7eb9\u7406\u9644\u7740 \u5c06\u7eb9\u7406\u9644\u52a0\u5728\u5e27\u7f13\u51b2\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); @startuml EntryPoint -> Context: framebufferTexture2D Context -> State : getTargetFramebuffer (ShareGroup) Context -> Framebuffer : setAttachment Framebuffer -> FramebufferAttachment : attachment(FBAObject) Context -> State : setObjectDirty() @enduml \u7ed1\u5b9a\u540e, \u4f1a\u8bbe\u7f6e\u5982\u4e0b dirty\u72b6\u6001 - State : setObjectDirty() - framebuffer.mDirtyBits.set(DIRTY_BIT_COLOR_ATTACHMENT_0) - state.mDirtyObjects.set(DIRTY_OBJECT_READ_FRAMEBUFFER); - state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_FRAMEBUFFER); - state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_ATTACHMENTS); 4.3.4. Renderbuffer \u9644\u7740 \u521b\u5efa\u548c\u7ed1\u5b9a Renderbuffer \u5bf9\u8c61\u7684\u5b9e\u73b0\u4e0e Framebuffer \u7c7b\u4f3c glGenRenderbuffers(1, &rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); \u53c2\u8003 GenFramebuffer , BindFramebuffer \u521b\u5efa\u4e00\u4e2a\u6df1\u5ea6\u548c\u6a21\u677f\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); \u4e24\u4e2a\u65b9\u6cd5\u540c\u4e00\u4e2a\u5b9e\u73b0, \u524d\u8005 samples=0 \u5b8c\u6210\u5bf9 RenderBufferVk \u5bf9\u8c61\u5185\u5404\u53c2\u6570\u7684\u521d\u59cb\u5316, \u53ca\u8bbe\u7f6e RenderTargetVk @startuml Context -> Renderbuffer : setStorage() Renderbuffer -> RenderbufferVk : setStorageImpl() RenderbufferVk -> ImageHelper : init() RenderbufferVk -> ImageViewHelper : init() RenderbufferVk -> RenderTargetVk : init() @enduml \u9644\u52a0\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5230 FBO\uff1a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); @startuml Context -> RenderbufferManager : getRenderbuffer() Context -> Framebuffer : setAttachmentMultisample(renderbuffer) @enduml framebuffer.mDirtyBits.set(DIRTY_BIT_DEPTH_ATTACHMENT); state.mDirtyObjects.set(DIRTY_OBJECT_READ_FRAMEBUFFER); state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_FRAMEBUFFER); state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_ATTACHMENTS); 4.4. \u72b6\u6001\u540c\u6b65 ANGLE \u7684\u524d\u540e\u7aef\u5728\u6267\u884c\u53ef\u80fd\u4f1a\u89e6\u53d1Flush\u7684\u64cd\u4f5c\u65f6, \u4f1a\u8fdb\u884c\u72b6\u6001\u540c\u6b65. \u5e38\u89c1\u7684\u64cd\u4f5c\u4f8b\u5982 Clear, Draw, CopyImage \u7b49. \u4f8b\u5982\u5728\u7ed1\u5b9a\u4e00\u4e2aFBO\u5e76\u6267\u884c Clear\u7684\u65f6\u5019, \u4f1a\u8fdb\u884c\u5982\u4e0b\u540c\u6b65: @startuml Context -> Context : syncState() Context -> State : syncDirtyObjects() State -> FramebufferVk : syncState() Context -> ContextVk : syncDirtyBits() ContextVk -> ContextVk : syncState() \\n case: DIRTY_BIT_DRAW_FRAMEBUFFER_BINDING ContextVk -> GraphicsPipelineDesc : updatePipelineXXXX() @enduml \u5176\u4e2dState : syncDirtyObjects \u4f1a\u4f9d\u6b21\u8c03\u7528\u6ce8\u518c\u7684 dirty \u5bf9\u8c61\u7684 syncState\u65b9\u6cd5. ContextVk : syncState \u7684 DirtyBits \u4e2d, \u5305\u542b\u4e00\u4e2a DRAW_FRAMEBUFFER_BINDING \u8868\u793a\u53d1\u751f\u8fc7 Framebuffer \u7684\u91cd\u7ed1\u5b9a, \u9700\u8981\u66f4\u65b0Pipeline 4.4.1. FramebufferVk.syncState() syncState RenderTargetCache.update // Read_Framebuffer updateColorAttachment RenderTargetCache.updateColorRenderTarget() RenderTargetCache.getColors() updateActiveColorMasks() contextVk->updateColorMasks() renderTarget->flushStagedUpdates() FramebufferDesc.updateColor() index++ FramebufferDesc::updateColorResolve() index++ updateDepthStencilAttachment RenderTargetCache.updateDepthStencilRenderTarget() FramebufferDesc.updateDepthStencil FramebufferDesc.updateColorResolve renderTarget->flushStagedUpdates contextVk->updateColorMasks() //Draw_fb\u5219\u66f4\u65b0pipeline\u7684colormask contextVk->flushCommandsAndEndRenderPass() // ??? \u4e3a\u4ec0\u4e48 sync \u8981 flush? updateRenderPassDesc(); contextVk->onFramebufferChange(this); GraphicsPipelineDesc->updateRenderPassDesc() 4.4.2. \u5207\u6362 Framebuffer \u65f6\u4fee\u6539 Pipeline (ContextVk::syncState) \u7531\u4e8e\u5728 gles \u5207\u6362 Framebuffer\u65f6, \u4e00\u4e9b\u4e0e\u4e4b\u7ed1\u5b9a\u7684\u8bbe\u7f6e\u4e5f\u76f8\u5e94\u88ab\u5207\u6362. \u4f8b\u5982 \u989c\u8272\u9644\u7740\u7684\u6570\u91cf\u7b49. \u800c\u5728 vk \u4e2d, \u9664\u4e86\u8981\u5207\u6362\u5bf9\u5e94 RenderPass \u548c Framebuffer, \u90e8\u5206\u8bbe\u7f6e\u8fd8\u4f1a\u53cd\u5e94\u5230 Pipeline \u4e0a, \u672c\u8282\u5217\u51fa\u5728 angle \u7684 vk::ContextVk \u8fdb\u884c\u72b6\u6001\u540c\u6b65( syncState ) \u7684\u8fc7\u7a0b\u4e2d, \u5bf9 Draw Framebuffer \u7ed1\u5b9a\u66f4\u65b0\u65f6\u6d89\u53ca\u5230\u7684 Pipeline \u5c5e\u6027\u7684\u66f4\u65b0: VkPipelineViewportStateCreateInfo pViewports pScissors \u6765\u6e90: \u7531\u7ed8\u5236\u8fc7\u7a0b\u4e2d, glViewpoint \u4fee\u6539 VkPipelineRasterizationStateCreateInfo \u5149\u6805, \u8bbe\u7f6e: \u6df1\u5ea6\u6d4b\u8bd5, \u80cc\u9762\u5254\u9664, \u88c1\u526a\u6d4b\u8bd5, \u4f8b\u5982: cullMode \u8868\u660e\u5254\u9664\u7c7b\u578b: \u80cc\u9762 / \u6b63\u9762 / \u53cc\u9762 frontFace =VK_FRONT_FACE_CLOCKWISE / VK_FRONT_FACE_COUNTER_CLOCKWISE \u6307\u5b9a\u987a\u65f6\u9488\u9876\u70b9\u5e8f\u662f\u6b63\u9762, \u8fd8\u662f\u9006\u65f6\u9488\u9876\u70b9\u5e8f\u662f\u6b63\u9762 \u6765\u6e90: ANGLE \u5728\u7ed8\u5236 \u9ed8\u8ba4FB\u548c\u81ea\u5b9a\u4e49FB\u65f6, \u4f1a\u5bf9\u753b\u9762\u8fdb\u884c\u65cb\u8f6c, \u6309\u4e0d\u540c\u7684\u987a\u5e8f\u8fdb\u884c\u7ed8\u5236. \u79bb\u5c4f: VK_FRONT_FACE_COUNTER_CLOCKWISE ANGLE \u8bf4\u660e: \u7531\u4e8eVulkan\u548cGLES\u5750\u6807\u7cfb\u7684\u4e0d\u540c\uff0c\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u533a\uff08\u6e90\u81ea\u4ea4\u6362\u94fe\uff09\u5448\u4e0a\u4e0b\u98a0\u5012\u663e\u793a\u3002\u98a0\u5012\u6e32\u67d3\u5177\u6709\u4e0eOpenGL\u76f8\u540c\u7684\u6e32\u67d3\u65b9\u5f0f\u3002\u968f\u540e\u542f\u7528KHR_MAINTENANCE_1 \u6269\u5c55\u7a0b\u5e8f\u4ee5\u5141\u8bb8\u5426\u5b9a\u89c6\u53e3\u3002\u6211\u4eec\u901a\u8fc7\u53cd\u8f6c\u89c6\u53e3\u7684\u9ad8\u5ea6\u5e76\u5c06Y\u589e\u52a0\u9ad8\u5ea6\u6765\u53cd\u8f6c\u6e32\u67d3\u5230\u540e\u7f13\u51b2\u533a\u3002\u56e0\u6b64\uff0c\u5982\u679c\u89c6\u53e3\u4e3a\uff080\uff0c0\uff0cwidth\uff0cheight\uff09\uff0c\u5219\u89c6\u53e3\u53d8\u4e3a\uff080\uff0cheight\uff0cwidth\uff0c-height\uff09\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u5f53\u6211\u4eec\u5f00\u59cb\u8fd9\u6837\u505a\u65f6\uff0c\u7531\u4e8e\u6e32\u67d3\u73b0\u5728\u662f\u4e0a\u4e0b\u98a0\u5012\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u8fd8\u9700\u8981\u8c03\u6574\u4e00\u4e9b\u4f4d\u7f6e\u3002\u5230\u76ee\u524d\u4e3a\u6b62\u53d7\u5f71\u54cd\u7684\u5730\u65b9\uff1a readPixels copyTexImage framebuffer blit generating mipmaps Point sprites tests texStorage VkPipelineMultisampleStateCreateInfo \u591a\u91cd\u91c7\u6837: \u7ec4\u5408\u591a\u4e2a\u4e0d\u540c\u591a\u8fb9\u5f62\u4ea7\u751f\u7684\u7247\u6bb5\u7684\u989c\u8272, \u6765\u51b3\u5b9a\u6700\u7ec8\u989c\u8272\u7684\u6280\u672f. (\u6297\u952f\u9f7f) rasterizationSamples : \u91c7\u6837\u6570, \u7b49\u4e8e VkImage.sample sampleShadingEnable : rasterizationSamples > 1 minSampleShading : sampleShadingEnable \u4e3a false \u65f6, \u503c\u4e3a1 pSampleMask : rasterizationSamples > 1 \u4e14 SamplerMaskEnable \u65f6\u624d\u4f1a\u542f\u7528 \u6765\u6e90: \u4e0e VkImage \u4e2d samples \u6570\u53d1\u751f\u53d8\u5316\u65f6, \u4e0a\u8ff0\u503c\u5bf9\u5e94\u6539\u53d8. VkPipelineDepthStencilStateCreateInfo \u6df1\u5ea6\u6d4b\u8bd5, \u6a21\u677f\u6d4b\u8bd5 depthTestEnable = static_cast (mDepthStencilStateInfo.enable. depthTest ); depthWriteEnable = static_cast (mDepthStencilStateInfo.enable. depthWrite ); stencilTestEnable = static_cast (mDepthStencilStateInfo.enable. stencilTest ); front.writeMask back.writeMask \u6765\u6e90: gLEnable \u542f\u7528 depth test\u7b49 VkPipelineColorBlendStateCreateInfo \u989c\u8272\u6df7\u5408: blendState. pAttachments [ \u200b VkPipelineColorBlendAttachmentState. colorWriteMask ] \u6765\u6e90: Color Attachment \u6570\u91cf\u53d8\u52a8\u65f6, \u9700\u5bf9\u5e94\u589e\u5220","title":"136 ANGLE FBO"},{"location":"ANGLE/136%20ANGLE_FBO/#1-gles-framebuffers","text":"\u672c\u7ae0\u4e3b\u8981\u6765\u81ea LearnOpenGL \u53ca GLES 3.0 \u7f16\u7a0b\u6307\u5357","title":"1. GLES Framebuffers"},{"location":"ANGLE/136%20ANGLE_FBO/#11","text":"\u901a\u5e38\u6211\u4eec\u7684\u64cd\u4f5c\u90fd\u662f\u5728 \u9ed8\u8ba4 \u5e27\u7f13\u51b2 (Default Framebuffer ) \u7684\u6e32\u67d3\u7f13\u51b2\u4e0a\u8fdb\u884c\u7684\u3002\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u662f\u5728\u4f60\u521b\u5efa\u7a97\u53e3\u7684\u65f6\u5019\u751f\u6210\u548c\u914d\u7f6e\u7684\uff08EGL\uff09\u3002 \u5728GL\u4e2d\u4f1a\u4f7f\u7528\u51e0\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u5c4f\u5e55\u7f13\u51b2\uff1a\u7528\u4e8e\u5199\u5165\u989c\u8272\u503c\u7684 \u989c\u8272\u7f13\u51b2 \uff0c\u7528\u4e8e\u5199\u5165\u6df1\u5ea6\u4fe1\u606f\u7684 \u6df1\u5ea6\u7f13\u51b2 \uff0c\u4ee5\u53ca\u5141\u8bb8\u6211\u4eec\u57fa\u4e8e\u4e00\u4e9b\u6761\u4ef6\u4e22\u5f03\u6307\u5b9a\u7247\u6bb5\u7684 \u6a21\u677f\u7f13\u51b2 \u3002\u628a\u8fd9\u51e0\u79cd\u7f13\u51b2\u7ed3\u5408\u8d77\u6765\u53eb\u505a\u5e27\u7f13\u51b2(Framebuffer)\u3002 \u800c\u4f7f\u7528 \u5e27\u7f13\u51b2\u5bf9\u8c61 (Framebuffer Object) \u5141\u8bb8\u7528\u6237 \u81ea\u5b9a\u4e49\u5e27\u7f13\u51b2 \uff0cFramebuffer \u5b9e\u9645\u662f\u4e00\u4e2a\u53ef\u6dfb\u52a0 \u7f13\u51b2\u7684\u5bb9\u5668 . \u7528\u6237\u53ef\u4ee5\u4e3a\u5176\u6dfb\u52a0 \u7eb9\u7406 (Textures ) \u6216 \u6e32\u67d3\u7f13\u51b2\u533a \u5bf9\u8c61\uff08Renderbuffer), \u6765\u5b9a\u4e49\u81ea\u5df1\u7684\u989c\u8272\u7f13\u51b2\uff0c\u6df1\u5ea6\u7f13\u51b2, \u548c\u6a21\u677f\u7f13\u51b2\u3002","title":"1.1. \u5b9a\u4e49"},{"location":"ANGLE/136%20ANGLE_FBO/#111","text":"\u6e32\u67d3\u5230\u4e00\u4e2a\u975e\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u88ab\u53eb\u505a \u79bb\u5c4f\u6e32\u67d3 (Off-screen Rendering) \u6216 \u6e32\u67d3\u5230\u7eb9\u7406 (Render to Texture)\u3002 \u901a\u8fc7\u81ea\u5b9a\u4e49\u5e27\u7f13\u51b2\u53ef\u4ee5\u5c06\u4f60\u7684\u573a\u666f\u6e32\u67d3\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u4e2d, \u53ef\u4ee5\u4f7f\u6211\u4eec\u80fd\u591f\u5728\u5f53\u524d\u573a\u666f\u4e2d\u521b\u5efa \u955c\u5b50, \u5012\u5f71 \u8fd9\u6837\u7684\u6548\u679c. \u8fd8\u6709\u5f88\u591a\u5e38\u89c1\u7279\u6548\u9700\u8981\u7528\u5230\u5e27\u7f13\u51b2, \u4f8b\u5982: \u9634\u5f71\u8d34\u56fe, \u52a8\u6001\u53cd\u5c04\u548c\u73af\u5883\u8d34\u56fe, \u591a\u9053\u666f\u6df1\u6280\u672f, \u52a8\u6001\u6a21\u7cca, \u548c\u540e\u671f\u5904\u7406\u7279\u6548\u7b49.","title":"1.1.1. \u5e94\u7528"},{"location":"ANGLE/136%20ANGLE_FBO/#12","text":"\u9ed8\u8ba4\u5e27\u7f13\u51b2 Default Framebuffers \u5728\u8fdb\u884cGLES\u6307\u4ee4\u64cd\u4f5c\u524d, \u9700\u8981\u521b\u5efa\u4e00\u4e2a Context \u548c \u7ed8\u56fe\u8868\u9762 (\u9ed8\u8ba4 Framebuffer), \u8fd9\u901a\u5e38\u7531\u539f\u751f\u7a97\u53e3\u7cfb\u7edf\u901a\u8fc7 EGL \u7b49\u5b8c\u6210. \u521b\u5efa EGL \u7ed8\u5236\u8868\u9762\u7684\u8c03\u7528\u65f6, \u4ee5\u50cf\u7d20\u5f62\u5f0f\u6307\u5b9a \u5bbd\u5ea6,\u9ad8\u5ea6, \u662f\u5426\u4f7f\u7528 \u989c\u8272\u7f13\u51b2, \u6df1\u5ea6\u7f13\u51b2, \u6a21\u677f\u7f13\u51b2, \u53ca\u8fd9\u4e9b\u7f13\u51b2\u533a\u7684\u4f4d\u6df1. \u4e0d\u80fd\u5bf9\u5176\u8fdb\u884c\u4fee\u6539\u6216\u67e5\u8be2\u72b6\u6001\u64cd\u4f5c glViewport \u63a7\u5236\u5e27\u7f13\u51b2\u7684\u5927\u5c0f, \u4ee5\u53ca\u63a7\u5236\u9634\u5f71\u6df1\u5ea6\u8d34\u56fe\u5927\u5c0f\u7b49\u7b49 \u5e27\u7f13\u51b2\u5bf9\u8c61 Framebuffers Objects (FBOs) \u9644\u7740 Attachment FBO \u4ec5\u88ab\u89c6\u4e3a\u7f13\u5b58\u7684\u5bb9\u5668, \u56e0\u6b64\u4f7f\u7528 FBO \u4f5c\u4e3a\u6e32\u67d3\u76ee\u6807\u65f6\uff0c\u9996\u5148\u9700\u8981\u4e3a FBO \u7684\u9644\u7740\u8fde\u63a5\u5bf9\u8c61\uff0c \u9644\u7740\u662f\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\uff0c\u5b83\u80fd\u591f\u4f5c\u4e3a\u5e27\u7f13\u51b2\u7684\u4e00\u4e2a\u7f13\u51b2\uff0c\u53ef\u4ee5\u5c06\u5b83\u60f3\u8c61\u4e3a\u4e00\u4e2a\u56fe\u50cf\u3002 \u521b\u5efa\u4e00\u4e2a\u9644\u4ef6\u65b9\u5f0f\u6709\u4e24\u79cd\uff1a \u7eb9\u7406 \u6216 \u6e32\u67d3\u7f13\u51b2 \u5bf9\u8c61(Renderbuffer)\u3002 \u5e27\u7f13\u51b2\u76843\u4e2a\u9644\u7740 \u989c\u8272\u9644\u7740 Color Attachment \u6df1\u5ea6\u9644\u7740 Depth Attachment \u6a21\u677f\u9644\u7740 Stencil Attachment \u7eb9\u7406\u9644\u4ef6 Textures \u5373\u666e\u901a\u7684 Texture, \u6839\u636e Format\u7684\u4e0d\u540c, \u53ef\u4ee5\u5206\u522b\u7528\u4f5c FBO \u4e2d\u7684\u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u9644\u7740\u3002 \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 Renderbuffer Objects \u662f\u4e00\u4e2a\u7531\u5e94\u7528\u7a0b\u5e8f\u5206\u914d\u7684 2D \u56fe\u50cf\u7f13\u51b2\u533a\u3002 \u6e32\u67d3\u7f13\u51b2\u533a\u53ef\u4ee5\u7528\u4e8e\u5206\u914d\u548c\u5b58\u50a8 \u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u503c\uff0c\u53ef\u4ee5\u7528\u4f5c FBO \u4e2d\u7684\u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u9644\u7740\u3002 \u4f7f\u7528 \u7eb9\u7406 \u548c Renderbuffer \u5bf9\u8c61, \u90fd\u652f\u6301\u4e3a FBO \u5206\u522b\u6dfb\u52a0\u4e09\u79cd\u9644\u7740. \u4f46\u901a\u5e38\u4f7f\u7528 Texture \u6dfb\u52a0\u989c\u8272\u9644\u7740, \u7528 Renderbuffer \u6765\u6dfb\u52a0\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740. \u539f\u56e0\u5728\u540e\u9762\u8ba8\u8bba. (OpenGL ES 3.0 \u7f16\u7a0b\u6307\u5357)","title":"1.2. \u76f8\u5173\u5b9a\u4e49"},{"location":"ANGLE/136%20ANGLE_FBO/#13","text":"\u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61 glGenFramebuffers(1, &fbo); \u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684(Active)\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, fbo); \u5728\u7ed1\u5b9a\u5230GL_FRAMEBUFFER\u76ee\u6807\u4e4b\u540e\uff0c\u6240\u6709\u7684 \u8bfb\u53d6 \u548c \u5199\u5165 \u5e27\u7f13\u51b2\u7684\u64cd\u4f5c\u5c06\u4f1a\u5f71\u54cd\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u3002 \u6211\u4eec\u4e5f\u53ef\u4ee5\u4f7f\u7528 GL_READ_FRAMEBUFFER \u6216 GL_DRAW_FRAMEBUFFER \uff0c\u5c06\u4e00\u4e2a\u5e27\u7f13\u51b2\u5206\u522b\u7ed1\u5b9a\u5230\u8bfb\u53d6\u76ee\u6807\u6216\u5199\u5165\u76ee\u6807\u3002 \u7ed1\u5b9a\u5230 GL_READ_FRAMEBUFFER \u7684\u5e27\u7f13\u51b2\u5c06\u4f1a\u4f7f\u7528\u5728\u6240\u6709\u50cf\u662f glReadPixels \u7684\u8bfb\u53d6\u64cd\u4f5c\u4e2d\uff0c \u7ed1\u5b9a\u5230 GL_DRAW_FRAMEBUFFER \u7684\u5e27\u7f13\u51b2\u5c06\u4f1a\u88ab\u7528\u4f5c\u6e32\u67d3\u3001\u6e05\u9664\u7b49\u5199\u5165\u64cd\u4f5c\u7684\u76ee\u6807\u3002 \u901a\u5e38\u90fd \u4e0d\u9700\u8981\u533a\u5206 \u5b83\u4eec\uff0c\u4f7f\u7528 GL_FRAMEBUFFER \uff0c\u7ed1\u5b9a\u5230\u4e24\u4e2a\u4e0a\u3002 \u6dfb\u52a0\u9644\u7740: \u5728\u8fd9\u4e00\u9636\u6bb5, \u4f7f\u7528Texture\u6216Renderbuffer\u5bf9FBO\u6dfb\u52a0\u9644\u7740, \u4ee3\u7801\u5728\u4e0b\u4e24\u8282\u79cd\u5c55\u793a. \u6dfb\u52a0\u9644\u7740\u540e, \u68c0\u67e5\u5e27\u7f13\u51b2\u7684\u5b8c\u6574\u6027 if( glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE) \u4e00\u4e2a\u5b8c\u6574\u7684\u5e27\u7f13\u51b2\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u7684\u6761\u4ef6\uff1a \u9644\u52a0\u81f3\u5c11\u4e00\u4e2a\u9644\u7740\uff08\u989c\u8272\u3001\u6df1\u5ea6\u6216\u6a21\u677f\u9644\u7740\uff09\u3002 \u81f3\u5c11\u6709\u4e00\u4e2a\u989c\u8272\u9644\u4ef6(Attachment)\u3002TODO: check angle \u6240\u6709\u7684\u9644\u4ef6\u90fd\u5fc5\u987b\u662f\u5b8c\u6574\u7684\uff08\u4fdd\u7559\u4e86\u5185\u5b58\uff09\u3002 \u6bcf\u4e2a\u7f13\u51b2\u90fd\u5e94\u8be5\u6709\u76f8\u540c\u7684\u9ad8\u5ea6\u548c\u5bbd\u5ea6\u3002 \u5982\u679c\u5b58\u5728\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740, \u5b83\u4eec\u5fc5\u987b\u662f\u76f8\u540c\u7684\u56fe\u50cf. \u6240\u6709\u9644\u7740\u7684 GL_RENDERBUFFER_SAMPLES \u6837\u672c\u503c\u76f8\u540c. \u82e5\u9644\u7740\u5bf9\u8c61\u662f\u7eb9\u7406, \u5219\u6b64\u503c\u4e3a0. \u89e3\u7ed1FBO / \u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u6e32\u67d3\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u88ab\u53eb\u505a \u79bb\u5c4f\u6e32\u67d3 (Off-screen Rendering)\u3002\u8981\u4fdd\u8bc1\u6240\u6709\u7684\u6e32\u67d3\u64cd\u4f5c\u5728\u4e3b\u7a97\u53e3\u4e2d\u6709\u89c6\u89c9\u6548\u679c\uff0c\u6211\u4eec\u9700\u8981\u518d\u6b21\u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2\uff0c\u5c06\u5b83\u7ed1\u5b9a\u5230 0 \u3002","title":"1.3. \u521b\u5efa\u5e27\u7f13\u51b2"},{"location":"ANGLE/136%20ANGLE_FBO/#14","text":"\u666e\u901a\u7684\u521b\u5efa\u7eb9\u7406\u7684\u65b9\u5f0f unsigned int texture; glGenTextures(1, &texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); \u5982\u679c\u4f60\u60f3\u5c06\u4f60\u7684\u5c4f\u5e55\u6e32\u67d3\u5230\u4e00\u4e2a\u66f4\u5c0f\u6216\u66f4\u5927\u7684\u7eb9\u7406\u4e0a\uff0c\u4f60\u9700\u8981\uff08\u5728\u6e32\u67d3\u5230\u4f60\u7684\u5e27\u7f13\u51b2\u4e4b\u524d\uff09\u518d\u6b21\u8c03\u7528 glViewport \uff0c\u4f7f\u7528\u7eb9\u7406\u7684\u65b0\u7ef4\u5ea6\u4f5c\u4e3a\u53c2\u6570\uff0c\u5426\u5219\u53ea\u6709\u4e00\u5c0f\u90e8\u5206\u7684\u7eb9\u7406\u6216\u5c4f\u5e55\u4f1a\u88ab\u6e32\u67d3\u5230\u8fd9\u4e2a\u7eb9\u7406\u4e0a\u3002(?) \u5c06\u7eb9\u7406\u9644\u52a0\u5728\u5e27\u7f13\u51b2\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); target \uff1a\u5e27\u7f13\u51b2\u7684\u76ee\u6807\uff08\u7ed8\u5236\u3001\u8bfb\u53d6\u6216\u8005\u4e24\u8005\u7686\u6709\uff09 attachment \uff1a\u6211\u4eec\u60f3\u8981\u9644\u52a0\u7684\u9644\u4ef6\u7c7b\u578b\u3002\u5f53\u524d\u6211\u4eec\u6b63\u5728\u9644\u52a0\u4e00\u4e2a \u989c\u8272\u9644\u4ef6 \u3002\u6ce8\u610f\u6700\u540e\u7684 0 \u610f\u5473\u7740\u53ef\u4ee5\u9644\u52a0\u591a\u4e2a\u989c\u8272\u9644\u4ef6\u3002 GL_COLOR_ATTACHMENT i , GL_DEPTH_ATTACHMENT , GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMENT . textarget \uff1a\u4f60\u5e0c\u671b\u9644\u52a0\u7684\u7eb9\u7406\u7c7b\u578b texture \uff1a\u8981\u9644\u52a0\u7684\u7eb9\u7406\u672c\u8eab level \uff1a\u591a\u7ea7\u6e10\u8fdc\u7eb9\u7406\u7684\u7ea7\u522b\u3002\u6211\u4eec\u5c06\u5b83\u4fdd\u7559\u4e3a0 \u7eb9\u7406\u5bf9\u8c61\u5141\u8bb8\u9644\u52a0\u4e00\u4e2a\u6df1\u5ea6\u6216\u6a21\u677f\u7f13\u51b2\u7eb9\u7406\u5230\u5e27\u7f13\u51b2\u5bf9\u8c61\u4e2d\u3002 \u8981\u9644\u52a0\u6df1\u5ea6\u7f13\u51b2\u7684\u8bdd\uff0c\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e\u4e3a GL_DEPTH_ATTACHMENT \u3002\u5e76\u5c06\u7eb9\u7406\u7684\u683c\u5f0f(Format)\u548c\u5185\u90e8\u683c\u5f0f(Internalformat)\u7c7b\u578b\u53d8\u4e3a GL_DEPTH_COMPONENT \uff0c\u6765\u53cd\u6620\u6df1\u5ea6\u7f13\u51b2\u7684\u50a8\u5b58\u683c\u5f0f\u3002 \u8981\u9644\u52a0\u6a21\u677f\u7f13\u51b2\u7684\u8bdd\uff0c\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e\u4e3a GL_STENCIL_ATTACHMENT \uff0c\u5e76\u5c06\u7eb9\u7406\u7684\u683c\u5f0f\u8bbe\u5b9a\u4e3a GL_STENCIL_INDEX \u3002 \u4e5f\u53ef\u4ee5\u5c06\u6df1\u5ea6\u7f13\u51b2\u548c\u6a21\u677f\u7f13\u51b2\u5408\u5e76\u9644\u52a0\u4e3a\u4e00\u4e2a\u7eb9\u7406\u3002\u7eb9\u7406\u7684\u6bcf32\u4f4d\u6570\u503c\u5c06\u5305\u542b24\u4f4d\u7684\u6df1\u5ea6\u4fe1\u606f\u548c8\u4f4d\u7684\u6a21\u677f\u4fe1\u606f\u3002\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e GL_DEPTH_STENCIL_ATTACHMENT \u7c7b\u578b\uff0c\u5e76\u914d\u7f6e\u7eb9\u7406\u7684\u683c\u5f0f\uff0c\u8ba9\u5b83\u5305\u542b\u5408\u5e76\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u503c\u3002 ``` glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL ); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0); ```","title":"1.4. \u7eb9\u7406\u9644\u7740"},{"location":"ANGLE/136%20ANGLE_FBO/#15-renderbuffer","text":"\u521b\u5efa\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u7684\u4ee3\u7801 glGenRenderbuffers(1, &rbo); \u7ed1\u5b9a\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\uff0c\u8ba9\u4e4b\u540e\u6240\u6709\u7684\u6e32\u67d3\u7f13\u51b2\u64cd\u4f5c\u5f71\u54cd\u5f53\u524d\u7684 RBO\uff1a glBindRenderbuffer(GL_RENDERBUFFER, rbo); \u521b\u5efa\u4e00\u4e2a\u6df1\u5ea6\u548c\u6a21\u677f\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); \u521b\u5efa\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u548c\u7eb9\u7406\u5bf9\u8c61\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u662f\u8fd9\u4e2a\u5bf9\u8c61\u662f\u4e13\u95e8\u88ab\u8bbe\u8ba1\u4f5c\u4e3a\u56fe\u50cf\u4f7f\u7528\u7684\uff0c\u800c\u4e0d\u662f\u7eb9\u7406\u90a3\u6837\u7684\u901a\u7528\u6570\u636e\u7f13\u51b2(General Purpose Data Buffer)\u3002 \u8fd9\u91cc\u6211\u4eec\u9009\u62e9 GL_DEPTH24_STENCIL8 \u4f5c\u4e3a\u5185\u90e8\u683c\u5f0f\uff0c\u5b83\u5c01\u88c5\u4e8624\u4f4d\u7684\u6df1\u5ea6\u548c8\u4f4d\u7684\u6a21\u677f\u7f13\u51b2\u3002 \u9644\u52a0\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5230 FBO\uff1a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); \u4f7f\u7528 GL_DEPTH_STENCIL_ATTACHMENT \u8868\u793a\u540c\u65f6\u5305\u542b\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740","title":"1.5. Renderbuffer \u9644\u7740"},{"location":"ANGLE/136%20ANGLE_FBO/#16-texture-vs-renderbuffer","text":"\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61(Renderbuffer Object) \u662f\u5728\u7eb9\u7406\u4e4b\u540e\u5f15\u5165\u5230OpenGL\u4e2d\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u53ef\u7528\u7684\u5e27\u7f13\u51b2\u9644\u4ef6\u7c7b\u578b\u7684\uff0c\u6240\u4ee5\u5728\u8fc7\u53bb\u7eb9\u7406\u662f\u552f\u4e00\u53ef\u7528\u7684\u9644\u4ef6\u3002 Renderbuffer : \u548c\u7eb9\u7406\u56fe\u50cf\u4e00\u6837\uff0c\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u662f\u4e00\u4e2a\u771f\u6b63\u7684\u7f13\u51b2\uff0c\u5373\u4e00\u7cfb\u5217\u7684\u5b57\u8282\u3001\u6574\u6570\u3001\u50cf\u7d20\u7b49\u3002 \u4f18\u70b9: Renderbuffer \u4f1a\u5c06\u6570\u636e\u50a8\u5b58\u4e3aOpenGL\u539f\u751f\u7684\u6e32\u67d3\u683c\u5f0f\uff0c\u5b83\u662f\u4e3a\u79bb\u5c4f\u6e32\u67d3\u5230\u5e27\u7f13\u51b2\u4f18\u5316\u8fc7\u7684\u3002 Renderbuffer \u76f4\u63a5\u5c06\u6240\u6709\u7684\u6e32\u67d3\u6570\u636e\u50a8\u5b58\u5230\u5b83\u7684\u7f13\u51b2\u4e2d\uff0c\u4e0d\u4f1a\u505a\u4efb\u4f55\u9488\u5bf9\u7eb9\u7406\u683c\u5f0f\u7684\u8f6c\u6362\uff0c\u8ba9\u5b83\u53d8\u4e3a\u4e00\u4e2a\u66f4\u5feb\u7684\u53ef\u5199\u50a8\u5b58\u4ecb\u8d28\u3002 \u7f3a\u70b9: Renderbuffer \u4e0d\u80fd\u505a\u7eb9\u7406: \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u901a\u5e38\u90fd\u662f \u53ea\u5199 \u7684\uff0c\u6240\u4ee5\u4f60\u4e0d\u80fd\u8bfb\u53d6\u5b83\u4eec, \u6bd4\u5982\u4f7f\u7528\u7eb9\u7406\u8bbf\u95ee\u3002 \u5f53\u7136\u4f60\u4ecd\u7136\u8fd8\u662f\u80fd\u591f\u4f7f\u7528 glReadPixels \u6765\u8bfb\u53d6\u5b83\uff0c\u8fd9\u4f1a\u4ece\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2(\u800c\u4e0d\u662f\u9644\u4ef6\u672c\u8eab)\u4e2d\u8fd4\u56de\u7279\u5b9a\u533a\u57df\u7684\u50cf\u7d20\u3002 \u56e0\u6b64\u901a\u5e38\u7684\u89c4\u5219\u662f: \u5982\u679c\u4f60 \u4e0d\u9700\u8981\u4ece\u4e00\u4e2a\u7f13\u51b2\u4e2d\u91c7\u6837 \u6570\u636e\uff0c\u90a3\u4e48\u5bf9\u8fd9\u4e2a\u7f13\u51b2\u4f7f\u7528 \u6e32\u67d3\u7f13\u51b2 \u5bf9\u8c61\u4f1a\u662f\u660e\u667a\u7684\u9009\u62e9\u3002 \u800c\u5982\u679c\u4f60 \u9700\u8981\u4ece\u7f13\u51b2\u4e2d\u91c7\u6837\u989c\u8272\u6216\u6df1\u5ea6 \u503c\u7b49\u6570\u636e\uff0c\u90a3\u4e48\u4f60\u5e94\u8be5\u9009\u62e9 \u7eb9\u7406 \u9644\u4ef6\u3002\u6027\u80fd\u65b9\u9762\u5b83\u4e0d\u4f1a\u4ea7\u751f\u975e\u5e38\u5927\u7684\u5f71\u54cd\u7684\u3002 Renderbuffer \u5bf9\u8c61\u901a\u5e38\u7528\u4e8e \u6df1\u5ea6\u548c\u6a21\u677f \u9644\u4ef6\uff0c\u56e0\u4e3a\u5927\u90e8\u5206\u65f6\u95f4\u6211\u4eec\u90fd\u4e0d\u9700\u8981\u4ece\u6df1\u5ea6\u548c\u6a21\u677f\u7f13\u51b2\u4e2d\u8bfb\u53d6\u503c\uff0c\u53ea\u5173\u5fc3\u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5, \u4f46\u4e0d\u9700\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u91c7\u6837. \u5bf9\u5e94\u5230\u573a\u666f\u4e2d: \u9009\u62e9 Texture \u6e32\u67d3\u5230\u4e00\u4e2a\u7528\u4f5c\u989c\u8272\u7eb9\u7406\u7684\u989c\u8272\u7f13\u51b2\u533a \u6e32\u67d3\u5230\u4e00\u4e2a\u7528\u4f5c\u9634\u5f71\u7684\u6df1\u5ea6\u7eb9\u7406\u7684\u6df1\u5ea6\u7f13\u51b2\u533a \u9009\u62e9 Renderbuffer \u591a\u91cd\u91c7\u6837(? \u6765\u81ea\"3.0 \u7f16\u7a0b\u6307\u5357\" \u4f46 Texture \u4e5f\u6709MS, \u7248\u672c\u539f\u56e0?) \u5982\u679c\u56fe\u50cf\u4e0d\u88ab\u4f5c\u4e3a\u7eb9\u7406, \u5219 Renderbuffer \u53ef\u80fd\u5e26\u6765\u6027\u80fd\u4f18\u52bf: GLES \u53ef\u80fd\u4ee5\u66f4\u9ad8\u6548\u7684\u683c\u5f0f\u5b58\u50a8 Renderbuffer, \u6bd4\u7eb9\u7406\u66f4\u9002\u5408\u6e32\u67d3 \u4f8b\u5982: \u5229\u7528\u5176\u5199\u5165\u6216\u8005\u590d\u5236\u5230\u5176\u5b83\u7f13\u51b2\u5feb\u7684\u7279\u70b9\u3002 \u4ea4\u6362\u7f13\u51b2 \u8fd9\u6837\u7684\u64cd\u4f5c\u5728\u4f7f\u7528\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u65f6\u4f1a\u975e\u5e38\u5feb\u3002 \u5728\u6bcf\u4e2a\u6e32\u67d3\u8fed\u4ee3\u6700\u540e\u4f7f\u7528\u7684 glfwSwapBuffers \uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5b9e\u73b0\uff1a\u53ea\u9700\u8981\u5199\u5165\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u56fe\u50cf\uff0c\u5e76\u5728\u6700\u540e\u4ea4\u6362\u5230\u53e6\u5916\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5c31\u53ef\u4ee5\u4e86\u3002","title":"1.6. Texture VS. Renderbuffer"},{"location":"ANGLE/136%20ANGLE_FBO/#17","text":"","title":"1.7. \u793a\u4f8b: \u573a\u666f\u6ee4\u955c"},{"location":"ANGLE/136%20ANGLE_FBO/#171","text":"// \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61\uff0c\u5e76\u7ed1\u5b9a unsigned int framebuffer; glGenFramebuffers(1, &framebuffer); glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); // \u4f7f\u7528 Texture \u6dfb\u52a0\u989c\u8272\u9644\u7740 // \u751f\u6210\u7eb9\u7406 unsigned int texColorBuffer; glGenTextures(1, &texColorBuffer); glBindTexture(GL_TEXTURE_2D, texColorBuffer); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glBindTexture(GL_TEXTURE_2D, 0); // \u5c06\u7eb9\u7406\u5bf9\u8c61, \u9644\u52a0\u5230\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u5bf9\u8c61\u989c\u8272(color)\u9644\u4ef6\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, 0); // \u4f7f\u7528 Renderbuffer \u6dfb\u52a0\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740 // \u6df1\u5ea6\uff08\u548c\u6a21\u677f\uff09\u6d4b\u8bd5 // \u6dfb\u52a0\u4e00\u4e2a\u6df1\u5ea6\uff08\u548c\u6a21\u677f\uff09\u9644\u4ef6\u5230\u5e27\u7f13\u51b2\u4e2d unsigned int rbo; glGenRenderbuffers(1, &rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); // GL_DEPTH24_STENCIL8 glBindRenderbuffer(GL_RENDERBUFFER, 0); // \u5c06\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61, \u9644\u52a0\u5230\u5230\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u7684 depth \u548c stencil \u9644\u4ef6\u4e0a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); // \u68c0\u67e5\u5e27\u7f13\u51b2\u662f\u5426\u662f\u5b8c\u6574\u7684 if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) std::cout << \"ERROR::FRAMEBUFFER:: Framebuffer is not complete!\" << std::endl; // \u89e3\u7ed1\u5e27\u7f13\u51b2/\u7ed1\u5b9a\u56de\u9ed8\u8ba4 glBindFramebuffer(GL_FRAMEBUFFER, 0);","title":"1.7.1. \u521b\u5efa\u9636\u6bb5"},{"location":"ANGLE/136%20ANGLE_FBO/#172","text":"\u8981\u60f3\u7ed8\u5236\u573a\u666f\u5230\u4e00\u4e2a\u7eb9\u7406\u4e0a\uff0c\u6211\u4eec\u9700\u8981\u91c7\u53d6\u4ee5\u4e0b\u7684\u6b65\u9aa4\uff1a \u5c06\u65b0\u7684\u5e27\u7f13\u51b2\u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684\u5e27\u7f13\u51b2 \u548c\u5f80\u5e38\u4e00\u6837\u6e32\u67d3\u573a\u666f \u6b64\u65f6\u573a\u666f\u4f1a\u6e32\u67d3\u5230\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2, \u800c\u4e0d\u662f\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u3002 \u6240\u6709\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u64cd\u4f5c\u90fd\u4f1a\u4ece\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u4ef6\u4e2d\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u8bfb\u53d6\u3002 \u7ed1\u5b9a\u56de\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2 \u7ed8\u5236\u4e00\u4e2a\u6574\u5c4f\u5e55\u7684\u56db\u8fb9\u5f62\uff0c\u7136\u540e\u5c06\u5e27\u7f13\u51b2\u7684\u989c\u8272\u7f13\u51b2\u4f5c\u4e3a\u56db\u8fb9\u5f62\u7684\u7eb9\u7406\u3002 // \u7b2c\u4e00\u5904\u7406\u9636\u6bb5: \u7ed8\u5236\u5230FBO glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // \u6211\u4eec\u73b0\u5728\u4e0d\u4f7f\u7528\u6a21\u677f\u7f13\u51b2 glEnable(GL_DEPTH_TEST); DrawScene(); // \u7ed8\u5236\u539f\u59cb 3D \u573a\u666f // Load VAO, bind Textures, uniform data, call glDrawArrays or glDrawElements // \u7b2c\u4e8c\u5904\u7406\u9636\u6bb5: \u7ed8\u5236\u5230\u5c4f\u5e55 glBindFramebuffer(GL_FRAMEBUFFER, 0); // \u8fd4\u56de\u9ed8\u8ba4 glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); screenShader.use(); // \u4f7f\u7528\u53e6\u4e00\u5957 shader glBindVertexArray(quadVAO); // \u7ed8\u5236\u4e00\u4e2a\u56db\u8fb9\u5f62 glDisable(GL_DEPTH_TEST); glBindTexture(GL_TEXTURE_2D, textureColorbuffer); // \u5c06 Color Buffer \u4f5c\u4e3a\u7eb9\u7406\u7ed8\u5236\u5230\u56db\u8fb9\u5f62\u4e0a glDrawArrays(GL_TRIANGLES, 0, 6); \u5982\u679c screenShader \u4e0d\u505a\u7279\u6b8a\u5904\u7406, \u6b64\u65f6\u753b\u9762\u4f1a\u548c DrawScene \u7ed8\u5236\u7684\u539f\u59cb3D\u573a\u666f\u4e00\u81f4. \u6b64\u65f6\u7ed8\u5236\u7684\u56db\u8fb9\u5f62\u7c7b\u4f3c\u4e00\u4e2a\u663e\u793a\u5c4f\u5e55, \u5229\u7528\u8d34\u56fe\u663e\u793a\u539f\u59cb\u573a\u666f. \u4f46\u5982\u679c\u5bf9 screenShader \u4e2d\u7eb9\u7406\u7684color\u8fdb\u884c\u4fee\u6539, \u5c31\u53ef\u7528\u5b9e\u73b0\u6ee4\u955c\u6548\u679c. void main() { // \u53cd\u8272\u7279\u6548 FragColor = vec4(vec3(1.0 - texture(screenTexture, TexCoords)), 1.0); } \u753b\u9762\u6548\u679c\u548c\u66f4\u591a\u7279\u6548\u5904\u7406, \u53c2\u89c1 LearnOpenGL","title":"1.7.2. \u7ed8\u5236\u9636\u6bb5"},{"location":"ANGLE/136%20ANGLE_FBO/#18-msaa","text":"\u79bb\u5c4fMSAA \u5728\u9ed8\u8ba4\u5e27\u7f13\u51b2\u4e2d\u542f\u7528MASS, \u53ea\u9700\u8981 glEnable(GL_MULTISAMPLE); \u542f\u7528\u5373\u53ef. \u4f46\u5bf9\u4e8e\u79bb\u5c4f\u6e32\u67d3, \u9700\u8981\u624b\u52a8\u521b\u5efa\u591a\u91cd\u91c7\u6837\u7684\u9644\u7740. Texture: \u521b\u5efaMS Texture: \u4f7f\u7528 glTexImage2DMultisample \u6765\u66ff\u4ee3 glTexImage2D glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex); glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE); glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0); \u9644\u52a0\u5230\u5e27\u7f13\u51b2: \u4f7f\u7528 glFramebufferTexture2D \u5c06\u591a\u91cd\u91c7\u6837\u7eb9\u7406\u4e0a\uff0c\u4f46\u8fd9\u91cc\u7eb9\u7406\u7c7b\u578b\u4f7f\u7528\u7684\u662f GL_TEXTURE_2D_MULTISAMPLE \u3002 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0); Renderbuffer : \u521b\u5efa\u8fc7\u7a0b\u4e0d\u53d8 \u9644\u52a0\u5230\u5e27\u7f13\u51b2: \u5c06 glRenderbufferStorage \u7684\u8c03\u7528\u6539\u4e3a glRenderbufferStorageMultisample \u5c31\u53ef\u4ee5\u4e86 glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, width, height); \u7b2c\u4e8c\u53c2\u6570 4 \u4e3a\u91c7\u6837\u6b21\u6570 \u7ed8\u5236: void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); \u5c06\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u7684\u50cf\u7d20\u503c, \u4ece\u4e00\u4e2a\u5e27\u7f13\u51b2\u590d\u5236\u5230\u53e6\u4e00\u4e2a\u5e27\u7f13\u51b2. \u901a\u8fc7 glBlitFramebuffer \u5c06\u591a\u91cd\u91c7\u6837\u7684\u5e27\u7f13\u51b2, \u590d\u5236\u5230\u4e00\u4e2a\u4e2d\u4ecb\u5e27\u7f13\u51b2\u7684\u989c\u8272\u9644\u7740\u7684\u7eb9\u7406, \u5b9e\u73b0\u591a\u91cd\u91c7\u6837. glBindFramebuffer(multisampledFBO); ClearFrameBuffer(); DrawScene(); // \u5c06\u591a\u91cd\u91c7\u6837\u7f13\u51b2\u8fd8\u539f\u5230\u4e2d\u4ecbFBO\u4e0a glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO); glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO); glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST); // \u73b0\u5728\u573a\u666f\u662f\u4e00\u4e2a2D\u7eb9\u7406\u7f13\u51b2\uff0c\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u56fe\u50cf\u7528\u6765\u540e\u671f\u5904\u7406 glBindFramebuffer(GL_FRAMEBUFFER, 0); ClearFramebuffer(); glBindTexture(GL_TEXTURE_2D, screenTexture); DrawPostProcessingQuad();","title":"1.8. \u79bb\u5c4fMSAA"},{"location":"ANGLE/136%20ANGLE_FBO/#19","text":"\u6cdb\u5149 \u591a\u6e32\u67d3\u76ee\u6807(Multiple Render Targets) \u4e0e \u5ef6\u8fdf\u7740\u8272\u6cd5 \u5176\u4ed6\u5f85\u8865\u5145\u5185\u5bb9: Framebuffer \u4e0e mipmaps \u53ca Cube_map \u76f8\u5173\u8d44\u6599","title":"1.9. \u66f4\u591a\u7528\u4f8b:"},{"location":"ANGLE/136%20ANGLE_FBO/#110-framebuffer-api","text":"API ES Ver. Notes void glGenFramebuffers ( sizei n, uint *framebuffers ); 2 void glBindFramebuffer ( enum target, uint framebuffer ); 2 void glGenRenderbuffers ( sizei n, uint *renderbuffers ); 2 void glBindRenderbuffer ( enum target, uint renderbuffer ); 2 void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); 2 \u521b\u5efa\u4e00\u4e2a Renderbuffer internalformat : \u6307\u5b9a\u7f13\u51b2\u683c\u5f0f: depth \u548c stencil GL_DEPTH24_STENCIL8; GL_DEPTH32F_STENCIL8 GL_DEPTH_COMPONENT16 GL_DEPTH_COMPONENT24 GL_DEPTH_COMPONENT32F GL_STENCIL_INDEX8 void glRenderbufferStorageMultisample ( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); 3.0 \u521b\u5efa\u4e00\u4e2a\u591a\u91cd\u91c7\u6837 Renderbuffer, \u4e0eglRenderbufferStorage\u7684\u533a\u522b\u4ec5\u4e3a\u540e\u8005samples=0 GLenum glCheckFramebufferStatus (GLenum target); \u68c0\u67e5fbo\u5b8c\u6574\u6027 void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); \u5c06\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u7684\u50cf\u7d20\u503c, \u4ece\u4e00\u4e2afb\u590d\u5236\u5230\u53e6\u4e00\u4e2afb. \u5e94\u7528\u4e3e\u4f8b: 1. \u590d\u5236\u591a\u4e2a\u7eb9\u7406\u5230\u5c4f\u5e55 2. \u5c06\u591a\u91cd\u91c7\u6837\u6e32\u67d3\u89e3\u6790\u4e3a\u4e00\u4e2a\u7eb9\u7406 \u7ed1\u5b9a void glFramebufferRenderbuffer ( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); 2 void glFramebufferTexture ( GLenum target, GLenum attachment, GLuint texture, GLint level); 3.2 void glFramebufferTexture2D ( enum target, enum attachment, enum textarget, uint texture, int level ); 2.0 void glFramebufferTextureLayer ( enum target, enum attachment, uint texture, int level, int layer ); 3.0 \u7ed1\u5b9a 3D Texture \u65e0\u6548\u5316/\u5220\u9664 void glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments); 3.0 \u901a\u77e5\u9a71\u52a8\u4e0d\u518d\u9700\u8981fb\u5185\u5bb9. \u4f7f\u9a71\u52a8\u53ef\u7528\u8fdb\u884c\u4f18\u5316: \u5982\u8df3\u8fc7TBR\u67b6\u6784\u4e2d\u4e0d\u5fc5\u8981\u7684\u56fe\u5757\u5185\u5bb9\u6062\u590d \u8df3\u8fc7\u5b9e\u73b0\u4e2d\u4e3a\u6539\u8fdb\u6027\u80fd\u800c\u505a\u7684\u7f13\u5b58\u5237\u65b0 void glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height); 3.0 void glDeleteRenderbuffers (GLsizei n, const GLuint *renderbuffers); 2 void glDeleteFramebuffers (GLsizei n, const GLuint *framebuffers); 2 \u5176\u4ed6 void glFramebufferParameteri (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params); boolean IsRenderbuffer ( uint renderbuffer ); boolean IsFramebuffer ( uint framebuffer ); \u5176\u4ed6\u9488\u5bf9\u8bfb\u5e27\u7f13\u51b2\u7684\u547d\u4ee4: glReadPixels, glCopyTexImage, and glCopyTexSubImage,","title":"1.10. Framebuffer \u76f8\u5173 API \u6c47\u603b"},{"location":"ANGLE/136%20ANGLE_FBO/#2-vulkan-framebuffer","text":"\u9996\u5148, Vulkan \u4e2d\u6ca1\u6709\u7c7b\u4f3c GLES\u4e2d\u5185\u7f6e\u7684\u9884\u5b9a\u4e49 Framebuffer, \u4e3b\u5c4f\u7684\u6e32\u67d3\u8fc7\u7a0b\u4e5f\u5168\u9700\u8981\u663e\u5f0f\u7684\u5b9a\u4e49. \u5176\u6b21, \u5bf9\u4e8e\u79bb\u5c4f\u6e32\u67d3, \u5176\u6d41\u7a0b\u4e0e\u4e3b\u5c4f\u6e32\u67d3\u57fa\u672c\u4e00\u81f4, \u5e76\u901a\u8fc7\u5c06\u79bb\u5c4f\u6e32\u67d3\u7684 Attachments \u901a\u8fc7 DescriptorSet \u7ed1\u5b9a\u5230\u4e3b\u5c4f\u4f5c\u4e3a\u7eb9\u7406\u6e32\u67d3.","title":"2. Vulkan Framebuffer"},{"location":"ANGLE/136%20ANGLE_FBO/#21-vkrenderpass","text":"// RenderPass VkRenderPassCreateInfo renderPassInfo = {}; renderPassInfo.pAttachments = attachmentDescs.data(); // attachment descriptions renderPassInfo.pSubpasses = &subpassDescription; // subpass renderPassInfo.pDependencies = dependencies.data(); // dependencies ... \u6e32\u67d3\u8fc7\u7a0b Renderpass \u9644\u7740\u63cf\u8ff0 Attachments Descriptions \u6e32\u67d3\u8fc7\u7a0b \u63cf\u8ff0 \u6e32\u67d3\u64cd\u4f5c\u6240\u9700\u7684\u4e00\u7ec4\u6570\u636e\u3002\u5728Vulkan\u4e2d\uff0c\u63cf\u8ff0\u7684\u662f\u4e00\u7ec4\u5c06\u5728\u6e32\u67d3\u671f\u95f4\u4f7f\u7528\u7684 \u5e27\u7f13\u51b2\u533a\u9644\u7740 \u3002 \u8fd9\u4e9b\u9644\u7740\u5305\u62ec\u5728\u6e32\u67d3\u8fc7\u7a0b\u4e2d\u4f1a\u8bfb\u53d6\u6216\u5199\u5165\u7684\u4efb\u4f55\u7f13\u51b2\u533a\uff0c\u4f8b\u5982 \u989c\u8272\uff0c\u6df1\u5ea6\u548c\u6a21\u677f\u7f13\u51b2\u533a \u3002 \u8fd9\u4e5f\u53ef\u4ee5\u5305\u62ec\u8f93\u5165\u9644\u4ef6\uff0c\u8fd9\u4e9b\u8f93\u5165\u9644\u4ef6\u662f\u4e2d\u95f4\u7f13\u51b2\u533a\uff0c\u5b83\u4eec\u88ab\u5199\u5165\u4e00\u4e2a\u5b50\u901a\u9053\u4e2d\uff0c\u7136\u540e\u88ab\u53e6\u4e00\u4e2a\u5b50\u901a\u9053\u8bfb\u51fa\u3002 \u5728\u521b\u5efa\u6e32\u67d3\u901a\u9053\u65f6\u5fc5\u987b\u660e\u786e\u5b9a\u4e49\u8fd9\u4e9b\u9644\u4ef6\uff0c\u5e76\u6307\u5b9a\u8bf8\u5982\u56fe\u50cf\u683c\u5f0f\uff0c\u6837\u672c\u6570\u91cf\u4ee5\u53ca\u6307\u5b9a\u7684\u52a0\u8f7d\u548c\u5b58\u50a8\u884c\u4e3a\u7b49\u4fe1\u606f\u3002\u8fd9\u6837\u5c31\u51cf\u5c11\u4e86\u9a71\u52a8\u7a0b\u5e8f\u5728\u8fd0\u884c\u65f6\u7684\u5de5\u4f5c\u91cf\uff0c\u56e0\u4e3a\u5b83\u4e0d\u5fc5\u63a8\u65ad\u6b64\u4fe1\u606f\u672c\u8eab\u3002 \u5b50\u8fc7\u7a0b Sub-pass \u6e32\u67d3\u8fc7\u7a0b\u5305\u542b\u4e00\u4e2a\u6216\u591a\u4e2a\u5b50\u8fc7\u7a0b subpass\uff0c\u8fd9\u4e9b\u5b50\u8fc7\u7a0b\u5bf9\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u6392\u5e8f\u3002 \u5b50\u9636\u6bb5\u672c\u8d28\u4e0a\u8868\u793a\u6e32\u67d3\u7684\u9636\u6bb5\uff0c\u5176\u4e2d\u6e32\u67d3\u5de5\u4f5c\u662f\u901a\u8fc7\u6e32\u67d3\u9636\u6bb5\u4e2d\u7684\u9644\u4ef6\u7684\u5b50\u96c6\u5b8c\u6210\u7684\u3002\u4e00\u7ec4\u547d\u4ee4\u8bb0\u5f55\u5728\u6bcf\u4e2a\u5b50\u901a\u9053\u4e2d\uff0c\u4ee5\u63cf\u8ff0\u5728\u8be5\u5b50\u901a\u9053\u4e2d\u9700\u8981\u5b8c\u6210\u7684\u5de5\u4f5c\u3002 \u5b50\u8fc7\u7a0b\u4f9d\u8d56 Sub-pass Dependencies \u6e32\u67d3\u8fc7\u7a0b\u5b9a\u4e49\u4e86\u4e00\u7ec4\u5b50\u8fc7\u7a0b\u4f9d\u8d56\u5173\u7cfb(sub-pass dependencies)\uff0c\u8fd9\u4e9b\u4f9d\u8d56\u5173\u7cfb\u786e\u5b9a\u4e86\u6210\u5bf9\u5b50\u8fc7\u7a0b\u7684\u6267\u884c\u987a\u5e8f\u3002 \u5b83\u4eec\u5145\u5f53\u6267\u884c\u548c\u5185\u5b58\u4f9d\u8d56\u9879\u3002\u5f53\u4e24\u4e2a\u6216\u591a\u4e2a\u5b50\u901a\u9053\u8bbf\u95ee\u540c\u4e00\u9644\u4ef6\u65f6\uff0c\u4f9d\u8d56\u5173\u7cfb\u81f3\u5173\u91cd\u8981\uff0c\u56e0\u4e3aVulkan\u4e0d\u4fdd\u8bc1GPU\u6267\u884c\u5b50\u901a\u9053\u7684\u987a\u5e8f\u3002 \u6ce8\u610f : \u5c3d\u7ba1 RenderPass \u63cf\u8ff0\u4e86\u6240\u6709\u4f7f\u7528\u7684\u9644\u4ef6\u7684 \u7279\u5f81 \u4ee5\u53ca \u5982\u4f55\u5904\u7406 \u9644\u4ef6\uff0c\u4f46\u5b83\u5e76\u4e0d\u6307\u5411\u4efb\u4f55\u5b9e\u9645\u5bf9\u8c61\u3002\u8fd9\u7531 Framebuffers \u5904\u7406\u3002","title":"2.1. VkRenderPass"},{"location":"ANGLE/136%20ANGLE_FBO/#22-vkframebuffers","text":"\u5728 Vulkan \u4e2d\uff0cVkFramebuffer \u7684\u4f5c\u7528\u4ec5\u662f\u5c06\u5305\u542b \u9644\u7740\u63cf\u8ff0 \u7684 RenderPass \u4e0e ImageView \u5b9a\u4e49\u7684 \u9644\u7740\u5bf9\u8c61 \u5173\u8054\u8d77\u6765. VkFramebufferCreateInfo frameBufferCreateInfo = {}; frameBufferCreateInfo.renderPass = renderPass; frameBufferCreateInfo.pAttachments = attachments; // VkImageView* ... \u62c6\u5206\u6e32\u67d3\u901a\u9053\u7684\u9644\u7740\u63cf\u8ff0, \u548c\u5e27\u7f13\u51b2\u533a\u7684\u9644\u7740\u5b9a\u4e49, \u6709\u52a9\u4e8e\u603b\u4f53\u4e0a\u4f18\u5316GPU\u4e0a\u7684\u64cd\u4f5c. \u5e76\u4e14\u53ea\u8981\u5e27\u7f13\u51b2\u533a\u4e0e\u6e32\u67d3\u901a\u9053\u517c\u5bb9\uff0c\u5c31\u53ef\u4ee5\u5141\u8bb8\u5728\u4e0d\u66f4\u6539\u6e32\u67d3\u901a\u9053\u7684\u60c5\u51b5\u4e0b\u4ea4\u6362\u5e27\u7f13\u51b2\u533a\u5bf9\u8c61\u3002(\u6765\u81ea imgtec ) \u7591\u95ee: RenderPass \u5728\u521b\u5efa\u540e\u88ab\u4e09\u5904\u5f15\u7528: Pipeline, Framebuffer, \u548c \u6267\u884c CommandBuffer \u9636\u6bb5\u7684 BeginRenderpass. \u800c\u4e14 BeginRenderpass \u540c\u65f6\u518d\u6b21\u6307\u5b9a\u4e86 Framebuffer. \u56e0\u6b64 Renderpass, Framebuffer, BeginRenderpass \u51fa\u73b0\u4e86\u7c7b\u4f3c\u5faa\u73af\u6307\u5b9a. \u4e3a\u4ec0\u4e48\u9700\u8981\u72ec\u7acb\u51fa Framebuffer \u800c\u4e0d\u662f\u628a Attachment \u548c AttachmentDescription \u4e00\u8d77\u90fd\u653e\u4e8e Renderpass \u4e2d ? \u4e3a\u4ec0\u4e48 Pipeline \u8981\u5f15\u7528 Renderpass ? \u731c\u6d4b: \u521b\u5efa Pipeline \u524d\u9700\u8981\u5b9a\u4e49\u597d\u7684 Renderpass\u83b7\u53d6 \"\u8bf8\u5982\u56fe\u50cf\u683c\u5f0f\uff0c\u6837\u672c\u6570\u91cf\u4ee5\u53ca\u6307\u5b9a\u7684\u52a0\u8f7d\u548c\u5b58\u50a8\u884c\u4e3a\u7b49\u4fe1\u606f\" \u6765\u8fdb\u884c\u4f18\u5316?","title":"2.2. VkFramebuffers"},{"location":"ANGLE/136%20ANGLE_FBO/#23-vk","text":"","title":"2.3. VK \u79bb\u5c4f\u6e32\u67d3\u793a\u4f8b:"},{"location":"ANGLE/136%20ANGLE_FBO/#231-vkrenderpass","text":"Renderpass \u4e2d, \u4f7f\u7528 VkAttachmentDescription \u5b9a\u4e49\u4e86 \u5404 Attachment \u7684\u7c7b\u578b, \u884c\u4e3a\u7b49. \u521b\u5efa Render Pass \u793a\u4f8b: // RenderPass VkRenderPassCreateInfo renderPassInfo = {}; renderPassInfo.pAttachments = attachmentDescs.data(); // attachment descriptions renderPassInfo.pSubpasses = &subpassDescription; // subpass renderPassInfo.pDependencies = dependencies.data(); // dependencies \u5176\u4e2d, Attachment Description, \u63cf\u8ff0\u9644\u7740\u7684\u7c7b\u578b, \u7279\u5f81\u548c\u5904\u7406\u65b9\u5f0f std::array<VkAttachmentDescription, 2> attachmentDescs = {}; // Color attachment attachmentDescs[0].format = swapChain.colorFormat; attachmentDescs[0].samples = VK_SAMPLE_COUNT_1_BIT; attachmentDescs[0].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; attachmentDescs[0].storeOp = VK_ATTACHMENT_STORE_OP_STORE; attachmentDescs[0].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; attachmentDescs[0].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; attachmentDescs[0].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; attachmentDescs[0].finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; // Depth attachment attachmentDescs[1].format = depthFormat; attachmentDescs[1].samples = VK_SAMPLE_COUNT_1_BIT; attachmentDescs[1].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; attachmentDescs[1].storeOp = VK_ATTACHMENT_STORE_OP_STORE; attachmentDescs[1].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; attachmentDescs[1].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; attachmentDescs[1].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; attachmentDescs[1].finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL; Subpass \u4e2d\u5305\u542b\u4e86\u5bf9\u9644\u7740\u7684\u5f15\u7528 VkAttachmentReference colorReference = {}; colorReference.attachment = 0; colorReference.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkAttachmentReference depthReference = {}; depthReference.attachment = 1; depthReference.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL; VkSubpassDescription subpassDescription = {}; subpassDescription.pColorAttachments = &colorReference; subpassDescription.pDepthStencilAttachment = &depthReference;","title":"2.3.1. VkRenderPass"},{"location":"ANGLE/136%20ANGLE_FBO/#232-vkimageview","text":"\u4f7f\u7528 ImageView \u5bf9\u8c61\u5b9a\u4e49\u9644\u7740, \u5305\u62ec \u989c\u8272\u9644\u7740\u548c \u6df1\u5ea6/\u6a21\u677f\u9644\u7740, \u540e\u8005\u901a\u5e38\u4e3a\u540c\u4e00\u4e2a\u9644\u7740. VkImageView attachments[2]; // Color attachement attachments[0] = color.view; // Depth/Stencil attachment is the same for all frame buffers attachments[1] = depthStencil.view;","title":"2.3.2. VkImageView"},{"location":"ANGLE/136%20ANGLE_FBO/#233-vkframebuffer","text":"FrameBuffer \u5c06 ImageView \u4f5c\u4e3a Attachment, \u5e76\u5c06\u5176\u4e0e Renderpass \u8fde\u63a5\u8d77\u6765. VkFramebufferCreateInfo frameBufferCreateInfo = {}; frameBufferCreateInfo.renderPass = renderPass; frameBufferCreateInfo.pAttachments = attachments; // VkImageView* ...","title":"2.3.3. VkFrameBuffer"},{"location":"ANGLE/136%20ANGLE_FBO/#234-imageview-descriptorset","text":"\u4e3a\u5c4f\u5e55\u6e32\u67d3\u7684 Framebuffer \u8bbe\u7f6e DescriptorSet, \u5c06\u79bb\u5c4f\u6e32\u67d3\u7684 ImageView \u4f5c\u4e3a Texture \u4f20\u9012\u7ed9 Shader. // Image descriptors for the offscreen color attachments VkDescriptorImageInfo imageInfo{}; imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL; imageInfo.imageView = color.view; // color attachments in Framebuffer imageInfo.sampler = textureSampler; std::array<VkWriteDescriptorSet, 2> descriptorWrites{}; descriptorWrites[0].dstSet = descriptorSet; descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER; descriptorWrites[0].pBufferInfo = &imageInfo; vkUpdateDescriptorSets(device, static_cast<uint32_t>(descriptorWrites.size()), descriptorWrites.data(), 0, nullptr);","title":"2.3.4. \u8bbe\u7f6e ImageView \u5230 DescriptorSet"},{"location":"ANGLE/136%20ANGLE_FBO/#235-commandbuffers","text":"","title":"2.3.5. \u7ed8\u5236: CommandBuffers"},{"location":"ANGLE/136%20ANGLE_FBO/#2351","text":"\u6307\u5b9a\u6e32\u67d3\u6d41\u7a0b Renderbuffer \u548c Framebuffer VkRenderPassBeginInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; renderPassBeginInfo.renderPass = offScreenFrameBuf.renderPass; renderPassBeginInfo.framebuffer = offScreenFrameBuf.frameBuffer; renderPassBeginInfo.renderArea.extent.width = offScreenFrameBuf.width; renderPassBeginInfo.renderArea.extent.height = offScreenFrameBuf.height; renderPassBeginInfo.clearValueCount = static_cast<uint32_t>(clearValues.size()); renderPassBeginInfo.pClearValues = clearValues.data(); \u5728\u79bb\u5c4f\u6e32\u67d3\u4e2d, \u6e32\u67d3\u6a21\u578b\u7b49 vkCmdBeginRenderPass(offScreenCmdBuffer, &ofsRenderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE); vkCmdBindPipeline(offScreenCmdBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.offscreen); // \u7ed8\u5236Background, \u80cc\u666f\u6a21\u578b vkCmdBindDescriptorSets(offScreenCmdBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &descriptorSets.floor, 0, nullptr); models.floor.draw(offScreenCmdBuffer); // \u7ed8\u5236\u5b9e\u4f8b\u6a21\u578b vkCmdBindDescriptorSets(offScreenCmdBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &descriptorSets.model, 0, nullptr); models.model.bindBuffers(offScreenCmdBuffer); vkCmdDrawIndexed(offScreenCmdBuffer, models.model.indices.count, 3, 0, 0, 0); vkCmdEndRenderPass(offScreenCmdBuffer);","title":"2.3.5.1. \u79bb\u5c4f\u6e32\u67d3"},{"location":"ANGLE/136%20ANGLE_FBO/#2352","text":"\u540c\u6837\u5148\u6307\u5b9a\u4e3b\u5c4f\u7684 Renderbuffer \u548c Framebuffer, \u7136\u540e\u5f00\u59cb\u6e32\u67d3 \u8f93\u51fa\u5230\u5c4f\u5e55\u65f6, \u53d6 descriptorSet \u4e2d\u7684\u7eb9\u7406, \u7ed8\u5236\u5230\u56db\u8fb9\u5f62\u4e0a. vkCmdBeginRenderPass(drawCmdBuffers[i], &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE); // \u542b Attachment \u7684 descriptorSet vkCmdBindDescriptorSets(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &descriptorSet, 0, nullptr); vkCmdBindPipeline(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.composition); // \u7ed8\u5236\u5168\u5c4f\u5e55\u7684\u56db\u8fb9\u5f62 vkCmdDraw(drawCmdBuffers[i], 3, 1, 0, 0); vkCmdEndRenderPass(drawCmdBuffers[i]);","title":"2.3.5.2. \u4e3b\u5c4f\u6e32\u67d3"},{"location":"ANGLE/136%20ANGLE_FBO/#3-gles-vk","text":"","title":"3. GLES \u4e0e Vk \u5bf9\u6bd4"},{"location":"ANGLE/136%20ANGLE_FBO/#31","text":"\u6982\u5ff5 GLES \u5bf9\u8c61 Vk\u5bf9\u8c61 Color/Depth/Stencil Attachment Texture / Renderbuffer ImageView Framebuffer \u5bb9\u5668 Framebuffer Framebuffer & Renderpass \u7eb9\u7406\u7ed1\u5b9a\u5230 Shader glBindTexture \u8bbe\u7f6e ImageView \u5230 DescriptorSets","title":"3.1. \u6982\u5ff5\u5bf9\u5e94"},{"location":"ANGLE/136%20ANGLE_FBO/#32","text":"GLES \u4e32\u884c\u6e32\u67d3: \u7528 Bindframebuffer \u8fdb\u884c\u4e24\u6b21\u6e32\u67d3\u7684\u5207\u6362, \u5229\u7528 Texture \u5bf9\u8c61\u4f20\u9012\u6e32\u67d3\u753b\u9762 Vulkan \u884c\u4e3a\u9884\u5b9a\u4e49\u5f0f: \u4e0d\u540c\u4e24\u5957 Commandbuffer \u6267\u884c\u8fc7\u7a0b, \u5bf9\u5e94\u4e24\u5957 Pipeline, Renderpass, \u548c DescriptionSet \u5229\u7528 DescriptionSet \u7ed1\u5b9a ImageView (Attachment) \u4f20\u9012\u753b\u9762","title":"3.2. \u6d41\u7a0b\u5bf9\u5e94"},{"location":"ANGLE/136%20ANGLE_FBO/#321","text":"\u4e24\u79cd\u6d41\u7a0b\u7684\u987a\u5e8f\u5dee\u5f02\u8f83\u5927, \u8fd9\u91cc\u5bf9 gles api \u64cd\u4f5c\u505a\u4e00\u4e2a\u6982\u5ff5\u4e0a\u7684\u5bf9\u5e94 GLES Vulkan \u521b\u5efa: \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61\uff0c\u5e76\u7ed1\u5b9a unsigned int framebuffer; glGenFramebuffers(1, &framebuffer); glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); \u8bbe\u7f6e\u5e76\u521b\u5efa Pipeline, RenderPass \u548c Framebuffer \u5bf9\u8c61 \u521b\u5efa Texture \u989c\u8272\u9644\u7740 glGenTextures(1, &texColorBuffer); glBindTexture(GL_TEXTURE_2D, texColorBuffer); \u8bbe\u7f6e\u5e76\u521b\u5efa Image \u548c ImageView \u5bf9\u8c61. \u5bf9\u5e94\u914d\u7f6e VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT \u4e3a\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740\u521b\u5efa Renderbuffer unsigned int rbo; glGenRenderbuffers(1, &rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); \u8bbe\u7f6e\u5e76\u521b\u5efa Image \u548c ImageView \u5bf9\u8c61. \u5bf9\u5e94\u914d\u7f6e DEPTH_STENCIL_ATTACHMENT_BIT \u7ed1\u5b9a\u9644\u7740\u5bf9\u8c61\u5230 Framebuffer glFramebufferTexture2D glBindRenderbuffer \u7528 Framebuffer \u5bf9\u8c61\u5c06 ImageView \u4e0e RenderPass \u5173\u8054 \u7ed8\u5236: \u7b2c\u4e00\u7ed8\u5236\u9636\u6bb5: \u7ed8\u5236\u5230FBO glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); \u4e3a\u79bb\u5c4f\u6e32\u67d3\u914d\u7f6e\u4e00\u4e2a CommandBuffer \u7ed8\u5236\u573a\u666f, \u5305\u62ec\u9876\u70b9, \u7eb9\u7406, Shader\u53c2\u6570\u7b49 DrawScene(); \u4f7f\u7528\u4e3a\u79bb\u5c4f\u6e32\u67d3\u914d\u7f6e\u7684 Pipeline \u548cRenderPass, Framebuffer \u5e76\u8bfb\u53d6 DescriptorSet \u6765\u6267\u884c CommandBuffer \u4e2d\u4e00\u7cfb\u5217\u6307\u4ee4 \u7b2c\u4e8c\u7ed8\u5236\u9636\u6bb5: \u7ed8\u5236\u5230\u5c4f\u5e55 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u4e3a\u4e3b\u5c4f\u6e32\u67d3\u914d\u7f6e CommandBuffer \u5c06\u4e00\u9636\u6bb5\u79bb\u5c4f\u6e32\u67d3\u7684\u7eb9\u7406, \u5728\u4e8c\u9636\u6bb5\u542f\u7528 glBindTexture(GL_TEXTURE_2D, textureColorbuffer); \u5c06\u79bb\u5c4f\u6e32\u67d3\u4e2d\u7684 ImageView \u914d\u7f6e\u5230 \u4e3b\u5c4f\u6e32\u67d3\u7684 DescriptorSet \u4e2d \u7ed8\u5236\u4e3b\u5c4f glDrawArrays(GL_TRIANGLES, 0, 6); \u4f7f\u7528\u4e3a\u4e3b\u5c4f\u6e32\u67d3\u914d\u7f6e\u7684 Pipeline \u548cRenderPass, Framebuffer \u5e76\u8bfb\u53d6 DescriptorSet \u6765\u6267\u884c CommandBuffer \u4e2d\u4e00\u7cfb\u5217\u6307\u4ee4","title":"3.2.1. \u5927\u81f4\u5bf9\u5e94\u6d41\u7a0b"},{"location":"ANGLE/136%20ANGLE_FBO/#33","text":"GL \u5ef6\u8fdf\u6e32\u67d3 \u4e0e Vulkan\u5ef6\u8fdf\u6e32\u67d3 ( \u5b8c\u6574\u4ee3\u7801: Vulkan Example: \u5ef6\u8fdf\u6e32\u67d3 )","title":"3.3. \u5b9e\u4f8b\u4ee3\u7801\u5bf9\u6bd4"},{"location":"ANGLE/136%20ANGLE_FBO/#34","text":"Framebuffer \u5bf9\u8c61 \u5c31 Framebuffer Object \u672c\u8eab\u800c\u8a00, \u5b83\u5728 gles \u548c vk \u4e2d\u90fd\u4ec5\u4ec5\u62c5\u5f53\u4e86\u5bb9\u5668\u7684\u4f5c\u7528, \u5bf9\u5e94\u7684 Attachment \u4e5f\u7c7b\u4f3c: \u591a\u4e2aColor \u548c\u4e00\u4e2a depth, stencil. \u4f46 Framebuffer \u5728 gles \u7684\u6e32\u67d3\u8fc7\u7a0b\u4e2d, \u4f5c\u4e3a\u9690\u85cf\u7684\u6e32\u67d3\u7684\u76ee\u6807\u800c\u5b58\u5728, \u867d\u7136\u4e0d\u5bf9\u5b83\u76f4\u63a5\u64cd\u4f5c, \u4f46\u5b83\u8d2f\u7a7f\u6bcf\u4e2a\u6e32\u67d3\u6d41\u7a0b, \u540c\u65f6\u4fdd\u5b58\u6e32\u67d3\u7684\u7ed3\u679c. \u5728 Vulkan \u4e2d, \u6e32\u67d3\u5904\u7406\u6307\u4ee4\u88ab\u5206\u6563\u5728\u521b\u5efa\u7684 Pipeline, RenderPass \u7b49\u4e00\u4f17\u914d\u7f6e\u9879\u4e2d, \u800c\u5176\u540d\u4e3aFramebuffer\u5bf9\u8c61\u7684\u804c\u8d23\u5f88\u8f7b. \u79bb\u5c4f\u6e32\u67d3 \u5bf9\u4e8e Framebuffer \u5728 gles \u63d0\u4f9b\u7684\u79bb\u5c4f\u6e32\u67d3\u529f\u80fd, Vulkan \u662f\u901a\u8fc7\u914d\u7f6e\u591a\u5957\u6e32\u67d3\u6d41\u7a0b\u6765\u5b9e\u73b0, \u6bcf\u5957\u5305\u542b Pipeline, RenderPass, CommandBuffer\u7b49\u914d\u7f6e. \u4e0d\u540c\u6e32\u67d3\u76f4\u63a5\u7684\u5171\u4eab, gles \u901a\u8fc7\u7ed1\u5b9a\u5b58\u50a8\u4e86\u989c\u8272\u9644\u7740\u7684\u7eb9\u7406\u5b9e\u73b0, Vulkan\u901a\u8fc7\u5c06\u7eb9\u7406\u9644\u7740\u914d\u7f6e\u7ed9 descriptorSet \u7684\u65b9\u5f0f\u5b9e\u73b0. \u56e0\u6b64\u6240\u4ee5\u5bf9\u4e8e FBO, \u5b9e\u73b0 gles on Vulkan \u5b9e\u5219\u662f\u5b9e\u73b0\u6e32\u67d3 \u6d41\u7a0b\u7684\u5bf9\u5e94 . \u53c2\u8003\u5176\u4ed6\u5206\u6790\u6587\u6863\u4e2d\u5173\u4e8e angle \u4e2d\u6d41\u7a0b\u5bf9\u5e94\u5206\u6790, \u5305\u62ec: CommandBuffer (PCB, SCB) \u7684\u914d\u7f6e\u548c Flush \u65f6\u673a. gles \u72b6\u6001\u66f4\u65b0\u4e0e Pipeline \u7b49\u914d\u7f6e\u66f4\u65b0\u7684\u5173\u8054\u65b9\u5f0f.","title":"3.4. \u603b\u7ed3"},{"location":"ANGLE/136%20ANGLE_FBO/#4-angle-fbo","text":"","title":"4. ANGLE \u5bf9\u4e8e FBO \u7684\u7ba1\u7406"},{"location":"ANGLE/136%20ANGLE_FBO/#41-framebuffer","text":"@startuml hide method class State { Framebuffer *mReadFramebuffer; Framebuffer *mDrawFramebuffer; BindingPointer<Renderbuffer> mRenderbuffer; } class Framebuffer { FramebufferImpl *mImpl; //FramebufferVk mutable Optional<GLenum> mCachedStatus; vector<ObserverBinding> mDirtyColorAttachmentBindings; ObserverBinding mDirtyDepthAttachmentBinding; ObserverBinding mDirtyStencilAttachmentBinding; } class FramebufferState { vector<FramebufferAttachment> mColorAttachments; FramebufferAttachment mDepthAttachment; FramebufferAttachment mStencilAttachment; DrawBufferMask mColorAttachmentsMask; } Context *-- State State --> Framebuffer FramebufferState --* Framebuffer FramebufferAttachment --* FramebufferState FramebufferAttachmentRenderTarget --* FramebufferAttachment @enduml","title":"4.1. \u524d\u7aef Framebuffer"},{"location":"ANGLE/136%20ANGLE_FBO/#42-framebuffervk","text":"@startuml skinparam classAttributeIconSize 0 class ContextVk { FramebufferVk *mDrawFramebuffer } class FramebufferVk { - WindowSurfaceVk *mBackbuffer syncState() startNewRenderPass() &getRenderPassDesc() getFramebuffer() } class RenderPassDesc { -DrawBufferMask mColorResolveAttachmentMask; -DrawBufferMask mColorUnresolveAttachmentMask; -FramebufferNonResolveAttachmentArray mAttachmentFormats; } class RenderTargetVk { ImageHelper *mImage; ImageViewHelper *mImageViews; } class FramebufferDesc { updateColor() updateDepthStencil() attachmentCount() } ContextVk --> RenderPassCache ContextVk ..> FramebufferVk FramebufferVk *-- RenderPassDesc FramebufferVk *-- RenderTargetCache RenderTargetVk ..> RenderTargetCache FramebufferVk *-- FramebufferDesc RenderPassCache ..> RenderPassDesc @enduml FramebufferDesc , RenderPassDesc \u7528\u4e8e\u6700\u7ec8\u751f\u6210 vk \u539f\u751f\u5bf9\u8c61\u7684\u5b57\u6bb5. RenderTargetVk \u5b9e\u73b0\u524d\u7aef\u7684 FramebufferAttachmentRenderTarget\u63a5\u53e3, \u4e3a\u5404\u9644\u7740\u7684\u5bf9\u8c61\u7c7b","title":"4.2. \u540e\u7aef FramebufferVk"},{"location":"ANGLE/136%20ANGLE_FBO/#43-api","text":"","title":"4.3. API \u5b9e\u73b0"},{"location":"ANGLE/136%20ANGLE_FBO/#431","text":"\u521b\u5efa\u9ed8\u8ba4 Framebuffer @startuml APP -> EGLWindow : initializeContext() EGLWindow -> Display : makeCurrent() Display -> Context : makeCurrent() Context -> Context : setDefaultFramebuffer(\\ndrawSurface = readSurface) Context -> Surface : createDefaultFramebuffer() Surface -> Framebuffer : Framebuffer() Framebuffer -> SurfaceVk : createDefaultFramebuffer() SurfaceVk -> FramebufferVk : CreateDefaultFBO() @enduml CreateDefaultFBO vs. CreateUserFBO \u521b\u5efa\u65f6, \u4e8c\u8005\u533a\u522b\u4ec5\u4e3a\u9ed8\u8ba4FBO\u4f1a\u5305\u542b\u4e00\u4e2aWindowSurfaceVk // static FramebufferVk *FramebufferVk::CreateUserFBO(RendererVk *renderer, const gl::FramebufferState &state) // static FramebufferVk *FramebufferVk::CreateDefaultFBO(RendererVk *renderer, const gl::FramebufferState &state, WindowSurfaceVk *backbuffer) \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61 glGenFramebuffers(1, &fbo); @startuml APP -> Context :createFramebuffer() Context -> FramebufferManager : createFramebuffer() Context -> FramebufferManager : AllocateEmptyObject() @startuml","title":"4.3.1. \u521b\u5efa\u9636\u6bb5"},{"location":"ANGLE/136%20ANGLE_FBO/#432-resourcemanager","text":"ANGLE \u7684 gles \u524d\u7aef\u4e2d, \u4f7f\u7528\u4e00\u7cfb\u5217 ResourceManager \u6765\u5173\u8054\u6ce8\u518c\u7684 id \u4e0e\u7c7b\u7684\u5bf9\u5e94\u60c5\u51b5.\u5176\u6709\u4e24\u4e2a\u529f\u80fd: \u521b\u5efa\u65b0\u5bf9\u8c61, \u5e76\u7528\u4e00\u4e2ahash\u8868\u628a id\u4e0e\u5bf9\u8c61\u5b58\u50a8\u8d77\u6765\u4ee5\u4f9b\u67e5\u8be2. @startuml hide method class ResourceManagerBase { HandleAllocator mHandleAllocator; } class TypedResourceManager { ResourceMap<ResourceType, IDType> mObjectMap; } class ShaderProgramManager { ResourceMap<Shader, ShaderProgramID> mShaders; ResourceMap<Program, ShaderProgramID> mPrograms; } TypedResourceManager --|> ResourceManagerBase ShaderProgramManager --|> ResourceManagerBase @enduml TypedResourceManager \u7684\u5b50\u7c7b: BufferManager ShaderProgramManager TextureManager RenderbufferManager SamplerManager SyncManager FramebufferManager ProgramPipelineManager MemoryObjectManager SemaphoreManager \u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684(Active)\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, fbo); GL_READ_FRAMEBUFFER \u548c GL_DRAW_FRAMEBUFFER \u5206\u5f00\u5904\u7406, \u82e5\u4e3aGL_FRAMEBUFFER\u5219\u4e24\u4e2a\u5206\u652f\u90fd\u8d70\u4e00\u904d. \u5148\u53bbFramebufferManager\u7684Hash\u4e2d\u67e5\u627e, \u65e0\u5219\u521b\u5efa. GL_READ_FRAMEBUFFER @startuml EntryPoint -> Context : bindReadFramebuffer box \"if(query(fbID) == null)\" Context -> FramebufferManager : checkFramebufferAllocation (ShareGroup) FramebufferManager -> FramebufferManager : AllocateNewObject FramebufferManager -> Framebuffer : new Framebuffer Framebuffer -> FramebufferVk : CreateUserFBO end box Context -> State : setReadFramebufferBinding(framebuffer) Context -> ObserverBinding : bind(framebuffer) @enduml Context \u4e2d mDrawFramebufferObserverBinding: ObserverBinding.bind \u4e3a\u89c2\u5bdf\u8005\u7ed1\u5b9a\u5355\u4e00\u89c2\u5bdf\u5bf9\u8c61. GL_DRAW_FRAMEBUFFER (\u7701\u7565\u521b\u5efa\u90e8\u5206) @startuml EntryPoint -> Context: bindDrawFramebuffer Context -> State : setDrawFramebufferBinding Context -> ObserverBinding : bind(framebuffer) Context -> StateCache : onDrawFramebufferChange( context ) \\n \u9519\u8bef\u6821\u9a8c\u7528 @enduml \u89e3\u7ed1FBO / \u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u540c\u7ed1\u5b9aFBO","title":"4.3.2. ResourceManager"},{"location":"ANGLE/136%20ANGLE_FBO/#433","text":"\u5c06\u7eb9\u7406\u9644\u52a0\u5728\u5e27\u7f13\u51b2\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); @startuml EntryPoint -> Context: framebufferTexture2D Context -> State : getTargetFramebuffer (ShareGroup) Context -> Framebuffer : setAttachment Framebuffer -> FramebufferAttachment : attachment(FBAObject) Context -> State : setObjectDirty() @enduml \u7ed1\u5b9a\u540e, \u4f1a\u8bbe\u7f6e\u5982\u4e0b dirty\u72b6\u6001 - State : setObjectDirty() - framebuffer.mDirtyBits.set(DIRTY_BIT_COLOR_ATTACHMENT_0) - state.mDirtyObjects.set(DIRTY_OBJECT_READ_FRAMEBUFFER); - state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_FRAMEBUFFER); - state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_ATTACHMENTS);","title":"4.3.3. \u7eb9\u7406\u9644\u7740"},{"location":"ANGLE/136%20ANGLE_FBO/#434-renderbuffer","text":"\u521b\u5efa\u548c\u7ed1\u5b9a Renderbuffer \u5bf9\u8c61\u7684\u5b9e\u73b0\u4e0e Framebuffer \u7c7b\u4f3c glGenRenderbuffers(1, &rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); \u53c2\u8003 GenFramebuffer , BindFramebuffer \u521b\u5efa\u4e00\u4e2a\u6df1\u5ea6\u548c\u6a21\u677f\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); \u4e24\u4e2a\u65b9\u6cd5\u540c\u4e00\u4e2a\u5b9e\u73b0, \u524d\u8005 samples=0 \u5b8c\u6210\u5bf9 RenderBufferVk \u5bf9\u8c61\u5185\u5404\u53c2\u6570\u7684\u521d\u59cb\u5316, \u53ca\u8bbe\u7f6e RenderTargetVk @startuml Context -> Renderbuffer : setStorage() Renderbuffer -> RenderbufferVk : setStorageImpl() RenderbufferVk -> ImageHelper : init() RenderbufferVk -> ImageViewHelper : init() RenderbufferVk -> RenderTargetVk : init() @enduml \u9644\u52a0\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5230 FBO\uff1a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); @startuml Context -> RenderbufferManager : getRenderbuffer() Context -> Framebuffer : setAttachmentMultisample(renderbuffer) @enduml framebuffer.mDirtyBits.set(DIRTY_BIT_DEPTH_ATTACHMENT); state.mDirtyObjects.set(DIRTY_OBJECT_READ_FRAMEBUFFER); state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_FRAMEBUFFER); state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_ATTACHMENTS);","title":"4.3.4. Renderbuffer \u9644\u7740"},{"location":"ANGLE/136%20ANGLE_FBO/#44","text":"ANGLE \u7684\u524d\u540e\u7aef\u5728\u6267\u884c\u53ef\u80fd\u4f1a\u89e6\u53d1Flush\u7684\u64cd\u4f5c\u65f6, \u4f1a\u8fdb\u884c\u72b6\u6001\u540c\u6b65. \u5e38\u89c1\u7684\u64cd\u4f5c\u4f8b\u5982 Clear, Draw, CopyImage \u7b49. \u4f8b\u5982\u5728\u7ed1\u5b9a\u4e00\u4e2aFBO\u5e76\u6267\u884c Clear\u7684\u65f6\u5019, \u4f1a\u8fdb\u884c\u5982\u4e0b\u540c\u6b65: @startuml Context -> Context : syncState() Context -> State : syncDirtyObjects() State -> FramebufferVk : syncState() Context -> ContextVk : syncDirtyBits() ContextVk -> ContextVk : syncState() \\n case: DIRTY_BIT_DRAW_FRAMEBUFFER_BINDING ContextVk -> GraphicsPipelineDesc : updatePipelineXXXX() @enduml \u5176\u4e2dState : syncDirtyObjects \u4f1a\u4f9d\u6b21\u8c03\u7528\u6ce8\u518c\u7684 dirty \u5bf9\u8c61\u7684 syncState\u65b9\u6cd5. ContextVk : syncState \u7684 DirtyBits \u4e2d, \u5305\u542b\u4e00\u4e2a DRAW_FRAMEBUFFER_BINDING \u8868\u793a\u53d1\u751f\u8fc7 Framebuffer \u7684\u91cd\u7ed1\u5b9a, \u9700\u8981\u66f4\u65b0Pipeline","title":"4.4. \u72b6\u6001\u540c\u6b65"},{"location":"ANGLE/136%20ANGLE_FBO/#441-framebuffervksyncstate","text":"syncState RenderTargetCache.update // Read_Framebuffer updateColorAttachment RenderTargetCache.updateColorRenderTarget() RenderTargetCache.getColors() updateActiveColorMasks() contextVk->updateColorMasks() renderTarget->flushStagedUpdates() FramebufferDesc.updateColor() index++ FramebufferDesc::updateColorResolve() index++ updateDepthStencilAttachment RenderTargetCache.updateDepthStencilRenderTarget() FramebufferDesc.updateDepthStencil FramebufferDesc.updateColorResolve renderTarget->flushStagedUpdates contextVk->updateColorMasks() //Draw_fb\u5219\u66f4\u65b0pipeline\u7684colormask contextVk->flushCommandsAndEndRenderPass() // ??? \u4e3a\u4ec0\u4e48 sync \u8981 flush? updateRenderPassDesc(); contextVk->onFramebufferChange(this); GraphicsPipelineDesc->updateRenderPassDesc()","title":"4.4.1. FramebufferVk.syncState()"},{"location":"ANGLE/136%20ANGLE_FBO/#442-framebuffer-pipeline","text":"(ContextVk::syncState) \u7531\u4e8e\u5728 gles \u5207\u6362 Framebuffer\u65f6, \u4e00\u4e9b\u4e0e\u4e4b\u7ed1\u5b9a\u7684\u8bbe\u7f6e\u4e5f\u76f8\u5e94\u88ab\u5207\u6362. \u4f8b\u5982 \u989c\u8272\u9644\u7740\u7684\u6570\u91cf\u7b49. \u800c\u5728 vk \u4e2d, \u9664\u4e86\u8981\u5207\u6362\u5bf9\u5e94 RenderPass \u548c Framebuffer, \u90e8\u5206\u8bbe\u7f6e\u8fd8\u4f1a\u53cd\u5e94\u5230 Pipeline \u4e0a, \u672c\u8282\u5217\u51fa\u5728 angle \u7684 vk::ContextVk \u8fdb\u884c\u72b6\u6001\u540c\u6b65( syncState ) \u7684\u8fc7\u7a0b\u4e2d, \u5bf9 Draw Framebuffer \u7ed1\u5b9a\u66f4\u65b0\u65f6\u6d89\u53ca\u5230\u7684 Pipeline \u5c5e\u6027\u7684\u66f4\u65b0: VkPipelineViewportStateCreateInfo pViewports pScissors \u6765\u6e90: \u7531\u7ed8\u5236\u8fc7\u7a0b\u4e2d, glViewpoint \u4fee\u6539 VkPipelineRasterizationStateCreateInfo \u5149\u6805, \u8bbe\u7f6e: \u6df1\u5ea6\u6d4b\u8bd5, \u80cc\u9762\u5254\u9664, \u88c1\u526a\u6d4b\u8bd5, \u4f8b\u5982: cullMode \u8868\u660e\u5254\u9664\u7c7b\u578b: \u80cc\u9762 / \u6b63\u9762 / \u53cc\u9762 frontFace =VK_FRONT_FACE_CLOCKWISE / VK_FRONT_FACE_COUNTER_CLOCKWISE \u6307\u5b9a\u987a\u65f6\u9488\u9876\u70b9\u5e8f\u662f\u6b63\u9762, \u8fd8\u662f\u9006\u65f6\u9488\u9876\u70b9\u5e8f\u662f\u6b63\u9762 \u6765\u6e90: ANGLE \u5728\u7ed8\u5236 \u9ed8\u8ba4FB\u548c\u81ea\u5b9a\u4e49FB\u65f6, \u4f1a\u5bf9\u753b\u9762\u8fdb\u884c\u65cb\u8f6c, \u6309\u4e0d\u540c\u7684\u987a\u5e8f\u8fdb\u884c\u7ed8\u5236. \u79bb\u5c4f: VK_FRONT_FACE_COUNTER_CLOCKWISE ANGLE \u8bf4\u660e: \u7531\u4e8eVulkan\u548cGLES\u5750\u6807\u7cfb\u7684\u4e0d\u540c\uff0c\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u533a\uff08\u6e90\u81ea\u4ea4\u6362\u94fe\uff09\u5448\u4e0a\u4e0b\u98a0\u5012\u663e\u793a\u3002\u98a0\u5012\u6e32\u67d3\u5177\u6709\u4e0eOpenGL\u76f8\u540c\u7684\u6e32\u67d3\u65b9\u5f0f\u3002\u968f\u540e\u542f\u7528KHR_MAINTENANCE_1 \u6269\u5c55\u7a0b\u5e8f\u4ee5\u5141\u8bb8\u5426\u5b9a\u89c6\u53e3\u3002\u6211\u4eec\u901a\u8fc7\u53cd\u8f6c\u89c6\u53e3\u7684\u9ad8\u5ea6\u5e76\u5c06Y\u589e\u52a0\u9ad8\u5ea6\u6765\u53cd\u8f6c\u6e32\u67d3\u5230\u540e\u7f13\u51b2\u533a\u3002\u56e0\u6b64\uff0c\u5982\u679c\u89c6\u53e3\u4e3a\uff080\uff0c0\uff0cwidth\uff0cheight\uff09\uff0c\u5219\u89c6\u53e3\u53d8\u4e3a\uff080\uff0cheight\uff0cwidth\uff0c-height\uff09\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u5f53\u6211\u4eec\u5f00\u59cb\u8fd9\u6837\u505a\u65f6\uff0c\u7531\u4e8e\u6e32\u67d3\u73b0\u5728\u662f\u4e0a\u4e0b\u98a0\u5012\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u8fd8\u9700\u8981\u8c03\u6574\u4e00\u4e9b\u4f4d\u7f6e\u3002\u5230\u76ee\u524d\u4e3a\u6b62\u53d7\u5f71\u54cd\u7684\u5730\u65b9\uff1a readPixels copyTexImage framebuffer blit generating mipmaps Point sprites tests texStorage VkPipelineMultisampleStateCreateInfo \u591a\u91cd\u91c7\u6837: \u7ec4\u5408\u591a\u4e2a\u4e0d\u540c\u591a\u8fb9\u5f62\u4ea7\u751f\u7684\u7247\u6bb5\u7684\u989c\u8272, \u6765\u51b3\u5b9a\u6700\u7ec8\u989c\u8272\u7684\u6280\u672f. (\u6297\u952f\u9f7f) rasterizationSamples : \u91c7\u6837\u6570, \u7b49\u4e8e VkImage.sample sampleShadingEnable : rasterizationSamples > 1 minSampleShading : sampleShadingEnable \u4e3a false \u65f6, \u503c\u4e3a1 pSampleMask : rasterizationSamples > 1 \u4e14 SamplerMaskEnable \u65f6\u624d\u4f1a\u542f\u7528 \u6765\u6e90: \u4e0e VkImage \u4e2d samples \u6570\u53d1\u751f\u53d8\u5316\u65f6, \u4e0a\u8ff0\u503c\u5bf9\u5e94\u6539\u53d8. VkPipelineDepthStencilStateCreateInfo \u6df1\u5ea6\u6d4b\u8bd5, \u6a21\u677f\u6d4b\u8bd5 depthTestEnable = static_cast (mDepthStencilStateInfo.enable. depthTest ); depthWriteEnable = static_cast (mDepthStencilStateInfo.enable. depthWrite ); stencilTestEnable = static_cast (mDepthStencilStateInfo.enable. stencilTest ); front.writeMask back.writeMask \u6765\u6e90: gLEnable \u542f\u7528 depth test\u7b49 VkPipelineColorBlendStateCreateInfo \u989c\u8272\u6df7\u5408: blendState. pAttachments [ \u200b VkPipelineColorBlendAttachmentState. colorWriteMask ] \u6765\u6e90: Color Attachment \u6570\u91cf\u53d8\u52a8\u65f6, \u9700\u5bf9\u5e94\u589e\u5220","title":"4.4.2. \u5207\u6362 Framebuffer \u65f6\u4fee\u6539 Pipeline"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/","text":"1. ANGLE: Vk\u6269\u5c55\u7684\u4f7f\u7528\u4e0e\u652f\u6301 2. Vulkan \u6269\u5c55 2.1. Vulkan \u521d\u59cb\u5316\u6d41\u7a0b 2.2. Extensions: \u6269\u5c55 2.2.1. \u542f\u7528 Vk Extensions 2.3. Features: \u529f\u80fd 2.3.1. \u6838\u5fc3 Features 2.3.2. \u6269\u5c55\u63d0\u4f9b\u7684Features 2.3.3. \u542f\u7528 Features 2.4. Limitations 2.4.1. \u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684Limits 2.5. Formats 3. ANGLE \u4e2d Vk \u6269\u5c55 3.1. ANGLE \u521d\u59cb\u5316 VkDevice 3.2. ANGLE \u4e2d\u7684 Vk Extensions 3.3. ANGLE FeaturesVk 4. ANGLE \u4e2d\u7684 GLES Extensions 4.1. ANGLE \u6dfb\u52a0\u7684 GLES \u6269\u5c55 5. ES \u4e0e Vk \u7684 Ext \u5bf9\u5e94\u6d41\u7a0b 6. GLES \u7248\u672c\u9009\u62e9 6.1. GLES 3.2 (\u672a\u542f\u7528) 6.1.1. Features 6.2. GLES 3.1 6.2.1. Caps 6.3. GLES 3.0 6.3.1. Features 6.3.2. Caps 7. GLES Extensions \u652f\u6301 7.1. \u9ed8\u8ba4\u652f\u6301\u7684 Extensions 7.2. \u6709\u6761\u4ef6\u7684\u652f\u6301\u7684 Extensions 7.3. \u4e0d\u652f\u6301\u7684 GLES Extensions 8. \u53c2\u8003\u5217\u8868 9. \u9644\u88681: ANGLE \u5411 KHR \u7279\u51fa\u7684\u7279\u6027\u9700\u6c42: 10. \u9644\u88682: ANGLE \u4e2d\u51fa\u73b0\u7684 Vk Extensions 11. \u9644\u88683: ANGLE \u4e2d\u542f\u7528\u7684 Vk Features Vulkan_1_0 Features: Extension Features: 12. \u9644\u88684: ANGLE \u81ea\u5b9a\u4e49 FeaturesVk 1. ANGLE: Vk\u6269\u5c55\u7684\u4f7f\u7528\u4e0e\u652f\u6301 \u672c\u6587\u6863\u5185\u5bb9: \u9996\u5148\u6839\u636e Vulkan Specification \u63cf\u8ff0\u4e86 Vulkan \u6807\u51c6\u4e2d\u5982\u4f55\u5b9a\u4e49 Extension, Feature \u7b49\u76f8\u5173\u529f\u80fd\u96c6, \u4ee5\u53ca\u5982\u4f55\u5728\u521d\u59cb\u5316\u8fc7\u7a0b\u4e2d\u542f\u7528\u4ed6\u4eec. \u63cf\u8ff0 ANGLE \u5728\u521b\u5efa Vulkan \u540e\u7aef\u65f6, \u5982\u4f55\u4f7f\u7528 Extensions. \u63cf\u8ff0 ANGLE \u524d\u7aef GLES \u4e2d\u662f\u5982\u4f55\u5bf9 GLES \u63d0\u4f9b\u652f\u6301\u7684 \u4ee5\u7edf\u8ba1\u5217\u8868, \u5217\u4e3e\u51fa ANGLE \u4f7f\u7528\u4e86\u54ea\u4e9b vk \u529f\u80fd, \u5e76\u7528\u6765\u652f\u6301\u4e86\u54ea\u4e9b GLES Extensions. 2. Vulkan \u6269\u5c55 \u5bf9\u4e8e\u4e0d\u540c\u7684\u5e73\u53f0, \u9a71\u52a8, \u64cd\u4f5c\u7cfb\u7edf\u7b49, \u5f53Vulkan\u7684\u5e95\u5c42\u5b9e\u73b0\u4e0d\u540c\u65f6, Vulkan \u53ef\u7528\u7684 \u529f\u80fd\u96c6 \u4e5f\u6709\u5f88\u591a\u533a\u522b. \u672c\u7ae0\u63cf\u8ff0\u4e86 Vulkan \u5982\u4f55\u5b9a\u4e49\u548c\u6269\u5c55\u529f\u80fd\u96c6, \u4e3b\u8981\u4ecb\u7ecd\u4e86\u56db\u4e2a\u6982\u5ff5: Extension, Feature, Limitation, \u548c Format. (\u672c\u7ae0\u6587\u672c\u5185\u5bb9\u7684\u66f4\u591a\u7ec6\u8282, \u53c2\u89c1 Vulkan Specification 1.1 , \u4ee3\u7801\u5747\u4e3a\u793a\u4f8b\u7528\u4f2a\u7801) 2.1. Vulkan \u521d\u59cb\u5316\u6d41\u7a0b \u5728\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u65f6, \u7a0b\u5e8f\u4e2d\u8981\u542f\u7528\u7684 Vulkan \u529f\u80fd\u96c6\u5fc5\u987b\u5728\u521d\u59cb\u5316 Device \u524d\u786e\u5b9a\u4e0b\u6765. \u4ee5\u4e0b\u662f\u521d\u59cb\u5316\u8fc7\u7a0b\u4e2d\u4e0e\u529f\u80fd\u76f8\u5173\u7684\u8fc7\u7a0b: \u5bf9\u5e94 vk \u521d\u59cb\u5316\u7684\u524d\u4e09\u6b65: Instance --> Physical Device --> Device @startuml class Device { } hide members hide circle Instance --> Physical_Device Physical_Device --> Device @enduml Vulkan\u521d\u59cb\u5316 Device \u76f8\u5173\u6d41\u7a0b: \u9009\u62e9\u542f\u7528 Instance Extensions, \u521b\u5efa VkInstance \u9009\u5b9a\u7269\u7406\u8bbe\u5907, \u67e5\u8be2 Extensions, Features, Limitations, Formats \u9009\u4e2d Device Extensions, \u67e5\u8be2 Features2*, Properties2, Formats \u9009\u62e9\u542f\u7528\u7684 Device Extensions, Features, Features2, \u521b\u5efa VkDevice \u6ce8 ( ): \u672c\u6587\u6863\u4e3a\u65b9\u4fbf\u63cf\u8ff0, Features2, Properties2 \u7528\u6765\u7279\u6307\u6765\u81ea Extension \u7684\u5c5e\u6027, \u4ee5\u533a\u5206\u7531 Vulkan \u6838\u5fc3\u63d0\u4f9b\u7684 Features, Properties. * @startuml [*] -> Enume_Instance_Extension Enume_Instance_Extension --> CreateInstance CreateInstance --> Enume_PhysicalDevices Enume_PhysicalDevices --> Device_Extension Device_Extension --> Features2 Device_Extension --> Properties2\u4e0eFormat Enume_PhysicalDevices --> Features Enume_PhysicalDevices --> Limits\u4e0eFormats Device_Extension --> vkCreateDevice Features --> vkCreateDevice Features2 --> vkCreateDevice Limits\u4e0eFormats --> Application Properties2\u4e0eFormat --> Application Enume_Instance_Extension: \u679a\u4e3e vk \u652f\u6301\u7684 Enume_Instance_Extension: Instance-level Extensions Enume_Instance_Extension: \u9009\u62e9\u8981\u542f\u7528\u7684 CreateInstance: \u521b\u5efa Instance Enume_PhysicalDevices: \u679a\u4e3e \u7269\u7406\u8bbe\u5907, \u9009\u62e9 GPU \u8bbe\u5907 Device_Extension: \u67e5\u8be2GPU\u652f\u6301\u7684 Device_Extension: Device-Level Extensions Device_Extension: \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 Features2: \u67e5\u8be2 Extensions Features2: \u7684 Features \u7ed3\u6784\u4f53, Features2: \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 Properties2\u4e0eFormat: \u67e5\u8be2 Extensions \u7684 Properties2\u4e0eFormat: Limits \u4e0e Format Features: \u67e5\u8be2 GPU \u652f\u6301\u7684 Features: Features, Features: \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 Limits\u4e0eFormats: \u67e5\u8be2 GPU \u652f\u6301\u7684 Limits\u4e0eFormats: Limits\u4e0eFormats vkCreateDevice: \u5c06\u542f\u7528\u7684 Extensions vkCreateDevice: \u548c Features \u4f5c\u4e3a\u53c2\u6570 vkCreateDevice: \u653e\u5165 CreateInfo \u7ed3\u6784\u4f53, vkCreateDevice: \u521b\u5efa\u903b\u8f91\u8bbe\u5907 Device, Application: \u67e5\u8be2\u652f\u6301\u529f\u80fd @enduml Extension: \u529f\u80fd\u96c6\u7684\u62bd\u8c61\u6982\u5ff5, \u7528\u6765\u4e3a Vulkan \u6dfb\u52a0\u65b0\u7684 Commands\uff0cStructures \u548c Enumerants. \u540c\u65f6\u53ef\u80fd\u65b0\u589e Features, Limitations, \u548c Format. Feature: bool \u503c\u96c6\u5408, \u53ef\u9009\u529f\u80fd\u7684\u5f00\u5173. \u53ef\u4ee5\u7528\u6765\u67e5\u8be2\u8bbe\u5907\u652f\u6301\u7684\u529f\u80fd, Limitation \u548c Format \u662f\u4e24\u4e2a\u53ea\u8bfb\u53c2\u6570\u96c6, Limitation \u53c8\u79f0\u505a Properties, \u8868\u793a\u8bbe\u5907\u7279\u5f81\u503c; Format \u8868\u793a\u652f\u6301\u7684\u683c\u5f0f. \u672c\u7ae0\u540e\u9762\u5404\u7ae0\u8282\u5bf9\u6b64\u6d41\u7a0b\u5404\u6b65\u9aa4\u8fdb\u884c\u89e3\u91ca, \u5e76\u5305\u542b\u793a\u4f8b\u4ee3\u7801. 2.2. Extensions: \u6269\u5c55 \u6269\u5c55 (Extensions) \u53ef\u7528\u6765\u4e3a Vk \u6dfb\u52a0\u65b0\u529f\u80fd. Vk \u6838\u5fc3\u7684\u65b0\u7248\u672c (\u5982: VK_VERSION_1_1) \u4e5f\u53ef\u4ee5\u89c6\u4e3a\u4e00\u4e2a\u6269\u5c55. \u6269\u5c55\u53ef\u4ee5\u5b9a\u4e49\u65b0\u7684 \u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784. ( Commands\uff0cStructures \u548c Enumerants) \u6269\u5c55\u5206\u4e3a\u5b9e\u4f8b\u7ea7\u548c\u8bbe\u5907\u7ea7 (Instance-level \u548c Device-level) \u5f53 Commands \u7528\u6765\u679a\u4e3e\u5b9e\u4f8b\u5c5e\u6027 (instance properties), \u6216\u63a5\u53d7 VkInstance \u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570, \u5219\u88ab\u89c6\u4e3a\u5b9e\u4f8b\u7ea7\u529f\u80fd\u3002 \u5f53 Commands \u7528\u6765\u679a\u4e3e\u7269\u7406\u8bbe\u5907\u5c5e\u6027 (physical device properties), \u6216\u63a5\u53d7 VkDevice \u53ca\u5176\u5b50\u7c7b\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\uff0c\u5219\u88ab\u89c6\u4e3a\u8bbe\u5907\u7ea7\u529f\u80fd\u3002 \u4e3a\u4e86\u65b9\u4fbf\u7f16\u8bd1\uff0c\u5728 Khronos \u63d0\u4f9b\u7684 vulkan_core.h \u4e2d\u9664\u4e86\u6838\u5fc3API, \u8fd8\u5b9a\u4e49\u4e86\u5df2\u6ce8\u518c Extensions \u5b9a\u4e49\u7684\u63a5\u53e3\uff0c\u5305\u62ec\u65b0 \u7ed3\u6784, \u679a\u4e3e, \u548c\u547d\u4ee4\u7684\u51fd\u6570\u6307\u9488\u7c7b\u578b\u3002\u6269\u5c55\u7684\u5b9e\u73b0\u901a\u8fc7 Layers \u548c Vulkan\u5b9e\u73b0\u6765\u63d0\u4f9b\u3002 Vulkan \u4e0e Extensions, Features, Properties \u7684\u5173\u7cfb: @startuml hide circle package Vulkan { class \"VK_VERSION_1_0\" { VkPhysicalDeviceFeatures VkPhysicalDeviceProperties VkFormat } class \"VK_VERSION_1_1\" { VK_KHR_XXX_ VK_XXX_Features VK_XXX_Properties vkGetPhysical_Device_Feature2() vkGetPhysical_Device_Properties2() } class \"Other Vk Extensions\" { VK_EXT_XXX_ VK_AMD/GOOLE_XXX_ VK_XXX_Features_EXT VK_XXX_Properties_EXT } } @enduml 2.2.1. \u542f\u7528 Vk Extensions Vk Extensions \u9700\u8981\u5728\u521d\u59cb\u5316\u9636\u6bb5\u663e\u5f0f\u542f\u7528. \u542f\u7528 instance extension, \u8981\u5728\u521b\u5efa VKInstance \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkInstanceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. \u542f\u7528 device extension, \u8981\u5728 \u521b\u5efa VkDevice \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkDeviceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. Physical-Device-Level \u529f\u80fd\u6ca1\u6709\u542f\u7528\u673a\u5236\uff0c\u53ea\u8981 VkPhysicalDevice \u7684\u529f\u80fd\u5bf9\u5e94\u7684 Extensions \u5728\u679a\u4e3e\u51fd\u6570 vkEnumerateDeviceExtensionProperties \u4e2d\u88ab\u5217\u51fa. \u4ec5 \u542f\u7528 \u6269\u5c55\u64cd\u4f5c\u800c\u8a00, \u9664\u4e86 \u542f\u7528 \u8be5\u6269\u5c55\u81ea\u8eab\u5b9a\u4e49\u7684\u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784\u5916, \u4e0d\u4f1a\u66f4\u6539\u6838\u5fc3Vulkan API \u6216\u5176\u4ed6\u6269\u5c55\u7684\u529f\u80fd\u3002 \u793a\u4f8b: \u521b\u5efa VkInstance \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> extensions(); extensions.push_back(VK_KHR_WIN32_SURFACE_EXTENSION_NAME); VkInstanceCreateInfo inst_info = {}; inst_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; ... // Enable Instance Extensions inst_info.enabledExtensionCount = extensions.size(); inst_info.ppEnabledExtensionNames = extensions.data(); VkInstance instance; VkResult res = vkCreateInstance(&inst_info, NULL, &instance); \u5bf9 VkPhysicalDevice, \u679a\u4e3e\u5176\u652f\u6301\u7684 Extensions: // \u679a\u4e3e\u8bbe\u5907 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); // \u9009\u62e9\u8bbe\u5907 VkPhysicalDevice physicalDevice = devices[0]; // \u4ec5\u793a\u4f8b,\u6b63\u786e\u4ee3\u7801\u5e94\u9009\u62e9\u5bf9\u5e94 GPU \u8bbe\u5907 // \u679a\u4e3e Extensions uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, availableExtensions.data()); \u521b\u5efa VkDevice \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> device_extension_names(); // check if physicalDevice support extension: for (const auto& extension : availableExtensions) { if(strcmp(extension.extensionName, VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0) device_extension_names.push_back(extension.extensionName); } } VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; device_info.pNext = NULL; ... // Enable Device Extensions device_info.enabledExtensionCount = device_extension_names.size(); device_info.ppEnabledExtensionNames = enabledExtensionCount ? device_extension_names.data() : NULL; VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device); 2.3. Features: \u529f\u80fd Features \u7528\u6765\u8bbe\u7f6e\u6216\u67e5\u8be2 \u975e\u6240\u6709\u5b9e\u73b0\u90fd\u652f\u6301 \u7684\u529f\u80fd\u3002 Feature \u5747\u4e3a bool \u503c. Features \u662f\u7269\u7406\u8bbe\u5907\u7684\u5c5e\u6027\u3002(physical device properties) \u8fd9\u4e9b\u529f\u80fd\u662f\u201c\u53ef\u9009\u201d\u7684\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u4f7f\u7528\u524d\u660e\u786e\u542f\u7528\u3002 2.3.1. \u6838\u5fc3 Features Vk \u6838\u5fc3\u4e2d\u5b9a\u4e49\u7684 Features, \u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceFeatures \u67e5\u8be2. VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); \u67e5\u8be2\u7ed3\u679c VkPhysicalDeviceFeatures \u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceFeatures { VkBool32 robustBufferAccess; VkBool32 fullDrawIndexUint32; VkBool32 imageCubeArray; VkBool32 independentBlend; VkBool32 geometryShader; VkBool32 tessellationShader; VkBool32 sampleRateShading; .... // \u603b\u8ba150+\u4e2a Bool \u503c } VkPhysicalDeviceFeatures \u5176\u4e2d\u6bcf\u4e2a Feature \u7684\u542b\u4e49 \u5728 Vulkan Specification 1.1/Features \u4e2d\u90fd\u6709\u89e3\u91ca. \u4f8b\u5982: IndependentBlend \u6307\u5b9a: \u662f\u5426\u6bcf\u4e2a attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u4e92\u76f8\u72ec\u7acb\u3002 \u672a\u542f\u7528\u6b64 Feature\uff0c\u5219\u6240\u6709 color attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u5fc5\u987b\u76f8\u540c\u3002 \u82e5\u542f\u7528\u6b64 Feature\uff0c\u5219\u53ef\u4ee5\u4e3a\u6bcf\u4e2a\u7ed1\u5b9a\u7684 color attachment \u63d0\u4f9b\u4e0d\u540c\u7684 VkPipelineColorBlendAttachmentState \u3002 2.3.2. \u6269\u5c55\u63d0\u4f9b\u7684Features \u67e5\u8be2\u51fd\u6570: vkGetPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 physicalDeviceFeatures2; vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &physicalDeviceFeatures2); \u67e5\u8be2\u7ed3\u679c: VkPhysicalDeviceFeatures2 \u7ed3\u6784: // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; sType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 pNext: \u6307\u9488\u94fe. VkPhysicalDeviceFeatures: Vulkan 1.0 \u63d0\u4f9b\u7684\u6838\u5fc3 Features \u6ce8: VkPhysicalDeviceFeatures2 \u7b49\u4ef7 VkPhysicalDeviceFeatures2KHR, vkGetPhysicalDeviceFeatures2 \u7b49\u4ef7 vkGetPhysicalDeviceFeatures2KHR \u901a\u8fc7 pNext , \u53ef\u4ee5\u83b7\u5f97\u6269\u5c55\u6240\u5b9a\u4e49\u7684 Features \u7ed3\u6784\u4f53, \u6709\u7684\u7531 Vulkan \u6838\u5fc3\u65b0\u7248\u672c\u63d0\u4f9b, \u6709\u7684\u7531\u5176\u4ed6 Extension\u63d0\u4f9b. \u4f8b\u5982: Vulkan 1.1 \u63d0\u4f9b\u7684 samplerYcbcrConversion. // Provided by VK_VERSION_1_1: VK_KHR_sampler_ycbcr_conversion typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures { VkStructureType sType; void* pNext; VkBool32 samplerYcbcrConversion; } VkPhysicalDeviceSamplerYcbcrConversionFeatures; VK_EXT_transform_feedback \u63d0\u4f9b\u7684 transformFeedback \u548c geometryStreams. // Provided by VK_EXT_transform_feedback typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 transformFeedback; VkBool32 geometryStreams; } VkPhysicalDeviceTransformFeedbackFeaturesEXT; \u67e5\u8be2\u793a\u4f8b: // \u6269\u5c55\u7684 Feature \u7ed3\u6784\u4f53 VkPhysicalDeviceSamplerYcbcrConversionFeatures mSamplerYcbcrConversionFeatures = {}; mSamplerYcbcrConversionFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; // vk1.1 \u7684 VkPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 deviceFeatures = {}; deviceFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; deviceFeatures.pNext = mVertexAttributeDivisorFeatures // \u67e5\u8be2 vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &deviceFeatures); // \u4f7f\u7528 if (mVertexAttributeDivisorFeatures.vertexAttributeInstanceRateDivisor) { ... } 2.3.3. \u542f\u7528 Features Features \u9ed8\u8ba4\u7686\u4e3a\u4e0d\u542f\u7528\u72b6\u6001. \u5fc5\u987b\u5728 VkDevice \u521b\u5efa\u65f6\u663e\u5f0f\u542f\u7528\u3002\u5982\u679c\u542f\u7528\u4e86\u7269\u7406\u8bbe\u5907\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5219 VkDevice \u521b\u5efa\u5c06\u5931\u8d25\uff0c\u5e76\u8fd4\u56deVK_ERROR_FEATURE_NOT_PRESENT\u3002 \u542f\u7528\u65b9\u6cd5: \u521b\u5efa VkPhysicalDeviceFeatures \u7ed3\u6784\u7684\u6307\u9488 (\u62161.1\u7684 VkPhysicalDeviceFeatures2\u7ed3\u6784) \u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \u6216 VK_FALSE, eg: physicalDeviceFeatures.independentBlend = VK_TRUE \u901a\u8fc7\u4f20\u9012\u7ed9 vkCreateDevice \u7528\u7684 VkDeviceCreateInfo\u7ed3\u6784\u7684 pEnabledFeatures \u6210\u5458. \u8981\u542f\u52a8\u6240\u6709\u8bbe\u5907\u7684\u529f\u80fd (\u614e\u7528)\uff0c\u5219\u53ea\u9700\u4f20\u5165\u67e5\u8be2\u51fd\u6570 vkGetPhysicalDeviceFeatures \u8fd4\u56de\u7684 VkPhysicalDeviceFeatures \u7ed3\u6784\u5373\u53ef\u3002\u8981\u7981\u7528\u5355\u4e2a\u529f\u80fd\uff0c\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728\u76f8\u540c\u7ed3\u6784\u4e2d\u5c06\u6240\u9700\u6210\u5458\u8bbe\u7f6e\u4e3aVK_FALSE\u3002 \u7528\u8fc7\u7ed9 pNext\u94fe\u6dfb\u52a0 Extensions \u63d0\u4f9b\u7684 Features \u7ed3\u6784\u4f53, \u6765\u542f\u7528\u6269\u5c55\u7684 Features. // \u67e5\u8be2\u6838\u5fc3 Features \u662f\u5426\u652f\u6301 VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); // \u8bbe\u7f6e\u542f\u7528 Features VkPhysicalDeviceFeatures2KHR enabledFeatures = {}; enabledFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; enabledFeatures.features.imageCubeArray = mPhysicalDeviceFeatures.imageCubeArray; enabledFeatures.features.independentBlend = mPhysicalDeviceFeatures.independentBlend; // Create Device VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; // \u6307\u5411 Features \u7ed3\u6784\u4f53\u4ee5\u8bbe\u7f6e Extensions \u63d0\u4f9b\u7684 Features // mSamplerYcbcrConversionFeatures : \u524d\u9762\u67e5\u8be2\u793a\u4f8b\u4e2d\u7684\u7ed3\u6784\u4f53. device_info.pNext = mSamplerYcbcrConversionFeatures; // Enable Physical Device Features device_info.pEnabledFeatures = &enabledFeatures.features; ... VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device); 2.4. Limitations Limits \u63d0\u4f9b\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u53ef\u80fd\u9700\u8981\u660e\u786e\u7684\u4e00\u4e9b\u8bbe\u5907\u7279\u5f81\u503c, \u8fd9\u4e9b\u7279\u5f81\u7684\u6700\u5c0f\u503c\uff0c\u6700\u5927\u503c\u7b49\u4f1a\u968f\u5e95\u5c42\u5b9e\u73b0\u7684\u4e0d\u540c\u800c\u5f02. \u901a\u8fc7\u67e5\u8be2 Properties \u547d\u4ee4, \u83b7\u53d6 VkPhysicalDeviceLimits \u7ed3\u6784\u4f53\u83b7\u53d6\u6838\u5fc31.0\u7684 Limits, \u6216\u5229\u7528 vk1.1 \u4e2d\u52a0\u5165\u7684 VkPhysicalDeviceProperties2 \u7684 pNext \u94fe \u83b7\u53d6\u5404 Extension \u65b0\u589e\u7684 Limits . \u7ed3\u6784\u4f53 VkPhysicalDeviceLimits \u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7701\u7565\u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd: \u4f8b\u5982: maxUniformBufferRange : \u5f53\u5c06\u7ed3\u6784\u4f53 VkDescriptorBufferInfo \u4f5c\u4e3a\u53c2\u6570\u8c03\u7528 vkUpdateDescriptorSets , \u5e76\u4e14 descriptors \u7c7b\u578b\u4e3a VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER \u6216 VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC \u65f6, \u5176\u7ed3\u6784\u4f53\u6210\u5458 range \u53ef\u8bbe\u7684\u6700\u5927\u503c. 2.4.1. \u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684Limits \u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684\u7ed3\u6784\u4f53\u5747\u4ee5 Properties \u800c\u975e Limits \u7ed3\u5c3e, \u5176\u67e5\u8be2\u65b9\u6cd5\u4e0e\u67e5\u8be2 \u6269\u5c55\u63d0\u4f9b\u7684 Feature \u4e00\u6837. \u67e5\u8be2\u51fd\u6570\u548c\u7ed3\u679c\u7ed3\u6784\u4f53\u5982\u4e0b: VkPhysicalDeviceProperties2 deviceProperties; vkGetPhysicalDeviceProperties2KHR(mPhysicalDevice, &deviceProperties); \u67e5\u8be2\u7ed3\u679c\u793a\u4f8b: \u7ed3\u6784\u4f53 VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT \u5305\u542b\u4e86\u6269\u5c55 VK_EXT_vertex_attribute_divisor \u63d0\u4f9b\u7684 limits \u503c maxVertexAttribDivisor : // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT; 2.5. Formats \u5bf9\u4e8e\u4e0d\u540c\u7684 vk \u5b9e\u73b0, \u5176\u652f\u6301\u7684\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u683c\u5f0f\u53ef\u80fd\u4f1a\u4e0d\u540c\u3002\u867d\u7136 Vulkan \u89c4\u5b9a\u4e86\u4e00\u7ec4\u5fc5\u987b\u652f\u6301\u7684 Format \u7684\u6700\u5c0f\u96c6\uff0c\u4f46\u5728\u4f7f\u7528\u9664\u6b64\u4ee5\u5916\u7684 Format\u529f\u80fd\u4e4b\u524d, \u5fc5\u987b\u663e\u5f0f\u7684\u67e5\u8be2\uff0c\u4ee5\u786e\u4fdd\u5b9e\u73b0\u652f\u6301\u8fd9\u4e9b\u683c\u5f0f\u3002 \u67e5\u8be2\u547d\u4ee4: vkGetPhysicalDeviceFormatProperties , \u67e5\u8be2\u8fd4\u56de\u7684 VkFormat \u7ed3\u6784\u4f53\u7684\u5305\u542b\u4e86\u5f53\u524d\u5b9e\u73b0\u6240\u652f\u6301\u7684\u683c\u5f0f\u529f\u80fd\u3002 VkFormat \u7ed3\u6784\u4f53\u793a\u4f8b: // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d \u5173\u4e8e Format \u76f8\u5173\u7684\u5185\u5bb9\u6bd4\u8f83\u590d\u6742, \u672c\u7ae0\u8282\u4ee5\u53ca\u540e\u7eed\u7ae0\u8282\u90fd\u4e0d\u8fdb\u884c\u6df1\u5165. \u5982\u679c\u9700\u8981\u8003\u8651\u518d\u5355\u72ec\u8fdb\u884c\u7814\u7a76. 3. ANGLE \u4e2d Vk \u6269\u5c55 \u540e\u7aef : \u5bf9\u8c03\u7528\u5404\u56fe\u5f62 API \u7684\u5b9e\u73b0, \u5982 Vulkan, DirectX, GL \u7b49 \u524d\u6bb5 : GLES \u90e8\u5206\u7684\u5b9e\u73b0, \u63d0\u4f9b\u7ed9\u5e94\u7528\u7a0b\u5e8f\u63a5\u53e3, \u8fdb\u884c\u72b6\u6001\u8ddf\u8e2a, \u8c03\u7528\u540e\u53f0 API. \u524d\u540e\u7aef\u5212\u5206\u793a\u610f\u56fe: @startuml class Application package \"Front-End (libANGLE)\" { Entry_Points --> gl::Context gl::Context --> \"State Tracing\" } Application --> Entry_Points package \"Back-End (libANGLE/renderer)\" { class Vk_backend class D3D_Backend class GL_Backend } \"State Tracing\" --> Vk_backend \"State Tracing\" --> D3D_Backend \"State Tracing\" --> GL_Backend hide member hide circle @enduml \u672c\u7ae0\u4e2d\u4ecb\u7ecd \u540e\u7aef Vulkan \u4e2d\u7684\u76f8\u5173\u5185\u5bb9. \u540e\u7eed\u7ae0\u8282\u4ecb\u7ecd GLES \u524d\u6bb5\u4e2d\u7684\u76f8\u5173\u5185\u5bb9. 3.1. ANGLE \u521d\u59cb\u5316 VkDevice ANGLE \u521d\u59cb\u5316 VkInstance \u548c VkDevice \u4f4d\u4e8e src/libANGLE/renderer/vulkan/RendererVk.cpp ANGLE \u4e2d Vulkan \u7684\u521d\u59cb\u5316\u6d41\u7a0b\u4e0e 2.1 Vulkan\u521d\u59cb\u5316\u6d41\u7a0b \u4e00\u81f4, \u7b80\u5355\u603b\u7ed3\u5373: \u9009\u62e9\u542f\u7528 Instance Extensions, \u521b\u5efa VkInstance \u9009\u5b9a\u7269\u7406\u8bbe\u5907, \u67e5\u8be2 Extensions, Features, Limitations, Formats \u9009\u4e2d Device Extensions, \u67e5\u8be2 Features2 , \u9009\u62e9\u542f\u7528\u7684 Device Extensions, Features, Features2, \u521b\u5efa VkDevice \u5176\u4e2d ANGLE \u4e2d\u542f\u7528\u7684 Extensions \u5217\u8868, \u53c2\u89c1 \u9644\u88682: ANGLE \u4e2d\u51fa\u73b0\u7684 Vk Extensions ANGLE \u4e2d\u542f\u7528\u7684\u7269\u7406\u8bbe\u5907 Features , \u548c Extensions \u63d0\u4f9b Features2, \u53c2\u89c1 \u9644\u88683: ANGLE \u4e2d\u542f\u7528\u7684 Vk Features 3.2. ANGLE \u4e2d\u7684 Vk Extensions \u9996\u5148, ANGLE \u4f7f\u7528\u4e86 \u8fd1 30\u4f59\u4e2a Vulkan Extensions . \u8fd9\u4e9b Vulkan \u7684\u5934\u6587\u4ef6\u90fd\u88ab\u5305\u542b\u5728 Vulkan \u5934\u6587\u4ef6\u4e2d, \u76f8\u5173\u8bf4\u660e\u53ef\u4ee5\u5728 Specification \u6587\u6863\u4e2d\u627e\u5230. \u5177\u4f53\u5f15\u7528\u5217\u8868, \u53c2\u89c1 \u9644\u88682: ANGLE \u4e2d\u51fa\u73b0\u7684 Vk Extensions \u6b64\u5916, ANGLE \u65b0\u589e\u4e86\u4e24\u4e2a\u81ea\u5b9a\u4e49 Vk \u7684 Extensions: VK_EXT_provoking_vertex angle/src/common/vulkan/vk_ext_provoking_vertex.h \u4f5c\u7528: \u5bf9\u5e94 GLES \u7aef\u7684 ANGLE \u81ea\u5b9a\u4e49 Extension: GL_ANGLE_provoking_vertex, \u5176\u65b0\u589e\u4e86API: glProvokingVertexANGLE : glProvokingVertexANGLE (GLenum mode) \u51fd\u6570: \u8c03\u7528 setProvokingVertex \u8bbe\u7f6e mode \u4e3a gl::ProvokingVertexConvention::LastVertexConvention, \u8ddf\u8e2a\u4ee3\u7801, \u8bfb\u53d6 ProvokingVertex \u5e76\u4f7f\u7528\u7684\u4ec5\u6709: ProgramD3D \u4e2d\u5224\u65ad\u662f\u5426 usesGeometryShader : if mode == LastVertexConvention, return true ; openGL \u540e\u7aef\u4e2d\u8fdb\u884c\u4e86\u4e00\u6b21\u5e8f\u5217\u5316 Vulkan : \u5728\u7ba1\u7ebf\u4e2d\u7684 RasterizationState \u7684 pNext\u94fe\u4e2d, \u6dfb\u52a0 provokingVertexState. \u731c\u6d4b: \u672a\u5b8c\u6210\u7684\u529f\u80fd. ANGLE \u591a\u6570\u81ea\u5b9a\u4e49 GLES \u4fa7 Extension \u90fd\u6709\u6807\u51c6\u7684\u8bf4\u660e\u6587\u6863, \u4f46\u4ec5\u67093\u4e2a\u6ca1\u6709, \u8fd9\u662f\u5176\u4e2d\u4e00\u4e2a. VK_GOOGLE_sampler_filtering_precision angle/src/common/vulkan/vk_google_sampler_filtering_precision.h \u4f5c\u7528: \u65b0\u589e\u4e86\u4e00\u4e2a CHROMIUM \u540e\u7f00\u7684 Texture: TEXTURE_FILTERING_HINT_CHROMIUM; \u5bf9\u5e94 GLES \u7aef \u81ea\u5b9a\u4e49 Extension: GL_CHROMIUM_texture_filtering_hint This extension defines a way to request high precision texture filtering using a new value to Hint. When this extension is enabled, TEXTURE_FILTERING_HINT_CHROMIUM can be used by the implementation as a means to distinguish between a performance focused implementation, using FASTEST, or a precision focused implementation, using NICEST. Like other hints, either option is spec compliant and the behavior of DONT_CARE is implementation specific. 3.3. ANGLE FeaturesVk (\u5728ANGLE \u540e\u7aef\u4e2d, \u7c7b\u7684\u540e\u7f00\u4e3a\u5bf9\u5e94\u56fe\u5f62 API, \u4f8b\u5982\u5b58\u5728 FeaturesVk, FeaturesD3D, FeaturesGL \u7b49. ) \u5bf9\u4e8e vk \u6838\u5fc31.0 \u63d0\u4f9b\u7684 Features, Limitations, ANGLE\u4e2d\u5206\u522b\u4f7f\u7528 Vulkan \u63d0\u4f9b\u7684\u7ed3\u6784\u4f53\u4fdd\u5b58, \u4ee5\u4f9b\u67e5\u8be2 VkPhysicalDeviceFeatures mPhysicalDeviceFeatures VkPhysicalDeviceLimits limitsVk (Formats \u6682\u4e0d\u505a\u8ba8\u8bba) \u6b64\u5916, ANGLE \u4e2d\u8fd8\u4e3a\u6bcf\u4e2a\u540e\u7aef\u90fd\u81ea\u5b9a\u4e49\u4e86\u4e00\u4e2aFeature\u5408\u96c6, Vulkan\u5bf9\u5e94\u7684\u4e3a: FeaturesVk (\u6e90\u7801: angle\\include\\platform\\FeaturesVk.h ) FeaturesVk.h struct FeaturesVk : FeatureSetBase { FeaturesVk(); ~FeaturesVk(); // Line segment rasterization must follow OpenGL rules. This means using an algorithm similar // to Bresenham's. Vulkan uses a different algorithm. This feature enables the use of pixel // shader patching to implement OpenGL basic line rasterization rules. This feature will // normally always be enabled. Exposing it as an option enables performance testing. Feature basicGLLineRasterization = { \"basicGLLineRasterization\", FeatureCategory::VulkanFeatures, \"Enable the use of pixel shader patching to implement OpenGL basic line \" \"rasterization rules\", &members}; // If the VK_EXT_line_rasterization extension is available we'll use it to get // Bresenham line rasterization. Feature bresenhamLineRasterization = { \"bresenhamLineRasterization\", FeatureCategory::VulkanFeatures, \"Enable Bresenham line rasterization via VK_EXT_line_rasterization extension\", &members}; // If the VK_EXT_provoking_vertex extension is available, we'll use it to set // the provoking vertex mode Feature provokingVertex = {\"provokingVertex\", FeatureCategory::VulkanFeatures, \"Enable provoking vertex mode via VK_EXT_provoking_vertex extension\", &members}; ... // \u603b\u8ba1 62 \u4e2a Feature } \u5176\u4e2d\u5404\u4e2a feature \u90fd\u6709\u6ce8\u91ca\u63cf\u8ff0, \u5176\u7c7b\u578b \u4e3a Feature \u7ed3\u6784: struct Feature { ... const char *const name; const FeatureCategory category; const char *const description; const char *const bug; const char *condition; // Whether the workaround is enabled or not. Determined by heuristics like vendor ID and // version, but may be overriden to any value. bool enabled = false; }; Feature \u6700\u4e3b\u8981\u4f7f\u7528\u7684\u5373 enabled \u5c5e\u6027, \u7528\u6765\u5224\u65ad\u8be5 Feature \u662f\u5426\u652f\u6301\u548c\u542f\u7528. \u548c Vulkan \u7684 Feature \u5408\u96c6\u4e00\u6837, ANGLE_FeaturesVk \u5185\u4e5f\u662f\u7531\u4e00\u7ec4 bool \u503c\u6765\u8868\u793a\u5f53\u524d\u662f\u5426\u652f\u6301\u67d0\u4e00\u529f\u80fd. \u5e76\u4e14 FeaturesVk \u540c\u6837\u5728\u521b\u5efa VkDevice \u7684\u8fc7\u7a0b\u4e2d\u5b8c\u6210\u521d\u59cb\u5316, \u5176\u503c\u6765\u6e90\u4f9d\u636e: Physical Device \u662f\u5426\u652f\u6301\u67d0 Extension, \u4ee5\u53ca Extension \u7684 Features2 \u548c Properties2 Features, Limitations, Format \u7684\u652f\u6301\u60c5\u51b5 OS : Windows, Linux, Android GPU : AMD, Intel, Nvidia, Qualcomm, ARM \u8bbe\u5907\u578b\u53f7: Nexus5X, Pixel2 FeaturesVk \u7684\u5c5e\u6027\u503c\u6765\u81ea\u4ee5\u4e0a\u51e0\u4e2a\u6761\u4ef6\u7684\u7ec4\u5408, \u4f8b\u5982 supportsShaderStencilExport : \u8bbe\u5907\u652f\u6301 VK_EXT_SHADER_STENCIL_EXPORT forceCPUPathForCubeMapCopy : \u5f53\u524d\u7cfb\u7edf\u4e3a Windows \u4e14\u8bbe\u5907\u4e3a Intel supportsImageFormatList : \u5f53\u524d\u8bbe\u5907\u652f\u6301 VK_KHR_IMAGE_FORMAT_LIST \u4e14 \u8bbe\u5907\u4e3a AMD \u8be6\u7ec6\u7684\u5bf9\u5e94\u5173\u7cfb, \u53c2\u89c1 \u9644\u88684: ANGLE \u81ea\u5b9a\u4e49 FeaturesVK FeaturesVK \u7684\u4f5c\u7528: FeaturesVK \u5728 RendererVk \u4e2d\u521d\u59cb\u5316\u540e, \u5305\u542b\u5728 ContextVk \u4e2d\u4f5c\u4e3a\u73af\u5883\u4e0a\u4e0b\u6587\u88ab Vulkan \u540e\u7aef \u7684\u5404\u4e2a\u7c7b\u4f7f\u7528, \u5982 FrameBufferVk, ProgramVk \u7b49. \u529f\u80fd\u4e3b\u8981\u5305\u62ec: \u521d\u59cb\u5316\u65f6, \u5224\u65ad\u662f\u5426\u652f\u6301\u67d0 Feature, \u8fdb\u800c\u6dfb\u52a0\u76f8\u5e94\u914d\u7f6e \u5b9e\u73b0\u6d41\u7a0b\u4e2d, \u6839\u636e Feature \u652f\u6301\u7684\u4e0d\u540c, \u8fdb\u5165\u4e0d\u540c\u7684\u5206\u652f \u4f8b: \u200b FeatureVk \u4e2d supportsDepthStencilResolve \u4e3a enabled \u9700\u8981 : \u7269\u7406\u8bbe\u5907\u652f\u6301 VK_KHR_CREATE_RENDERPASS_2, VK_KHR_DEPTH_STENCIL_RESOLVE \u4e14\u540e\u8005\u7684 Properties.independentResolveNone \u4e3a VK_TRUE. \u200b \u800c\u5f53\u5176\u4e3a enabled\u65f6, ANGLE: \u5728\u521b\u5efa Device \u65f6\u542f\u7528 Extension: VK_KHR_DEPTH_STENCIL_RESOLVE \u5728\u6267\u884c RenderBufferVk \u4e2d, \u5141\u8bb8\u652f\u6301 depth/stencil images , \u53ef\u8bbe\u7f6e VkImageUsageFlags \u542b VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT 4. ANGLE \u4e2d\u7684 GLES Extensions (angle/libANGLE/Caps.h) ANGLE \u5728GLES \u524d\u7aef, \u5b9a\u4e49\u4e86\u7ed3\u6784\u4f53 Extensions, Caps, \u548c TextureCapsMap, Extension : \u5176\u4e2d Extension \u4e2d\u5b9a\u4e49\u4e86\u7ea6 200 \u4e2abool \u503c, \u5206\u522b\u5bf9\u5e94\u4e86\u7ea6 200 \u4e2a GLES Extensions, \u5176\u4e2d 17\u4e2a\u4e3a texture ext. \u5927\u90e8\u5206 Extension \u53ef\u4ee5\u5728 GLES Specification \u7f51\u7ad9\u627e\u5230\u8bf4\u660e. \u6b64\u5916 ANGLE \u8fd8\u65b0\u589e\u4e86 \u6570\u5341\u4e2a EXT, \u5e76\u63d0\u4f9b\u4e86\u8bf4\u660e\u6587\u6863: angle/extensions \u65b0\u589eEXT\u5217\u8868\u89c1\u4e0b\u4e00\u8282 \" AGNLE \u6dfb\u52a0\u7684 GLES \u6269\u5c55 \" \u5176 bool \u503c\u4ee3\u8868\u4e86\u540e\u7aef\u662f\u5426\u652f\u6301\u6b64\u6269\u5c55. \u793a\u4f8b: // GL_OES_element_index_uint bool elementIndexUintOES = false; // GL_OES_packed_depth_stencil bool packedDepthStencilOES = false; // GL_NV_read_depth bool readDepthNV = false; Caps : \u7c7b\u4f3c vk Limitations, \u5b9a\u4e49\u8bbe\u5907\u652f\u6301\u7684\u8bbe\u5907\u7279\u5f81\u503c\u7684\u6700\u5927\u503c, \u6700\u5c0f\u503c\u7b49 \u793a\u4f8b: GLfloat minInterpolationOffset = 0; GLfloat maxInterpolationOffset = 0; GLint subPixelInterpolationOffsetBits = 0; // ES 3.1 (April 29, 2015) 20.39: implementation dependent values GLint64 maxElementIndex = 0; GLint max3DTextureSize = 0; GLint max2DTextureSize = 0; TextureCaps : \u7c7b\u4f3c vk Format, \u5b9a\u4e49\u8bbe\u5907\u652f\u6301\u7684\u683c\u5f0f\u529f\u80fd \u5b9a\u4e49\u7c7b TextureCapsMap, \u63d0\u4f9b set \u548c get \u51fd\u6570, \u6839\u636e formatID \u67e5\u8be2\u662f\u5426\u652f\u6301\u67d0\u683c\u5f0f. 4.1. ANGLE \u6dfb\u52a0\u7684 GLES \u6269\u5c55 GLES Extesions \u5728\u6e90\u7801\u4e2d\u96c6\u4e2d\u6ce8\u518c\u7684\u5730\u65b9: register_xml.py \u63cf\u8ff0\u5404\u7248\u672c\u5305\u542b\u7684 Extensions gl_angle_ext.xml \u6ce8\u518c Extensions \u6269\u5c55\u7684\u65b9\u6cd5, \u901a\u5e38\u4e3a glXXXXANGLE gl_angle_ext.xml gl2ext_angle.h extensions/\u6587\u6863 -- GL_ANGLE_client_arrays ANGLE_client_arrays GL_ANGLE_request_extension GL_ANGLE_request_extension ANGLE_request_extension -- GL_ANGLE_robust_resource_initialization ANGLE_robust_resource_initialization GL_ANGLE_provoking_vertex GL_ANGLE_provoking_vertex -- GL_ANGLE_memory_size ANGLE_memory_size GL_ANGLE_copy_texture_3d GL_ANGLE_copy_texture_3d ANGLE_copy_texture_3d -- GL_ANGLE_lossy_etc_decode ANGLE_lossy_etc_decode GL_ANGLE_robust_client_memory GL_ANGLE_robust_client_memory ANGLE_robust_client_memory -- GL_ANGLE_program_cache_control ANGLE_program_cache_control -- GL_ANGLE_texture_rectangle GL_ANGLE_texture_multisample GL_ANGLE_texture_multisample ANGLE_texture_multisample GL_ANGLE_get_tex_level_parameter GL_ANGLE_get_tex_level_parameter ANGLE_get_tex_level_parameter -- GL_ANGLE_explicit_context ANGLE_explicit_context GL_ANGLE_multi_draw GL_ANGLE_multi_draw ANGLE_multi_draw GL_ANGLE_base_vertex_base_instance GL_ANGLE_base_vertex_base_instance ANGLE_base_vertex_base_instance GL_ANGLE_texture_external_update GL_ANGLE_texture_external_update GL_ANGLE_get_image GL_ANGLE_get_image ANGLE_get_image GL_ANGLE_memory_object_flags GL_ANGLE_memory_object_flags ANGLE_external_objects_flags GL_ANGLE_memory_object_fuchsia GL_ANGLE_memory_object_fuchsia ANGLE_external_objects_fuchsia GL_ANGLE_semaphore_fuchsia GL_ANGLE_semaphore_fuchsia ANGLE_external_objects_fuchsia ANGLE_compressed_texture_etc ANGLE_depth_texture ANGLE_explicit_context_gles1 ANGLE_framebuffer_blit ANGLE_framebuffer_multisample ANGLE_instanced_arrays ANGLE_multiview_multisample ANGLE_pack_reverse_row_order ANGLE_program_binary ANGLE_texture_compression_dxt ANGLE_texture_usage ANGLE_timer_query ANGLE_translated_shader_source ANGLE_webgl_compatibility 5. ES \u4e0e Vk \u7684 Ext \u5bf9\u5e94\u6d41\u7a0b \u5e94\u7528\u7a0b\u5e8f\u8c03\u7528 API \u65f6\u7684\u9a8c\u8bc1\u6d41\u7a0b: @startuml participant APP participant entry_points participant Validation participant Context participant Renderer Renderer-> Renderer : initDevice() APP -> entry_points : glAnyCall() entry_points -> Validation : ValidateAnyCall() Validation -> Context : initCaps() [\u521d\u59cb\u5316] Context -> Renderer : getNativeExtensions() Renderer -> Renderer : ensureCapsInitialized() \u4ec5\u4e00\u6b21 Context -> Renderer : getNativeCaps() Context -> Renderer : getNativeTextureCaps() Validation -> Context : getExtensions() Validation -> Context : getCaps() Validation -> Context : getTextureCaps() @enduml \u5c06\u529f\u80fd\u96c6\u5bf9\u5e94 \u5728 Renderer :: ensureCapsInitialized() \u4e2d, \u5c06 GLES \u4fa7\u7684\u529f\u80fd\u96c6 \u4e0e vk \u4fa7\u7684 Extension, Features, Limits, Format \u5bf9\u5e94, \u5b8c\u6210\u5bf9 GLES \u4fa7\u7684\u529f\u80fd\u96c6\u7684\u8d4b\u503c\u521d\u59cb\u5316 @startmindmap + Mapping ++ ANGLE FeatureVk ++ Physical Device Features ++ Physical Device Limits ++ Formats -- Extensions -- Caps -- TextureCaps @endmindmap \u5177\u4f53 Extension \u5bf9\u5e94\u65b9\u5f0f, \u53c2\u89c1\u7ae0\u8282 GLES Extensions \u652f\u6301 GLES Extensions \u4f5c\u7528 GLES Extensions \u529f\u80fd\u4e3b\u8981\u5305\u62ec: \u5e94\u7528\u7a0b\u5e8f\u8c03\u7528 API \u65f6, \u5728\u6821\u9a8c\u5c42\u6839\u636e Extensions \u7684 bool \u503c, \u5224\u65ad\u662f\u5426\u652f\u6301\u67d0\u6269\u5c55. \u5b9e\u73b0\u6d41\u7a0b\u4e2d, \u6839\u636e Extensions \u652f\u6301\u7684\u4e0d\u540c, \u8fdb\u5165\u4e0d\u540c\u7684\u5206\u652f \u793a\u4f8b1: \u6821\u9a8c\u67d0 API \u8c03\u7528\u65f6, \u4f20\u5165\u7684 type \u7c7b\u578b\u662f\u5426\u652f\u6301: bool ValidReadPixelsTypeEnum(const Context *context, GLenum type) { switch (type) { .... case GL_UNSIGNED_SHORT: case GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT: case GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT: return context->getClientVersion() >= ES_3_0; case GL_FLOAT: return context->getClientVersion() >= ES_3_0 || context->getExtensions().textureFloatOES || context->getExtensions().colorBufferHalfFloat; case GL_HALF_FLOAT: return context->getClientVersion() >= ES_3_0 || context->getExtensions().textureHalfFloat; case GL_HALF_FLOAT_OES: return context->getExtensions().colorBufferHalfFloat; default: return false; } } \u793a\u4f8b2: \u6839\u636e Extensions \u8fdb\u5165\u4e0d\u540c\u5206\u652f void Program::postResolveLink(const gl::Context *context) { mState.updateActiveSamplers(); mState.mExecutable->updateActiveImages(getExecutable()); setUniformValuesFromBindingQualifiers(); if (context->getExtensions().multiDraw) { mState.mDrawIDLocation = getUniformLocation(\"gl_DrawID\").value; } if (context->getExtensions().baseVertexBaseInstance) { mState.mBaseVertexLocation = getUniformLocation(\"gl_BaseVertex\").value; mState.mBaseInstanceLocation = getUniformLocation(\"gl_BaseInstance\").value; } } 6. GLES \u7248\u672c\u9009\u62e9 \u6765\u6e90: RendererVk::getMaxSupportedESVersion \u5728\u83b7\u53d6\u652f\u6301\u7684 ES \u7248\u672c\u65f6, ANGLE \u6839\u636e\u4ee5\u4e0b\u7279\u6027\u6765\u8fc7\u6ee4, \u5f53\u5b58\u5728 \u7279\u6027/\u53c2\u6570 \u4e0d\u6ee1\u8db3\u65f6, \u964d\u4e00\u7ea7. \u6700\u4f4e 2.0. 6.1. GLES 3.2 (\u672a\u542f\u7528) 6.1.1. Features ES 3.2 \u9700\u8981\u5b9e\u73b0 EXT_gpu_shader5 \u76844\u4e2a\u7279\u6027 3.2 \u76ee\u524d\u4ec5\u5728\u6d4b\u8bd5\u6a21\u5f0f\u4e0b\u542f\u7528 Vk Features Spec shaderImageGatherExtended VkPhysicalDeviceFeatures \u4e00\u4e2a\u975e\u5e38\u91cf\u7684 offset \u7684 textureGatherOffset\u548c \u4e00\u7cfb\u5217\u76f8\u5173\u529f\u80fd\u3002 shaderSampledImageArrayDynamicIndexing VkPhysicalDeviceFeatures \u7528\u4e8e \u91c7\u6837(Sample) \u7684 \u52a8\u6001 uniform indices shaderUniformBufferArrayDynamicIndexing VkPhysicalDeviceFeatures \u7528\u4e8e uniform buffers \u7684 \u52a8\u6001 uniform indices shaderStorageBufferArrayDynamicIndexing VkPhysicalDeviceFeatures \u5f53 EXT_gpu_shader5 \u4e0d\u9700\u8981\u5728\u5b58\u50a8\u7f13\u51b2\u533a(storage buffers)\u4f7f\u7528 \u52a8\u6001uniform indices \u65f6, \u9700\u8981\u6b64\u7279\u6027\u5728\u5b58\u50a8\u7f13\u51b2\u533a\u6765 \u6a21\u62df \u539f\u5b50\u8ba1\u6570\u7f13\u5b58(atomic counter buffers) 6.2. GLES 3.1 ES 3.1 \u9700\u652f\u6301\u4ee5\u4e0b\u4e24\u4e2a\u53c2\u6570: 6.2.1. Caps VkPhysicalDeviceLimits Value Note maxPerStageDescriptorStorageBuffers >= gl::kMinimumComputeStorageBuffers (4) + gl::IMPLEMENTATION_MAX_ATOMIC_COUNTER_BUFFERS (8) \u81f3\u5c11\u4e00\u4e2a atomic counter buffer \u548c \u56db\u4e2a storage buffers maxVertexInputAttributeOffset >= 2047 maximum offset \u81f3\u5c11 2047 6.3. GLES 3.0 6.3.1. Features Vk Features Spec Note inheritedQueries VkPhysicalDeviceFeatures command buffer \u652f\u6301\u67e5\u8be2 independentBlend VkPhysicalDeviceFeatures blending operations are controlled per-attachment supportsTransformFeedbackExtension VK_EXT_transform_feedback emulateTransformFeedback PhysicalDeviceFeatures.vertexPipelineStoresAndAtomics \u6ca1\u6709 VK_EXT_transform_feedback \u65f6\u7684\u66ff\u4ee3 6.3.2. Caps Spec Value Note vk standardSampleLocations = true Multisample textures (ES3.1) \u548c multisample renderbuffers (ES3.0) gles MAX_VERTEX_UNIFORM_BLOCKS >= 12 gles MAX_FRAGMENT_UNIFORM_BLOCKS >= 12 gles MAX_VERTEX_OUTPUT_COMPONENTS >= 64 7. GLES Extensions \u652f\u6301 \u672c\u7ae0\u7684\u5404\u8868\u4e2d ES Features \u5373 GLES Extension \u540d\u79f0\u7684\u7b80\u5199, \u540c\u65f6\u4e3a ANGLE \u4ee3\u7801\u4e2d\u7684\u5bf9\u5e94\u7684\u53d8\u91cf\u540d. ES Features \u7b80\u5199\u89c4\u5219: \u6539\u5199\u6210 \"GL_OES/EXT_\u4e0b\u5212\u7ebf\u683c\u5f0f\", \u5373\u4e3a\u6269\u5c55\u540d. \u5982: bufferStorageEXT = GL_EXT_buffer_storage), mapBufferOES = GL_OES_mapbuffer \u90e8\u5206\u540e\u7f00 ANGLE, CHROMIUM \u7b49\u6ca1\u6709\u5199\u5728\u540d\u79f0\u540e\u9762, \u89c1 ES EXT name \u8865\u5145 7.1. \u9ed8\u8ba4\u652f\u6301\u7684 Extensions ANGLE \u5728\u521d\u59cb\u5316 GLES \u65f6\u9ed8\u8ba4\u5f00\u542f\u7684\u7279\u6027 ES Features ES EXT Name Note bufferStorageEXT GL_EXT_buffer_storage \u4ee5\u4e0b\u7a7a\u5373\u5bf9\u5e94\u9ed8\u8ba4\u89c4\u5219\u7684\u540d\u79f0 mapBufferOES mapBufferRange textureStorage drawBuffers fragDepth EXT framebufferBlit framebufferMultisample GL_ANGLE_framebuffer_blit GL_ANGLE_framebuffer_multisample copyTexture copyCompressedTexture copyTexture3d CHROMIUM CHROMIUM ANGLE debugMarker translatedShaderSource GL_ANGLE_translated_shader_source discardFramebuffer EXT memoryObject memoryObjectFlagsANGLE EXT ANGLE semaphore EXT eglImageOES eglImageExternalOES eglImageExternalWrapModesEXT eglImageExternalEssl3OES eglImageArray textureFormat2101010REV baseVertexBaseInstance GL_ANGLE_base_vertex_base_instance drawElementsBaseVertexOES drawElementsBaseVertexEXT blendMinMax EXT vertexHalfFloatOES instancedArraysANGLE instancedArraysEXT textureNPOTOES texture3DOES Vulkan natively supports non power-of-two textures standardDerivativesOES Vulkan natively supports standard derivatives shaderTextureLOD Vulkan natively supports texture LOD noperspectiveInterpolationNV Vulkan natively supports noperspective interpolation elementIndexUintOES Vulkan natively supports 32-bit indices, entry in kIndexTypeMap fboRenderMipmapOES getImageANGLE ANGLE support getting image data for Textures and Renderbuffers. shaderNonConstGlobalInitializersEXT Implemented in the translator separateShaderObjects EXT Implemented in the front end eglSyncOES vertexAttribType1010102OES getProgramBinaryOES Program Binary extension. pixelBufferObjectNV fenceNV copyImageEXT shadowSamplersEXT 7.2. \u6709\u6761\u4ef6\u7684\u652f\u6301\u7684 Extensions ANGLE \u5728\u521d\u59cb\u5316 GLES \u65f6, \u9700\u5148\u521d\u59cb\u5316 Vk Features, \u7136\u540e\u6839\u636e Vk Features \u7684\u542f\u7528\u60c5\u51b5, \u6765\u6709\u6761\u4ef6\u7684\u542f\u7528 ES \u7279\u6027: Note: \u8868\u683c\u7565\u53bb\u4e86\u4e0e Format \u76f8\u5173\u7684\u7279\u6027 ES Features Vk Features Vk Spec / EXT Note multisampledRenderToTexture multisampledRenderToTexture2 enableMultisampledRenderToTexture Enable on Android by default textureStorageMultisample2DArrayOES standardSampleLocations VkPhysicalDeviceLimits compressedTextureETC (ANGLE_compressed_texture_etc) textureCompressionETC2 VkPhysicalDeviceFeatures GL_ANGLE_compressed_texture_etc To ensure that ETC2/EAC formats are enabled only on hardware that supports them natively, this flag is not set by the function above and must be set explicitly. It exposes ANGLE_compressed_texture_etc extension string textureCompressionSliced3dASTCKHR GL_KHR_texture_compression_astc_ldr Vulkan supports sliced 3D ASTC texture uploads when ASTC is supported. compressedETC1RGB8SubTexture GL_OES_compressed_ETC1_RGB8_texture drawBuffersIndexedOES drawBuffersIndexedOES; independentBlend VkPhysicalDeviceFeatures memoryObjectFd supportsExternalMemoryFd VK_KHR_external_memory_fd semaphoreFd supportsExternalSemaphoreFd VK_KHR_external_semaphore_fd robustBufferAccessBehavior robustBufferAccess VkPhysicalDeviceFeatures occlusionQueryBoolean inheritedQueries VkPhysicalDeviceFeatures ANGLE use secondary command buffers almost everywhere and they require a feature to be able to execute in the presence of queries. As a result, we won't support queries unless that feature is available. disjointTimerQuery queryCounterBitsTimeElapsed queryCounterBitsTimestamp timestampValidBits VkQueueFamilyProperties textureFilterAnisotropic maxTextureAnisotropy samplerAnisotropy maxSamplerAnisotropy VkPhysicalDeviceFeatures VkPhysicalDeviceLimits depthTextureCubeMapOES (ES)GL_OES_depth_texture (ES)GL_OES_packed_depth_stencil Vulkan has no restrictions of the format of cubemaps, so if the proper formats are supported, creating a cube of any of these formats should be implicitly supported. gpuShader5EXT shaderImageGatherExtended, shaderSampledImageArrayDynamicIndexing, shaderUniformBufferArrayDynamicIndexing, shaderStorageBufferArrayDynamicIndexing VkPhysicalDeviceFeatures textureFilteringCHROMIUM supportsFilteringPrecision VK_GOOGLE_sampler_filtering_precision textureCubeMapArrayOES textureCubeMapArrayEXT imageCubeArray mPhysicalDeviceFeatures Only expose texture cubemap array if the physical device supports it. sampleShadingOES sampleVariablesOES multisampleInterpolationOES sampleRateShading VkPhysicalDeviceFeatures 7.3. \u4e0d\u652f\u6301\u7684 GLES Extensions ANGLE \u5728\u521d\u59cb\u5316 GLES \u65f6\u9ed8\u8ba4\u5173\u95ed\u7684\u7279\u6027 ES Features EXT Name Note textureBorderClampOES GL_OES_texture_border_clamp \u5c1a\u672a\u5b9e\u73b0 textureCompressionASTCOES GL_OES_texture_compression_astc Vulkan doesn't support ASTC 3D block textures. textureCompressionASTCHDRKHR GL_KHR_texture_compression_astc_hdr Vulkan doesn't guarantee HDR blocks decoding without VK_EXT_texture_compression_astc_hdr. 8. \u53c2\u8003\u5217\u8868 9. \u9644\u88681: ANGLE \u5411 KHR \u7279\u51fa\u7684\u7279\u6027\u9700\u6c42: (\u6765\u81ea \u534e\u4e3a GPU Workshop \"Khronos \u76f8\u5173\u8bae\u9898\", \u738b\u8f1d\u9f8d, 2020) ANGLE \u5411 vk 1.2/1.3 \u63d0\u51fa\u7684\u9700\u6c42 10. \u9644\u88682: ANGLE \u4e2d\u51fa\u73b0\u7684 Vk Extensions Instance Level WSIExtension: VK_KHR_ANDROID_SURFACE / VK_KHR_WIN32_SURFACE / ... VK_KHR_SURFACE VK_EXT_DEBUG_UTILS VK_EXT_DEBUG_REPORT VK_EXT_SWAPCHAIN_COLOR_SPACE VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2 Device Level VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER VK_EXT_DEPTH_CLIP_ENABLE VK_EXT_EXTERNAL_MEMORY_HOST VK_EXT_INDEX_TYPE_UINT8 VK_EXT_LINE_RASTERIZATION VK_EXT_PROVOKING_VERTEX VK_EXT_QUEUE_FAMILY_FOREIGN VK_EXT_SHADER_STENCIL_EXPORT VK_EXT_TRANSFORM_FEEDBACK VK_EXT_VERTEX_ATTRIBUTE_DIVISOR VK_FUCHSIA_EXTERNAL_MEMORY VK_FUCHSIA_EXTERNAL_SEMAPHORE VK_GOOGLE_SAMPLER_FILTERING_PRECISION VK_GGP_FRAME_TOKEN VK_KHR_BIND_MEMORY_2 VK_KHR_CREATE_RENDERPASS_2 VK_KHR_DEPTH_STENCIL_RESOLVE VK_KHR_EXTERNAL_FENCE_CAPABILITIES VK_KHR_EXTERNAL_FENCE_FD VK_KHR_EXTERNAL_MEMORY VK_KHR_EXTERNAL_MEMORY_FD VK_KHR_EXTERNAL_SEMAPHORE VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES VK_KHR_EXTERNAL_SEMAPHORE_FD VK_KHR_GET_MEMORY_REQUIREMENTS_2 VK_KHR_IMAGE_FORMAT_LIST VK_KHR_INCREMENTAL_PRESENT VK_KHR_MAINTENANCE1 VK_KHR_SAMPLER_YCBCR_CONVERSION VK_KHR_SHADER_FLOAT16_INT8 VK_KHR_SWAPCHAIN VK_QCOM_render_pass_store_ops 11. \u9644\u88683: ANGLE \u4e2d\u542f\u7528\u7684 Vk Features Vulkan_1_0 Features: // Select additional features to be enabled. mPhysicalDeviceFeatures{ // Used to support cubemap array: only enable when not SwiftShader or not Qualcomm imageCubeArray; // Used to support framebuffers with multiple attachments: independentBlend; // Used to support robust buffer access: robustBufferAccess; // Used to support Anisotropic filtering: samplerAnisotropy; // Used to support wide lines: wideLines; // Used to emulate transform feedback: vertexPipelineStoresAndAtomics; // Used to implement storage buffers and images in the fragment shader: fragmentStoresAndAtomics; // Used to support geometry shaders: geometryShader = mPhysicalDeviceFeatures.geometryShader; // Used to support EXT_gpu_shader5: mPhysicalDeviceFeatures.shaderImageGatherExtended; // Used to support EXT_gpu_shader5: shaderUniformBufferArrayDynamicIndexing // Used to support EXT_gpu_shader5 and sampler array of array emulation: shaderSampledImageArrayDynamicIndexing; // Used to support atomic counter emulation: shaderStorageBufferArrayDynamicIndexing; // Used to support APPLE_clip_distance enabledFeatures.features.shaderClipDistance // Used to support OES_sample_shading sampleRateShading; // Used to support depth clears through draw calls. depthClamp; // if (!vk::CommandBuffer::ExecutesInline()) inheritedQueries; // Used to support OES_sample_variables sampleRateShading; } Extension Features: VkPhysicalDeviceLineRasterizationFeaturesEXT VkPhysicalDeviceProvokingVertexFeaturesEXT VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT VkPhysicalDeviceTransformFeedbackFeaturesEXT VkPhysicalDeviceIndexTypeUint8FeaturesEXT VkPhysicalDeviceShaderFloat16Int8FeaturesKHR VkPhysicalDeviceSamplerYcbcrConversionFeatures 12. \u9644\u88684: ANGLE \u81ea\u5b9a\u4e49 FeaturesVk \u4ee5\u4e0b\u7686\u4e3a ANGLE \u5728\u521d\u59cb\u5316 Vk \u4e2d\u6d89\u53ca\u7684\u7279\u6027\u548c\u5217\u8868, \u4ee5\u4f9b\u53c2\u8003 ANGLE Features Extension Platform Note supportsSwapchainColorspace VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME bresenhamLineRasterization VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME basicGLLineRasterization -- !IsAndroid() && !isPowerVR Use OpenGL line rasterization rules if extension mLineRasterizationFeatures not available by default. provokingVertex VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME extraCopyBufferRegion -- IsWindows() && isIntel forceCPUPathForCubeMapCopy -- IsWindows() && isIntel clampPointSize -- isNvidia nvidia Version < 421 depthClamping VK_EXT_depth_clip_enable isNvidia flushAfterVertexConversion -- IsAndroid() && IsNexus5X Work around ineffective compute-graphics barriers on Nexus 5X. Testing other vendors and driver versions are affected supportsRenderpass2 VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME supportsIncrementalPresent VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME supportsAndroidHardwareBuffer VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE _BUFFER_EXTENSION_NAME VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME ANDROID supportsExternalMemoryFd VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME supportsExternalMemoryFuchsia VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME supportsFilteringPrecision VK_GOOGLE_SAMPLER_FILTERING_PRECISION_EXTENSION_NAME supportsExternalFenceCapabilities VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME supportsExternalSemaphoreCapabilities VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME supportsExternalSemaphoreFd VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME supportsExternalSemaphoreFuchsia VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME supportsExternalFenceFd VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME supportsAndroidNativeFenceSync VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME ANDROID supportsShaderStencilExport VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME supportsRenderPassStoreOpNoneQCOM VK_QCOM_render_pass_store_ops_EXTENSION_NAME supportsTransformFeedbackExtension VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME supportsIndexTypeUint8 mIndexTypeUint8Features supportsDepthStencilResolve VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME mDepthStencilResolveProperties emulateTransformFeedback mTransformFeedbackFeatures PhysicalDeviceFeatures. vertexPipelineStoresAndAtomics = true disableFifoPresentMode -- Linux() && isIntel bindEmptyForUnusedDescriptorSets -- IsAndroid() && isQualcomm forceOldRewriteStructSamplers mPhysicalDeviceFeatures. shaderSampledImageArrayDynamicIndexing = false isQualcomm perFrameWindowSizeQuery -- isIntel || (IsWindows() && isAMD) || IsFuchsia() disallowSeamfulCubeMapEmulation -- IsWindows() && isAMD padBuffersToMaxVertexAttribStride -- isAMD forceD16TexFilter -- IsAndroid() && isQualcomm disableFlippingBlitWithCommand -- IsAndroid() && isQualcomm shadowBuffers Enable persistentlyMappedBuffers Enable allocateNonZeroMemory Disable Allocation sanitization disabled by default because of a heaveyweight implementation that can cause OOM and timeouts. supportsExternalMemoryHost VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME enablePreRotateSurfaces Enable on Android IsAndroid enableFramebufferVkCache Disable on apple !IsApple() Currently disable FramebufferVk cache on Apple enablePrecisionQualifiers Disabled by default preferAggregateBarrierCalls Enable on target gpu isNvidia || isAMD || isIntel asyncCommandQueue Disabled supportsYUVSamplerConversion VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME supportsShaderFloat16 VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME forceMaxUniformBufferSize16KB Enable on Adreno540 isQualcomm && isAdreno540 supportsImageFormatList VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME isAMD enableMultisampledRenderToTexture Enable except on Swiftshader, Inter, AMD !(IsApple() && isSwiftShader) && !(IsWindows() && (isIntel || isAMD)) supportsImageCubeArray mPhysicalDeviceFeatures.imageCubeArray == VK_TRUE !isSwiftShader && !isQualcomm preferredLargeHeapBlockSize4MB Enable except Qualcomm !isQualcomm deferFlushUntilEndRenderPass Enable except Qualcomm !isQualcomm Defer glFLush call causes manhattan 3.0 perf regression. Let Qualcomm driver opt out from // this optimization. waitIdleBeforeSwapchainRecreation Enable on Android Arm IsAndroid() && isARM Android mistakenly destroys the old swapchain when creating a new one. preferDrawClearOverVkCmdClearAttachments Enable only on Pixel2 IsPixel2","title":"139 ANGLE ES Extensions Support"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#1-angle-vk","text":"\u672c\u6587\u6863\u5185\u5bb9: \u9996\u5148\u6839\u636e Vulkan Specification \u63cf\u8ff0\u4e86 Vulkan \u6807\u51c6\u4e2d\u5982\u4f55\u5b9a\u4e49 Extension, Feature \u7b49\u76f8\u5173\u529f\u80fd\u96c6, \u4ee5\u53ca\u5982\u4f55\u5728\u521d\u59cb\u5316\u8fc7\u7a0b\u4e2d\u542f\u7528\u4ed6\u4eec. \u63cf\u8ff0 ANGLE \u5728\u521b\u5efa Vulkan \u540e\u7aef\u65f6, \u5982\u4f55\u4f7f\u7528 Extensions. \u63cf\u8ff0 ANGLE \u524d\u7aef GLES \u4e2d\u662f\u5982\u4f55\u5bf9 GLES \u63d0\u4f9b\u652f\u6301\u7684 \u4ee5\u7edf\u8ba1\u5217\u8868, \u5217\u4e3e\u51fa ANGLE \u4f7f\u7528\u4e86\u54ea\u4e9b vk \u529f\u80fd, \u5e76\u7528\u6765\u652f\u6301\u4e86\u54ea\u4e9b GLES Extensions.","title":"1. ANGLE: Vk\u6269\u5c55\u7684\u4f7f\u7528\u4e0e\u652f\u6301"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#2-vulkan","text":"\u5bf9\u4e8e\u4e0d\u540c\u7684\u5e73\u53f0, \u9a71\u52a8, \u64cd\u4f5c\u7cfb\u7edf\u7b49, \u5f53Vulkan\u7684\u5e95\u5c42\u5b9e\u73b0\u4e0d\u540c\u65f6, Vulkan \u53ef\u7528\u7684 \u529f\u80fd\u96c6 \u4e5f\u6709\u5f88\u591a\u533a\u522b. \u672c\u7ae0\u63cf\u8ff0\u4e86 Vulkan \u5982\u4f55\u5b9a\u4e49\u548c\u6269\u5c55\u529f\u80fd\u96c6, \u4e3b\u8981\u4ecb\u7ecd\u4e86\u56db\u4e2a\u6982\u5ff5: Extension, Feature, Limitation, \u548c Format. (\u672c\u7ae0\u6587\u672c\u5185\u5bb9\u7684\u66f4\u591a\u7ec6\u8282, \u53c2\u89c1 Vulkan Specification 1.1 , \u4ee3\u7801\u5747\u4e3a\u793a\u4f8b\u7528\u4f2a\u7801)","title":"2. Vulkan \u6269\u5c55"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#21-vulkan","text":"\u5728\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u65f6, \u7a0b\u5e8f\u4e2d\u8981\u542f\u7528\u7684 Vulkan \u529f\u80fd\u96c6\u5fc5\u987b\u5728\u521d\u59cb\u5316 Device \u524d\u786e\u5b9a\u4e0b\u6765. \u4ee5\u4e0b\u662f\u521d\u59cb\u5316\u8fc7\u7a0b\u4e2d\u4e0e\u529f\u80fd\u76f8\u5173\u7684\u8fc7\u7a0b: \u5bf9\u5e94 vk \u521d\u59cb\u5316\u7684\u524d\u4e09\u6b65: Instance --> Physical Device --> Device @startuml class Device { } hide members hide circle Instance --> Physical_Device Physical_Device --> Device @enduml Vulkan\u521d\u59cb\u5316 Device \u76f8\u5173\u6d41\u7a0b: \u9009\u62e9\u542f\u7528 Instance Extensions, \u521b\u5efa VkInstance \u9009\u5b9a\u7269\u7406\u8bbe\u5907, \u67e5\u8be2 Extensions, Features, Limitations, Formats \u9009\u4e2d Device Extensions, \u67e5\u8be2 Features2*, Properties2, Formats \u9009\u62e9\u542f\u7528\u7684 Device Extensions, Features, Features2, \u521b\u5efa VkDevice \u6ce8 ( ): \u672c\u6587\u6863\u4e3a\u65b9\u4fbf\u63cf\u8ff0, Features2, Properties2 \u7528\u6765\u7279\u6307\u6765\u81ea Extension \u7684\u5c5e\u6027, \u4ee5\u533a\u5206\u7531 Vulkan \u6838\u5fc3\u63d0\u4f9b\u7684 Features, Properties. * @startuml [*] -> Enume_Instance_Extension Enume_Instance_Extension --> CreateInstance CreateInstance --> Enume_PhysicalDevices Enume_PhysicalDevices --> Device_Extension Device_Extension --> Features2 Device_Extension --> Properties2\u4e0eFormat Enume_PhysicalDevices --> Features Enume_PhysicalDevices --> Limits\u4e0eFormats Device_Extension --> vkCreateDevice Features --> vkCreateDevice Features2 --> vkCreateDevice Limits\u4e0eFormats --> Application Properties2\u4e0eFormat --> Application Enume_Instance_Extension: \u679a\u4e3e vk \u652f\u6301\u7684 Enume_Instance_Extension: Instance-level Extensions Enume_Instance_Extension: \u9009\u62e9\u8981\u542f\u7528\u7684 CreateInstance: \u521b\u5efa Instance Enume_PhysicalDevices: \u679a\u4e3e \u7269\u7406\u8bbe\u5907, \u9009\u62e9 GPU \u8bbe\u5907 Device_Extension: \u67e5\u8be2GPU\u652f\u6301\u7684 Device_Extension: Device-Level Extensions Device_Extension: \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 Features2: \u67e5\u8be2 Extensions Features2: \u7684 Features \u7ed3\u6784\u4f53, Features2: \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 Properties2\u4e0eFormat: \u67e5\u8be2 Extensions \u7684 Properties2\u4e0eFormat: Limits \u4e0e Format Features: \u67e5\u8be2 GPU \u652f\u6301\u7684 Features: Features, Features: \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 Limits\u4e0eFormats: \u67e5\u8be2 GPU \u652f\u6301\u7684 Limits\u4e0eFormats: Limits\u4e0eFormats vkCreateDevice: \u5c06\u542f\u7528\u7684 Extensions vkCreateDevice: \u548c Features \u4f5c\u4e3a\u53c2\u6570 vkCreateDevice: \u653e\u5165 CreateInfo \u7ed3\u6784\u4f53, vkCreateDevice: \u521b\u5efa\u903b\u8f91\u8bbe\u5907 Device, Application: \u67e5\u8be2\u652f\u6301\u529f\u80fd @enduml Extension: \u529f\u80fd\u96c6\u7684\u62bd\u8c61\u6982\u5ff5, \u7528\u6765\u4e3a Vulkan \u6dfb\u52a0\u65b0\u7684 Commands\uff0cStructures \u548c Enumerants. \u540c\u65f6\u53ef\u80fd\u65b0\u589e Features, Limitations, \u548c Format. Feature: bool \u503c\u96c6\u5408, \u53ef\u9009\u529f\u80fd\u7684\u5f00\u5173. \u53ef\u4ee5\u7528\u6765\u67e5\u8be2\u8bbe\u5907\u652f\u6301\u7684\u529f\u80fd, Limitation \u548c Format \u662f\u4e24\u4e2a\u53ea\u8bfb\u53c2\u6570\u96c6, Limitation \u53c8\u79f0\u505a Properties, \u8868\u793a\u8bbe\u5907\u7279\u5f81\u503c; Format \u8868\u793a\u652f\u6301\u7684\u683c\u5f0f. \u672c\u7ae0\u540e\u9762\u5404\u7ae0\u8282\u5bf9\u6b64\u6d41\u7a0b\u5404\u6b65\u9aa4\u8fdb\u884c\u89e3\u91ca, \u5e76\u5305\u542b\u793a\u4f8b\u4ee3\u7801.","title":"2.1. Vulkan \u521d\u59cb\u5316\u6d41\u7a0b"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#22-extensions","text":"\u6269\u5c55 (Extensions) \u53ef\u7528\u6765\u4e3a Vk \u6dfb\u52a0\u65b0\u529f\u80fd. Vk \u6838\u5fc3\u7684\u65b0\u7248\u672c (\u5982: VK_VERSION_1_1) \u4e5f\u53ef\u4ee5\u89c6\u4e3a\u4e00\u4e2a\u6269\u5c55. \u6269\u5c55\u53ef\u4ee5\u5b9a\u4e49\u65b0\u7684 \u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784. ( Commands\uff0cStructures \u548c Enumerants) \u6269\u5c55\u5206\u4e3a\u5b9e\u4f8b\u7ea7\u548c\u8bbe\u5907\u7ea7 (Instance-level \u548c Device-level) \u5f53 Commands \u7528\u6765\u679a\u4e3e\u5b9e\u4f8b\u5c5e\u6027 (instance properties), \u6216\u63a5\u53d7 VkInstance \u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570, \u5219\u88ab\u89c6\u4e3a\u5b9e\u4f8b\u7ea7\u529f\u80fd\u3002 \u5f53 Commands \u7528\u6765\u679a\u4e3e\u7269\u7406\u8bbe\u5907\u5c5e\u6027 (physical device properties), \u6216\u63a5\u53d7 VkDevice \u53ca\u5176\u5b50\u7c7b\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\uff0c\u5219\u88ab\u89c6\u4e3a\u8bbe\u5907\u7ea7\u529f\u80fd\u3002 \u4e3a\u4e86\u65b9\u4fbf\u7f16\u8bd1\uff0c\u5728 Khronos \u63d0\u4f9b\u7684 vulkan_core.h \u4e2d\u9664\u4e86\u6838\u5fc3API, \u8fd8\u5b9a\u4e49\u4e86\u5df2\u6ce8\u518c Extensions \u5b9a\u4e49\u7684\u63a5\u53e3\uff0c\u5305\u62ec\u65b0 \u7ed3\u6784, \u679a\u4e3e, \u548c\u547d\u4ee4\u7684\u51fd\u6570\u6307\u9488\u7c7b\u578b\u3002\u6269\u5c55\u7684\u5b9e\u73b0\u901a\u8fc7 Layers \u548c Vulkan\u5b9e\u73b0\u6765\u63d0\u4f9b\u3002 Vulkan \u4e0e Extensions, Features, Properties \u7684\u5173\u7cfb: @startuml hide circle package Vulkan { class \"VK_VERSION_1_0\" { VkPhysicalDeviceFeatures VkPhysicalDeviceProperties VkFormat } class \"VK_VERSION_1_1\" { VK_KHR_XXX_ VK_XXX_Features VK_XXX_Properties vkGetPhysical_Device_Feature2() vkGetPhysical_Device_Properties2() } class \"Other Vk Extensions\" { VK_EXT_XXX_ VK_AMD/GOOLE_XXX_ VK_XXX_Features_EXT VK_XXX_Properties_EXT } } @enduml","title":"2.2. Extensions: \u6269\u5c55"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#221-vk-extensions","text":"Vk Extensions \u9700\u8981\u5728\u521d\u59cb\u5316\u9636\u6bb5\u663e\u5f0f\u542f\u7528. \u542f\u7528 instance extension, \u8981\u5728\u521b\u5efa VKInstance \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkInstanceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. \u542f\u7528 device extension, \u8981\u5728 \u521b\u5efa VkDevice \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkDeviceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. Physical-Device-Level \u529f\u80fd\u6ca1\u6709\u542f\u7528\u673a\u5236\uff0c\u53ea\u8981 VkPhysicalDevice \u7684\u529f\u80fd\u5bf9\u5e94\u7684 Extensions \u5728\u679a\u4e3e\u51fd\u6570 vkEnumerateDeviceExtensionProperties \u4e2d\u88ab\u5217\u51fa. \u4ec5 \u542f\u7528 \u6269\u5c55\u64cd\u4f5c\u800c\u8a00, \u9664\u4e86 \u542f\u7528 \u8be5\u6269\u5c55\u81ea\u8eab\u5b9a\u4e49\u7684\u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784\u5916, \u4e0d\u4f1a\u66f4\u6539\u6838\u5fc3Vulkan API \u6216\u5176\u4ed6\u6269\u5c55\u7684\u529f\u80fd\u3002 \u793a\u4f8b: \u521b\u5efa VkInstance \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> extensions(); extensions.push_back(VK_KHR_WIN32_SURFACE_EXTENSION_NAME); VkInstanceCreateInfo inst_info = {}; inst_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; ... // Enable Instance Extensions inst_info.enabledExtensionCount = extensions.size(); inst_info.ppEnabledExtensionNames = extensions.data(); VkInstance instance; VkResult res = vkCreateInstance(&inst_info, NULL, &instance); \u5bf9 VkPhysicalDevice, \u679a\u4e3e\u5176\u652f\u6301\u7684 Extensions: // \u679a\u4e3e\u8bbe\u5907 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); // \u9009\u62e9\u8bbe\u5907 VkPhysicalDevice physicalDevice = devices[0]; // \u4ec5\u793a\u4f8b,\u6b63\u786e\u4ee3\u7801\u5e94\u9009\u62e9\u5bf9\u5e94 GPU \u8bbe\u5907 // \u679a\u4e3e Extensions uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, availableExtensions.data()); \u521b\u5efa VkDevice \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> device_extension_names(); // check if physicalDevice support extension: for (const auto& extension : availableExtensions) { if(strcmp(extension.extensionName, VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0) device_extension_names.push_back(extension.extensionName); } } VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; device_info.pNext = NULL; ... // Enable Device Extensions device_info.enabledExtensionCount = device_extension_names.size(); device_info.ppEnabledExtensionNames = enabledExtensionCount ? device_extension_names.data() : NULL; VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device);","title":"2.2.1. \u542f\u7528 Vk Extensions"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#23-features","text":"Features \u7528\u6765\u8bbe\u7f6e\u6216\u67e5\u8be2 \u975e\u6240\u6709\u5b9e\u73b0\u90fd\u652f\u6301 \u7684\u529f\u80fd\u3002 Feature \u5747\u4e3a bool \u503c. Features \u662f\u7269\u7406\u8bbe\u5907\u7684\u5c5e\u6027\u3002(physical device properties) \u8fd9\u4e9b\u529f\u80fd\u662f\u201c\u53ef\u9009\u201d\u7684\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u4f7f\u7528\u524d\u660e\u786e\u542f\u7528\u3002","title":"2.3. Features: \u529f\u80fd"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#231-features","text":"Vk \u6838\u5fc3\u4e2d\u5b9a\u4e49\u7684 Features, \u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceFeatures \u67e5\u8be2. VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); \u67e5\u8be2\u7ed3\u679c VkPhysicalDeviceFeatures \u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceFeatures { VkBool32 robustBufferAccess; VkBool32 fullDrawIndexUint32; VkBool32 imageCubeArray; VkBool32 independentBlend; VkBool32 geometryShader; VkBool32 tessellationShader; VkBool32 sampleRateShading; .... // \u603b\u8ba150+\u4e2a Bool \u503c } VkPhysicalDeviceFeatures \u5176\u4e2d\u6bcf\u4e2a Feature \u7684\u542b\u4e49 \u5728 Vulkan Specification 1.1/Features \u4e2d\u90fd\u6709\u89e3\u91ca. \u4f8b\u5982: IndependentBlend \u6307\u5b9a: \u662f\u5426\u6bcf\u4e2a attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u4e92\u76f8\u72ec\u7acb\u3002 \u672a\u542f\u7528\u6b64 Feature\uff0c\u5219\u6240\u6709 color attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u5fc5\u987b\u76f8\u540c\u3002 \u82e5\u542f\u7528\u6b64 Feature\uff0c\u5219\u53ef\u4ee5\u4e3a\u6bcf\u4e2a\u7ed1\u5b9a\u7684 color attachment \u63d0\u4f9b\u4e0d\u540c\u7684 VkPipelineColorBlendAttachmentState \u3002","title":"2.3.1. \u6838\u5fc3 Features"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#232-features","text":"\u67e5\u8be2\u51fd\u6570: vkGetPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 physicalDeviceFeatures2; vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &physicalDeviceFeatures2); \u67e5\u8be2\u7ed3\u679c: VkPhysicalDeviceFeatures2 \u7ed3\u6784: // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; sType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 pNext: \u6307\u9488\u94fe. VkPhysicalDeviceFeatures: Vulkan 1.0 \u63d0\u4f9b\u7684\u6838\u5fc3 Features \u6ce8: VkPhysicalDeviceFeatures2 \u7b49\u4ef7 VkPhysicalDeviceFeatures2KHR, vkGetPhysicalDeviceFeatures2 \u7b49\u4ef7 vkGetPhysicalDeviceFeatures2KHR \u901a\u8fc7 pNext , \u53ef\u4ee5\u83b7\u5f97\u6269\u5c55\u6240\u5b9a\u4e49\u7684 Features \u7ed3\u6784\u4f53, \u6709\u7684\u7531 Vulkan \u6838\u5fc3\u65b0\u7248\u672c\u63d0\u4f9b, \u6709\u7684\u7531\u5176\u4ed6 Extension\u63d0\u4f9b. \u4f8b\u5982: Vulkan 1.1 \u63d0\u4f9b\u7684 samplerYcbcrConversion. // Provided by VK_VERSION_1_1: VK_KHR_sampler_ycbcr_conversion typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures { VkStructureType sType; void* pNext; VkBool32 samplerYcbcrConversion; } VkPhysicalDeviceSamplerYcbcrConversionFeatures; VK_EXT_transform_feedback \u63d0\u4f9b\u7684 transformFeedback \u548c geometryStreams. // Provided by VK_EXT_transform_feedback typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 transformFeedback; VkBool32 geometryStreams; } VkPhysicalDeviceTransformFeedbackFeaturesEXT; \u67e5\u8be2\u793a\u4f8b: // \u6269\u5c55\u7684 Feature \u7ed3\u6784\u4f53 VkPhysicalDeviceSamplerYcbcrConversionFeatures mSamplerYcbcrConversionFeatures = {}; mSamplerYcbcrConversionFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; // vk1.1 \u7684 VkPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 deviceFeatures = {}; deviceFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; deviceFeatures.pNext = mVertexAttributeDivisorFeatures // \u67e5\u8be2 vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &deviceFeatures); // \u4f7f\u7528 if (mVertexAttributeDivisorFeatures.vertexAttributeInstanceRateDivisor) { ... }","title":"2.3.2. \u6269\u5c55\u63d0\u4f9b\u7684Features"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#233-features","text":"Features \u9ed8\u8ba4\u7686\u4e3a\u4e0d\u542f\u7528\u72b6\u6001. \u5fc5\u987b\u5728 VkDevice \u521b\u5efa\u65f6\u663e\u5f0f\u542f\u7528\u3002\u5982\u679c\u542f\u7528\u4e86\u7269\u7406\u8bbe\u5907\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5219 VkDevice \u521b\u5efa\u5c06\u5931\u8d25\uff0c\u5e76\u8fd4\u56deVK_ERROR_FEATURE_NOT_PRESENT\u3002 \u542f\u7528\u65b9\u6cd5: \u521b\u5efa VkPhysicalDeviceFeatures \u7ed3\u6784\u7684\u6307\u9488 (\u62161.1\u7684 VkPhysicalDeviceFeatures2\u7ed3\u6784) \u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \u6216 VK_FALSE, eg: physicalDeviceFeatures.independentBlend = VK_TRUE \u901a\u8fc7\u4f20\u9012\u7ed9 vkCreateDevice \u7528\u7684 VkDeviceCreateInfo\u7ed3\u6784\u7684 pEnabledFeatures \u6210\u5458. \u8981\u542f\u52a8\u6240\u6709\u8bbe\u5907\u7684\u529f\u80fd (\u614e\u7528)\uff0c\u5219\u53ea\u9700\u4f20\u5165\u67e5\u8be2\u51fd\u6570 vkGetPhysicalDeviceFeatures \u8fd4\u56de\u7684 VkPhysicalDeviceFeatures \u7ed3\u6784\u5373\u53ef\u3002\u8981\u7981\u7528\u5355\u4e2a\u529f\u80fd\uff0c\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728\u76f8\u540c\u7ed3\u6784\u4e2d\u5c06\u6240\u9700\u6210\u5458\u8bbe\u7f6e\u4e3aVK_FALSE\u3002 \u7528\u8fc7\u7ed9 pNext\u94fe\u6dfb\u52a0 Extensions \u63d0\u4f9b\u7684 Features \u7ed3\u6784\u4f53, \u6765\u542f\u7528\u6269\u5c55\u7684 Features. // \u67e5\u8be2\u6838\u5fc3 Features \u662f\u5426\u652f\u6301 VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); // \u8bbe\u7f6e\u542f\u7528 Features VkPhysicalDeviceFeatures2KHR enabledFeatures = {}; enabledFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; enabledFeatures.features.imageCubeArray = mPhysicalDeviceFeatures.imageCubeArray; enabledFeatures.features.independentBlend = mPhysicalDeviceFeatures.independentBlend; // Create Device VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; // \u6307\u5411 Features \u7ed3\u6784\u4f53\u4ee5\u8bbe\u7f6e Extensions \u63d0\u4f9b\u7684 Features // mSamplerYcbcrConversionFeatures : \u524d\u9762\u67e5\u8be2\u793a\u4f8b\u4e2d\u7684\u7ed3\u6784\u4f53. device_info.pNext = mSamplerYcbcrConversionFeatures; // Enable Physical Device Features device_info.pEnabledFeatures = &enabledFeatures.features; ... VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device);","title":"2.3.3. \u542f\u7528 Features"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#24-limitations","text":"Limits \u63d0\u4f9b\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u53ef\u80fd\u9700\u8981\u660e\u786e\u7684\u4e00\u4e9b\u8bbe\u5907\u7279\u5f81\u503c, \u8fd9\u4e9b\u7279\u5f81\u7684\u6700\u5c0f\u503c\uff0c\u6700\u5927\u503c\u7b49\u4f1a\u968f\u5e95\u5c42\u5b9e\u73b0\u7684\u4e0d\u540c\u800c\u5f02. \u901a\u8fc7\u67e5\u8be2 Properties \u547d\u4ee4, \u83b7\u53d6 VkPhysicalDeviceLimits \u7ed3\u6784\u4f53\u83b7\u53d6\u6838\u5fc31.0\u7684 Limits, \u6216\u5229\u7528 vk1.1 \u4e2d\u52a0\u5165\u7684 VkPhysicalDeviceProperties2 \u7684 pNext \u94fe \u83b7\u53d6\u5404 Extension \u65b0\u589e\u7684 Limits . \u7ed3\u6784\u4f53 VkPhysicalDeviceLimits \u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7701\u7565\u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd: \u4f8b\u5982: maxUniformBufferRange : \u5f53\u5c06\u7ed3\u6784\u4f53 VkDescriptorBufferInfo \u4f5c\u4e3a\u53c2\u6570\u8c03\u7528 vkUpdateDescriptorSets , \u5e76\u4e14 descriptors \u7c7b\u578b\u4e3a VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER \u6216 VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC \u65f6, \u5176\u7ed3\u6784\u4f53\u6210\u5458 range \u53ef\u8bbe\u7684\u6700\u5927\u503c.","title":"2.4. Limitations"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#241-limits","text":"\u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684\u7ed3\u6784\u4f53\u5747\u4ee5 Properties \u800c\u975e Limits \u7ed3\u5c3e, \u5176\u67e5\u8be2\u65b9\u6cd5\u4e0e\u67e5\u8be2 \u6269\u5c55\u63d0\u4f9b\u7684 Feature \u4e00\u6837. \u67e5\u8be2\u51fd\u6570\u548c\u7ed3\u679c\u7ed3\u6784\u4f53\u5982\u4e0b: VkPhysicalDeviceProperties2 deviceProperties; vkGetPhysicalDeviceProperties2KHR(mPhysicalDevice, &deviceProperties); \u67e5\u8be2\u7ed3\u679c\u793a\u4f8b: \u7ed3\u6784\u4f53 VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT \u5305\u542b\u4e86\u6269\u5c55 VK_EXT_vertex_attribute_divisor \u63d0\u4f9b\u7684 limits \u503c maxVertexAttribDivisor : // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;","title":"2.4.1. \u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684Limits"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#25-formats","text":"\u5bf9\u4e8e\u4e0d\u540c\u7684 vk \u5b9e\u73b0, \u5176\u652f\u6301\u7684\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u683c\u5f0f\u53ef\u80fd\u4f1a\u4e0d\u540c\u3002\u867d\u7136 Vulkan \u89c4\u5b9a\u4e86\u4e00\u7ec4\u5fc5\u987b\u652f\u6301\u7684 Format \u7684\u6700\u5c0f\u96c6\uff0c\u4f46\u5728\u4f7f\u7528\u9664\u6b64\u4ee5\u5916\u7684 Format\u529f\u80fd\u4e4b\u524d, \u5fc5\u987b\u663e\u5f0f\u7684\u67e5\u8be2\uff0c\u4ee5\u786e\u4fdd\u5b9e\u73b0\u652f\u6301\u8fd9\u4e9b\u683c\u5f0f\u3002 \u67e5\u8be2\u547d\u4ee4: vkGetPhysicalDeviceFormatProperties , \u67e5\u8be2\u8fd4\u56de\u7684 VkFormat \u7ed3\u6784\u4f53\u7684\u5305\u542b\u4e86\u5f53\u524d\u5b9e\u73b0\u6240\u652f\u6301\u7684\u683c\u5f0f\u529f\u80fd\u3002 VkFormat \u7ed3\u6784\u4f53\u793a\u4f8b: // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d \u5173\u4e8e Format \u76f8\u5173\u7684\u5185\u5bb9\u6bd4\u8f83\u590d\u6742, \u672c\u7ae0\u8282\u4ee5\u53ca\u540e\u7eed\u7ae0\u8282\u90fd\u4e0d\u8fdb\u884c\u6df1\u5165. \u5982\u679c\u9700\u8981\u8003\u8651\u518d\u5355\u72ec\u8fdb\u884c\u7814\u7a76.","title":"2.5. Formats"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#3-angle-vk","text":"\u540e\u7aef : \u5bf9\u8c03\u7528\u5404\u56fe\u5f62 API \u7684\u5b9e\u73b0, \u5982 Vulkan, DirectX, GL \u7b49 \u524d\u6bb5 : GLES \u90e8\u5206\u7684\u5b9e\u73b0, \u63d0\u4f9b\u7ed9\u5e94\u7528\u7a0b\u5e8f\u63a5\u53e3, \u8fdb\u884c\u72b6\u6001\u8ddf\u8e2a, \u8c03\u7528\u540e\u53f0 API. \u524d\u540e\u7aef\u5212\u5206\u793a\u610f\u56fe: @startuml class Application package \"Front-End (libANGLE)\" { Entry_Points --> gl::Context gl::Context --> \"State Tracing\" } Application --> Entry_Points package \"Back-End (libANGLE/renderer)\" { class Vk_backend class D3D_Backend class GL_Backend } \"State Tracing\" --> Vk_backend \"State Tracing\" --> D3D_Backend \"State Tracing\" --> GL_Backend hide member hide circle @enduml \u672c\u7ae0\u4e2d\u4ecb\u7ecd \u540e\u7aef Vulkan \u4e2d\u7684\u76f8\u5173\u5185\u5bb9. \u540e\u7eed\u7ae0\u8282\u4ecb\u7ecd GLES \u524d\u6bb5\u4e2d\u7684\u76f8\u5173\u5185\u5bb9.","title":"3. ANGLE \u4e2d Vk \u6269\u5c55"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#31-angle-vkdevice","text":"ANGLE \u521d\u59cb\u5316 VkInstance \u548c VkDevice \u4f4d\u4e8e src/libANGLE/renderer/vulkan/RendererVk.cpp ANGLE \u4e2d Vulkan \u7684\u521d\u59cb\u5316\u6d41\u7a0b\u4e0e 2.1 Vulkan\u521d\u59cb\u5316\u6d41\u7a0b \u4e00\u81f4, \u7b80\u5355\u603b\u7ed3\u5373: \u9009\u62e9\u542f\u7528 Instance Extensions, \u521b\u5efa VkInstance \u9009\u5b9a\u7269\u7406\u8bbe\u5907, \u67e5\u8be2 Extensions, Features, Limitations, Formats \u9009\u4e2d Device Extensions, \u67e5\u8be2 Features2 , \u9009\u62e9\u542f\u7528\u7684 Device Extensions, Features, Features2, \u521b\u5efa VkDevice \u5176\u4e2d ANGLE \u4e2d\u542f\u7528\u7684 Extensions \u5217\u8868, \u53c2\u89c1 \u9644\u88682: ANGLE \u4e2d\u51fa\u73b0\u7684 Vk Extensions ANGLE \u4e2d\u542f\u7528\u7684\u7269\u7406\u8bbe\u5907 Features , \u548c Extensions \u63d0\u4f9b Features2, \u53c2\u89c1 \u9644\u88683: ANGLE \u4e2d\u542f\u7528\u7684 Vk Features","title":"3.1. ANGLE \u521d\u59cb\u5316 VkDevice"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#32-angle-vk-extensions","text":"\u9996\u5148, ANGLE \u4f7f\u7528\u4e86 \u8fd1 30\u4f59\u4e2a Vulkan Extensions . \u8fd9\u4e9b Vulkan \u7684\u5934\u6587\u4ef6\u90fd\u88ab\u5305\u542b\u5728 Vulkan \u5934\u6587\u4ef6\u4e2d, \u76f8\u5173\u8bf4\u660e\u53ef\u4ee5\u5728 Specification \u6587\u6863\u4e2d\u627e\u5230. \u5177\u4f53\u5f15\u7528\u5217\u8868, \u53c2\u89c1 \u9644\u88682: ANGLE \u4e2d\u51fa\u73b0\u7684 Vk Extensions \u6b64\u5916, ANGLE \u65b0\u589e\u4e86\u4e24\u4e2a\u81ea\u5b9a\u4e49 Vk \u7684 Extensions: VK_EXT_provoking_vertex angle/src/common/vulkan/vk_ext_provoking_vertex.h \u4f5c\u7528: \u5bf9\u5e94 GLES \u7aef\u7684 ANGLE \u81ea\u5b9a\u4e49 Extension: GL_ANGLE_provoking_vertex, \u5176\u65b0\u589e\u4e86API: glProvokingVertexANGLE : glProvokingVertexANGLE (GLenum mode) \u51fd\u6570: \u8c03\u7528 setProvokingVertex \u8bbe\u7f6e mode \u4e3a gl::ProvokingVertexConvention::LastVertexConvention, \u8ddf\u8e2a\u4ee3\u7801, \u8bfb\u53d6 ProvokingVertex \u5e76\u4f7f\u7528\u7684\u4ec5\u6709: ProgramD3D \u4e2d\u5224\u65ad\u662f\u5426 usesGeometryShader : if mode == LastVertexConvention, return true ; openGL \u540e\u7aef\u4e2d\u8fdb\u884c\u4e86\u4e00\u6b21\u5e8f\u5217\u5316 Vulkan : \u5728\u7ba1\u7ebf\u4e2d\u7684 RasterizationState \u7684 pNext\u94fe\u4e2d, \u6dfb\u52a0 provokingVertexState. \u731c\u6d4b: \u672a\u5b8c\u6210\u7684\u529f\u80fd. ANGLE \u591a\u6570\u81ea\u5b9a\u4e49 GLES \u4fa7 Extension \u90fd\u6709\u6807\u51c6\u7684\u8bf4\u660e\u6587\u6863, \u4f46\u4ec5\u67093\u4e2a\u6ca1\u6709, \u8fd9\u662f\u5176\u4e2d\u4e00\u4e2a. VK_GOOGLE_sampler_filtering_precision angle/src/common/vulkan/vk_google_sampler_filtering_precision.h \u4f5c\u7528: \u65b0\u589e\u4e86\u4e00\u4e2a CHROMIUM \u540e\u7f00\u7684 Texture: TEXTURE_FILTERING_HINT_CHROMIUM; \u5bf9\u5e94 GLES \u7aef \u81ea\u5b9a\u4e49 Extension: GL_CHROMIUM_texture_filtering_hint This extension defines a way to request high precision texture filtering using a new value to Hint. When this extension is enabled, TEXTURE_FILTERING_HINT_CHROMIUM can be used by the implementation as a means to distinguish between a performance focused implementation, using FASTEST, or a precision focused implementation, using NICEST. Like other hints, either option is spec compliant and the behavior of DONT_CARE is implementation specific.","title":"3.2. ANGLE \u4e2d\u7684 Vk Extensions"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#33-angle-featuresvk","text":"(\u5728ANGLE \u540e\u7aef\u4e2d, \u7c7b\u7684\u540e\u7f00\u4e3a\u5bf9\u5e94\u56fe\u5f62 API, \u4f8b\u5982\u5b58\u5728 FeaturesVk, FeaturesD3D, FeaturesGL \u7b49. ) \u5bf9\u4e8e vk \u6838\u5fc31.0 \u63d0\u4f9b\u7684 Features, Limitations, ANGLE\u4e2d\u5206\u522b\u4f7f\u7528 Vulkan \u63d0\u4f9b\u7684\u7ed3\u6784\u4f53\u4fdd\u5b58, \u4ee5\u4f9b\u67e5\u8be2 VkPhysicalDeviceFeatures mPhysicalDeviceFeatures VkPhysicalDeviceLimits limitsVk (Formats \u6682\u4e0d\u505a\u8ba8\u8bba) \u6b64\u5916, ANGLE \u4e2d\u8fd8\u4e3a\u6bcf\u4e2a\u540e\u7aef\u90fd\u81ea\u5b9a\u4e49\u4e86\u4e00\u4e2aFeature\u5408\u96c6, Vulkan\u5bf9\u5e94\u7684\u4e3a: FeaturesVk (\u6e90\u7801: angle\\include\\platform\\FeaturesVk.h ) FeaturesVk.h struct FeaturesVk : FeatureSetBase { FeaturesVk(); ~FeaturesVk(); // Line segment rasterization must follow OpenGL rules. This means using an algorithm similar // to Bresenham's. Vulkan uses a different algorithm. This feature enables the use of pixel // shader patching to implement OpenGL basic line rasterization rules. This feature will // normally always be enabled. Exposing it as an option enables performance testing. Feature basicGLLineRasterization = { \"basicGLLineRasterization\", FeatureCategory::VulkanFeatures, \"Enable the use of pixel shader patching to implement OpenGL basic line \" \"rasterization rules\", &members}; // If the VK_EXT_line_rasterization extension is available we'll use it to get // Bresenham line rasterization. Feature bresenhamLineRasterization = { \"bresenhamLineRasterization\", FeatureCategory::VulkanFeatures, \"Enable Bresenham line rasterization via VK_EXT_line_rasterization extension\", &members}; // If the VK_EXT_provoking_vertex extension is available, we'll use it to set // the provoking vertex mode Feature provokingVertex = {\"provokingVertex\", FeatureCategory::VulkanFeatures, \"Enable provoking vertex mode via VK_EXT_provoking_vertex extension\", &members}; ... // \u603b\u8ba1 62 \u4e2a Feature } \u5176\u4e2d\u5404\u4e2a feature \u90fd\u6709\u6ce8\u91ca\u63cf\u8ff0, \u5176\u7c7b\u578b \u4e3a Feature \u7ed3\u6784: struct Feature { ... const char *const name; const FeatureCategory category; const char *const description; const char *const bug; const char *condition; // Whether the workaround is enabled or not. Determined by heuristics like vendor ID and // version, but may be overriden to any value. bool enabled = false; }; Feature \u6700\u4e3b\u8981\u4f7f\u7528\u7684\u5373 enabled \u5c5e\u6027, \u7528\u6765\u5224\u65ad\u8be5 Feature \u662f\u5426\u652f\u6301\u548c\u542f\u7528. \u548c Vulkan \u7684 Feature \u5408\u96c6\u4e00\u6837, ANGLE_FeaturesVk \u5185\u4e5f\u662f\u7531\u4e00\u7ec4 bool \u503c\u6765\u8868\u793a\u5f53\u524d\u662f\u5426\u652f\u6301\u67d0\u4e00\u529f\u80fd. \u5e76\u4e14 FeaturesVk \u540c\u6837\u5728\u521b\u5efa VkDevice \u7684\u8fc7\u7a0b\u4e2d\u5b8c\u6210\u521d\u59cb\u5316, \u5176\u503c\u6765\u6e90\u4f9d\u636e: Physical Device \u662f\u5426\u652f\u6301\u67d0 Extension, \u4ee5\u53ca Extension \u7684 Features2 \u548c Properties2 Features, Limitations, Format \u7684\u652f\u6301\u60c5\u51b5 OS : Windows, Linux, Android GPU : AMD, Intel, Nvidia, Qualcomm, ARM \u8bbe\u5907\u578b\u53f7: Nexus5X, Pixel2 FeaturesVk \u7684\u5c5e\u6027\u503c\u6765\u81ea\u4ee5\u4e0a\u51e0\u4e2a\u6761\u4ef6\u7684\u7ec4\u5408, \u4f8b\u5982 supportsShaderStencilExport : \u8bbe\u5907\u652f\u6301 VK_EXT_SHADER_STENCIL_EXPORT forceCPUPathForCubeMapCopy : \u5f53\u524d\u7cfb\u7edf\u4e3a Windows \u4e14\u8bbe\u5907\u4e3a Intel supportsImageFormatList : \u5f53\u524d\u8bbe\u5907\u652f\u6301 VK_KHR_IMAGE_FORMAT_LIST \u4e14 \u8bbe\u5907\u4e3a AMD \u8be6\u7ec6\u7684\u5bf9\u5e94\u5173\u7cfb, \u53c2\u89c1 \u9644\u88684: ANGLE \u81ea\u5b9a\u4e49 FeaturesVK FeaturesVK \u7684\u4f5c\u7528: FeaturesVK \u5728 RendererVk \u4e2d\u521d\u59cb\u5316\u540e, \u5305\u542b\u5728 ContextVk \u4e2d\u4f5c\u4e3a\u73af\u5883\u4e0a\u4e0b\u6587\u88ab Vulkan \u540e\u7aef \u7684\u5404\u4e2a\u7c7b\u4f7f\u7528, \u5982 FrameBufferVk, ProgramVk \u7b49. \u529f\u80fd\u4e3b\u8981\u5305\u62ec: \u521d\u59cb\u5316\u65f6, \u5224\u65ad\u662f\u5426\u652f\u6301\u67d0 Feature, \u8fdb\u800c\u6dfb\u52a0\u76f8\u5e94\u914d\u7f6e \u5b9e\u73b0\u6d41\u7a0b\u4e2d, \u6839\u636e Feature \u652f\u6301\u7684\u4e0d\u540c, \u8fdb\u5165\u4e0d\u540c\u7684\u5206\u652f \u4f8b: \u200b FeatureVk \u4e2d supportsDepthStencilResolve \u4e3a enabled \u9700\u8981 : \u7269\u7406\u8bbe\u5907\u652f\u6301 VK_KHR_CREATE_RENDERPASS_2, VK_KHR_DEPTH_STENCIL_RESOLVE \u4e14\u540e\u8005\u7684 Properties.independentResolveNone \u4e3a VK_TRUE. \u200b \u800c\u5f53\u5176\u4e3a enabled\u65f6, ANGLE: \u5728\u521b\u5efa Device \u65f6\u542f\u7528 Extension: VK_KHR_DEPTH_STENCIL_RESOLVE \u5728\u6267\u884c RenderBufferVk \u4e2d, \u5141\u8bb8\u652f\u6301 depth/stencil images , \u53ef\u8bbe\u7f6e VkImageUsageFlags \u542b VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT","title":"3.3. ANGLE FeaturesVk"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#4-angle-gles-extensions","text":"(angle/libANGLE/Caps.h) ANGLE \u5728GLES \u524d\u7aef, \u5b9a\u4e49\u4e86\u7ed3\u6784\u4f53 Extensions, Caps, \u548c TextureCapsMap, Extension : \u5176\u4e2d Extension \u4e2d\u5b9a\u4e49\u4e86\u7ea6 200 \u4e2abool \u503c, \u5206\u522b\u5bf9\u5e94\u4e86\u7ea6 200 \u4e2a GLES Extensions, \u5176\u4e2d 17\u4e2a\u4e3a texture ext. \u5927\u90e8\u5206 Extension \u53ef\u4ee5\u5728 GLES Specification \u7f51\u7ad9\u627e\u5230\u8bf4\u660e. \u6b64\u5916 ANGLE \u8fd8\u65b0\u589e\u4e86 \u6570\u5341\u4e2a EXT, \u5e76\u63d0\u4f9b\u4e86\u8bf4\u660e\u6587\u6863: angle/extensions \u65b0\u589eEXT\u5217\u8868\u89c1\u4e0b\u4e00\u8282 \" AGNLE \u6dfb\u52a0\u7684 GLES \u6269\u5c55 \" \u5176 bool \u503c\u4ee3\u8868\u4e86\u540e\u7aef\u662f\u5426\u652f\u6301\u6b64\u6269\u5c55. \u793a\u4f8b: // GL_OES_element_index_uint bool elementIndexUintOES = false; // GL_OES_packed_depth_stencil bool packedDepthStencilOES = false; // GL_NV_read_depth bool readDepthNV = false; Caps : \u7c7b\u4f3c vk Limitations, \u5b9a\u4e49\u8bbe\u5907\u652f\u6301\u7684\u8bbe\u5907\u7279\u5f81\u503c\u7684\u6700\u5927\u503c, \u6700\u5c0f\u503c\u7b49 \u793a\u4f8b: GLfloat minInterpolationOffset = 0; GLfloat maxInterpolationOffset = 0; GLint subPixelInterpolationOffsetBits = 0; // ES 3.1 (April 29, 2015) 20.39: implementation dependent values GLint64 maxElementIndex = 0; GLint max3DTextureSize = 0; GLint max2DTextureSize = 0; TextureCaps : \u7c7b\u4f3c vk Format, \u5b9a\u4e49\u8bbe\u5907\u652f\u6301\u7684\u683c\u5f0f\u529f\u80fd \u5b9a\u4e49\u7c7b TextureCapsMap, \u63d0\u4f9b set \u548c get \u51fd\u6570, \u6839\u636e formatID \u67e5\u8be2\u662f\u5426\u652f\u6301\u67d0\u683c\u5f0f.","title":"4. ANGLE \u4e2d\u7684 GLES Extensions"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#41-angle-gles","text":"GLES Extesions \u5728\u6e90\u7801\u4e2d\u96c6\u4e2d\u6ce8\u518c\u7684\u5730\u65b9: register_xml.py \u63cf\u8ff0\u5404\u7248\u672c\u5305\u542b\u7684 Extensions gl_angle_ext.xml \u6ce8\u518c Extensions \u6269\u5c55\u7684\u65b9\u6cd5, \u901a\u5e38\u4e3a glXXXXANGLE gl_angle_ext.xml gl2ext_angle.h extensions/\u6587\u6863 -- GL_ANGLE_client_arrays ANGLE_client_arrays GL_ANGLE_request_extension GL_ANGLE_request_extension ANGLE_request_extension -- GL_ANGLE_robust_resource_initialization ANGLE_robust_resource_initialization GL_ANGLE_provoking_vertex GL_ANGLE_provoking_vertex -- GL_ANGLE_memory_size ANGLE_memory_size GL_ANGLE_copy_texture_3d GL_ANGLE_copy_texture_3d ANGLE_copy_texture_3d -- GL_ANGLE_lossy_etc_decode ANGLE_lossy_etc_decode GL_ANGLE_robust_client_memory GL_ANGLE_robust_client_memory ANGLE_robust_client_memory -- GL_ANGLE_program_cache_control ANGLE_program_cache_control -- GL_ANGLE_texture_rectangle GL_ANGLE_texture_multisample GL_ANGLE_texture_multisample ANGLE_texture_multisample GL_ANGLE_get_tex_level_parameter GL_ANGLE_get_tex_level_parameter ANGLE_get_tex_level_parameter -- GL_ANGLE_explicit_context ANGLE_explicit_context GL_ANGLE_multi_draw GL_ANGLE_multi_draw ANGLE_multi_draw GL_ANGLE_base_vertex_base_instance GL_ANGLE_base_vertex_base_instance ANGLE_base_vertex_base_instance GL_ANGLE_texture_external_update GL_ANGLE_texture_external_update GL_ANGLE_get_image GL_ANGLE_get_image ANGLE_get_image GL_ANGLE_memory_object_flags GL_ANGLE_memory_object_flags ANGLE_external_objects_flags GL_ANGLE_memory_object_fuchsia GL_ANGLE_memory_object_fuchsia ANGLE_external_objects_fuchsia GL_ANGLE_semaphore_fuchsia GL_ANGLE_semaphore_fuchsia ANGLE_external_objects_fuchsia ANGLE_compressed_texture_etc ANGLE_depth_texture ANGLE_explicit_context_gles1 ANGLE_framebuffer_blit ANGLE_framebuffer_multisample ANGLE_instanced_arrays ANGLE_multiview_multisample ANGLE_pack_reverse_row_order ANGLE_program_binary ANGLE_texture_compression_dxt ANGLE_texture_usage ANGLE_timer_query ANGLE_translated_shader_source ANGLE_webgl_compatibility","title":"4.1. ANGLE \u6dfb\u52a0\u7684 GLES \u6269\u5c55"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#5-es-vk-ext","text":"\u5e94\u7528\u7a0b\u5e8f\u8c03\u7528 API \u65f6\u7684\u9a8c\u8bc1\u6d41\u7a0b: @startuml participant APP participant entry_points participant Validation participant Context participant Renderer Renderer-> Renderer : initDevice() APP -> entry_points : glAnyCall() entry_points -> Validation : ValidateAnyCall() Validation -> Context : initCaps() [\u521d\u59cb\u5316] Context -> Renderer : getNativeExtensions() Renderer -> Renderer : ensureCapsInitialized() \u4ec5\u4e00\u6b21 Context -> Renderer : getNativeCaps() Context -> Renderer : getNativeTextureCaps() Validation -> Context : getExtensions() Validation -> Context : getCaps() Validation -> Context : getTextureCaps() @enduml \u5c06\u529f\u80fd\u96c6\u5bf9\u5e94 \u5728 Renderer :: ensureCapsInitialized() \u4e2d, \u5c06 GLES \u4fa7\u7684\u529f\u80fd\u96c6 \u4e0e vk \u4fa7\u7684 Extension, Features, Limits, Format \u5bf9\u5e94, \u5b8c\u6210\u5bf9 GLES \u4fa7\u7684\u529f\u80fd\u96c6\u7684\u8d4b\u503c\u521d\u59cb\u5316 @startmindmap + Mapping ++ ANGLE FeatureVk ++ Physical Device Features ++ Physical Device Limits ++ Formats -- Extensions -- Caps -- TextureCaps @endmindmap \u5177\u4f53 Extension \u5bf9\u5e94\u65b9\u5f0f, \u53c2\u89c1\u7ae0\u8282 GLES Extensions \u652f\u6301 GLES Extensions \u4f5c\u7528 GLES Extensions \u529f\u80fd\u4e3b\u8981\u5305\u62ec: \u5e94\u7528\u7a0b\u5e8f\u8c03\u7528 API \u65f6, \u5728\u6821\u9a8c\u5c42\u6839\u636e Extensions \u7684 bool \u503c, \u5224\u65ad\u662f\u5426\u652f\u6301\u67d0\u6269\u5c55. \u5b9e\u73b0\u6d41\u7a0b\u4e2d, \u6839\u636e Extensions \u652f\u6301\u7684\u4e0d\u540c, \u8fdb\u5165\u4e0d\u540c\u7684\u5206\u652f \u793a\u4f8b1: \u6821\u9a8c\u67d0 API \u8c03\u7528\u65f6, \u4f20\u5165\u7684 type \u7c7b\u578b\u662f\u5426\u652f\u6301: bool ValidReadPixelsTypeEnum(const Context *context, GLenum type) { switch (type) { .... case GL_UNSIGNED_SHORT: case GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT: case GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT: return context->getClientVersion() >= ES_3_0; case GL_FLOAT: return context->getClientVersion() >= ES_3_0 || context->getExtensions().textureFloatOES || context->getExtensions().colorBufferHalfFloat; case GL_HALF_FLOAT: return context->getClientVersion() >= ES_3_0 || context->getExtensions().textureHalfFloat; case GL_HALF_FLOAT_OES: return context->getExtensions().colorBufferHalfFloat; default: return false; } } \u793a\u4f8b2: \u6839\u636e Extensions \u8fdb\u5165\u4e0d\u540c\u5206\u652f void Program::postResolveLink(const gl::Context *context) { mState.updateActiveSamplers(); mState.mExecutable->updateActiveImages(getExecutable()); setUniformValuesFromBindingQualifiers(); if (context->getExtensions().multiDraw) { mState.mDrawIDLocation = getUniformLocation(\"gl_DrawID\").value; } if (context->getExtensions().baseVertexBaseInstance) { mState.mBaseVertexLocation = getUniformLocation(\"gl_BaseVertex\").value; mState.mBaseInstanceLocation = getUniformLocation(\"gl_BaseInstance\").value; } }","title":"5. ES \u4e0e Vk \u7684 Ext \u5bf9\u5e94\u6d41\u7a0b"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#6-gles","text":"\u6765\u6e90: RendererVk::getMaxSupportedESVersion \u5728\u83b7\u53d6\u652f\u6301\u7684 ES \u7248\u672c\u65f6, ANGLE \u6839\u636e\u4ee5\u4e0b\u7279\u6027\u6765\u8fc7\u6ee4, \u5f53\u5b58\u5728 \u7279\u6027/\u53c2\u6570 \u4e0d\u6ee1\u8db3\u65f6, \u964d\u4e00\u7ea7. \u6700\u4f4e 2.0.","title":"6. GLES \u7248\u672c\u9009\u62e9"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#61-gles-32","text":"","title":"6.1. GLES 3.2 (\u672a\u542f\u7528)"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#611-features","text":"ES 3.2 \u9700\u8981\u5b9e\u73b0 EXT_gpu_shader5 \u76844\u4e2a\u7279\u6027 3.2 \u76ee\u524d\u4ec5\u5728\u6d4b\u8bd5\u6a21\u5f0f\u4e0b\u542f\u7528 Vk Features Spec shaderImageGatherExtended VkPhysicalDeviceFeatures \u4e00\u4e2a\u975e\u5e38\u91cf\u7684 offset \u7684 textureGatherOffset\u548c \u4e00\u7cfb\u5217\u76f8\u5173\u529f\u80fd\u3002 shaderSampledImageArrayDynamicIndexing VkPhysicalDeviceFeatures \u7528\u4e8e \u91c7\u6837(Sample) \u7684 \u52a8\u6001 uniform indices shaderUniformBufferArrayDynamicIndexing VkPhysicalDeviceFeatures \u7528\u4e8e uniform buffers \u7684 \u52a8\u6001 uniform indices shaderStorageBufferArrayDynamicIndexing VkPhysicalDeviceFeatures \u5f53 EXT_gpu_shader5 \u4e0d\u9700\u8981\u5728\u5b58\u50a8\u7f13\u51b2\u533a(storage buffers)\u4f7f\u7528 \u52a8\u6001uniform indices \u65f6, \u9700\u8981\u6b64\u7279\u6027\u5728\u5b58\u50a8\u7f13\u51b2\u533a\u6765 \u6a21\u62df \u539f\u5b50\u8ba1\u6570\u7f13\u5b58(atomic counter buffers)","title":"6.1.1. Features"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#62-gles-31","text":"ES 3.1 \u9700\u652f\u6301\u4ee5\u4e0b\u4e24\u4e2a\u53c2\u6570:","title":"6.2. GLES 3.1"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#621-caps","text":"VkPhysicalDeviceLimits Value Note maxPerStageDescriptorStorageBuffers >= gl::kMinimumComputeStorageBuffers (4) + gl::IMPLEMENTATION_MAX_ATOMIC_COUNTER_BUFFERS (8) \u81f3\u5c11\u4e00\u4e2a atomic counter buffer \u548c \u56db\u4e2a storage buffers maxVertexInputAttributeOffset >= 2047 maximum offset \u81f3\u5c11 2047","title":"6.2.1. Caps"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#63-gles-30","text":"","title":"6.3. GLES 3.0"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#631-features","text":"Vk Features Spec Note inheritedQueries VkPhysicalDeviceFeatures command buffer \u652f\u6301\u67e5\u8be2 independentBlend VkPhysicalDeviceFeatures blending operations are controlled per-attachment supportsTransformFeedbackExtension VK_EXT_transform_feedback emulateTransformFeedback PhysicalDeviceFeatures.vertexPipelineStoresAndAtomics \u6ca1\u6709 VK_EXT_transform_feedback \u65f6\u7684\u66ff\u4ee3","title":"6.3.1. Features"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#632-caps","text":"Spec Value Note vk standardSampleLocations = true Multisample textures (ES3.1) \u548c multisample renderbuffers (ES3.0) gles MAX_VERTEX_UNIFORM_BLOCKS >= 12 gles MAX_FRAGMENT_UNIFORM_BLOCKS >= 12 gles MAX_VERTEX_OUTPUT_COMPONENTS >= 64","title":"6.3.2. Caps"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#7-gles-extensions","text":"\u672c\u7ae0\u7684\u5404\u8868\u4e2d ES Features \u5373 GLES Extension \u540d\u79f0\u7684\u7b80\u5199, \u540c\u65f6\u4e3a ANGLE \u4ee3\u7801\u4e2d\u7684\u5bf9\u5e94\u7684\u53d8\u91cf\u540d. ES Features \u7b80\u5199\u89c4\u5219: \u6539\u5199\u6210 \"GL_OES/EXT_\u4e0b\u5212\u7ebf\u683c\u5f0f\", \u5373\u4e3a\u6269\u5c55\u540d. \u5982: bufferStorageEXT = GL_EXT_buffer_storage), mapBufferOES = GL_OES_mapbuffer \u90e8\u5206\u540e\u7f00 ANGLE, CHROMIUM \u7b49\u6ca1\u6709\u5199\u5728\u540d\u79f0\u540e\u9762, \u89c1 ES EXT name \u8865\u5145","title":"7. GLES Extensions \u652f\u6301"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#71-extensions","text":"ANGLE \u5728\u521d\u59cb\u5316 GLES \u65f6\u9ed8\u8ba4\u5f00\u542f\u7684\u7279\u6027 ES Features ES EXT Name Note bufferStorageEXT GL_EXT_buffer_storage \u4ee5\u4e0b\u7a7a\u5373\u5bf9\u5e94\u9ed8\u8ba4\u89c4\u5219\u7684\u540d\u79f0 mapBufferOES mapBufferRange textureStorage drawBuffers fragDepth EXT framebufferBlit framebufferMultisample GL_ANGLE_framebuffer_blit GL_ANGLE_framebuffer_multisample copyTexture copyCompressedTexture copyTexture3d CHROMIUM CHROMIUM ANGLE debugMarker translatedShaderSource GL_ANGLE_translated_shader_source discardFramebuffer EXT memoryObject memoryObjectFlagsANGLE EXT ANGLE semaphore EXT eglImageOES eglImageExternalOES eglImageExternalWrapModesEXT eglImageExternalEssl3OES eglImageArray textureFormat2101010REV baseVertexBaseInstance GL_ANGLE_base_vertex_base_instance drawElementsBaseVertexOES drawElementsBaseVertexEXT blendMinMax EXT vertexHalfFloatOES instancedArraysANGLE instancedArraysEXT textureNPOTOES texture3DOES Vulkan natively supports non power-of-two textures standardDerivativesOES Vulkan natively supports standard derivatives shaderTextureLOD Vulkan natively supports texture LOD noperspectiveInterpolationNV Vulkan natively supports noperspective interpolation elementIndexUintOES Vulkan natively supports 32-bit indices, entry in kIndexTypeMap fboRenderMipmapOES getImageANGLE ANGLE support getting image data for Textures and Renderbuffers. shaderNonConstGlobalInitializersEXT Implemented in the translator separateShaderObjects EXT Implemented in the front end eglSyncOES vertexAttribType1010102OES getProgramBinaryOES Program Binary extension. pixelBufferObjectNV fenceNV copyImageEXT shadowSamplersEXT","title":"7.1. \u9ed8\u8ba4\u652f\u6301\u7684 Extensions"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#72-extensions","text":"ANGLE \u5728\u521d\u59cb\u5316 GLES \u65f6, \u9700\u5148\u521d\u59cb\u5316 Vk Features, \u7136\u540e\u6839\u636e Vk Features \u7684\u542f\u7528\u60c5\u51b5, \u6765\u6709\u6761\u4ef6\u7684\u542f\u7528 ES \u7279\u6027: Note: \u8868\u683c\u7565\u53bb\u4e86\u4e0e Format \u76f8\u5173\u7684\u7279\u6027 ES Features Vk Features Vk Spec / EXT Note multisampledRenderToTexture multisampledRenderToTexture2 enableMultisampledRenderToTexture Enable on Android by default textureStorageMultisample2DArrayOES standardSampleLocations VkPhysicalDeviceLimits compressedTextureETC (ANGLE_compressed_texture_etc) textureCompressionETC2 VkPhysicalDeviceFeatures GL_ANGLE_compressed_texture_etc To ensure that ETC2/EAC formats are enabled only on hardware that supports them natively, this flag is not set by the function above and must be set explicitly. It exposes ANGLE_compressed_texture_etc extension string textureCompressionSliced3dASTCKHR GL_KHR_texture_compression_astc_ldr Vulkan supports sliced 3D ASTC texture uploads when ASTC is supported. compressedETC1RGB8SubTexture GL_OES_compressed_ETC1_RGB8_texture drawBuffersIndexedOES drawBuffersIndexedOES; independentBlend VkPhysicalDeviceFeatures memoryObjectFd supportsExternalMemoryFd VK_KHR_external_memory_fd semaphoreFd supportsExternalSemaphoreFd VK_KHR_external_semaphore_fd robustBufferAccessBehavior robustBufferAccess VkPhysicalDeviceFeatures occlusionQueryBoolean inheritedQueries VkPhysicalDeviceFeatures ANGLE use secondary command buffers almost everywhere and they require a feature to be able to execute in the presence of queries. As a result, we won't support queries unless that feature is available. disjointTimerQuery queryCounterBitsTimeElapsed queryCounterBitsTimestamp timestampValidBits VkQueueFamilyProperties textureFilterAnisotropic maxTextureAnisotropy samplerAnisotropy maxSamplerAnisotropy VkPhysicalDeviceFeatures VkPhysicalDeviceLimits depthTextureCubeMapOES (ES)GL_OES_depth_texture (ES)GL_OES_packed_depth_stencil Vulkan has no restrictions of the format of cubemaps, so if the proper formats are supported, creating a cube of any of these formats should be implicitly supported. gpuShader5EXT shaderImageGatherExtended, shaderSampledImageArrayDynamicIndexing, shaderUniformBufferArrayDynamicIndexing, shaderStorageBufferArrayDynamicIndexing VkPhysicalDeviceFeatures textureFilteringCHROMIUM supportsFilteringPrecision VK_GOOGLE_sampler_filtering_precision textureCubeMapArrayOES textureCubeMapArrayEXT imageCubeArray mPhysicalDeviceFeatures Only expose texture cubemap array if the physical device supports it. sampleShadingOES sampleVariablesOES multisampleInterpolationOES sampleRateShading VkPhysicalDeviceFeatures","title":"7.2. \u6709\u6761\u4ef6\u7684\u652f\u6301\u7684 Extensions"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#73-gles-extensions","text":"ANGLE \u5728\u521d\u59cb\u5316 GLES \u65f6\u9ed8\u8ba4\u5173\u95ed\u7684\u7279\u6027 ES Features EXT Name Note textureBorderClampOES GL_OES_texture_border_clamp \u5c1a\u672a\u5b9e\u73b0 textureCompressionASTCOES GL_OES_texture_compression_astc Vulkan doesn't support ASTC 3D block textures. textureCompressionASTCHDRKHR GL_KHR_texture_compression_astc_hdr Vulkan doesn't guarantee HDR blocks decoding without VK_EXT_texture_compression_astc_hdr.","title":"7.3. \u4e0d\u652f\u6301\u7684 GLES Extensions"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#8","text":"","title":"8. \u53c2\u8003\u5217\u8868"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#9-1-angle-khr","text":"(\u6765\u81ea \u534e\u4e3a GPU Workshop \"Khronos \u76f8\u5173\u8bae\u9898\", \u738b\u8f1d\u9f8d, 2020) ANGLE \u5411 vk 1.2/1.3 \u63d0\u51fa\u7684\u9700\u6c42","title":"9. \u9644\u88681: ANGLE \u5411 KHR \u7279\u51fa\u7684\u7279\u6027\u9700\u6c42:"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#10-2-angle-vk-extensions","text":"Instance Level WSIExtension: VK_KHR_ANDROID_SURFACE / VK_KHR_WIN32_SURFACE / ... VK_KHR_SURFACE VK_EXT_DEBUG_UTILS VK_EXT_DEBUG_REPORT VK_EXT_SWAPCHAIN_COLOR_SPACE VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2 Device Level VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER VK_EXT_DEPTH_CLIP_ENABLE VK_EXT_EXTERNAL_MEMORY_HOST VK_EXT_INDEX_TYPE_UINT8 VK_EXT_LINE_RASTERIZATION VK_EXT_PROVOKING_VERTEX VK_EXT_QUEUE_FAMILY_FOREIGN VK_EXT_SHADER_STENCIL_EXPORT VK_EXT_TRANSFORM_FEEDBACK VK_EXT_VERTEX_ATTRIBUTE_DIVISOR VK_FUCHSIA_EXTERNAL_MEMORY VK_FUCHSIA_EXTERNAL_SEMAPHORE VK_GOOGLE_SAMPLER_FILTERING_PRECISION VK_GGP_FRAME_TOKEN VK_KHR_BIND_MEMORY_2 VK_KHR_CREATE_RENDERPASS_2 VK_KHR_DEPTH_STENCIL_RESOLVE VK_KHR_EXTERNAL_FENCE_CAPABILITIES VK_KHR_EXTERNAL_FENCE_FD VK_KHR_EXTERNAL_MEMORY VK_KHR_EXTERNAL_MEMORY_FD VK_KHR_EXTERNAL_SEMAPHORE VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES VK_KHR_EXTERNAL_SEMAPHORE_FD VK_KHR_GET_MEMORY_REQUIREMENTS_2 VK_KHR_IMAGE_FORMAT_LIST VK_KHR_INCREMENTAL_PRESENT VK_KHR_MAINTENANCE1 VK_KHR_SAMPLER_YCBCR_CONVERSION VK_KHR_SHADER_FLOAT16_INT8 VK_KHR_SWAPCHAIN VK_QCOM_render_pass_store_ops","title":"10. \u9644\u88682: ANGLE \u4e2d\u51fa\u73b0\u7684 Vk Extensions"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#11-3-angle-vk-features","text":"","title":"11. \u9644\u88683: ANGLE \u4e2d\u542f\u7528\u7684 Vk Features"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#vulkan_1_0-features","text":"// Select additional features to be enabled. mPhysicalDeviceFeatures{ // Used to support cubemap array: only enable when not SwiftShader or not Qualcomm imageCubeArray; // Used to support framebuffers with multiple attachments: independentBlend; // Used to support robust buffer access: robustBufferAccess; // Used to support Anisotropic filtering: samplerAnisotropy; // Used to support wide lines: wideLines; // Used to emulate transform feedback: vertexPipelineStoresAndAtomics; // Used to implement storage buffers and images in the fragment shader: fragmentStoresAndAtomics; // Used to support geometry shaders: geometryShader = mPhysicalDeviceFeatures.geometryShader; // Used to support EXT_gpu_shader5: mPhysicalDeviceFeatures.shaderImageGatherExtended; // Used to support EXT_gpu_shader5: shaderUniformBufferArrayDynamicIndexing // Used to support EXT_gpu_shader5 and sampler array of array emulation: shaderSampledImageArrayDynamicIndexing; // Used to support atomic counter emulation: shaderStorageBufferArrayDynamicIndexing; // Used to support APPLE_clip_distance enabledFeatures.features.shaderClipDistance // Used to support OES_sample_shading sampleRateShading; // Used to support depth clears through draw calls. depthClamp; // if (!vk::CommandBuffer::ExecutesInline()) inheritedQueries; // Used to support OES_sample_variables sampleRateShading; }","title":"Vulkan_1_0 Features:"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#extension-features","text":"VkPhysicalDeviceLineRasterizationFeaturesEXT VkPhysicalDeviceProvokingVertexFeaturesEXT VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT VkPhysicalDeviceTransformFeedbackFeaturesEXT VkPhysicalDeviceIndexTypeUint8FeaturesEXT VkPhysicalDeviceShaderFloat16Int8FeaturesKHR VkPhysicalDeviceSamplerYcbcrConversionFeatures","title":"Extension Features:"},{"location":"ANGLE/139%20ANGLE_ES_Extensions_Support/#12-4-angle-featuresvk","text":"\u4ee5\u4e0b\u7686\u4e3a ANGLE \u5728\u521d\u59cb\u5316 Vk \u4e2d\u6d89\u53ca\u7684\u7279\u6027\u548c\u5217\u8868, \u4ee5\u4f9b\u53c2\u8003 ANGLE Features Extension Platform Note supportsSwapchainColorspace VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME bresenhamLineRasterization VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME basicGLLineRasterization -- !IsAndroid() && !isPowerVR Use OpenGL line rasterization rules if extension mLineRasterizationFeatures not available by default. provokingVertex VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME extraCopyBufferRegion -- IsWindows() && isIntel forceCPUPathForCubeMapCopy -- IsWindows() && isIntel clampPointSize -- isNvidia nvidia Version < 421 depthClamping VK_EXT_depth_clip_enable isNvidia flushAfterVertexConversion -- IsAndroid() && IsNexus5X Work around ineffective compute-graphics barriers on Nexus 5X. Testing other vendors and driver versions are affected supportsRenderpass2 VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME supportsIncrementalPresent VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME supportsAndroidHardwareBuffer VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE _BUFFER_EXTENSION_NAME VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME ANDROID supportsExternalMemoryFd VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME supportsExternalMemoryFuchsia VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME supportsFilteringPrecision VK_GOOGLE_SAMPLER_FILTERING_PRECISION_EXTENSION_NAME supportsExternalFenceCapabilities VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME supportsExternalSemaphoreCapabilities VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME supportsExternalSemaphoreFd VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME supportsExternalSemaphoreFuchsia VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME supportsExternalFenceFd VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME supportsAndroidNativeFenceSync VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME ANDROID supportsShaderStencilExport VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME supportsRenderPassStoreOpNoneQCOM VK_QCOM_render_pass_store_ops_EXTENSION_NAME supportsTransformFeedbackExtension VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME supportsIndexTypeUint8 mIndexTypeUint8Features supportsDepthStencilResolve VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME mDepthStencilResolveProperties emulateTransformFeedback mTransformFeedbackFeatures PhysicalDeviceFeatures. vertexPipelineStoresAndAtomics = true disableFifoPresentMode -- Linux() && isIntel bindEmptyForUnusedDescriptorSets -- IsAndroid() && isQualcomm forceOldRewriteStructSamplers mPhysicalDeviceFeatures. shaderSampledImageArrayDynamicIndexing = false isQualcomm perFrameWindowSizeQuery -- isIntel || (IsWindows() && isAMD) || IsFuchsia() disallowSeamfulCubeMapEmulation -- IsWindows() && isAMD padBuffersToMaxVertexAttribStride -- isAMD forceD16TexFilter -- IsAndroid() && isQualcomm disableFlippingBlitWithCommand -- IsAndroid() && isQualcomm shadowBuffers Enable persistentlyMappedBuffers Enable allocateNonZeroMemory Disable Allocation sanitization disabled by default because of a heaveyweight implementation that can cause OOM and timeouts. supportsExternalMemoryHost VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME enablePreRotateSurfaces Enable on Android IsAndroid enableFramebufferVkCache Disable on apple !IsApple() Currently disable FramebufferVk cache on Apple enablePrecisionQualifiers Disabled by default preferAggregateBarrierCalls Enable on target gpu isNvidia || isAMD || isIntel asyncCommandQueue Disabled supportsYUVSamplerConversion VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME supportsShaderFloat16 VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME forceMaxUniformBufferSize16KB Enable on Adreno540 isQualcomm && isAdreno540 supportsImageFormatList VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME isAMD enableMultisampledRenderToTexture Enable except on Swiftshader, Inter, AMD !(IsApple() && isSwiftShader) && !(IsWindows() && (isIntel || isAMD)) supportsImageCubeArray mPhysicalDeviceFeatures.imageCubeArray == VK_TRUE !isSwiftShader && !isQualcomm preferredLargeHeapBlockSize4MB Enable except Qualcomm !isQualcomm deferFlushUntilEndRenderPass Enable except Qualcomm !isQualcomm Defer glFLush call causes manhattan 3.0 perf regression. Let Qualcomm driver opt out from // this optimization. waitIdleBeforeSwapchainRecreation Enable on Android Arm IsAndroid() && isARM Android mistakenly destroys the old swapchain when creating a new one. preferDrawClearOverVkCmdClearAttachments Enable only on Pixel2 IsPixel2","title":"12. \u9644\u88684: ANGLE \u81ea\u5b9a\u4e49 FeaturesVk"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/","text":"1. Angle \u80cc\u666f\u4ecb\u7ecd ANGLE ( Almost Native Graphics Layer Engine ) AGNLE \u662f Google \u5f00\u53d1\u7684, \u5f00\u6e90\u7684\u56fe\u5f62\u5f15\u64ce ( BSD license). Github\u5730\u5740: https://github.com/google/angle. \u4f5c\u7528: \u5c06 OpenGL ES API \u8c03\u7528\u7ffb\u8bd1\u5230\u5404\u5e73\u53f0\u786c\u4ef6\u652f\u6491\u7684 API (DirectX / Vulkan / OpenGL), \u6765\u5b9e\u73b0\u65e0\u7f1d\u7684\u8de8\u5e73\u53f0\u7684 OpenGL ES \u5e94\u7528, \u76ee\u7684: \u4e3a Chromium \u7b49\u5404\u6d4f\u89c8\u5668\u63d0\u4f9b \u8de8\u786c\u4ef6/\u9a71\u52a8/\u5e73\u53f0\u7684 WebGL \u652f\u6301. \u6700\u521d\u76ee\u6807: \u5728 WebGL\u7684\u5b50\u96c6 OpenGL ES 2.0 \u548c DirectX 9.0c \u4e4b\u95f4\u5efa\u7acb\u7b80\u5355\u7684\u5c42\uff0c\u7528\u6765\u652f\u6301 Chrome \u5728\u4efb\u610f Windows \u7cfb\u7edf\u4e2d\u90fd\u53ef\u4ee5\u5904\u7406 3D \u56fe\u5f62. \u9879\u76ee\u5f52\u4e8eChrome\u9879\u76ee\u4e0b: chromium / angle Android 10 \u4e2d\u5b9e\u9a8c\u6027\u52a0\u5165 ANGLE, \u76ee\u6807\u5728\u672a\u6765\u5b9e\u73b0 OpenGL ES on Vulkan \u4f9b\u5e94\u5546 \u4e13\u6ce8\u4e8e\u5b9e\u73b0\u5177\u6709 GL \u4eff\u771f\u529f\u80fd\u7684\u9ad8\u8d28\u91cf Vulkan \u9a71\u52a8\u3002 (2019\u5e747\u6708, Vulkan Session) @startuml package Browsers <<Rectangle>> { package WebGL <<Rectangle>> { } } package \"OpenGL ES\" <<Rectangle>> { } package ANGLE <<Rectangle>> { } package Direct3D <<Rectangle>> { } package Vulkan <<Rectangle>> { } package OpenGL <<Rectangle>> { } WebGL --> \"OpenGL ES\" \"OpenGL ES\" --> ANGLE ANGLE --> Direct3D ANGLE --> Vulkan ANGLE --> OpenGL @enduml \u652f\u6301\u7684\u8f6c\u6362 \u5f53\u524d ANGLE \u652f\u6301\u7684\u8f6c\u6362 From OpenGL ES 2.0, 3.0 and 3.1 To Vulkan, desktop OpenGL, OpenGL ES, Direct3D 9, and Direct3D 11 . @startmindmap * ANGLE ** Vulkan ** Desktop OpenGL ** Direct3D 9 ** Direct3D 11 left side ** OpenGL ES 2.0 ** 3.0 ** 3.1 @endmindmap \u5176\u4ed6\u529f\u80fd ANGLE \u5b9e\u73b0\u4e86 EGL 1.4 Shader Compiler \u4e2d\u7684\u7ffb\u8bd1\u5668 \u5728\u8de8\u5e73\u53f0\u7684 WebGL \u5b9e\u73b0\u4e2d, ANGLE shader compiler \u7684\u4e00\u90e8\u5206\u88ab\u7528\u4f5c\u7740\u8272\u5668\u9a8c\u8bc1\u5668 (validator) \u548c\u8f6c\u6362\u5668 (translator) \u3002 \u7740\u8272\u5668\u9a8c\u8bc1\u5668 (validator) \u786e\u4fdd\u5728\u6d4f\u89c8\u5668\u548c\u5e73\u53f0\u4e4b\u95f4\u63a5\u53d7\u4e00\u81f4\u7684GLSL ES\u7740\u8272\u5668\u96c6\u3002 \u7740\u8272\u5668\u8f6c\u6362\u5668 (translator) \u53ef\u7528\u4e8e \u5c06\u7740\u8272\u5668\u7ffb\u8bd1\u4e3a\u5176\u4ed6\u7740\u8272\u8bed\u8a00\uff0c \u53ef\u4ee5\u9009\u62e9\u6027\u7684\u5e94\u7528\u7740\u8272\u5668\u4fee\u6539\u6765\u89e3\u51b3\u672c\u673a\u56fe\u5f62\u9a71\u52a8\u7a0b\u5e8f\u4e2d\u7684\u9519\u8bef\u6216\u7279\u6b8a\u5904\u7406\u3002 \u8be5\u7ffb\u8bd1\u7a0b\u5e8f\u76ee\u6807\u5305\u62ec Desktop GLSL \uff0cVulkan GLSL\uff0cDirect3D HLSL , \u751a\u81f3\u662f\u539f\u751f GLES2 \u5e73\u53f0\u7684 ESSL\u3002 \u672a\u6765 \u6b63\u5728\u5b9e\u73b0 ES 3.2, \u5e76\u63d0\u4f9b\u8f6c\u6362\u5230 Metal \u548c\u652f\u6301 MacOS, Chrome OS, \u548c Fuchsia . \u652f\u6301\u7684 OpenGL ES \u7248\u672c\u4e0e\u540e\u53f0 Direct3D 9 Direct3D 11 Desktop GL GL ES Vulkan Metal OpenGL ES 2.0 complete complete complete complete complete complete OpenGL ES 3.0 complete complete complete complete in progress OpenGL ES 3.1 incomplete complete complete complete OpenGL ES 3.2 in progress in progress in progress \u540e\u53f0\u5bf9\u5e94\u7684\u5e73\u53f0 Direct3D 9 Direct3D 11 Desktop GL GL ES Vulkan Metal Windows complete complete complete complete complete Linux complete complete Mac OS X complete in progress iOS planned Chrome OS complete planned Android complete complete GGP (Stadia) complete Fuchsia in progress \u53d1\u5c55\u65f6\u95f4\u7ebf 2010 \u5e743\u6708 \u5ba3\u5e03\u7acb\u9879 ( google blog ) \u4e3b\u8981\u4ee5\u652f\u6301 WebGL on DirectX \u4e3a\u6765\u5b9e\u73b0 Chrome on Windows \u4e3a\u76ee\u7684. 2011\u5e7411\u6708 ANGLE v1.0.772 \u901a\u8fc7 OpenGL 2.0.3 \u7684\u8ba4\u8bc1\u6d4b\u8bd5. ... 2019\u5e743\u6708 \u53d1\u5e03 Android Q (10) \u65f6\u79f0, \u5c06\u5b9e\u9a8c\u6027\u5bfc\u5165 Angle on Vulkan ( google blog ) \u5f00\u53d1\u8005\u9009\u9879\u542b \"OpenGL \u9a71\u52a8\u5207\u6362\" \u529f\u80fd, \u53ef\u4ee5\u5207\u6362\u5230 Angle, \u7136\u540e\u8fd0\u884cgles \u7684 app\u8fdb\u884c\u6d4b\u8bd5. \u8dd1\u5206\u6d4b\u8bd5\u53ea\u6709\u539f\u751fOpenGL\u6027\u80fd\u7684\u7ea663%, \u5e76\u5b58\u5728\u9ed1\u5c4f\u6216\u95ea\u70c1. (2019\u5e747\u6708 \u817e\u8baf\u7f51:Angle\u6027\u80fd\u6d4b\u8bd5 ) ANGLE\u6027\u80fd\u5927\u7ea6\u662f\u539f\u751f\u9a71\u52a8\u7684 65%-90%, \u5176\u4e2d\u5728render off-screen \u65f6\u572865%\u5de6\u53f3, \u5728render front / back buffer\u65f6\u53ef\u8fbe90%. (2019\u5e748\u6708 Vulkan Sessions SIGGRAPH ) \u57fa\u4e8eVulkan\u540e\u7aef\u7684\u6d4b\u8bd5\u8ba4\u8bc1: 2019\u5e7411\u6708: OpenGL ES 2.0: ANGLE 2.1.0.d46e2fb1e341 2020\u5e742\u6708: OpenGL ES 3.0: ANGLE 2.1.0.f18ff947360d 2020\u5e747\u6708: OpenGL ES 3.1: ANGLE 2.1.0.f5dace0f1e57 \u5e94\u7528 \u6d4f\u89c8\u5668\u7684 WebGL \u9ed8\u8ba4\u540e\u7aef Chrome, Firefox, Safari, Edge Chrome \u4f7f\u7528ANGLE \u8fdb\u884c Windows\u4e0a\u7684\u6240\u6709\u56fe\u5f62\u6e32\u67d3\uff0c\u5305\u62ec\u52a0\u901f\u7684Canvas2D\u5b9e\u65bd\u548cNative Client\u6c99\u7bb1\u73af\u5883\u3002 Shader \u9a8c\u8bc1\u5668 Chrome, Firefox, Safari on Windows, MacOS, Linux, mobile \u79fb\u690d Qt Framework \u63d0\u4f9b\u4ece Android \u5411 Windows \u79fb\u690d\u5e94\u7528 RetroArch (\u591a\u5e73\u53f0\u6a21\u62df\u5668) \u5229\u7528ANGLE, \u5b9e\u73b0\u5728 Xbox One\u7248\u6a21\u62df\u5668\u4e0a\u8fd0\u884c OpenGL ES \u5fae\u8f6f\u63d0\u4f9b\u652f\u6301 2014\u5e74\u589e\u52a0\u4e86\u5728 Windows Store \u5e94\u7528\u7a0b\u5e8f\u4e2d\u4f7f\u7528 ANGLE \u7684\u529f\u80fd\u3002 \u5728 ANGLE \u7684 EGL \u4e2d\u652f\u6301 CoreWindow \u548c SwapChainPanel \u53ef\u4ee5\u4f7f\u5e94\u7528\u7a0b\u5e8f\u5728 Windows 8 \u4ee5\u4e0a\u8fd0\u884c\u3002 VS Studio \u63d0\u4f9b Windows Phone app \u5f00\u53d1\u63d2\u4ef6ANGLE\u652f\u6301 \u5fae\u8f6f\u5458\u5de5\u5728\u6b64\u8fc7\u7a0b\u4e2d\u4e5f\u5c11\u91cf\u53c2\u4e0e ANGLE \u7684\u8d21\u732e 2. \u5f00\u53d1\u4e0e\u8c03\u8bd5 \u6e90\u7801\u6784\u5efa \u5728 Windows \u4e0abuild, \u5e76\u53ef\u4ee5\u751f\u6210\u5305\u542b\u6e90\u7801\u7684, \u53ef\u8c03\u8bd5\u7684 VS Solution. \u5b89\u88c5 Visual Studio 2019 \u5b89\u88c5\u6700\u65b0 Window 10 SDK \u5b89\u88c5 Chromium's depot_tools \u5c06 depot_tools \u6dfb\u52a0\u5230 PATH IMPORTANT : \u5728\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\u4e2d\u8bbe\u7f6e DEPOT_TOOLS_WIN_TOOLCHAIN=0 \u5b89\u88c5 Git, \u83b7\u53d6\u6e90\u7801 git clone https://chromium.googlesource.com/angle/angle cd angle python scripts/bootstrap.py gclient sync git checkout master \u751f\u6210 ninja \u6587\u4ef6: gn gen out/Debug --sln=angle-debug --ide=vs2019 \u5728 Visual Studio \u4e2d, \u6253\u5f00 ANGLE solution : out/Debug/angle-debug.sln . \u6b64\u65f6, sample projects \u548c angle_end2end_tests , angle_unittests \u5e94\u8be5\u53ef\u4ee5\u8fd0\u884c\u4e86. \u8be6\u7ec6\u6b65\u9aa4 \u53ca\u5176\u4ed6\u5e73\u53f0, \u53ef\u53c2\u89c1 github/angle \u6587\u6863 Dev setup instructions . \u4f7f\u7528 ANGLE \u5f00\u53d1 GLES \u5e94\u7528 Windows VS C++ : \u6dfb\u52a0 angle/include \u6587\u4ef6\u5939\u6765\u8bbf\u95ee\u6807\u51c6\u7684 Khronos EGL, GLES2 header \u6587\u4ef6. \u53c2\u7167\u4e0a\u6587 \u6784\u5efa\u5f15\u7528 , \u4f7f\u7528 Visual Studio \u6765 build ANGLE, \u5e76\u5728 output \u4e2d\u627e\u5230\u6784\u5efa\u7684 .lib \u6587\u4ef6 \u590d\u5236 libEGL.lib \u548c libGLESv2.lib , \u5e76\u914d\u88c5 Linker \u6b64\u65f6\u53ef\u4ee5\u4f7f\u7528 GLES \u548c EGL \u5f00\u53d1\u5e94\u7528\u4e86 Linux \u548c MacOS: \u5c06\u5e94\u7528\u8fde\u63a5\u5230 libGLESv2 and libEGL \u4f7f\u7528 dlopen \u5728\u8fd0\u884c\u65f6\u52a0\u8f7d OpenGL ES \u548c EGL \u5165\u53e3. dEQP \u6d4b\u8bd5 deqp (drawElements Quality Program) Testing drawElements \u8d28\u91cf\u8ba1\u5212\u6d4b\u8bd5 \u662f\u9488\u5bf9GLES2\uff0cGLES3 + \u548c EGL \u7684 \u5f3a\u5927\u4e14\u5168\u9762\u7684\u5f00\u6e90\u6d4b\u8bd5\u96c6\u3002 \u5b83\u4eec\u4e3a\u51e0\u4e4e\u6240\u6709GL API\u529f\u80fd\u90fd\u63d0\u4f9b\u4e86\u5e7f\u6cdb\u7684\u8986\u76d6\u8303\u56f4\u3002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cANGLE \u5c06\u6784\u5efa dEQP \u6d4b\u8bd5\u76ee\u6807\uff0c\u4ee5\u9488\u5bf9GLES 2\uff0cGLES 3\uff0cEGL\u548cGLES 3.1\uff08\u5728\u53d7\u652f\u6301\u7684\u5e73\u53f0\u4e0a\uff09\u8fdb\u884c\u6d4b\u8bd5\u3002 \u652f\u6301 Android \u5e73\u53f0\u6d4b\u8bd5, \u9700\u5b89\u88c5\u5bf9\u5e94 APK \u73b0\u53ef\u4ee5\u6784\u5efa\u7684\u5305\u62ec GLES 2.0 \u548c 3.0, EGL \u7684 \u5305\u542b&\u4e0d\u5305\u542b google test \u5957\u4ef6\u7684\u6d4b\u8bd5 \u5bf9\u4e8e GLES 3.1 \u6d4b\u8bd5, \u76ee\u524d\u5904\u4e8e\u5b9e\u9a8c\u9636\u6bb5 \u6784\u5efa\u6d4b\u8bd5\u65b9\u6cd5, \u53c2\u89c1 https://github.com/google/angle/blob/master/doc/dEQP.md \u6d4b\u8bd5\u7ed3\u679c \u5b98\u65b9\u4e0a\u4f20\u6bcf\u65e5\u66f4\u65b0\u7684\u6d4b\u8bd5\u7ed3\u679c, \u5e76\u7ed8\u5236\u6210\u5728\u7ebf\u56fe\u8868: \u4ee5\u4e0b\u662f GLES on Vulkan for Android GLES on Vulkan for Android 2.0 \u548c 3.0 \u652f\u6301\u5ea6\u8d85\u8fc795% 3.1 \u652f\u6301\u5ea6\u7ea6 65%, \u53ef\u80fd\u4e0e dEQP \u6d4b\u8bd5\u7684\u4e0d\u5b8c\u6574\u6709\u5173 \u5b8c\u6574\u6d4b\u8bd5\u7ed3\u679c: https://chromium.googlesource.com/angle/angle/+/master/doc/dEQP-Charts.md 3. \u6e90\u7801\u7ed3\u6784 \u672c\u7ae0\u8282\u6536\u96c6 Angle \u5b98\u65b9\u5df2\u516c\u5e03\u7684\u4ee3\u7801\u5206\u6790\u8d44\u6599, \u5206\u6790\u5b9e\u73b0\u903b\u8f91. \u793a\u610f\u4ee3\u7801, \u975e\u6e90\u7801: Front-End (State Tracking): Buffer angle::Result Buffer::bufferData(Context *context, BufferBinding target, const void *data, GLsizeiptr size, BufferUsage usage) { ANGLE_TRY(mImpl->setData(context, target, data, size, usage)); mIndexRangeCache.clear(); mState.mUsage = usage; mState.mSize = size; onStateChange(angle::SubjectMessage::SubjectChanged); return angle::Result::Continue; } VK Back-End: BufferVk angle::Result BufferVk::setData(const gl::Context *context, gl::BufferBinding target, const void *data, size_t size, gl::BufferUsage usage) { ContextVk *contextVk = vk::GetImpl(context); if (size > static_cast<size_t>(mState.getSize())) { // Release and re-create the memory and buffer. release(contextVk); VkBufferCreateInfo createInfo = { /* ... */ }; ANGLE_TRY(mBuffer.init(contextVk, createInfo, kMemoryPropertyFlags)); } if (data && size > 0) { ANGLE_TRY(setDataImpl(contextVk, data, size, 0)); } return angle::Result::Continue; } \u6e90\u7801\u76ee\u5f55\u7ed3\u6784 \u6838\u5fc3\u4ee3\u7801\u4f4d\u4e8e src/libANGLE/ ANGLE \u73b0\u5728\u5df2\u7ecf\u6f14\u53d8\u4e3aMANGLE\uff0c\u5373 Multi-platform ANGLE. \u5728MANGLE\u7684\u8bed\u4e49\u4e2d\uff0cD3D / GL / Vulkan \u662f\u5b83\u7684\u4e00\u4e2arenderer \u76ee\u5f55 \u63cf\u8ff0 android build_overrides doc \u6587\u6863 extensions \u76f8\u5173\u63d2\u4ef6\u63cf\u8ff0, txt \u6587\u4ef6 gni include GLES, EGL \u6807\u51c6\u5934\u6587\u4ef6, infra samples \u53ef\u672c\u5730\u8fd0\u884c\u7684\u6d4b\u8bd5\u793a\u4f8b, \u53c2\u7167\u81ea script ninjia \u6784\u5efa\u811a\u672c, for depot_tools src \u6e90\u7801 ... src\\compiler GLSL \u7ffb\u8bd1\u5668 ... src\\libANGLE \u6838\u5fc3\u6e90\u7801, Entery Points, GL Validation, GL Context, State Tracking src\\libANGLE\\renderer \u6838\u5fc3\u6e90\u7801 \\ \u540e\u53f0\u63a5\u53e3\u53ca\u5b9e\u73b0 src\\libANGLE\\renderer\\d3d \u6838\u5fc3\u6e90\u7801 \\ \u540e\u53f0\u63a5\u53e3\u53ca\u5b9e\u73b0 \\ DirectX \u5b9e\u73b0 src\\libANGLE\\renderer\\metal ..... Metal \u5b9e\u73b0 src\\libANGLE\\renderer\\vulkan ..... Vulkan \u5b9e\u73b0 ... third_party tools util \u5404\u76ee\u5f55\u4e0b\u7684\u90e8\u5206\u7c7b libANGLE libANGLE/renderer Vulkan Backend (libANGLE/renderer/vulkan) AttributeMap.h BinaryStream.h BlobCache.h Buffer.h Caps.h Compiler.h Config.h Constants.h Context.h Context_gl.cpp Context_gles_1_0.cpp Context_gles_1_0_autogen.h Context_gles_2_0_autogen.h Context_gles_3_0_autogen.h Context_gles_3_1_autogen.h Context_gles_3_2_autogen.h Context_gles_ext_autogen.h Context_gl_1_autogen.h Debug.h Device.cpp Device.h Display.h EGLSync.h Error.h Fence.h Framebuffer.h FramebufferAttachment.h FrameCapture.h FrameCapture_mock.cpp GLES1Renderer.h GLES1State.h HandleAllocator.h Image.h ImageIndex.h IndexRangeCache.h InfoLog.h LoggingAnnotator.h MemoryObject.h MemoryProgramCache.h Observer.h Overlay.h OverlayWidgets.h Program.h ProgramExecutable.h ProgramLinkedResources.h ProgramPipeline.h Query.h queryconversions.h queryutils.h RefCountObject.h Renderbuffer.h ResourceManager.h ResourceMap.h Sampler.cpp Sampler.h Semaphore.h Shader.h SizedMRUCache.h State.cpp State.h Stream.h Surface.h Texture.h Thread.h trace.h TransformFeedback.h Uniform.h validation (about 30 validations) VaryingPacking.h VertexArray.cpp VertexArray.h VertexAttribute.h WorkerThread.h BufferImpl.h CompilerImpl.h ContextImpl.h DeviceImpl.h DisplayImpl.h EGLImplFactory.h EGLReusableSync.h EGLSyncImpl.h FenceNVImpl.h Format.h FormatID_autogen.h FramebufferAttachmentObjectImpl.h FramebufferImpl.h GLImplFactory.h glslang_wrapper_utils.h ImageImpl.h ImageImpl_mock.h load_functions_table.h MemoryObjectImpl.h OverlayImpl.h ProgramImpl.h ProgramPipelineImpl.h QueryImpl.h RenderbufferImpl.h renderer_utils.h RenderTargetCache.h SamplerImpl.h SemaphoreImpl.h serial_utils.h ShaderImpl.h StreamProducerImpl.h SurfaceImpl.h SyncImpl.h TextureImpl.h TransformFeedbackImpl.h VertexArrayImpl.h BufferVk.h CommandProcessor.h CompilerVk.h ContextVk.h DebugAnnotatorVk.h DeviceVk.h DisplayVk.h FenceNVVk.h FramebufferVk.h GlslangWrapperVk.h ImageVk.h MemoryObjectVk.h OverlayVk.h PersistentCommandPool.h ProgramExecutableVk.h ProgramPipelineVk.h ProgramVk.h QueryVk.h RenderbufferVk.h RendererVk.h RenderTargetVk.h ResourceVk.h SamplerVk.h SecondaryCommandBuffer.h SemaphoreVk.h ShaderVk.h SurfaceVk.h SyncVk.h TextureVk.h TransformFeedbackVk.h UtilsVk.h VertexArrayVk.h \u7c7b\u5173\u7cfb: renderer<--display 4. \u6d41\u7a0b\u793a\u4f8b DrawElements libANGLE \u4e2d, \u4e3a\u5404\u7c7b\u578b\u5b9a\u4e49\u4e86\u7c7b, \u5982 Context, Renderer (GLES1Renderer) DrawElements \u4e3b\u8981\u6d41\u7a0b\u793a\u610f\u56fe: @startuml Application-> entry_point_2_0: glDrawElements entry_point_2_0 -> entry_point_2_0: ValidateDrawElements entry_point_2_0 -> Context: drawElements Context-> GLES1Renderer: prepareForDraw GLES1Renderer -> GLES1Renderer: checkState GLES1Renderer -> Program : setUniform1fv GLES1Renderer -> Context Context-> ContextVk: drawElements ContextVk-> SecondaryCommandBuffer: drawIndexed SecondaryCommandBuffer --> SecondaryCommandBuffer : CommandID::\\nDrawIndexed @enduml entry_points_gles_2_0_autogen.cpp : void GL_APIENTRY DrawElements(GLenum mode, GLsizei count, GLenum type, const void *indices) { Context *context = GetValidGlobalContext(); EVENT(context, GLDrawElements, \"context = %d, mode = %s, count = %d, type = %s, indices = 0x%016\" PRIxPTR \"\", CID(context), GLenumToString(GLenumGroup::PrimitiveType, mode), count, GLenumToString(GLenumGroup::DrawElementsType, type), (uintptr_t)indices); if (context) { PrimitiveMode modePacked = PackParam<PrimitiveMode>(mode); DrawElementsType typePacked = PackParam<DrawElementsType>(type); std::unique_lock<angle::GlobalMutex> shareContextLock = GetShareGroupLock(context); bool isCallValid = (context->skipValidation() || ValidateDrawElements(context, modePacked, count, typePacked, indices)); if (isCallValid) { context->drawElements(modePacked, count, typePacked, indices); } ANGLE_CAPTURE(DrawElements, isCallValid, context, modePacked, count, typePacked, indices); } else { GenerateContextLostErrorOnCurrentGlobalContext(); } } Context.inl.h : ANGLE_INLINE void Context::drawElements(PrimitiveMode mode, GLsizei count, DrawElementsType type, const void *indices) { // No-op if count draws no primitives for given mode if (noopDraw(mode, count)) { return; } ANGLE_CONTEXT_TRY(prepareForDraw(mode)); // GLES1Renderer ANGLE_CONTEXT_TRY(mImplementation->drawElements(this, mode, count, type, indices)); // Go backend: D3d/gl/vulkan } GLES1Renderer::prepareForDraw: Program::setUniform1fv - Feature enables - Texture unit enables and format info - Client state / current vector enables - Matrices - Alpha test - Shading, materials, lighting, fog - Clip planes - Point rasterization - Draw texture ContextVk.cpp : angle::Result ContextVk::drawElements(const gl::Context *context, gl::PrimitiveMode mode, GLsizei count, gl::DrawElementsType type, const void *indices) { vk::CommandBuffer *commandBuffer = nullptr; if (mode == gl::PrimitiveMode::LineLoop) { uint32_t indexCount; ANGLE_TRY( setupLineLoopDraw(context, mode, 0, count, type, indices, &commandBuffer, &indexCount)); vk::LineLoopHelper::Draw(indexCount, 0, commandBuffer); } else { ANGLE_TRY(setupIndexedDraw(context, mode, count, 1, type, indices, &commandBuffer)); commandBuffer->drawIndexed(count); } return angle::Result::Continue; } 3. \u914d\u7f6e OpenGL ES API \u53ef\u9009\u53c2\u6570\u7684\u914d\u7f6e \u53c2\u6570 Capability ES 2.0 Minimum ANGLE SM2 SM3 SM4+ GL_MAX_VERTEX_ATTRIBS 8 16 GL_MAX_VERTEX_UNIFORM_VECTORS 128 254 GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0 (fn1) 0 0 4 GL_MAX_VARYING_VECTORS 8 (fn1) 8 10 10 GL_MAX_FRAGMENT_UNIFORM_VECTORS 16 (fn1) 29 221 221 GL_MAX_TEXTURE_IMAGE_UNITS 8 16 GL_MAX_TEXTURE_SIZE 64 2048-16384 (fn1) GL_MAX_CUBE_MAP_SIZE 16 2048-16384 (fn1) GL_MAX_RENDERBUFFER_SIZE 1 2048-16384 (fn1) GL_ALIASED_POINT_SIZE_RANGE (min, max) (1, 1) (fn2) (1,1) (1, fn2) (1, fn2) GL_ALIASED_LINE_WIDTH_RANGE (min, max) (1, 1) (1, 1) fn1\uff1a\u9650\u5236\u56e0\u786c\u4ef6\u80fd\u529b\u800c\u5f02 fn2\uff1a\u5728SM3\u6216\u66f4\u9ad8\u7248\u672c\u7684\u786c\u4ef6\u4e0a\uff0c\u6700\u5927\u70b9\u5927\u5c0f\u4e3a D3DCAPS9.MaxPointSize \u603b\u7ed3 \u4f18\u70b9: \u6709Google \u548c Android \u56e2\u961f\u7684\u6301\u7eed\u66f4\u65b0\u652f\u6301, \u5e76\u4e14\u76ee\u6807\u4e00\u81f4: \u5b9e\u73b0\u9a71\u52a8\u7684 GLES on Vulkan \u826f\u597d\u7684\u67b6\u6784, \u7cbe\u7b80\u7684\u9762\u5411\u5bf9\u8c61\u7a0b\u5e8f\u8bbe\u8ba1 \u7f3a\u70b9: \u6027\u80fd\u4ecd\u9700\u6301\u7eed\u6539\u8fdb, \u5e76\u5f88\u53ef\u80fd\u5c06\u6765\u59cb\u7ec8\u6709\u81f3\u5c11 10% \u7684\u6027\u80fd\u635f\u5931 \u5176\u4ed6\u53c2\u8003\u8d44\u6599 github \u6587\u6863 https://github.com/google/angle/tree/master/doc \u591a\u5e73\u53f0ANGLE \u8bbe\u8ba1 https://docs.google.com/document/d/17mxRfzXuEWyvGM3t2KqVY4svvfRj_GzysOEpmnDpqeo/edit ANGLE: OpenGL on Vulkan https://www.youtube.com/watch?v=QrIKdjmpmaA Vulkan Sessions SIGGRAPH 2019 - (ANGLE 2:59:50) https://www.youtube.com/watch?v=1fU4w2ZGxH4&list=WL&index=3&t=11119s","title":"1. Angle \u80cc\u666f\u4ecb\u7ecd"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#1-angle","text":"","title":"1. Angle \u80cc\u666f\u4ecb\u7ecd"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#angle-almost-native-graphics-layer-engine","text":"AGNLE \u662f Google \u5f00\u53d1\u7684, \u5f00\u6e90\u7684\u56fe\u5f62\u5f15\u64ce ( BSD license). Github\u5730\u5740: https://github.com/google/angle. \u4f5c\u7528: \u5c06 OpenGL ES API \u8c03\u7528\u7ffb\u8bd1\u5230\u5404\u5e73\u53f0\u786c\u4ef6\u652f\u6491\u7684 API (DirectX / Vulkan / OpenGL), \u6765\u5b9e\u73b0\u65e0\u7f1d\u7684\u8de8\u5e73\u53f0\u7684 OpenGL ES \u5e94\u7528, \u76ee\u7684: \u4e3a Chromium \u7b49\u5404\u6d4f\u89c8\u5668\u63d0\u4f9b \u8de8\u786c\u4ef6/\u9a71\u52a8/\u5e73\u53f0\u7684 WebGL \u652f\u6301. \u6700\u521d\u76ee\u6807: \u5728 WebGL\u7684\u5b50\u96c6 OpenGL ES 2.0 \u548c DirectX 9.0c \u4e4b\u95f4\u5efa\u7acb\u7b80\u5355\u7684\u5c42\uff0c\u7528\u6765\u652f\u6301 Chrome \u5728\u4efb\u610f Windows \u7cfb\u7edf\u4e2d\u90fd\u53ef\u4ee5\u5904\u7406 3D \u56fe\u5f62. \u9879\u76ee\u5f52\u4e8eChrome\u9879\u76ee\u4e0b: chromium / angle Android 10 \u4e2d\u5b9e\u9a8c\u6027\u52a0\u5165 ANGLE, \u76ee\u6807\u5728\u672a\u6765\u5b9e\u73b0 OpenGL ES on Vulkan \u4f9b\u5e94\u5546 \u4e13\u6ce8\u4e8e\u5b9e\u73b0\u5177\u6709 GL \u4eff\u771f\u529f\u80fd\u7684\u9ad8\u8d28\u91cf Vulkan \u9a71\u52a8\u3002 (2019\u5e747\u6708, Vulkan Session) @startuml package Browsers <<Rectangle>> { package WebGL <<Rectangle>> { } } package \"OpenGL ES\" <<Rectangle>> { } package ANGLE <<Rectangle>> { } package Direct3D <<Rectangle>> { } package Vulkan <<Rectangle>> { } package OpenGL <<Rectangle>> { } WebGL --> \"OpenGL ES\" \"OpenGL ES\" --> ANGLE ANGLE --> Direct3D ANGLE --> Vulkan ANGLE --> OpenGL @enduml","title":"ANGLE (Almost Native Graphics Layer Engine)"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#_1","text":"\u5f53\u524d ANGLE \u652f\u6301\u7684\u8f6c\u6362 From OpenGL ES 2.0, 3.0 and 3.1 To Vulkan, desktop OpenGL, OpenGL ES, Direct3D 9, and Direct3D 11 . @startmindmap * ANGLE ** Vulkan ** Desktop OpenGL ** Direct3D 9 ** Direct3D 11 left side ** OpenGL ES 2.0 ** 3.0 ** 3.1 @endmindmap \u5176\u4ed6\u529f\u80fd ANGLE \u5b9e\u73b0\u4e86 EGL 1.4 Shader Compiler \u4e2d\u7684\u7ffb\u8bd1\u5668 \u5728\u8de8\u5e73\u53f0\u7684 WebGL \u5b9e\u73b0\u4e2d, ANGLE shader compiler \u7684\u4e00\u90e8\u5206\u88ab\u7528\u4f5c\u7740\u8272\u5668\u9a8c\u8bc1\u5668 (validator) \u548c\u8f6c\u6362\u5668 (translator) \u3002 \u7740\u8272\u5668\u9a8c\u8bc1\u5668 (validator) \u786e\u4fdd\u5728\u6d4f\u89c8\u5668\u548c\u5e73\u53f0\u4e4b\u95f4\u63a5\u53d7\u4e00\u81f4\u7684GLSL ES\u7740\u8272\u5668\u96c6\u3002 \u7740\u8272\u5668\u8f6c\u6362\u5668 (translator) \u53ef\u7528\u4e8e \u5c06\u7740\u8272\u5668\u7ffb\u8bd1\u4e3a\u5176\u4ed6\u7740\u8272\u8bed\u8a00\uff0c \u53ef\u4ee5\u9009\u62e9\u6027\u7684\u5e94\u7528\u7740\u8272\u5668\u4fee\u6539\u6765\u89e3\u51b3\u672c\u673a\u56fe\u5f62\u9a71\u52a8\u7a0b\u5e8f\u4e2d\u7684\u9519\u8bef\u6216\u7279\u6b8a\u5904\u7406\u3002 \u8be5\u7ffb\u8bd1\u7a0b\u5e8f\u76ee\u6807\u5305\u62ec Desktop GLSL \uff0cVulkan GLSL\uff0cDirect3D HLSL , \u751a\u81f3\u662f\u539f\u751f GLES2 \u5e73\u53f0\u7684 ESSL\u3002 \u672a\u6765 \u6b63\u5728\u5b9e\u73b0 ES 3.2, \u5e76\u63d0\u4f9b\u8f6c\u6362\u5230 Metal \u548c\u652f\u6301 MacOS, Chrome OS, \u548c Fuchsia .","title":"\u652f\u6301\u7684\u8f6c\u6362"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#opengl-es","text":"Direct3D 9 Direct3D 11 Desktop GL GL ES Vulkan Metal OpenGL ES 2.0 complete complete complete complete complete complete OpenGL ES 3.0 complete complete complete complete in progress OpenGL ES 3.1 incomplete complete complete complete OpenGL ES 3.2 in progress in progress in progress","title":"\u652f\u6301\u7684 OpenGL ES \u7248\u672c\u4e0e\u540e\u53f0"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#_2","text":"Direct3D 9 Direct3D 11 Desktop GL GL ES Vulkan Metal Windows complete complete complete complete complete Linux complete complete Mac OS X complete in progress iOS planned Chrome OS complete planned Android complete complete GGP (Stadia) complete Fuchsia in progress","title":"\u540e\u53f0\u5bf9\u5e94\u7684\u5e73\u53f0"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#_3","text":"2010 \u5e743\u6708 \u5ba3\u5e03\u7acb\u9879 ( google blog ) \u4e3b\u8981\u4ee5\u652f\u6301 WebGL on DirectX \u4e3a\u6765\u5b9e\u73b0 Chrome on Windows \u4e3a\u76ee\u7684. 2011\u5e7411\u6708 ANGLE v1.0.772 \u901a\u8fc7 OpenGL 2.0.3 \u7684\u8ba4\u8bc1\u6d4b\u8bd5. ... 2019\u5e743\u6708 \u53d1\u5e03 Android Q (10) \u65f6\u79f0, \u5c06\u5b9e\u9a8c\u6027\u5bfc\u5165 Angle on Vulkan ( google blog ) \u5f00\u53d1\u8005\u9009\u9879\u542b \"OpenGL \u9a71\u52a8\u5207\u6362\" \u529f\u80fd, \u53ef\u4ee5\u5207\u6362\u5230 Angle, \u7136\u540e\u8fd0\u884cgles \u7684 app\u8fdb\u884c\u6d4b\u8bd5. \u8dd1\u5206\u6d4b\u8bd5\u53ea\u6709\u539f\u751fOpenGL\u6027\u80fd\u7684\u7ea663%, \u5e76\u5b58\u5728\u9ed1\u5c4f\u6216\u95ea\u70c1. (2019\u5e747\u6708 \u817e\u8baf\u7f51:Angle\u6027\u80fd\u6d4b\u8bd5 ) ANGLE\u6027\u80fd\u5927\u7ea6\u662f\u539f\u751f\u9a71\u52a8\u7684 65%-90%, \u5176\u4e2d\u5728render off-screen \u65f6\u572865%\u5de6\u53f3, \u5728render front / back buffer\u65f6\u53ef\u8fbe90%. (2019\u5e748\u6708 Vulkan Sessions SIGGRAPH ) \u57fa\u4e8eVulkan\u540e\u7aef\u7684\u6d4b\u8bd5\u8ba4\u8bc1: 2019\u5e7411\u6708: OpenGL ES 2.0: ANGLE 2.1.0.d46e2fb1e341 2020\u5e742\u6708: OpenGL ES 3.0: ANGLE 2.1.0.f18ff947360d 2020\u5e747\u6708: OpenGL ES 3.1: ANGLE 2.1.0.f5dace0f1e57","title":"\u53d1\u5c55\u65f6\u95f4\u7ebf"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#_4","text":"\u6d4f\u89c8\u5668\u7684 WebGL \u9ed8\u8ba4\u540e\u7aef Chrome, Firefox, Safari, Edge Chrome \u4f7f\u7528ANGLE \u8fdb\u884c Windows\u4e0a\u7684\u6240\u6709\u56fe\u5f62\u6e32\u67d3\uff0c\u5305\u62ec\u52a0\u901f\u7684Canvas2D\u5b9e\u65bd\u548cNative Client\u6c99\u7bb1\u73af\u5883\u3002 Shader \u9a8c\u8bc1\u5668 Chrome, Firefox, Safari on Windows, MacOS, Linux, mobile \u79fb\u690d Qt Framework \u63d0\u4f9b\u4ece Android \u5411 Windows \u79fb\u690d\u5e94\u7528 RetroArch (\u591a\u5e73\u53f0\u6a21\u62df\u5668) \u5229\u7528ANGLE, \u5b9e\u73b0\u5728 Xbox One\u7248\u6a21\u62df\u5668\u4e0a\u8fd0\u884c OpenGL ES \u5fae\u8f6f\u63d0\u4f9b\u652f\u6301 2014\u5e74\u589e\u52a0\u4e86\u5728 Windows Store \u5e94\u7528\u7a0b\u5e8f\u4e2d\u4f7f\u7528 ANGLE \u7684\u529f\u80fd\u3002 \u5728 ANGLE \u7684 EGL \u4e2d\u652f\u6301 CoreWindow \u548c SwapChainPanel \u53ef\u4ee5\u4f7f\u5e94\u7528\u7a0b\u5e8f\u5728 Windows 8 \u4ee5\u4e0a\u8fd0\u884c\u3002 VS Studio \u63d0\u4f9b Windows Phone app \u5f00\u53d1\u63d2\u4ef6ANGLE\u652f\u6301 \u5fae\u8f6f\u5458\u5de5\u5728\u6b64\u8fc7\u7a0b\u4e2d\u4e5f\u5c11\u91cf\u53c2\u4e0e ANGLE \u7684\u8d21\u732e","title":"\u5e94\u7528"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#2","text":"","title":"2. \u5f00\u53d1\u4e0e\u8c03\u8bd5"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#_5","text":"\u5728 Windows \u4e0abuild, \u5e76\u53ef\u4ee5\u751f\u6210\u5305\u542b\u6e90\u7801\u7684, \u53ef\u8c03\u8bd5\u7684 VS Solution. \u5b89\u88c5 Visual Studio 2019 \u5b89\u88c5\u6700\u65b0 Window 10 SDK \u5b89\u88c5 Chromium's depot_tools \u5c06 depot_tools \u6dfb\u52a0\u5230 PATH IMPORTANT : \u5728\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\u4e2d\u8bbe\u7f6e DEPOT_TOOLS_WIN_TOOLCHAIN=0 \u5b89\u88c5 Git, \u83b7\u53d6\u6e90\u7801 git clone https://chromium.googlesource.com/angle/angle cd angle python scripts/bootstrap.py gclient sync git checkout master \u751f\u6210 ninja \u6587\u4ef6: gn gen out/Debug --sln=angle-debug --ide=vs2019 \u5728 Visual Studio \u4e2d, \u6253\u5f00 ANGLE solution : out/Debug/angle-debug.sln . \u6b64\u65f6, sample projects \u548c angle_end2end_tests , angle_unittests \u5e94\u8be5\u53ef\u4ee5\u8fd0\u884c\u4e86. \u8be6\u7ec6\u6b65\u9aa4 \u53ca\u5176\u4ed6\u5e73\u53f0, \u53ef\u53c2\u89c1 github/angle \u6587\u6863 Dev setup instructions .","title":"\u6e90\u7801\u6784\u5efa"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#angle-gles","text":"Windows VS C++ : \u6dfb\u52a0 angle/include \u6587\u4ef6\u5939\u6765\u8bbf\u95ee\u6807\u51c6\u7684 Khronos EGL, GLES2 header \u6587\u4ef6. \u53c2\u7167\u4e0a\u6587 \u6784\u5efa\u5f15\u7528 , \u4f7f\u7528 Visual Studio \u6765 build ANGLE, \u5e76\u5728 output \u4e2d\u627e\u5230\u6784\u5efa\u7684 .lib \u6587\u4ef6 \u590d\u5236 libEGL.lib \u548c libGLESv2.lib , \u5e76\u914d\u88c5 Linker \u6b64\u65f6\u53ef\u4ee5\u4f7f\u7528 GLES \u548c EGL \u5f00\u53d1\u5e94\u7528\u4e86 Linux \u548c MacOS: \u5c06\u5e94\u7528\u8fde\u63a5\u5230 libGLESv2 and libEGL \u4f7f\u7528 dlopen \u5728\u8fd0\u884c\u65f6\u52a0\u8f7d OpenGL ES \u548c EGL \u5165\u53e3.","title":"\u4f7f\u7528 ANGLE \u5f00\u53d1 GLES \u5e94\u7528"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#deqp","text":"deqp (drawElements Quality Program) Testing drawElements \u8d28\u91cf\u8ba1\u5212\u6d4b\u8bd5 \u662f\u9488\u5bf9GLES2\uff0cGLES3 + \u548c EGL \u7684 \u5f3a\u5927\u4e14\u5168\u9762\u7684\u5f00\u6e90\u6d4b\u8bd5\u96c6\u3002 \u5b83\u4eec\u4e3a\u51e0\u4e4e\u6240\u6709GL API\u529f\u80fd\u90fd\u63d0\u4f9b\u4e86\u5e7f\u6cdb\u7684\u8986\u76d6\u8303\u56f4\u3002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cANGLE \u5c06\u6784\u5efa dEQP \u6d4b\u8bd5\u76ee\u6807\uff0c\u4ee5\u9488\u5bf9GLES 2\uff0cGLES 3\uff0cEGL\u548cGLES 3.1\uff08\u5728\u53d7\u652f\u6301\u7684\u5e73\u53f0\u4e0a\uff09\u8fdb\u884c\u6d4b\u8bd5\u3002 \u652f\u6301 Android \u5e73\u53f0\u6d4b\u8bd5, \u9700\u5b89\u88c5\u5bf9\u5e94 APK \u73b0\u53ef\u4ee5\u6784\u5efa\u7684\u5305\u62ec GLES 2.0 \u548c 3.0, EGL \u7684 \u5305\u542b&\u4e0d\u5305\u542b google test \u5957\u4ef6\u7684\u6d4b\u8bd5 \u5bf9\u4e8e GLES 3.1 \u6d4b\u8bd5, \u76ee\u524d\u5904\u4e8e\u5b9e\u9a8c\u9636\u6bb5 \u6784\u5efa\u6d4b\u8bd5\u65b9\u6cd5, \u53c2\u89c1 https://github.com/google/angle/blob/master/doc/dEQP.md","title":"dEQP \u6d4b\u8bd5"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#_6","text":"\u5b98\u65b9\u4e0a\u4f20\u6bcf\u65e5\u66f4\u65b0\u7684\u6d4b\u8bd5\u7ed3\u679c, \u5e76\u7ed8\u5236\u6210\u5728\u7ebf\u56fe\u8868: \u4ee5\u4e0b\u662f GLES on Vulkan for Android GLES on Vulkan for Android 2.0 \u548c 3.0 \u652f\u6301\u5ea6\u8d85\u8fc795% 3.1 \u652f\u6301\u5ea6\u7ea6 65%, \u53ef\u80fd\u4e0e dEQP \u6d4b\u8bd5\u7684\u4e0d\u5b8c\u6574\u6709\u5173 \u5b8c\u6574\u6d4b\u8bd5\u7ed3\u679c: https://chromium.googlesource.com/angle/angle/+/master/doc/dEQP-Charts.md","title":"\u6d4b\u8bd5\u7ed3\u679c"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#3","text":"\u672c\u7ae0\u8282\u6536\u96c6 Angle \u5b98\u65b9\u5df2\u516c\u5e03\u7684\u4ee3\u7801\u5206\u6790\u8d44\u6599, \u5206\u6790\u5b9e\u73b0\u903b\u8f91. \u793a\u610f\u4ee3\u7801, \u975e\u6e90\u7801: Front-End (State Tracking): Buffer angle::Result Buffer::bufferData(Context *context, BufferBinding target, const void *data, GLsizeiptr size, BufferUsage usage) { ANGLE_TRY(mImpl->setData(context, target, data, size, usage)); mIndexRangeCache.clear(); mState.mUsage = usage; mState.mSize = size; onStateChange(angle::SubjectMessage::SubjectChanged); return angle::Result::Continue; } VK Back-End: BufferVk angle::Result BufferVk::setData(const gl::Context *context, gl::BufferBinding target, const void *data, size_t size, gl::BufferUsage usage) { ContextVk *contextVk = vk::GetImpl(context); if (size > static_cast<size_t>(mState.getSize())) { // Release and re-create the memory and buffer. release(contextVk); VkBufferCreateInfo createInfo = { /* ... */ }; ANGLE_TRY(mBuffer.init(contextVk, createInfo, kMemoryPropertyFlags)); } if (data && size > 0) { ANGLE_TRY(setDataImpl(contextVk, data, size, 0)); } return angle::Result::Continue; }","title":"3. \u6e90\u7801\u7ed3\u6784"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#_7","text":"\u6838\u5fc3\u4ee3\u7801\u4f4d\u4e8e src/libANGLE/ ANGLE \u73b0\u5728\u5df2\u7ecf\u6f14\u53d8\u4e3aMANGLE\uff0c\u5373 Multi-platform ANGLE. \u5728MANGLE\u7684\u8bed\u4e49\u4e2d\uff0cD3D / GL / Vulkan \u662f\u5b83\u7684\u4e00\u4e2arenderer \u76ee\u5f55 \u63cf\u8ff0 android build_overrides doc \u6587\u6863 extensions \u76f8\u5173\u63d2\u4ef6\u63cf\u8ff0, txt \u6587\u4ef6 gni include GLES, EGL \u6807\u51c6\u5934\u6587\u4ef6, infra samples \u53ef\u672c\u5730\u8fd0\u884c\u7684\u6d4b\u8bd5\u793a\u4f8b, \u53c2\u7167\u81ea script ninjia \u6784\u5efa\u811a\u672c, for depot_tools src \u6e90\u7801 ... src\\compiler GLSL \u7ffb\u8bd1\u5668 ... src\\libANGLE \u6838\u5fc3\u6e90\u7801, Entery Points, GL Validation, GL Context, State Tracking src\\libANGLE\\renderer \u6838\u5fc3\u6e90\u7801 \\ \u540e\u53f0\u63a5\u53e3\u53ca\u5b9e\u73b0 src\\libANGLE\\renderer\\d3d \u6838\u5fc3\u6e90\u7801 \\ \u540e\u53f0\u63a5\u53e3\u53ca\u5b9e\u73b0 \\ DirectX \u5b9e\u73b0 src\\libANGLE\\renderer\\metal ..... Metal \u5b9e\u73b0 src\\libANGLE\\renderer\\vulkan ..... Vulkan \u5b9e\u73b0 ... third_party tools util \u5404\u76ee\u5f55\u4e0b\u7684\u90e8\u5206\u7c7b libANGLE libANGLE/renderer Vulkan Backend (libANGLE/renderer/vulkan) AttributeMap.h BinaryStream.h BlobCache.h Buffer.h Caps.h Compiler.h Config.h Constants.h Context.h Context_gl.cpp Context_gles_1_0.cpp Context_gles_1_0_autogen.h Context_gles_2_0_autogen.h Context_gles_3_0_autogen.h Context_gles_3_1_autogen.h Context_gles_3_2_autogen.h Context_gles_ext_autogen.h Context_gl_1_autogen.h Debug.h Device.cpp Device.h Display.h EGLSync.h Error.h Fence.h Framebuffer.h FramebufferAttachment.h FrameCapture.h FrameCapture_mock.cpp GLES1Renderer.h GLES1State.h HandleAllocator.h Image.h ImageIndex.h IndexRangeCache.h InfoLog.h LoggingAnnotator.h MemoryObject.h MemoryProgramCache.h Observer.h Overlay.h OverlayWidgets.h Program.h ProgramExecutable.h ProgramLinkedResources.h ProgramPipeline.h Query.h queryconversions.h queryutils.h RefCountObject.h Renderbuffer.h ResourceManager.h ResourceMap.h Sampler.cpp Sampler.h Semaphore.h Shader.h SizedMRUCache.h State.cpp State.h Stream.h Surface.h Texture.h Thread.h trace.h TransformFeedback.h Uniform.h validation (about 30 validations) VaryingPacking.h VertexArray.cpp VertexArray.h VertexAttribute.h WorkerThread.h BufferImpl.h CompilerImpl.h ContextImpl.h DeviceImpl.h DisplayImpl.h EGLImplFactory.h EGLReusableSync.h EGLSyncImpl.h FenceNVImpl.h Format.h FormatID_autogen.h FramebufferAttachmentObjectImpl.h FramebufferImpl.h GLImplFactory.h glslang_wrapper_utils.h ImageImpl.h ImageImpl_mock.h load_functions_table.h MemoryObjectImpl.h OverlayImpl.h ProgramImpl.h ProgramPipelineImpl.h QueryImpl.h RenderbufferImpl.h renderer_utils.h RenderTargetCache.h SamplerImpl.h SemaphoreImpl.h serial_utils.h ShaderImpl.h StreamProducerImpl.h SurfaceImpl.h SyncImpl.h TextureImpl.h TransformFeedbackImpl.h VertexArrayImpl.h BufferVk.h CommandProcessor.h CompilerVk.h ContextVk.h DebugAnnotatorVk.h DeviceVk.h DisplayVk.h FenceNVVk.h FramebufferVk.h GlslangWrapperVk.h ImageVk.h MemoryObjectVk.h OverlayVk.h PersistentCommandPool.h ProgramExecutableVk.h ProgramPipelineVk.h ProgramVk.h QueryVk.h RenderbufferVk.h RendererVk.h RenderTargetVk.h ResourceVk.h SamplerVk.h SecondaryCommandBuffer.h SemaphoreVk.h ShaderVk.h SurfaceVk.h SyncVk.h TextureVk.h TransformFeedbackVk.h UtilsVk.h VertexArrayVk.h","title":"\u6e90\u7801\u76ee\u5f55\u7ed3\u6784"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#_8","text":"renderer<--display","title":"\u7c7b\u5173\u7cfb:"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#4-drawelements","text":"libANGLE \u4e2d, \u4e3a\u5404\u7c7b\u578b\u5b9a\u4e49\u4e86\u7c7b, \u5982 Context, Renderer (GLES1Renderer) DrawElements \u4e3b\u8981\u6d41\u7a0b\u793a\u610f\u56fe: @startuml Application-> entry_point_2_0: glDrawElements entry_point_2_0 -> entry_point_2_0: ValidateDrawElements entry_point_2_0 -> Context: drawElements Context-> GLES1Renderer: prepareForDraw GLES1Renderer -> GLES1Renderer: checkState GLES1Renderer -> Program : setUniform1fv GLES1Renderer -> Context Context-> ContextVk: drawElements ContextVk-> SecondaryCommandBuffer: drawIndexed SecondaryCommandBuffer --> SecondaryCommandBuffer : CommandID::\\nDrawIndexed @enduml entry_points_gles_2_0_autogen.cpp : void GL_APIENTRY DrawElements(GLenum mode, GLsizei count, GLenum type, const void *indices) { Context *context = GetValidGlobalContext(); EVENT(context, GLDrawElements, \"context = %d, mode = %s, count = %d, type = %s, indices = 0x%016\" PRIxPTR \"\", CID(context), GLenumToString(GLenumGroup::PrimitiveType, mode), count, GLenumToString(GLenumGroup::DrawElementsType, type), (uintptr_t)indices); if (context) { PrimitiveMode modePacked = PackParam<PrimitiveMode>(mode); DrawElementsType typePacked = PackParam<DrawElementsType>(type); std::unique_lock<angle::GlobalMutex> shareContextLock = GetShareGroupLock(context); bool isCallValid = (context->skipValidation() || ValidateDrawElements(context, modePacked, count, typePacked, indices)); if (isCallValid) { context->drawElements(modePacked, count, typePacked, indices); } ANGLE_CAPTURE(DrawElements, isCallValid, context, modePacked, count, typePacked, indices); } else { GenerateContextLostErrorOnCurrentGlobalContext(); } } Context.inl.h : ANGLE_INLINE void Context::drawElements(PrimitiveMode mode, GLsizei count, DrawElementsType type, const void *indices) { // No-op if count draws no primitives for given mode if (noopDraw(mode, count)) { return; } ANGLE_CONTEXT_TRY(prepareForDraw(mode)); // GLES1Renderer ANGLE_CONTEXT_TRY(mImplementation->drawElements(this, mode, count, type, indices)); // Go backend: D3d/gl/vulkan } GLES1Renderer::prepareForDraw: Program::setUniform1fv - Feature enables - Texture unit enables and format info - Client state / current vector enables - Matrices - Alpha test - Shading, materials, lighting, fog - Clip planes - Point rasterization - Draw texture ContextVk.cpp : angle::Result ContextVk::drawElements(const gl::Context *context, gl::PrimitiveMode mode, GLsizei count, gl::DrawElementsType type, const void *indices) { vk::CommandBuffer *commandBuffer = nullptr; if (mode == gl::PrimitiveMode::LineLoop) { uint32_t indexCount; ANGLE_TRY( setupLineLoopDraw(context, mode, 0, count, type, indices, &commandBuffer, &indexCount)); vk::LineLoopHelper::Draw(indexCount, 0, commandBuffer); } else { ANGLE_TRY(setupIndexedDraw(context, mode, count, 1, type, indices, &commandBuffer)); commandBuffer->drawIndexed(count); } return angle::Result::Continue; }","title":"4. \u6d41\u7a0b\u793a\u4f8b DrawElements"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#3_1","text":"OpenGL ES API \u53ef\u9009\u53c2\u6570\u7684\u914d\u7f6e","title":"3. \u914d\u7f6e"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#_9","text":"Capability ES 2.0 Minimum ANGLE SM2 SM3 SM4+ GL_MAX_VERTEX_ATTRIBS 8 16 GL_MAX_VERTEX_UNIFORM_VECTORS 128 254 GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0 (fn1) 0 0 4 GL_MAX_VARYING_VECTORS 8 (fn1) 8 10 10 GL_MAX_FRAGMENT_UNIFORM_VECTORS 16 (fn1) 29 221 221 GL_MAX_TEXTURE_IMAGE_UNITS 8 16 GL_MAX_TEXTURE_SIZE 64 2048-16384 (fn1) GL_MAX_CUBE_MAP_SIZE 16 2048-16384 (fn1) GL_MAX_RENDERBUFFER_SIZE 1 2048-16384 (fn1) GL_ALIASED_POINT_SIZE_RANGE (min, max) (1, 1) (fn2) (1,1) (1, fn2) (1, fn2) GL_ALIASED_LINE_WIDTH_RANGE (min, max) (1, 1) (1, 1) fn1\uff1a\u9650\u5236\u56e0\u786c\u4ef6\u80fd\u529b\u800c\u5f02 fn2\uff1a\u5728SM3\u6216\u66f4\u9ad8\u7248\u672c\u7684\u786c\u4ef6\u4e0a\uff0c\u6700\u5927\u70b9\u5927\u5c0f\u4e3a D3DCAPS9.MaxPointSize","title":"\u53c2\u6570"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#_10","text":"\u4f18\u70b9: \u6709Google \u548c Android \u56e2\u961f\u7684\u6301\u7eed\u66f4\u65b0\u652f\u6301, \u5e76\u4e14\u76ee\u6807\u4e00\u81f4: \u5b9e\u73b0\u9a71\u52a8\u7684 GLES on Vulkan \u826f\u597d\u7684\u67b6\u6784, \u7cbe\u7b80\u7684\u9762\u5411\u5bf9\u8c61\u7a0b\u5e8f\u8bbe\u8ba1 \u7f3a\u70b9: \u6027\u80fd\u4ecd\u9700\u6301\u7eed\u6539\u8fdb, \u5e76\u5f88\u53ef\u80fd\u5c06\u6765\u59cb\u7ec8\u6709\u81f3\u5c11 10% \u7684\u6027\u80fd\u635f\u5931","title":"\u603b\u7ed3"},{"location":"ANGLE/142%20ANGLE%20%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/#_11","text":"github \u6587\u6863 https://github.com/google/angle/tree/master/doc \u591a\u5e73\u53f0ANGLE \u8bbe\u8ba1 https://docs.google.com/document/d/17mxRfzXuEWyvGM3t2KqVY4svvfRj_GzysOEpmnDpqeo/edit ANGLE: OpenGL on Vulkan https://www.youtube.com/watch?v=QrIKdjmpmaA Vulkan Sessions SIGGRAPH 2019 - (ANGLE 2:59:50) https://www.youtube.com/watch?v=1fU4w2ZGxH4&list=WL&index=3&t=11119s","title":"\u5176\u4ed6\u53c2\u8003\u8d44\u6599"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/","text":"\u603b\u89c8 Vk Extensions ANGLE \u4e2d vk Ext \u5bf9\u5e94es\u529f\u80fd Vk Extensions in ANGLE \u5df2\u652f\u6301 vk\u5185\u90e8 es\u6838\u5fc3 es Ext EGL \u5176\u4ed6 Instance Level: WSI: VK_KHR_ANDROID_SURFACE / VK_KHR_WIN32_SURFACE M* \u2714 VK_KHR_SURFACE M* \u2714 VK_EXT_DEBUG_UTILS / VK_EXT_DEBUG_REPORT ?? \u2714 VK_EXT_SWAPCHAIN_COLOR_SPACE ?? \u2714 VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2 \u2714 \u2714 Device Level : VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER \u2714 VK_EXT_QUEUE_FAMILY_FOREIGN \u2714 VK_EXT_DEPTH_CLIP_ENABLE Nvidia VK_EXT_EXTERNAL_MEMORY_HOST MAC VK_EXT_INDEX_TYPE_UINT8 \u2714 VK_EXT_LINE_RASTERIZATION \u2714 VK_EXT_PROVOKING_VERTEX ANGLE EXT VK_EXT_SHADER_STENCIL_EXPORT \u2714 VK_EXT_TRANSFORM_FEEDBACK \u2714 VK_EXT_VERTEX_ATTRIBUTE_DIVISOR \u2714 VK_FUCHSIA_EXTERNAL_MEMORY FUCHSIA VK_FUCHSIA_EXTERNAL_SEMAPHORE FUCHSIA VK_GOOGLE_SAMPLER_FILTERING_PRECISION ANGLE EXT VK_GGP_FRAME_TOKEN Stadia VK_KHR_BIND_MEMORY_2 \u2714 \u2714 VK_KHR_CREATE_RENDERPASS_2 \u2714 \u2714 VK_KHR_DEPTH_STENCIL_RESOLVE \u2714 \u2714 VK_KHR_EXTERNAL_FENCE_CAPABILITIES \u2714 \u2714 VK_KHR_EXTERNAL_FENCE_FD U VK_KHR_EXTERNAL_MEMORY \u2714 \u2714 VK_KHR_EXTERNAL_MEMORY_FD U VK_KHR_EXTERNAL_SEMAPHORE \u2714 \u2714 VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES \u2714 \u2714 VK_KHR_EXTERNAL_SEMAPHORE_FD U VK_KHR_GET_MEMORY_REQUIREMENTS_2 \u2714 \u2714 VK_KHR_IMAGE_FORMAT_LIST \u2714 AMD VK_KHR_INCREMENTAL_PRESENT U VK_KHR_MAINTENANCE1 \u2714 \u2714 VK_KHR_SAMPLER_YCBCR_CONVERSION \u2714 \u2714 VK_KHR_SHADER_FLOAT16_INT8 \u2714 VK_KHR_SWAPCHAIN \u2714 VK_QCOM_render_pass_store_ops \u2714 *M \u8868\u793a\u4e3aVulkan\u5fc5\u987b\u6269\u5c55, \u4f46 v100 \u6587\u6863\u6ca1\u6709\u6807\u51fa. \u56e0\u6b64\u5bf9\u4e8e\u4e0b\u9762\u7684 VK_EXT_SWAPCHAIN_COLOR_SPACE \u662f\u5426\u5df2\u652f\u6301\u8868\u793a\u5b58\u7591. \u6709\u5176\u4ed6\u6587\u6863\u663e\u793av100,v200\u5747\u652f\u6301. *U \u8868\u793a\u975e\u5fc5\u987b: \u5176\u5bf9\u5e94\u7684 GLES / EGL Extension \u4e0d\u5728 v100 \u7684\u652f\u6301\u5217\u8868\u4e2d. \u589e\u52a0 Vk Extensions \u7684\u9700\u6c42 \u5c06\u4e0a\u8868\u4e2d\u7684\u6570\u636e, \u5220\u53bb\"'\u5df2\u652f\u6301\u7684\", \"vk\u5185\u90e8\u4f7f\u7528\", \u548c\"\u5176\u4ed6\u5e73\u53f0\"\u7684\u6269\u5c55, \u5269\u4e0b\u7684\u5373 v100 \u5c1a\u672a\u652f\u6301\u7684\u6269\u5c55\u9700\u6c42\u8868\u5982\u4e0b: Vk Extensions \u6240\u9700 Feature \u5206\u7c7b \u5fc5\u9700 \u652f\u6301 es \u529f\u80fd VK_EXT_SWAPCHAIN_COLOR_SPACE -- EGL \u2714 EGL_KHR_gl_colorspace VK_ANDROID_EXTERNAL_MEMORY _ANDROID_HARDWARE_BUFFER VK_EXT_QUEUE_FAMILY_FOREIGN -- EGL \u2714 EGL_ANDROID_image_native_buffer VK_EXT_INDEX_TYPE_UINT8 indexTypeUint8 es2.0 \u5339\u914d Draw \u7684 indexType \u53c2\u6570, \u4ee5\u4f18\u5316\u6027\u80fd VK_EXT_LINE_RASTERIZATION bresenhamLines es2.0 \u7ba1\u7ebf\u7b97\u6cd5\u652f\u6301 VK_EXT_SHADER_STENCIL_EXPORT -- es2.0 VK_EXT_TRANSFORM_FEEDBACK transformFeedback es3.1 \u2714 \u5b9e\u73b0 Transform Feedback \u76f8\u5173 API VK_EXT_VERTEX_ATTRIBUTE_DIVISOR vertexAttributeInstanceRateDivisor es2.0 VK_KHR_SHADER_FLOAT16_INT8 shaderFloat16 es2.0 VK_KHR_EXTERNAL_FENCE_FD -- EGL U EGL_ANDROID_native_fence VK_KHR_EXTERNAL_MEMORY_FD -- EXT U GL_EXT_memory_object_fd VK_KHR_EXTERNAL_SEMAPHORE_FD -- EXT U GL_EXT_semaphore_fd VK_KHR_INCREMENTAL_PRESENT -- EGL U EGL_KHR_swap_buffers_with_damage *U \u8868\u793a\u975e\u5fc5\u987b: \u5176\u5bf9\u5e94\u7684 GLES / EGL Extension \u4e0d\u5728 v100 \u7684\u652f\u6301\u5217\u8868\u4e2d. Vk Features \u5bf9\u6bd4 v100 \u652f\u6301\u60c5\u51b5: \u4ec5 inheritedQueries \u4e0d\u652f\u6301 \u4e14\u5fc5\u9700. \u6b64\u5916\u867d\u7136 vertexPipelineStoresAndAtomics \u4e0d\u652f\u6301, \u4f46 ANGLE \u63a8\u8350\u7528 VK_EXT_TRANSFORM_FEEDBACK \u53d6\u4ee3. \u5176\u4f59Features \u5747\u5728 v100 \u4e2d\u652f\u6301: Vk Features in ANGLE \u5bf9\u5e94 GLES Note inheritedQueries es 3.0, Query vertexPipelineStoresAndAtomics transform feedback \u6a21\u62df\u5b9e\u73b0 transform feedback, \u5e94\u7528 VK_EXT_TRANSFORM_FEEDBACK \u4ee3\u66ff imageCubeArray cubemap array \u4ec5\u5728\u975e SwiftShader \u548c\u975e Qualcomm \u4e0b\u542f\u7528 independentBlend fbo \u591a\u4e2a attachments robustBufferAccess \u8bbf\u95ee robust buffer samplerAnisotropy Anisotropic filtering wideLines wide lines fragmentStoresAndAtomics storage buffers \u5b9e\u73b0 fragment shader \u4e2d storage buffers \u548c images geometryShader geometry shaders shaderImageGatherExtended EXT_gpu_shader5 shaderUniformBufferArrayDynamicIndexing EXT_gpu_shader5 shaderSampledImageArrayDynamicIndexing EXT_gpu_shader5 \u652f\u6301 EXT_gpu_shader5 \u5e76\u6a21\u62df\u5b9e\u73b0 sampler array shaderStorageBufferArrayDynamicIndexing \u6a21\u62df\u5b9e\u73b0 atomic counter shaderClipDistance APPLE_clip_distance sampleRateShading OES_sample_shading depthClamp OES_sample_shading support depth clears through draw calls. sampleRateShading OES_sample_variables *\u7c97\u4f53 Features\u4e3a\u6838\u5fc3API\u6240\u5fc5\u9700\u7279\u6027. Limits \u672c\u8868\u5217\u51fa ANGLE \u4e2d\u8bb0\u4e86\u6570\u5b57\u9700\u6c42\u7684 Limits. [ ] \u5bf9\u5e94 v100 GLES Limits * \u662f\u6307 ANGLE \u5728\u6a21\u62df\u5b9e\u73b0 GLES \u65f6, \u9700\u8981\u5360\u7528\u90e8\u5206\u8d44\u6e90, \u5bfc\u81f4 v100 \u4e2d\u6807\u8bb0\u7684 GLES Limits \u4e0d\u518d\u80fd\u6ee1\u8db3. \u672c\u8868\u5047\u8bbe VK_EXT_TRANSFORM_FEEDBACK \u4e0e VK_EXT_LINE_RASTERIZATION \u5df2\u6ee1\u8db3. \u5426\u5219\u4e00\u4e9b\u6240\u9700\u503c\u4f1a\u589e\u52a0, \u4f46\u4e0d\u4f1a\u6539\u53d8\u5f53\u524d\u6ee1\u8db3\u60c5\u51b5. Vk Limits in ANGLE \u6240\u9700\u503c Limits in v100 v100 \u5df2\u6ee1\u8db3 \u5bf9\u5e94 GLES EXT / Cap maxPerStageDescriptorStorageBuffers >=12 / 16 8 \u4e0d\u6ee1\u8db3 es3.0, 12 \u4e3a\u6ee1\u8db3 ANGLE es3.0 16 \u4e3a\u6ee1\u8db3 v100 GLES Limits maxPerStageDescriptorUniformBuffers >=14 12 \u4e0d\u6ee1\u8db3 v100 GLES Limits* maxDescriptorSetUniformBuffers >=76 72 \u4e0d\u6ee1\u8db3 v100 GLES Limits* maxVertexOutputComponents \u4e0e maxFragmentInputComponents >=136 128 \u4e0d\u6ee1\u8db3 v100 GLES Limits* standardSampleLocations true true textureStorageMultisample2DArrayOES maxSamplerAnisotropy > 1.0f; 16 textureFilterAnisotropic maxTextureAnisotropy maxInterpolationOffset >= 0.5; 0.4375 \u4e0d\u6ee1\u8db3 OES_shader_multisample_interpolation maxVertexInputAttributeOffset >=2047 2047 es3.1 ANGLE : Vk Extensions GLES Core VK_EXT_TRANSFORM_FEEDBACK V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es3.0 APIs \u5bf9\u5e94\u529f\u80fd Transform Feedback \u5fc5\u8981\u6027 \u5b9e\u73b0 Transform Feedback \u5fc5\u9700 \u6240\u9700 FeaturesEXT transformFeedback angle doc: TransformFeedbackViaExtension angle issue: http://anglebug.com/3206 ANGLE\u4f7f\u7528Vulkan\u4e2d\u7684vertexPipelineStoresAndAtomics\u529f\u80fd\u6a21\u62df\u53d8\u6362\u53cd\u9988\u3002\u4f46\u662f\u67d0\u4e9b Driver \u4e0d\u652f\u6301\u6b64\u7279\u6027\u3002\u540c\u6837\uff0c\u5728GLES 3.2\u4e2d\uff0c\u4eff\u771f\u53d8\u5f97\u66f4\u52a0\u56f0\u96be\u3002\u56e0\u6b64\uff0c ANGLE\u5fc5\u987b\u652f\u6301\u4f7f\u7528 VK_EXT_transform_feedback \u6269\u5c55 \u3002\u5e76\u4e14\u5f53\u4f7f\u7528\u6b64\u6269\u5c55\u65f6\uff0c\u6211\u4eec\u4e5f\u671f\u671b\u6027\u80fd\u63d0\u9ad8\u3002 \u4f7f\u7528CounterBuffer\u5b9e\u73b0\u6682\u505c/\u6062\u590d Vulkan\u6269\u5c55\u6ca1\u6709\u4e3a glPauseTransformFeedback / glEndTransformFeedback \u5206\u522b\u63d0\u4f9b\u5355\u72ec\u7684API \u3002 \u76f8\u53cd\uff0cVulkan\u5728 vkCmdBeginTransformFeedbackEXT / vkCmdEndTransformFeedbackEXT \u4e2d \u5f15\u5165\u4e86\u8ba1\u6570\u5668\u7f13\u51b2\u533a\u4f5c\u4e3aAPI\u53c2\u6570\u3002 \u8981\u6682\u505cFB\uff0c\u8c03\u7528 vkCmdEndTransformFeedbackEXT \u5e76\u5728 pCounterBuffers \u6570\u7ec4\u4e2d\u63d0\u4f9b\u6709\u6548\u7684\u7f13\u51b2\u533a\u53e5\u67c4, \u5728 pCounterBufferOffsets \u6570\u7ec4\u4e2d\u63d0\u4f9b\u6709\u6548\u7684\u504f\u79fb\u91cf\uff0c\u4ee5\u5b9e\u73b0\u4fdd\u5b58\u6062\u590d\u70b9\u7684\u5b9e\u73b0\u3002 \u8981\u6062\u590dFB\uff0c\u6211\u4eec\u8c03\u7528 vkCmdBeginTransformFeedbackEXT \u5e76\u4f20\u5165\u5148\u524d\u7684 pCounterBuffers \u548c pCounterBufferOffsets \u503c\u3002 \u6682\u505c\u548c\u6062\u590d\u4e4b\u95f4, \u9700\u8981\u6709\u4e00\u4e2a\u5b58\u50a8\u963b\u6321 (memory barrier), \u7528\u4e8e\u4e0e\u8bbf\u95ee\u6e90\u5230\u8bbf\u95ee\u6a21\u677f\u7684\u8ba1\u6570\u5668\u7f13\u51b2\u5668. \u8bbf\u95ee\u6e90: Pipeline Stage \u7684 VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT \u4e2d\u7684 VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT \u8bbf\u95ee\u76ee\u6807 Pipeline Stage \u7684 VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT \u4e2d\u7684 VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT glTransformFeedbackVaryings \u7684\u5b9e\u73b0 Vulkan\u4e2d\u6ca1\u6709 glTransformFeedbackVaryings \u7684\u7b49\u6548\u51fd\u6570\u3002 Vulkan\u89c4\u8303\u6307\u51fa\uff0c\u5fc5\u987b\u4f7f\u7528XFB\u6267\u884c\u6a21\u5f0f\u58f0\u660e\u6700\u540e\u4e00\u4e2a\u9876\u70b9\u5904\u7406\u9636\u6bb5\u7740\u8272\u5668\u3002 SPIR-V \u8f6c\u6362\u5668\u8d1f\u8d23\u6dfb\u52a0\u6b64\u6267\u884c\u6a21\u5f0f\uff0c\u5e76\u4fee\u9970\u9700\u8981\u6355\u83b7\u7684\u53d8\u91cf\u3002 ANGLE \u4e3a Vulkan \u5750\u6807\u7cfb\u4fee\u6539\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684 gl_position.z \u3002\u56e0\u6b64\uff0c\u5982\u679c\u6211\u4eec\u5728XFB\u7f13\u51b2\u533a\u4e2d\u6355\u83b7\u201c gl_position\u201d\u7684\u503c\uff0c\u5219\u6355\u83b7\u7684\u503c\u5c06\u662f\u9519\u8bef\u7684\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u58f0\u660e\u4e00\u4e2a\u5185\u90e8 position \u53d8\u5316\u91cf\uff0c\u7136\u540e\u590d\u5236'gl_position'\u7684\u503c\u3002\u6211\u4eec\u6355\u83b7\u4e86\u53d8\u6362\u53cd\u9988\u64cd\u4f5c(transform feedback)\u671f\u95f4\u5185\u90e8 position \u53d8\u5316\u91cf\u7684\u53d8\u5316\u3002\u4e3a\u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u4f1a\u5bf9\u6bcf\u4e2a\u6355\u83b7\u7684\u53d8\u5316\u90fd\u8fdb\u884c\u6b64\u64cd\u4f5c, \u800c\u6ca1\u6709\u7528 gl_PerVertex \u76f4\u63a5\u5728SPIR-V\u4e2d\u88c5\u9970\u7ed3\u6784\u4f53\u3002 Transform Feedback Queries GLES \u6709\u4e24\u4e2a\u4e0d\u540c\u7684\u67e5\u8be2\uff1a GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN \u548c GL_PRIMITIVES_GENERATED \u3002 \u4f46\u662f\u5728Vulkan\u4e2d\uff0c\u8fd9\u4e9b\u662f\u7531\u6765\u81ea VK_EXT_transform_feedback \u7684\u5355\u4e2a\u67e5\u8be2\u63d0\u4f9b\u7684\u3002 \u6b64\u5916\uff0cVulkan\u8981\u6c42\u4e00\u6b21\u53ea\u80fd\u6fc0\u6d3b\u67d0\u7c7b\u578b\u7684\u4e00\u4e2a\u67e5\u8be2\u3002 \u5f53\u4e24\u4e2a Transform Feedback \u67e5\u8be2\u90fd\u5904\u4e8e\u6d3b\u52a8\u72b6\u6001\u65f6\uff0c\u8fd9\u5c06\u8feb\u4f7fANGLE\u4f7f\u4e24\u4e2aGL\u67e5\u8be2\u5171\u4eab\u5176Vulkan\u67e5\u8be2\u3002 \u5bf9\u5e94 GLES API Transform Feedback glBeginTransformFeedback/ glPauseTransformFeedback /glResumeTransformFeedback/ glEndTransformFeedback / glTransformFeedbackVaryings Buffer glBufferData / glBufferStorage / glDeleteBuffers glsl glDispatchComputeIndirect / glDispatchCompute / glLinkProgram / glCreateShaderProgramv Query glBeginQuery / glEndQuery Vulkan \u5b9a\u4e49 Features : \u4ec5\u9700\u542f\u7528 transformFeedback // Provided by VK_EXT_transform_feedback typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 transformFeedback; VkBool32 geometryStreams; } VkPhysicalDeviceTransformFeedbackFeaturesEXT; \u6269\u5c55\u547d\u4ee4: vkCmdBeginQueryIndexedEXT vkCmdBeginTransformFeedbackEXT vkCmdBindTransformFeedbackBuffersEXT vkCmdDrawIndirectByteCountEXT vkCmdEndQueryIndexedEXT vkCmdEndTransformFeedbackEXT ANGLE : GLES on Vk /API\u8f83\u591a, \u5f85\u5206\u6790/ \u7ed3\u675f VK_EXT_INDEX_TYPE_UINT8 (.) V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 APIs \u5bf9\u5e94\u529f\u80fd \u6307\u5b9a\u4e86 IndexType \u7684 Draw \u5fc5\u8981\u6027 \u6027\u80fd\u4f18\u5316, \u53ef\u7ed5\u8fc7 \u6240\u9700 FeaturesEXT indexTypeUint8 angle issue: http://anglebug.com/4405 \u6b64\u6269\u5c55\u4e3a\u89e3\u51b3\u4e00\u4e2a\u6027\u80fd\u95ee\u9898: \u67d0\u4e9bGLES\u57fa\u51c6\uff08\u4f8b\u5982T-Rex\uff09\u5728 draw \u65f6\u4f7f\u7528 8bit \u7684 indices \u3002 \u4f46\u662f, Vulkan \u4e2d\u9ed8\u8ba4\u6ca1\u6709 8bit index, \u56e0\u6b64ANGLE \u9700\u8981\u4f7f\u7528 CPU, \u6216GPU\u7684\u8ba1\u7b97\u7740\u8272\u5668, \u5c068\u4f4d\u7d22\u5f15\u8f6c\u6362\u4e3a16\u4f4d\u3002 \u800c\u5982\u679c driver \u652f\u6301 VK_EXT_index_type_uint8 \uff0c\u5219\u4e0d\u9700\u8981\u6b64\u8f6c\u6362. \u5bf9\u5e94 GLES \u529f\u80fd \u6240\u6709\u6307\u5b9a\u4e86 IndexType \u7684 Draw. (DrawArrays, DrawElements.....) \u4f8b: glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices); \u5176\u4e2d index \u7c7b\u578b\u4e3a\u4ee5\u4e0b\u679a\u4e3e\u503c\u4e4b\u4e00: GL_UNSIGNED_BYTE , GL_UNSIGNED_SHORT , or GL_UNSIGNED_INT , \u5206\u522b\u5bf9\u5e94\u4e86 8bit, 16bit, \u548c 32bit. Vulkan \u5b9a\u4e49 \u6b64\u6269\u5c55\u5141\u8bb8\u5728 vkCmdBindIndexBuffer \u547d\u4ee4\u4e2d\u4f7f\u7528 uint8_t indices, \u5bf9\u5e94\u679a\u4e3e: VkIndexType: VK_INDEX_TYPE_UINT8_EXT \u800c\u5728\u6ca1\u6709\u6b64\u6269\u5c55\u65f6, \u4ec5\u652f\u6301 VK_INDEX_TYPE_UINT16 \u548c VK_INDEX_TYPE_UINT32, \u5206\u522b\u5bf9\u5e94 16bit \u548c 32bit Features : \u4ec5\u9700\u542f\u7528 indexTypeUint8 // Provided by VK_EXT_index_type_uint8 typedef struct VkPhysicalDeviceIndexTypeUint8FeaturesEXT { VkStructureType sType; void* pNext; VkBool32 indexTypeUint8; } VkPhysicalDeviceIndexTypeUint8FeaturesEXT; vkCmdBindIndexBuffer \u547d\u4ee4: // Provided by VK_VERSION_1_0 void vkCmdBindIndexBuffer( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType); \u5176\u4e2d indexType \u5bf9\u5e94\u679a\u4e3e: // Provided by VK_VERSION_1_0 typedef enum VkIndexType { VK_INDEX_TYPE_UINT16 = 0, VK_INDEX_TYPE_UINT32 = 1, // Provided by VK_KHR_acceleration_structure VK_INDEX_TYPE_NONE_KHR = 1000165000, // Provided by VK_EXT_index_type_uint8 VK_INDEX_TYPE_UINT8_EXT = 1000265000, // Provided by VK_NV_ray_tracing VK_INDEX_TYPE_NONE_NV = VK_INDEX_TYPE_NONE_KHR, } VkIndexType; ANGLE : GLES on Vk // Init gles-vulkan index type map mIndexTypeMap[UnsignedByte] = supportsIndexTypeUint8 ? VK_INDEX_TYPE_UINT8_EXT : VK_INDEX_TYPE_UINT16; mIndexTypeMap[UnsignedShort] = VK_INDEX_TYPE_UINT16; mIndexTypeMap[UnsignedInt] = VK_INDEX_TYPE_UINT32; mIndexTypeMap \u7528\u4e8e \u6267\u884c vkCmdBindIndexBuffer \u8bbe\u7f6e\u7c7b\u578b UnsignedByte : VK_INDEX_TYPE_UINT8_EXT (\u539f\u5148 VK_INDEX_TYPE_UINT16) UnsignedShort : VK_INDEX_TYPE_UINT16 UnsignedInt : VK_INDEX_TYPE_UINT32 \u5982\u679c\u4e0d\u652f\u6301, \u5728 DrawXXX \u5b9e\u73b0\u4e2d\u5904\u7406 indices \u65f6 (\u4f8b\u5982\u5206\u914d\u5185\u5b58\u7a7a\u95f4) \u9700\u8981\u5c06 GLubyte \u8f6c\u4e3a GLushort \u540e\u518d\u5904\u7406. TODO: \u5206\u6790\u73b0\u6709DDK\u5b9e\u73b0, \u68c0\u67e5\u662f\u5426\u9700\u8981 VK_EXT_LINE_RASTERIZATION (.) V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 \u5bf9\u5e94\u529f\u80fd \u5149\u6805\u5316: \u5355\u6837\u672c\u6e32\u67d3 \u5fc5\u8981\u6027 \u975e\u5fc5\u9700: \u4fdd\u6301\u7b97\u6cd5\u4e00\u81f4\u6027 \u6240\u9700 FeaturesEXT bresenhamLines angle doc: OpenGLLineSegmentRasterization \u7531\u4e8e Vk \u5728\u5149\u6805\u5316\u7684\u5355\u6837\u672c\u6e32\u67d3\u91c7\u6837\u4e86\u4e0d\u540c\u7684\u7ebf\u6bb5\u6e32\u67d3\u7b97\u6cd5, \u9700\u8981\u6b64\u6269\u5c55\u6765\u4fdd\u6301 GLES \u4e0e\u539f\u6709\u7b97\u6cd5\u7684\u4e00\u81f4\u6027: \u5728\u5149\u6805\u5316\u9636\u6bb5, OpenGL\u548cVulkan\u90fd\u5c06\u7ebf\u6bb5\u6e32\u67d3\u4e3a\u4e24\u70b9\u4e4b\u95f4\u7684\u4e00\u7cfb\u5217\u50cf\u7d20\u3002\u5b83\u4eec\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u8986\u76d6\u7ebf\u7684\u50cf\u7d20\u3002 \u5bf9\u4e8e\u5355\u6837\u672c\u6e32\u67d3\uff0cVulkan\u4f7f\u7528 \u57fa\u4e8e\u56db\u8fb9\u5f62\u8986\u76d6\u7387\u7684\u7b97\u6cd5 \u3002\u8f83\u5c0f\u7684\u5f62\u72b6\u56f4\u7ed5\u7ebf\u6bb5\u6324\u51fa\u3002\u5f62\u72b6\u6240\u8986\u76d6\u7684\u6837\u672c\u5c06\u4ee3\u8868\u7ebf\u6bb5\u3002 OpenGL\u7684\u7b97\u6cd5 \u57fa\u4e8eBresenham\u7684line\u7b97\u6cd5 \u3002\u5728\u4e24\u4e2a\u5206\u6bb5\u70b9\u4e4b\u95f4\u7684\u7ebf\u4e0a\u9009\u62e9\u50cf\u7d20\u3002\u6ce8\u610fBresenham\u4e0d\u652f\u6301\u591a\u91cd\u91c7\u6837\u3002 \u5728\u89c6\u89c9\u4e0a\u8fdb\u884c\u6bd4\u8f83\u65f6\uff0cVulkan\u7ebf\u6bb5\u6805\u683c\u5316\u7b97\u6cd5\u59cb\u7ec8\u9009\u62e9\u5728OpenGL\u4e2d\u6805\u683c\u5316\u7684\u7ebf\u6bb5\u50cf\u7d20\u7684\u8d85\u96c6\u3002 \u8be6\u7ec6\u533a\u522b\u89c1 ANGLE \u6587\u6863: OpenGLLineSegmentRasterization \u5bf9\u5e94 GLES \u7ba1\u7ebf\u7684\u5149\u6805\u5316, \u65e0API\u5bf9\u5e94 Vulkan \u5b9a\u4e49 Features : \u4ec5\u9700\u542f\u7528 bresenhamLines. // Provided by VK_EXT_line_rasterization typedef struct VkPhysicalDeviceLineRasterizationFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 rectangularLines; VkBool32 bresenhamLines; VkBool32 smoothLines; VkBool32 stippledRectangularLines; VkBool32 stippledBresenhamLines; VkBool32 stippledSmoothLines; } VkPhysicalDeviceLineRasterizationFeaturesEXT; \u63d0\u4f9b Pipeline State \u6269\u5c55: // Provided by VK_EXT_line_rasterization typedef struct VkPipelineRasterizationLineStateCreateInfoEXT { VkStructureType sType; const void* pNext; VkLineRasterizationModeEXT lineRasterizationMode; VkBool32 stippledLineEnable; uint32_t lineStippleFactor; uint16_t lineStipplePattern; } VkPipelineRasterizationLineStateCreateInfoEXT; \u5176\u4e2d lineRasterizationMode \u5bf9\u5e94\u679a\u4e3e: // Provided by VK_EXT_line_rasterization typedef enum VkLineRasterizationModeEXT { VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0, VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1, VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2, VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3, } VkLineRasterizationModeEXT; \u5176\u4e2d VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT \u6839\u636e Bresenham Line Segment Rasterization \u7b97\u6cd5\u4e2d\u7684\u5b9a\u4e49\uff0c\u6307\u5b9a\u901a\u8fc7\u786e\u5b9a\u7ebf\u6761\u76f8\u4ea4\u548c\u79bb\u5f00\u7684\u50cf\u7d20\u83f1\u5f62\u7ed8\u5236\u7684\u7ebf\u6761\u3002 GLES on Vulkan TODO: \u4e0e\u786c\u4ef6\u6c9f\u901a\u65f6, \u8bbe\u7f6e\u9009\u62e9\u7b97\u6cd5\u7684\u53c2\u6570. \u5728\u975e\u591a\u91cd\u91c7\u6837\u65f6, \u5728\u5b9a\u4e49 Pipeline \u7684 VkPipelineRasterizationStateCreateInfo \u65f6, \u4e3a\u5176 pNext \u94fe\u4e0a\u6dfb\u52a0 VkPipelineRasterizationLineStateCreateInfoEXT \u5373\u53ef. \u8bbe\u7f6e lineRasterizationMode \u4e3a VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT VkPipelineRasterizationStateCreateInfo rasterState = {}; ... const void **pNextPtr = &rasterState.pNext; VkPipelineRasterizationLineStateCreateInfoEXT rasterLineState = {}; rasterLineState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT; // Enable Bresenham line rasterization if available and not multisampling. if (rasterizationSamples <= 1 && bresenhamLineRasterization.enabled) { rasterLineState.lineRasterizationMode = VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT; *pNextPtr = &rasterLineState; pNextPtr = &rasterLineState.pNext; } VK_EXT_SHADER_STENCIL_EXPORT V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 \u5bf9\u5e94\u529f\u80fd glBlitFramebuffer: stencil buffer \u7684 resolve \u548c unresolve \u5fc5\u8981\u6027 \u975e\u5fc5\u987b, \u53ef\u6a21\u62df\u5b9e\u73b0 \u6240\u9700 FeaturesEXT \u65e0 \u6b64\u6269\u5c55\u7528\u4e8e\u6267\u884c\u6a21\u677f\u7f13\u51b2\u533a\u7684\u591a\u91c7\u6837\u89e3\u6790(multisampled resolve of stencil buffer)\u3002 \u5982\u679c\u6b64\u6269\u5c55\u4e0d\u53ef\u7528\uff0c\u5219\u4f7f\u7528\u591a\u6b65\u9aa4\u6a21\u62df\u5b9e\u73b0\u3002 \u5bf9\u5e94 GLES \u529f\u80fd Framebuffer \u7684 resolve \u548c unresolve, \u53d1\u751f\u5728\u8bfb\u53d6\u548c\u590d\u5236\u8fc7\u7a0b\u4e2d, \u5982 glBlitFramebuffer Vulkan \u5b9a\u4e49 \u6b64\u6269\u5c55\u63d0\u4f9b\u4e00\u79cd\u673a\u5236\uff0c\u4f7f\u7740\u8272\u5668\u53ef\u4ee5\u5728\u6bcf\u6b21\u8c03\u7528\u65f6\u751f\u6210\u6a21\u677f\u5f15\u7528\u503c\u3002\u5728\u542f\u7528\u6a21\u677f\u6d4b\u8bd5\u65f6\uff0c\u8fd9\u5141\u8bb8\u9488\u5bf9\u7740\u8272\u5668\u4e2d\u751f\u6210\u7684\u503c\u6267\u884c\u6d4b\u8bd5\u3002 \u6b64\u6269\u5c55\u4f9d\u8d56 SPV_EXT_shader_stencil_export \u6b64\u6269\u5c55\u4e3aGLES\u7684shader\u6269\u5c55: GL_ARB_shader_stencil_export \u63d0\u4f9b API \u652f\u6301 \u6b64\u6269\u4e3a\u4e0d\u589e\u52a0\u5176\u4ed6\u7ed3\u6784\u4f53\u548c\u6307\u4ee4. GLES on Vk \u5f85\u5206\u6790 VK_EXT_VERTEX_ATTRIBUTE_DIVISOR V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 APIs \u5bf9\u5e94\u529f\u80fd Vertex \u7ed1\u5b9a, GL_EXT_instanced_arrays \u5fc5\u8981\u6027 \u6240\u9700 FeaturesEXT vertexAttributeInstanceRateDivisor \u5bf9\u5e94 GLES \u529f\u80fd Vertex \u7ed1\u5b9a GL_EXT_instanced_arrays glDrawArraysInstancedEXT glDrawElementsInstancedEXT glVertexAttribDivisorEXT Vulkan \u5b9a\u4e49 Vertex Attribute Divisor in Instanced Rendering structure controls how vertex attributes are assigned to an instance when instanced rendering is enabled. VkPipelineVertexInputStateCreateInfo // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPipelineVertexInputDivisorStateCreateInfoEXT { VkStructureType sType; const void* pNext; uint32_t vertexBindingDivisorCount; const VkVertexInputBindingDivisorDescriptionEXT* pVertexBindingDivisors; } VkPipelineVertexInputDivisorStateCreateInfoEXT; // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkVertexInputBindingDivisorDescriptionEXT { uint32_t binding; uint32_t divisor; } VkVertexInputBindingDivisorDescriptionEXT; binding is the binding number for which the divisor is specified. divisor is the number of successive instances that will use the same value of the vertex attribute when instanced rendering is enabled. For example, if the divisor is N, the same vertex attribute will be applied to N successive instances before moving on to the next vertex attribute. The maximum value of divisor is implementation dependent and can be queried using VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT :: maxVertexAttribDivisor . A value of 0 can be used for the divisor if the vertexAttributeInstanceRateZeroDivisor feature is enabled. In this case, the same vertex attribute will be applied to all instances. GLES on Vk \u53c2\u8003Spec, \u4e3a Pipeline \u914d\u7f6e VkPipelineVertexInputDivisorStateCreateInfoEXT \u5373\u53ef. VK_KHR_SHADER_FLOAT16_INT8 (.) V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 APIs \u5bf9\u5e94\u529f\u80fd glGenerateMipmap \u5fc5\u8981\u6027 \u975e\u5fc5\u8981: \u6027\u80fd\u4f18\u5316 \u6240\u9700 FeaturesEXT shaderFloat16 angle issue: http://anglebug.com/4551 \u5bf9\u5e94GLES API glGenerateMipmap \u7528\u4e8e\u8fdb\u884c\u751f\u6210Mipmap \u8ba1\u7b97\u65f6, \u5728\u7740\u8272\u5668\u4e2d\u542f\u7528 float 16 \u6765\u52a0\u901f\u8fd0\u7b97 Vulkan \u5b9a\u4e49 \u6b64\u6269\u5c55\u5c06\u63d0\u5347\u81f3 Vulkan 1.2 Core \u6b64\u6269\u5c55\u5141\u8bb8\u5728\u7740\u8272\u5668\u4e2d\u4f7f\u752816\u4f4d\u6d6e\u70b9\u7c7b\u578b\u548c8\u4f4d\u6574\u6570\u7c7b\u578b\u8fdb\u884c\u7b97\u672f\u8fd0\u7b97\u3002 Features : \u4ec5\u9700\u542f\u7528 shaderFloat16 typedef struct VkPhysicalDeviceShaderFloat16Int8Features { VkStructureType sType; void* pNext; VkBool32 shaderFloat16; VkBool32 shaderInt8; } VkPhysicalDeviceShaderFloat16Int8Features; GLES on VK \u5728 GenerateMipmap \u8fc7\u7a0b\u4e2d, \u53d6 shader \u8fdb\u884c\u8ba1\u7b97\u65f6, \u5982\u679c\u56fe\u7247\u7684 bits-per-component (eg: redBits) \u4e3a 8 \u6216 16\u65f6, \u4f7f\u7528\u6269\u5c55\u63d0\u4f9b\u7684 float16 \u6765\u8ba1\u7b97\u4ee5\u83b7\u53d6\u66f4\u5feb\u7684\u8ba1\u7b97\u901f\u5ea6. if (actualFormat.redBits <= 8) { flags = hasShaderFloat16 ? GenerateMipmap_comp::kIsRGBA8_UseHalf : GenerateMipmap_comp::kIsRGBA8; } else if (actualFormat.redBits <= 16) { flags = hasShaderFloat16 ? GenerateMipmap_comp::kIsRGBA16_UseHalf : GenerateMipmap_comp::kIsRGBA16; } else { flags = GenerateMipmap_comp::kIsRGBA32F; } \u5404 flag \u5206\u522b\u5404\u81ea\u5bf9\u5e94\u4e00\u4e2a\u9884\u751f\u6210\u7684 compressedShaderCode. EGL VK_EXT_SWAPCHAIN_COLOR_SPACE(.) V100 \u5df2\u652f\u6301 \u5426 ? \u5bf9\u5e94 GLES EGL Extension \u5bf9\u5e94\u529f\u80fd EGL_KHR_gl_colorspace (v100\u652f\u6301) \u5fc5\u8981\u6027 \u652f\u6301 EGL EXT \u5fc5\u987b \u6240\u9700 FeaturesEXT \u65e0 angle issue: http://anglebug.com/2514 \u652f\u6301\u6269\u5c55 EGL_KHR_gl_colorspace (v100\u652f\u6301), \u8fdb\u800c\u652f\u6301 EGL_EXT_image_gl_colorspace \u7b49 colorspace \u6269\u5c55. \u5bf9\u5e94 GLES \u529f\u80fd \u6269\u5c55 EGL_KHR_gl_colorspace \u683c\u5f0f: EGL_GL_COLORSPACE_KHR EGL_GL_COLORSPACE_SRGB_KHR EGL_GL_COLORSPACE_LINEAR_KHR Vulkan \u5b9a\u4e49 \u63d0\u4f9b\u6269\u5c55: VkColorSpaceKHR : VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT VK_COLOR_SPACE_BT2020_LINEAR_EXT VK_COLOR_SPACE_BT709_LINEAR_EXT VK_COLOR_SPACE_BT709_NONLINEAR_EXT VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT VK_COLOR_SPACE_DOLBYVISION_EXT VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT VK_COLOR_SPACE_HDR10_HLG_EXT VK_COLOR_SPACE_HDR10_ST2084_EXT VK_COLOR_SPACE_PASS_THROUGH_EXT GLES on Vulkan \u5bf9 EGL \u7684 Format \u5411 Vk Format \u8fdb\u884c\u6620\u5c04: static VkColorSpaceKHR MapEglColorSpaceToVkColorSpace(EGLenum EGLColorspace) { switch (EGLColorspace) { case EGL_NONE: case EGL_GL_COLORSPACE_LINEAR: case EGL_GL_COLORSPACE_SRGB_KHR: case EGL_GL_COLORSPACE_DISPLAY_P3_PASSTHROUGH_EXT: return VK_COLOR_SPACE_SRGB_NONLINEAR_KHR; case EGL_GL_COLORSPACE_DISPLAY_P3_LINEAR_EXT: return VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT; case EGL_GL_COLORSPACE_DISPLAY_P3_EXT: return VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT; case EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT: return VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT; case EGL_GL_COLORSPACE_SCRGB_EXT: return VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT; default: UNREACHABLE(); return VK_COLOR_SPACE_SRGB_NONLINEAR_KHR; } } VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER \u548c VK_EXT_QUEUE_FAMILY_FOREIGN V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES EGL Extension (\u4ec5\u5b89\u5353) \u5bf9\u5e94\u529f\u80fd EGL_ANDROID_image_native_buffer (v100\u652f\u6301) \u5fc5\u8981\u6027 \u652f\u6301 EGL EXT \u5fc5\u987b \u6240\u9700 FeaturesEXT \u65e0 \u5bf9\u5e94 GLES \u529f\u80fd \u652f\u6301 ANativeWindowBuffer : EGL_NATIVE_BUFFER_ANDROID \u793a\u4f8b: ANativeWindowBuffer* sSrcBuffer = graphicBuffer->getNativeBuffer(); EGLint attrs[] = { EGL_IMAGE_PRESERVED_KHR, EGL_TRUE, EGL_NONE, }; EGLImageKHR eglSrcImage =eglCreateImageKHR(eglDisplay, EGL_NO_CONTEXT, EGL_NATIVE_BUFFER_ANDROID, (EGLClientBuffer)&sSrcBuffer, attrs); Vulkan \u5b9a\u4e49 1. VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER \u6b64\u6269\u5c55\u4f7f\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5c06\u5728Vulkan\u8bbe\u5907\u5916\u90e8\u521b\u5efa\u7684Android AHardwareBuffer\u5bf9\u8c61\u5bfc\u5165Vulkan\u5185\u5b58\u5bf9\u8c61\uff0c\u5728\u5176\u4e2d\u53ef\u4ee5\u5c06\u5b83\u4eec\u7ed1\u5b9a\u5230\u56fe\u50cf\u548c\u7f13\u51b2\u533a\u3002 \u5b83\u8fd8\u5141\u8bb8\u4eceVulkan\u5185\u5b58\u5bf9\u8c61\u4e2d\u5bfc\u51faAHardwareBuffer\uff0c\u4ee5\u4e0e\u5176\u4ed6\u64cd\u4f5c\u7cfb\u7edf\u5bf9\u79f0\u3002 \u4f46\u662f\uff0c\u7531\u4e8e\u5e76\u975e\u6240\u6709AHardwareBuffer\u7528\u6cd5\u548c\u683c\u5f0f\u90fd\u5177\u6709Vulkan\u7b49\u6548\u9879\uff0c\u56e0\u6b64\u4eceVulkan\u5bfc\u51fa\u4e0e\u63d0\u4f9b\u5916\u90e8AHardwareBuffer\u5e76\u5bfc\u5165\u76f8\u6bd4\uff0c\u63d0\u4f9b\u7684\u529f\u80fd\u8981\u5c11\u5f97\u591a\u3002 \u67d0\u4e9bAHardwareBuffer\u6620\u50cf\u5177\u6709\u5b9e\u73b0\u5b9a\u4e49\u7684\u5916\u90e8\u683c\u5f0f\uff0c\u8fd9\u4e9b\u683c\u5f0f\u53ef\u80fd\u4e0eVulkan\u683c\u5f0f\u4e0d\u5bf9\u5e94\u3002 \u91c7\u6837\u5668Y'CBCR\u8f6c\u6362\u53ef\u7528\u4e8e\u4ece\u8fd9\u4e9b\u56fe\u50cf\u4e2d\u91c7\u6837\u5e76\u5c06\u5b83\u4eec\u8f6c\u6362\u4e3a\u5df2\u77e5\u7684\u8272\u5f69\u7a7a\u95f4\u3002 \u6269\u5c55\u547d\u4ee4\u5305\u62ec: vkGetAndroidHardwareBufferPropertiesANDROID vkGetMemoryAndroidHardwareBufferANDROID 2. VK_EXT_QUEUE_FAMILY_FOREIGN \u6b64\u6269\u5c55\u5b9a\u4e49\u4e86\u4e00\u4e2a\u7279\u6b8a\u7684\u961f\u5217\u65cf (Queue Family): VK_QUEUE_FAMILY_FOREIGN_EXT : \u7528\u4e8e\u5c06\u5916\u90e8\u5b58\u50a8\u5668\u652f\u6301\u7684\u8d44\u6e90\u6240\u6709\u6743\u8f6c\u79fb\u5230\u5916\u90e8\u5916\u90e8\u961f\u5217\u3002 \u8fd9\u7c7b\u4f3c\u4e8e VK_KHR_external_memory \u4e2d\u5b9a\u4e49\u7684 VK_QUEUE_FAMILY_EXTERNAL_KHR \u3002 \u4e24\u8005\u4e4b\u95f4\u7684\u4e3b\u8981\u533a\u522b\u662f\uff1a VK_QUEUE_FAMILY_EXTERNAL_KHR \u8868\u793a\u7684\u961f\u5217\u5fc5\u987b\u4e0e\u5f53\u524dVkInstance\u5171\u4eab\u76f8\u540c\u7684\u7269\u7406\u8bbe\u5907\u548c\u76f8\u540c\u7684\u9a71\u52a8\u7a0b\u5e8f\u7248\u672c\u3002 VK_QUEUE_FAMILY_FOREIGN_EXT \u6ca1\u6709\u8fd9\u6837\u7684\u9650\u5236\u3002 \u5b83\u53ef\u4ee5\u4ee3\u8868\u5176\u4ed6\u4f9b\u5e94\u5546\u7684\u8bbe\u5907\u548c\u9a71\u52a8\u7a0b\u5e8f\uff0c\u751a\u81f3\u53ef\u4ee5\u4ee3\u8868\u4e0d\u5177\u6709Vulkan\u529f\u80fd\u7684\u8bbe\u5907\u3002 \u5916\u90e8\u5b58\u50a8\u5668\u652f\u6301\u7684\u6240\u6709\u8d44\u6e90\u5747\u652f\u6301 VK_QUEUE_FAMILY_EXTERNAL_KHR \u3002 \u5bf9 VK_QUEUE_FAMILY_FOREIGN_EXT \u7684\u652f\u6301\u66f4\u5177\u9650\u5236\u6027\u3002 \u5e94\u7528\u7a0b\u5e8f\u5e94\u8be5\u671f\u671b\u5230 VK_QUEUE_FAMILY_FOREIGN_EXT \u7684\u8f6c\u6362\u6bd4\u4ece VK_QUEUE_FAMILY_EXTERNAL_KHR \u7684\u8f6c\u6362\u8981\u6602\u8d35\u3002 GLES on Vulkan Android\u5e73\u53f0\u7279\u6b8a\u4ee3\u7801 (src\\libANGLE\\renderer\\vulkan\\android). \u4e3aimage\u521b\u5efabuffer\u65f6, \u7528\u4e8e\u83b7\u53d6 BufferMemory \u7b49\u5e95\u5c42\u4fe1\u606f. \u5177\u4f53\u5185\u5bb9\u5f85\u5206\u6790. VK_KHR_EXTERNAL_FENCE_FD \u6709\u5219\u542f\u7528 supportsExternalFenceFd \u652f\u6301: EGL_ANDROID_native_fence VK_KHR_INCREMENTAL_PRESENT \u6709\u5219\u542f\u7528 supportsIncrementalPresent \u652f\u6301 EGL_KHR_swap_buffers_with_damage eglSwapBuffersWithDamageEXT SurfaceVk::present SurfaceVk::swapImpl GLES EXT VK_KHR_EXTERNAL_MEMORY_FD \u6709\u5219\u542f\u7528 supportsExternalMemoryFd \u652f\u6301: GL_EXT_memory_object_fd VK_KHR_EXTERNAL_SEMAPHORE_FD \u6709\u5219\u542f\u7528 supportsExternalSemaphoreFd \u652f\u6301: GL_EXT_semaphore_fd Vulkan \u81ea\u7528 VK_KHR_SURFACE && VK_KHR_ANDROID_SURFACE WSI , \u975e\u53ef\u9009 Extension VK_EXT_DEBUG_UTILS / VK_EXT_DEBUG_REPORT Vulkan ValidationLayers VK_KHR_SWAPCHAIN \u975e\u53ef\u9009 Extension VK_QCOM_render_pass_store_ops \u6709\u5219\u542f\u7528 supportsRenderPassStoreOpNoneQCOM VK_ATTACHMENT_STORE_OP_NONE_QCOM http://anglebug.com/5505 For read only depth stencil, we can use StoreOpNone if available. DONT_CARE is still preferred, so do this after finish the DONT_CARE handling. \u5176\u4ed6\u5e73\u53f0 Nvidia VK_EXT_DEPTH_CLIP_ENABLE \u6709\u5219\u542f\u7528 FeatureVk.depthClamping \u542f\u7528 : isNvidia && Features.depthClamp && EXT The workaround requires the VK_EXT_depth_clip_enable extension and the 'depthClamp' physical device feature. This workaround caused test failures on Quadro P400/driver 418.56/Linux. Therefore, on Linux we require a major version > 418. On some NVIDIA drivers the depth value is not clamped to [0,1] for floating point depth buffers. This is NVIDIA bug 3171019, see http://anglebug.com/3970 for details. When depth clamping is used, depth clipping is automatically disabled. When the 'depthClamping' feature is enabled, we'll be using depth clamping to work around a driver issue, not as an alternative to depth clipping. Therefore we need to explicitly re-enable depth clipping. \u5bf9\u5e94 vk: VkPipelineRasterizationState.depthClampEnable MAC VK_EXT_EXTERNAL_MEMORY_HOST \u6709\u5219\u542f\u7528 FeatureVk.supportsExternalMemoryHost Whether the VkDevice supports the VK_EXT_external_memory_host extension, on which the ANGLE_iosurface_client_buffer extension can be layered. IOSurfaceSurfaceVkMac.mm OffscreenSurfaceVk::AttachmentImage::initializeWithExternalMemory RendererVk.mMinImportedHostPointerAlignment vkGetMemoryHostPointerPropertiesEXT IOSurfaceSurfaceVkMac.mm GGP(Stadia) VK_GGP_FRAME_TOKEN if PLANTFORM_GGP \u6709\u5219\u542f\u7528 supportsGGPFrameToken \u652f\u6301 : EGL_ANGLE_swap_with_frame_token eglSwapBuffersWithFrameTokenANGLE Fuchsia VK_FUCHSIA_EXTERNAL_MEMORY \u6709\u5219\u542f\u7528 supportsExternalMemoryFuchsia \u652f\u6301: GL_ANGLE_memory_object_fuchsia VK_FUCHSIA_EXTERNAL_SEMAPHORE \u6709\u5219\u542f\u7528 supportsExternalSemaphoreFuchsia \u652f\u6301: GL_ANGLE_semaphore_fuchsia ANGLE VK_EXT_PROVOKING_VERTEX GL_ANGLE_provoking_vertex glProvokingVertexANGLE VK_GOOGLE_SAMPLER_FILTERING_PRECISION \u672a\u542f\u7528, ANGLE\u81ea\u5b9a\u4e49 supportsFilteringPrecision \u652f\u6301: GL_CHROMIUM_texture_filtering_hint gHint(GL_TEXTURE_FILTERING_HINT_CHROMIUM) v100 \u5df2\u652f\u6301\u7684Ext GLES VK_KHR_DEPTH_STENCIL_RESOLVE \u542f\u7528 if supportsRenderpass2.enabled && mDepthStencilResolveProperties.independentResolveNone supportsDepthStencilResolve http://anglebug.com/5065 RenderbufferVk::setStorageImpl \u4e3a multisampled depth/stenci \u542f\u7528 render render to texture \u53ef\u542f\u7528 VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT // If multisampled render to texture, an implicit multisampled image is created which is used as // the color or depth/stencil attachment. At the end of the render pass, this image is // automatically resolved into |mImage| and its contents are discarded. \u652f\u6301 depth/stencil images, \u975e\u5fc5\u9700, \u53ef\u7ed5\u8fc7 VK_KHR_EXTERNAL_FENCE_CAPABILITIES \u6709\u5219\u542f\u7528 supportsExternalFenceCapabilities supportsAndroidNativeFenceSync (supportsExternalFenceCapabilities && supportsExternalSemaphoreCapabilities ) || (supportsExternalFenceFd&& supportsExternalSemaphoreFd) VK_KHR_EXTERNAL_SEMAPHORE \u542f\u7528 if supportsExternalSemaphoreFd || supportsExternalSemaphoreFuchsia \u4e8c\u8005\u7684\u524d\u7f6e? \u65e0EXT\u5b58\u5728\u68c0\u67e5 \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES \u6709\u5219\u542f\u7528 supportsExternalSemaphoreCapabilities VK_KHR_MAINTENANCE1 PhysicalDeviceProperties.apiVersion < VK_MAKE_VERSION(1, 1, 0) Enable KHR_MAINTENANCE1 to support viewport flipping. VK_KHR_SAMPLER_YCBCR_CONVERSION \u542f\u7528 if SamplerYcbcrConversionFeatures.samplerYcbcrConversion supportsYUVSamplerConversion Vulkan \u81ea\u7528 VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2 \u6709\u5219\u542f\u7528 VK_KHR_GET_MEMORY_REQUIREMENTS_2 \u6709\u5219\u542f\u7528 \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_BIND_MEMORY_2 \u6709\u5219\u542f\u7528 \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_EXTERNAL_MEMORY \u542f\u7528 if supportsAndroidHardwareBuffer || supportsExternalMemoryFd|| supportsExternalMemoryFuchsia \u53ef\u80fd\u4e3a\u4e09\u8005\u7684\u524d\u7f6e: \u65e0EXT\u652f\u6301\u68c0\u67e5, \u6761\u4ef6\u6ee1\u8db3\u76f4\u63a5\u542f\u7528. \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_CREATE_RENDERPASS_2 \u6709\u5219\u542f\u7528 supportsRenderpass2 vkCreateRenderPass2KHR VK_KHR_DEPTH_STENCIL_RESOLVE \u4f9d\u8d56\u6b64\u6269\u5c55 AMD VK_KHR_IMAGE_FORMAT_LIST \u542f\u7528 if AMD supportsImageFormatList EGL_EXT_image_gl_colorspace ANGLE \u671f\u671b\u5c06\u6765\u52a0\u5165\u7684 EXT TODO \u5206\u6790\u5bf9\u5e94\u529f\u80fd \u4ee5\u4e0b\u591aExtension\u5c1a\u672a\u5217\u5165 Vulkan Spec, \u662f ANGLE \u671f\u671b\u4e3a\u652f\u6301GLES \u800c\u63d0\u51fa\u7684. VK_KHR_shader_terminate_invocation VK_EXT_primitive_topology_list_restart VK_EXT_vertex_attribute_aliasing VK_EXT_generate_mipmap VK_EXT_pipeline_robustness VK_EXT_image_robustness VK_EXT_custom_border_color VK_EXT_blend_operation_advanced \u51fa\u73b0\u5728\u4ee3\u7801\u4e2d\u4f46\u5c1a\u672a\u542f\u7528\u7684Feature. textureCompressionETC2 ANGLE: Vk Features inheritedQueries 3.0 \u5fc5\u987b \u652f\u6301 GLES \u529f\u80fd: glBeginQuery glEndQuery glGetQueryiv \u652f\u6301GLES \u6269\u5c55: GL_EXT_occlusion_query_boolean glGenQueriesEXT glDeleteQueriesEXT glIsQueryEXT glBeginQueryEXT glEndQueryEXT glGetQueryivEXT glGetQueryObjectuivEXT vertexPipelineStoresAndAtomics \u7528\u4e8e\u6a21\u62df\u5b9e\u73b0 transform feedback \u529f\u80fd, \u4f5c\u4e3a\u4e0d\u652f\u6301\u6269\u5c55 VK_EXT_ransform_feedback \u65f6\u7684\u66ff\u4ee3. \u4f46 es3.2 \u4e2d\u53ef\u80fd\u51fa\u73b0\u65e0\u6cd5\u652f\u6301\u529f\u80fd. ANGLE: Vk Limits maxPerStageDescriptorStorageBuffers \u5f53\u524d\u503c \u671f\u5f85\u503c 8 12 / 16 ANGLE \u4e2d, Vulkan Limit: maxPerStageDescriptorStorageBuffers \u4e3a GLES \u540c\u65f6\u63d0\u4f9b StorageBuffers \u548c CounterBuffers, \u5bf9\u5e94\u7684 GLES \u7684 Limits \u4e3a: StorageBuffers: MAX_VERTEX_SHADER_STORAGE_BLOCKS MAX_FRAGMENT_SHADER_STORAGE_BLOCKS MAX_COMPUTE_SHADER_STORAGE_BLOCKS AtomicCounterBuffers: MAX_VERTEX_ATOMIC_COUNTER_BUFFERS MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS \u5404\u7ec4\u503c\u5206\u522b\u8ba1\u7b97, \u4f8b\u5982 VERTEX \u7684\u4e24\u8005\u76f8\u52a0\u4e3aBuffer \u7684 Limit \u503c: MAX_VERTEX_SHADER_STORAGE_BLOCKS + MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = maxPerStageDescriptorStorageBuffers, FRAGMENT, COMPUTE \u540c\u7406. (GEOMETRY \u7684 StorageBuffers \u5bf9\u5e94 vkLimit: maxPerStageResources) \u5728 ANGLE \u4e2d, \u671f\u5f85\u503c StorageBuffers >=4, AtomicCounterBuffers =8, \u56e0\u6b64\u5bf9 GLES 3.1 \u8981\u6c42 maxPerStageDescriptorStorageBuffers >=12 \u82e5\u4e0d\u6ee1\u8db3, \u9650\u5236\u7248\u672c\u4e3a3.0, \u5e76\u8bbe AtomicCounterBuffers \u4e3a 0. \u540c\u65f6, \u82e5\u6ee1\u8db3 AtomicCounterBuffers =8 \u540e, \u8981\u540c\u65f6\u6ee1\u8db3 v100 GLES Limits \u4e2d MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 8, \u5219\u9700 maxPerStageDescriptorStorageBuffers = 16 \u5bf9\u5e943.1\u529f\u80fd: MAX_VERTEX_SHADER_STORAGE_BLOCKS \u548c MAX_VERTEX_ATOMIC_COUNTER_BUFFERS \u9700\u8981 vk \u7279\u6027 vertexPipelineStoresAndAtomics, \u800c\u6b64\u7279\u6027\u5728\u652f\u6301 VK_EXT_TRANSFORM_FEEDBACK \u6269\u5c55\u65f6\u4e0d\u518d\u9700\u8981. \u56e0\u6b64\u5b9e\u73b0 VK_EXT_TRANSFORM_FEEDBACK \u540e\u8be5\u7ec4\u53ef\u5ffd\u7565 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS \u548c MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS \u9700\u8981 vk \u7279\u6027 fragmentStoresAndAtomics (v100\u5df2\u652f\u6301). maxPerStageDescriptorUniformBuffers \u5f53\u524d\u503c \u671f\u5f85\u503c 12 14 \u4e3a kReservedDriverUniformBindingCount, kReservedPerStageDefaultUniformBindingCount \u5404\u7559\u51fa1\u4e2a. \u5f71\u54cd GLES Limits: MAX_VERTEX_UNIFORM_BLOCKS MAX_FRAGMENT_UNIFORM_BLOCKS MAX_COMPUTE_UNIFORM_BLOCKS MAX_GEOMETRY_UNIFORM_BLOCKS MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS maxDescriptorSetUniformBuffers \u5f53\u524d\u503c \u671f\u5f85\u503c 72 72+4 = 76 \u4e3a kReservedDriverUniformBindingCount , kReservedDefaultUniformBindingCount \u9884\u7559\u51fa1 + 3 = 4\u4e2a. constexpr uint32_t kTotalReservedUniformBuffers = kReservedDriverUniformBindingCount + kReservedDefaultUniformBindingCount; const int32_t maxCombinedUniformBuffers = LimitToInt(limitsVk.maxDescriptorSetUniformBuffers - kTotalReservedUniformBuffers); \u5f71\u54cd GLES Limits: MAX_UNIFORM_BUFFER_BINDINGS MAX_COMBINED_UNIFORM_BLOCKS maxVertexOutputComponents \u4e0e maxFragmentInputComponents \u5f53\u524d\u503c \u671f\u5f85\u503c 128 128 + 4*2 = 136 \u5f53\u524d\u503c 128, \u5047\u8bbe EXT \u5747\u5f97\u5230\u652f\u6301, \u4e14\u8981\u6ee1\u8db3GLES Limits, \u82e5 \u4e0d \u652f\u6301 VK_EXT_LINE_RASTERIZATION, \u5219\u9884\u7559 1 \u4e3a\u4e86\u652f\u6301 VK_EXT_TRANSFORM_FEEDBACK, \u9700\u8981\u9884\u7559 2 \u5f71\u54cd GLES Limits: MAX_VARYING_VECTORS \u9884\u7559\u524d 31\u521a\u597d\u6ee1\u8db3. MAX_VARYING_COMPONENTS \u9884\u7559\u524d 124 \u521a\u597d\u6ee1\u8db3. (Vector * 4 = Components ) maxInterpolationOffset \u5f53\u524d\u503c \u671f\u5f85\u503c 0.4375 0.5 \u9644\u8868: GLES Limits \u6ee1\u8db3\u60c5\u51b5\u8be6\u60c5 \u672c\u8868\u57fa\u4e8e ANGLE \u5185\u7684\u8ba1\u7b97\u65b9\u5f0f, \u5e26\u5165 v100 \u7684 Vulkan Limits \u503c, \u68c0\u67e5\u7ed3\u679c\u662f\u5426\u6ee1\u8db3 GLES Limits \u7684\u8981\u6c42. [*] \u5e26\u6b64\u6807\u8bb0\u7684\u8ba1\u7b97\u516c\u5f0f\u57fa\u4e8e\u5047\u8bbe: \u4e0a\u9762\u63d0\u53ca\u7684\u6269\u5c55 TransForm_feedback \u548c Line_Rasterization \u5df2\u5f97\u5230\u652f\u6301. \u800c\u76f8\u5e94\u7684\u7531\u4e8e\u6a21\u62df\u7684Feature\u4e0d\u518d\u542f\u7528. maxPerStageDescriptorStorageBuffers \u4ee5 12 \u8ba1\u7b97 1 GLES Limits GLES Limits in V100 Vk(v100)\u503c\u5e26\u5165 ANGLE ANGLE \u8ba1\u7b97\u516c\u5f0f 2 SUBPIXEL_BITS 8 8 subPixelPrecisionBits 3 MAX_3D_TEXTURE_SIZE 256 256 maxImageDimension3D 4 MAX_TEXTURE_SIZE 8192 8192 min(maxFramebufferWidth, maxImageDimension2D); 5 MAX_ARRAY_TEXTURE_LAYERS 256 256 maxImageArrayLayers 6 MAX_TEXTURE_LOD_BIAS 14 14 maxSamplerLodBias 7 MAX_CUBE_MAP_TEXTURE_SIZE 8192 8192 maxImageDimensionCube 8 MAX_RENDERBUFFER_SIZE 8192 8192 min(maxImageDimension2D, maxFramebufferWidth, maxFramebufferHeight); 9 ALIASED_LINE_WIDTH_RANGE[0] 1 1 1 10 ALIASED_LINE_WIDTH_RANGE[1] 4095.9375 1 1 11 ALIASED_POINT_SIZE_RANGE[0] 1 1 max(1.0f, pointSizeRange[0]) 12 ALIASED_POINT_SIZE_RANGE[1] 1024 1024 pointSizeRange[1] 13 MULTISAMPLE_LINE_WIDTH_RANGE [1.0, 4095.9375] - - 14 MULTISAMPLE_LINE_WIDTH_GRANULARITY 0.125 - - 15 MAX_DRAW_BUFFERS 4 4 min(maxColorAttachments, maxFragmentOutputAttachments); 16 MAX_FRAMEBUFFER_WIDTH 8192 8192 maxFramebufferWidth 17 MAX_FRAMEBUFFER_HEIGHT 8192 8192 maxFramebufferHeight 18 MAX_FRAMEBUFFER_LAYERS 256 256 maxFramebufferLayers 19 MAX_FRAMEBUFFER_SAMPLES SAMPLECOUNT1 - SAMPLE_COUNT_4 4 \u540c maxSamples 21 MAX_COLOR_ATTACHMENTS 4 4 maxColorAttachments 22 MIN_FRAGMENT_INTERPOLATION_OFFSET -0.5 -0.5 minInterpolationOffset 23 MAX_FRAGMENT_INTERPOLATION_OFFSET 0.5 0.4375 maxInterpolationOffset 24 FRAGMENT_INTERPOLATION_OFFSET_BITS 4 4 subPixelInterpolationOffsetBits 25 MAX_VIEWPORT_DIMS[0] 8192 8192 maxViewportDimensions[0] 26 MAX_VIEWPORT_DIMS[1] 8192 8192 maxViewportDimensions[1] 27 MAX_SAMPLE_MASK_WORDS 1 1 maxSampleMaskWords 28 MAX_COLOR_TEXTURE_SAMPLES SAMPLECOUNT1 ??? SAMPLECOUNT1-SAMPLECOUNT4? sampledImageColorSampleCounts&31 29 SAMPLE_COUNT_4 - - 30 MAX_DEPTH_TEXTURE_SAMPLES SAMPLECOUNT1 ??? SAMPLECOUNT1-SAMPLECOUNT4? sampledImageDepthSampleCounts&31 31 SAMPLE_COUNT_4 - - 32 MAX_INTEGER_SAMPLES SAMPLECOUNT1 ??? SAMPLECOUNT1-SAMPLECOUNT4? sampledImageIntegerSampleCounts&31 33 SAMPLE_COUNT_4 - - 34 MAX_SERVER_WAIT_TIMEOUT 0 - UNIMPLEMENT 35 LAYER_PROVOKING_VERTEX FIRSTVERTEXCONVENTION - GL_LAST_VERTEX_CONVENTION_EXT 36 LAST_VERTEX_CONVENTION - -- 37 PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED FALSE - -- 38 MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 2047 2047 min(maxVertexInputAttributeOffset, (int16_max -1)) 39 MAX_VERTEX_ATTRIB_BINDINGS 16 16 maxVertexInputBindings 40 MAX_VERTEX_ATTRIB_STRIDE 2048 2048 min(maxVertexInputBindingStride, int16_max) 41 MAX_ELEMENTS_INDICES INT_MAX INT_MAX 42 MAX_ELEMENTS_VERTICES INT_MAX INT_MAX 43 MAX_ELEMENT_INDEX 0xFFFFFFFF UINT_MAX - 1 UINT_MAX - 1 44 MAX_TEXTURE_BUFFER_SIZE 2^24 ??? 224 maxTexelBufferElements 45 NUM_COMPRESSED_TEXTURE_FORMATS 49 -- -- // size of Compressed Texture Formats 46 COMPRESSED_TEXTURE_FORMATS -- -- 47 NUM_PROGRAM_BINARY_FORMATS 0 -- -- 48 PROGRAM_BINARY_FORMATS -- -- 49 NUM_SHADER_BINARY_FORMATS 0 -- -- 50 SHADER_BINARY_FORMATS -- -- 51 SHADER_COMPILER TRUE TRUE 52 TEXTURE_BUFFER_OFFSET_ALIGNMENT 256 256 minTexelBufferOffsetAlignment 53 MAX_TEXTURE_MAX_ANISOTROPY_EXT 16 16 maxSamplerAnisotropy 54 MAX_VERTEX_ATTRIBS 16 16 maxVertexInputAttributes 55 MAX_VERTEX_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 56 MAX_VERTEX_UNIFORM_VECTORS 256 1024 maxUniformBufferRange / (sizeof(float) *4) 57 MAX_VERTEX_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 58 MAX_VERTEX_OUTPUT_COMPONENTS 128 128 maxVertexOutputComponents 59 MAX_VERTEX_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 60 MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0 0 0* 61 MAX_VERTEX_ATOMIC_COUNTERS 0 0 0* 62 MAX_VERTEX_SHADER_STORAGE_BLOCKS 0 0 0* 63 MAX_TESS_GEN_LEVEL 64 -- 64 MAX_PATCH_VERTICES 32 -- 65 MAX_TESS_CONTROL_UNIFORM_COMPONENTS 1024 -- 66 MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 16 -- 67 MAX_TESS_CONTROL_OUTPUT_COMPONENTS 128 -- 68 MAX_TESS_PATCH_COMPONENTS 120 -- 69 MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 4096 -- 70 MAX_TESS_CONTROL_INPUT_COMPONENTS 128 -- 71 MAX_TESS_CONTROL_UNIFORM_BLOCKS 12 -- 72 MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0 -- 73 MAX_TESS_CONTROL_ATOMIC_COUNTERS 0 -- 74 MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0 -- 75 MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 1024 -- 76 MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 16 -- 77 MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 128 -- 78 MAX_TESS_EVALUATION_INPUT_COMPONENTS 128 -- 79 MAX_TESS_EVALUATION_UNIFORM_BLOCKS 12 -- 80 MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0 -- 81 MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0 -- 82 MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0 -- 83 MAX_GEOMETRY_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 84 MAX_GEOMETRY_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 85 MAX_GEOMETRY_INPUT_COMPONENTS 128 128 maxGeometryInputComponents 86 MAX_GEOMETRY_OUTPUT_COMPONENTS 128 128 maxGeometryOutputComponents 87 MAX_GEOMETRY_OUTPUT_VERTICES 256 256 maxGeometryOutputVertices 88 MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 1024 1024 maxGeometryTotalOutputComponents 89 MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 90 MAX_GEOMETRY_SHADER_INVOCATIONS 32 32 maxGeometryShaderInvocations 91 MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0 8* 8* 92 MAX_GEOMETRY_ATOMIC_COUNTERS 0 56 maxStorageBufferRange / sizeof(uint32_t) 93 MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0 45 maxPerStageResources-7 94 MAX_FRAGMENT_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 95 MAX_FRAGMENT_UNIFORM_VECTORS 256 1024 maxUniformBufferRange / (sizeof(float) *4) 96 MAX_FRAGMENT_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 97 MAX_FRAGMENT_INPUT_COMPONENTS 128 4,096\u202c maxUniformBufferRange / sizeof(float) 98 MAX_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 99 MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 1 8 8* 100 MAX_FRAGMENT_ATOMIC_COUNTERS 8 56 maxStorageBufferRange / sizeof(uint32_t) 101 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 8 4 4* 102 MIN_PROGRAM_TEXTURE_GATHER_OFFSET -8 -8 minTexelGatherOffset 103 MAX_PROGRAM_TEXTURE_GATHER_OFFSET 7 7 maxTexelGatherOffset 104 MIN_PROGRAM_TEXEL_OFFSET -8 -8 minTexelOffset 105 MAX_PROGRAM_TEXEL_OFFSET 7 7 maxTexelOffset 106 MAX_COMPUTE_WORK_GROUP_COUNT[0] 65535 65535 maxComputeWorkGroupCount[0] 107 MAX_COMPUTE_WORK_GROUP_COUNT[1] 65535 65535 maxComputeWorkGroupCount[1] 108 MAX_COMPUTE_WORK_GROUP_COUNT[2] 65535 65535 maxComputeWorkGroupCount[2] 109 MAX_COMPUTE_WORK_GROUP_SIZE[0] 1024 1024 [vulkan] maxComputeWorkGroupSize[0] 110 MAX_COMPUTE_WORK_GROUP_SIZE[1] 1024 1024 [vulkan] maxComputeWorkGroupSize[1] 111 MAX_COMPUTE_WORK_GROUP_SIZE[2] 64 64 [vulkan] maxComputeWorkGroupSize[2] 112 MAX_COMPUTE_WORK_GROUP_INVOCATIONS 1024 1024 [vulkan] maxComputeWorkGroupInvocations 113 MAX_COMPUTE_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 114 MAX_COMPUTE_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 115 MAX_COMPUTE_SHARED_MEMORY_SIZE 32768 32768 maxComputeSharedMemorySize 116 MAX_COMPUTE_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 117 MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 1 8 8* 118 MAX_COMPUTE_ATOMIC_COUNTERS 8 56 maxStorageBufferRange / sizeof(uint32_t) 119 MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 120 MAX_COMPUTE_SHADER_STORAGE_BLOCKS 8 4 maxPerStageDescriptorStorageBuffers - 8 121 MAX_UNIFORM_BUFFER_BINDINGS 72 68 maxDescriptorSetUniformBuffers -4 122 MAX_UNIFORM_BLOCK_SIZE 16384 16384 maxUniformBufferRange 123 UNIFORM_BUFFER_OFFSET_ALIGNMENT 16 16 minUniformBufferOffsetAlignment 124 MAX_COMBINED_UNIFORM_BLOCKS 72 68 maxDescriptorSetUniformBuffers -4 125 MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 126 MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 50176 -- 127 MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 50176 -- 128 MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 129 MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 130 MAX_VARYING_COMPONENTS 124 116 (min(maxVertexOutputComponents, maxFragmentInputComponents) /4 - 3)*4 131 MAX_VARYING_VECTORS 31 29 min(maxVertexOutputComponents, maxFragmentInputComponents) /4 - 3 132 MAX_COMBINED_TEXTURE_IMAGE_UNITS 96 96 min(maxDescriptorSetSamplers, maxDescriptorSetSampledImages); 133 MAX_COMBINED_SHADER_OUTPUT_RESOURCES 20 45 maxPerStageResources-7 134 MAX_UNIFORM_LOCATIONS 1024 1024 maxUniformBufferRange / (sizeof(float) *4) 135 MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 1 8 8* 136 MAX_ATOMIC_COUNTER_BUFFER_SIZE 32 227 maxStorageBufferRange 137 MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 1 8 8* 138 MAX_COMBINED_ATOMIC_COUNTERS 8 56 maxStorageBufferRange / sizeof(uint32_t) 139 MAX_IMAGE_UNITS 8 48 maxDescriptorSetStorageImages 140 MAX_VERTEX_IMAGE_UNIFORMS 0 0 0* 141 MAX_TESS_CONTROL_IMAGE_UNIFORMS 0 -- -- 142 MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0 -- -- 143 MAX_GEOMETRY_IMAGE_UNIFORMS 0 0 0* 144 MAX_FRAGMENT_IMAGE_UNIFORMS 8 8 maxPerStageDescriptorStorageImages* 145 MAX_COMPUTE_IMAGE_UNIFORMS 8 8 maxPerStageDescriptorStorageImages* 146 MAX_COMBINED_IMAGE_UNIFORMS 8 48 maxDescriptorSetStorageImages 147 MAX_SHADER_STORAGE_BUFFER_BINDINGS 4 40 maxDescriptorSetStorageBuffers - 8* 148 MAX_SHADER_STORAGE_BLOCK_SIZE 2^27 ??? 227 maxStorageBufferRange 149 MAX_COMBINED_SHADER_STORAGE_BLOCKS 8 40 maxDescriptorSetStorageBuffers - 8* 150 SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 256 256 minStorageBufferOffsetAlignment 151 MAX_LABEL_LENGTH 256 1024 1024 152 MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 64 128 128 153 MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 4 4 4 154 MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 4 4 4 155 MAX_SAMPLES 4 4 SAMPLE_COUNT_1 - SAMPLE_COUNT_4 156 MAX_SERVER_WAIT_TIMEOUT 0 -- UNIMPLEMENT 157 MAX_VIEWS_OVR 6 1 1 \u5176\u4ed6 Properties // Provided by VK_VERSION_1_0 typedef struct VkQueueFamilyProperties { VkQueueFlags queueFlags; uint32_t queueCount; uint32_t timestampValidBits; VkExtent3D minImageTransferGranularity; } VkQueueFamilyProperties; \u9700\u6c42: VkQueueFamilyProperties. timestampValidBits > 0 \u652f\u6301 GLES EXT: GL_EXT_disjoint_timer_query disjointTimerQuery \u9644\u5f55 v100 GLES Extension \u652f\u6301\u60c5\u51b5 \u4ece GLES Extensions \u89c6\u89d2, \u67e5\u8be2\u6240\u9700\u7684 Vk \u652f\u6301. OpenGL ES Extension in v100 ANGLE \u652f\u6301 ANGLE \u652f\u6301\u6761\u4ef6 Vulkan (v100) \u6ee1\u8db3 GL_EXT_multi_draw_indirect UNIMPLEMENTED GL_EXT_debug_marker Y GL_ARM_rgba8 GL_ARM_mali_shader_binary GL_OES_depth24 Y GL_OES_depth_texture Y GL_OES_depth_texture_cube_map Y GL_OES_packed_depth_stencil Y GL_OES_rgb8_rgba8 Y GL_EXT_read_format_bgra Y GL_OES_compressed_paletted_texture GL_OES_compressed_ETC1_RGB8_texture Y GL_OES_standard_derivatives Y GL_OES_EGL_image Y GL_OES_EGL_image_external Y GL_OES_EGL_image_external_essl3 Y GL_OES_EGL_sync Y GL_OES_texture_npot Y GL_OES_vertex_half_float Y GL_OES_required_internalformat GL_OES_vertex_array_object Y GL_OES_mapbuffer Y GL_EXT_texture_format_BGRA8888 Y GL_EXT_texture_rg Y GL_EXT_texture_type_2_10_10_10_REV Y GL_OES_fbo_render_mipmap Y GL_OES_element_index_uint Y GL_EXT_shadow_samplers Y GL_KHR_texture_compression_astc_ldr GL_KHR_debug Y GL_EXT_occlusion_query_boolean Y GL_EXT_disjoint_timer_query Y GL_EXT_blend_minmax Y GL_EXT_discard_framebuffer Y GL_OES_get_program_binary Y GL_OES_texture_3D Y GL_EXT_texture_storage Y GL_EXT_multisampled_render_to_texture Y GL_OES_surfaceless_context Y GL_OES_texture_stencil8 Y GL_EXT_shader_pixel_local_storage GL_ARM_shader_framebuffer_fetch GL_ARM_shader_framebuffer_fetch_depth_stencil GL_EXT_shader_framebuffer_fetch_non_coherent GL_ARM_mali_program_binary GL_EXT_sRGB Y GL_EXT_sRGB_write_control GL_EXT_texture_sRGB_decode Y GL_EXT_texture_sRGB_R8 Y GL_EXT_texture_sRGB_RG8 GL_KHR_blend_equation_advanced GL_KHR_blend_equation_advanced_coherent GL_OES_texture_storage_multisample_2d_array Y GL_OES_shader_image_atomic Y GL_EXT_robustness Y GL_EXT_draw_buffers_indexed Y GL_OES_draw_buffers_indexed Y GL_EXT_texture_border_clamp GL_OES_texture_border_clamp GL_EXT_texture_cube_map_array Y GL_OES_texture_cube_map_array Y GL_OES_sample_variables Y GL_OES_sample_shading Y GL_OES_shader_multisample_interpolation GL_EXT_shader_io_blocks GL_OES_shader_io_blocks GL_EXT_tessellation_shader GL_OES_tessellation_shader GL_EXT_primitive_bounding_box GL_OES_primitive_bounding_box GL_EXT_geometry_shader Y GL_OES_geometry_shader GL_ANDROID_extension_pack_es31a GL_EXT_gpu_shader5 Y GL_OES_gpu_shader5 GL_EXT_texture_buffer Y GL_OES_texture_buffer Y GL_EXT_copy_image Y GL_OES_copy_image GL_EXT_shader_non_constant_global_initializers Y GL_EXT_color_buffer_half_float Y GL_EXT_color_buffer_float Y GL_EXT_YUV_target GL_OVR_multiview GL_OVR_multiview2 GL_OVR_multiview_multisampled_render_to_texture GL_KHR_robustness GL_KHR_robust_buffer_access_behavior GL_EXT_draw_elements_base_vertex Y GL_OES_draw_elements_base_vertex Y GL_EXT_protected_textures GL_EXT_geometry_point_size GL_OES_geometry_point_size GL_EXT_tessellation_point_size GL_OES_tessellation_point_size GL_OES_draw_texture v100 EGL Extension EGL extensions EGL_KHR_get_all_proc_addresses EGL_ANDROID_presentation_time EGL_KHR_swap_buffes_witn_damage EGL_ANDROID_get_native_client_buffer EGL_ANDROID_front_buffer_auto_refresh EGL_ANDROID_get_frame_timestamps EGL_KHR_image EGL_KHR_image_base EGL_KHR_gl_colorspace EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_gl_renderbuffer_image EGL_KHR_fence_sync EGL_KHR_create_context EGL_KHR_config_attribs EGL_KHR_surfaceless_context EGL_EXT_create_context_robustness EGL_ANDROID_image_native_buffer EGL_KHR_wait_sync EGL_ANDROID_recordable EGL_KHR_partial_update EGL_KHR_mutable_render_buffer EGL_EXT_protected_content EGL_IMG_context_priority ANGLE \u4e2d\u542f\u7528\u7684 Vk Features Vulkan_1_0 Features: // Select additional features to be enabled. mPhysicalDeviceFeatures{ // Used to support cubemap array: only enable when not SwiftShader or not Qualcomm imageCubeArray; // Used to support framebuffers with multiple attachments: independentBlend; // Used to support robust buffer access: robustBufferAccess; // Used to support Anisotropic filtering: samplerAnisotropy; // Used to support wide lines: wideLines; // Used to emulate transform feedback: vertexPipelineStoresAndAtomics; // Used to implement storage buffers and images in the fragment shader: fragmentStoresAndAtomics; // Used to support geometry shaders: geometryShader // Used to support EXT_gpu_shader5: shaderImageGatherExtended; // Used to support EXT_gpu_shader5: shaderUniformBufferArrayDynamicIndexing // Used to support EXT_gpu_shader5 and sampler array of array emulation: shaderSampledImageArrayDynamicIndexing; // Used to support atomic counter emulation: shaderStorageBufferArrayDynamicIndexing; // Used to support APPLE_clip_distance shaderClipDistance // Used to support OES_sample_shading sampleRateShading; // Used to support depth clears through draw calls. depthClamp; // if (!vk::CommandBuffer::ExecutesInline()) inheritedQueries; // Used to support OES_sample_variables sampleRateShading; } Extension Features: VkPhysicalDeviceLineRasterizationFeaturesEXT VkPhysicalDeviceProvokingVertexFeaturesEXT VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT VkPhysicalDeviceTransformFeedbackFeaturesEXT VkPhysicalDeviceIndexTypeUint8FeaturesEXT VkPhysicalDeviceShaderFloat16Int8FeaturesKHR VkPhysicalDeviceSamplerYcbcrConversionFeatures 8. Appendix 8.1. Capability The recommended value for vulkan 1.1 features and limits report for HiVoyager V100 chip are listed in this chapter. 8.1.1. Physical Device Features Feature Supported on HiVoyager V100 robustBufferAccess yes fullDrawIndexUint32 yes imageCubeArray yes independentBlend yes geometryShader yes tessellationShader yes sampleRateShading yes dualSrcBlend no logicOp no multiDrawIndirect yes drawIndirectFirstInstance yes depthClamp yes depthBiasClamp yes fillModeNonSolid yes depthBounds yes wideLines yes largePoints yes alphaToOne yes multiViewport no samplerAnisotropy yes textureCompressionETC2 yes textureCompressionASTC_LDR yes textureCompressionBC no occlusionQueryPrecise yes pipelineStatisticsQuery no vertexPipelineStoresAndAtomics no fragmentStoresAndAtomics yes shaderTessellationAndGeometryPointSize yes shaderImageGatherExtended yes shaderStorageImageExtendedFormats yes shaderStorageImageMultisample no shaderStorageImageReadWithoutFormat yes shaderStorageImageWriteWithoutFormat yes shaderUniformBufferArrayDynamicIndexing yes shaderSampledImageArrayDynamicIndexing yes shaderStorageBufferArrayDynamicIndexing yes shaderStorageImageArrayDynamicIndexing yes shaderClipDistance yes shaderCullDistance yes shaderFloat64 no shaderInt64 no shaderInt16 yes shaderResourceResidency no shaderResourceMinLod no sparseBinding no sparseResidencyBuffer no sparseResidencyImage2D no sparseResidencyImage3D no sparseResidency2Samples no sparseResidency4Samples no sparseResidency8Samples no sparseResidency16Samples no sparseResidencyAliased no variableMultisampleRate no inheritedQueries no 8.1.2. Physical Device Limits Name Limit of HiVoyager V100 maxImageDimension1D 8192 maxImageDimension2D 8192[ 1 ] maxImageDimension3D 256 maxImageDimensionCube 8192 maxImageArrayLayers 256 maxTexelBufferElements 224 maxUniformBufferRange 16384 maxStorageBufferRange 227 maxPushConstantsSize 256 maxMemoryAllocationCount 232-1 maxSamplerAllocationCount 223 bufferImageGranularity 4096 sparseAddressSpaceSize 0 maxBoundDescriptorSets 4 maxPerStageDescriptorSamplers 16 maxPerStageDescriptorUniformBuffers 12 maxPerStageDescriptorStorageBuffers 8 maxPerStageDescriptorSampledImages 16 maxPerStageDescriptorStorageImages 8[ 2 ] maxPerStageDescriptorInputAttachments 4 maxPerStageResources 52 maxDescriptorSetSamplers 96 maxDescriptorSetUniformBuffers 72 maxDescriptorSetUniformBuffersDynamic 8 maxDescriptorSetStorageBuffers 48 maxDescriptorSetStorageBuffersDynamic 4 maxDescriptorSetSampledImages 96 maxDescriptorSetStorageImages 48 maxDescriptorSetInputAttachments 4 maxVertexInputAttributes 16 maxVertexInputBindings 16 maxVertexInputAttributeOffset 2047 maxVertexInputBindingStride 2048 maxVertexOutputComponents 128 maxTessellationGenerationLevel 64 maxTessellationPatchSize 32 maxTessellationControlPerVertexInputComponents 128 maxTessellationControlPerVertexOutputComponents 128 maxTessellationControlPerPatchOutputComponents 120 maxTessellationControlTotalOutputComponents 4096 maxTessellationEvaluationInputComponents 128 maxTessellationEvaluationOutputComponents 128 maxGeometryShaderInvocations 32 maxGeometryInputComponents 128 maxGeometryOutputComponents 128 maxGeometryOutputVertices 256 maxGeometryTotalOutputComponents 1024 maxFragmentInputComponents 128 maxFragmentOutputAttachments 4 maxFragmentDualSrcAttachments 1 maxFragmentCombinedOutputResources 20 maxComputeSharedMemorySize 32768 maxComputeWorkGroupCount[0] 65535 maxComputeWorkGroupCount[1] 65535 maxComputeWorkGroupCount[2] 65535 maxComputeWorkGroupInvocations 384 [v120, opencl] maxComputeWorkGroupInvocations 256 [v100, opencl] maxComputeWorkGroupInvocations 1024 [vulkan] maxComputeWorkGroupSize[0] 256 [opencl] maxComputeWorkGroupSize[0] 1024 [vulkan] maxComputeWorkGroupSize[1] 256 [v120, opencl] maxComputeWorkGroupSize[1] 32 [v100, opencl] maxComputeWorkGroupSize[1] 1024 [vulkan] maxComputeWorkGroupSize[2] 64 [v120, opencl] maxComputeWorkGroupSize[2] 2 [v100, opencl] maxComputeWorkGroupSize[2] 64 [vulkan] subPixelPrecisionBits 8 subTexelPrecisionBits 8 mipmapPrecisionBits 6 maxDrawIndexedIndexValue 0xFFFFFFFF maxDrawIndirectCount 232-1 maxSamplerLodBias 14 maxSamplerAnisotropy 16 maxViewports 1 maxViewportDimensions[0] 8192 maxViewportDimensions[1] 8192 viewportBoundsRange[0] -16384 viewportBoundsRange[1] 16383 viewportSubPixelBits 0 minMemoryMapAlignment 64 minTexelBufferOffsetAlignment 256 minUniformBufferOffsetAlignment 16 minStorageBufferOffsetAlignment 256 minTexelOffset -8 maxTexelOffset 7 minTexelGatherOffset -8 maxTexelGatherOffset 7 minInterpolationOffset -0.5 maxInterpolationOffset 0.4375 subPixelInterpolationOffsetBits 4 maxFramebufferWidth 8192 maxFramebufferHeight 8192 maxFramebufferLayers 256 framebufferColorSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 framebufferDepthSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 framebufferStencilSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 framebufferNoAttachmentsSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 maxColorAttachments 4 sampledImageColorSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 sampledImageIntegerSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 sampledImageDepthSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 sampledImageStencilSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 storageImageSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 maxSampleMaskWords 1 timestampComputeAndGraphics yes timestampPeriod 52.083333333 (1000/19.2) maxClipDistances 8 maxCullDistances 8 maxCombinedClipAndCullDistances 8 discreteQueuePriorities 2 pointSizeRange[0] 1.0 pointSizeRange[1] 1024.0 lineWidthRange[0] 1.0 lineWidthRange[1] 4095.9375 pointSizeGranularity 0.1 lineWidthGranularity 0.1 strictLines yes standardSampleLocations yes optimalBufferCopyOffsetAlignment 512 optimalBufferCopyRowPitchAlignment 512 nonCoherentAtomSize 64 maxUpdateAfterBindDescriptorsInAllPools 500000 maxMultiviewViewCount 6 Actually the hardware ability of maxImageDimension2D is 16384 . According to driver\u2019s requirement, maxImageDimension2D is set to 8192 . Do not support image load store for vertex pipeline in GLES; Do not support image store for vertex pipeline in Vulkan. 8.1.3. Physical Device Limits OpenGLES Name Limit of HiVoyager V100 SUBPIXEL_BITS 8 MAX_3D_TEXTURE_SIZE 256 MAX_TEXTURE_SIZE 8192 MAX_ARRAY_TEXTURE_LAYERS 256 MAX_TEXTURE_LOD_BIAS 14 MAX_CUBE_MAP_TEXTURE_SIZE 8192 MAX_RENDERBUFFER_SIZE 8192 ALIASED_LINE_WIDTH_RANGE[0] 1.0 ALIASED_LINE_WIDTH_RANGE[1] 4095.9375 ALIASED_POINT_SIZE_RANGE[0] 1.0 ALIASED_POINT_SIZE_RANGE[1] 1024.0 MULTISAMPLE_LINE_WIDTH_RANGE [1.0, 4095.9375] MULTISAMPLE_LINE_WIDTH_GRANULARITY 0.125 MAX_DRAW_BUFFERS 4 MAX_FRAMEBUFFER_WIDTH 8192 MAX_FRAMEBUFFER_HEIGHT 8192 MAX_FRAMEBUFFER_LAYERS 256 MAX_FRAMEBUFFER_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_COLOR_ATTACHMENTS 4 MIN_FRAGMENT_INTERPOLATION_OFFSET -0.5 MAX_FRAGMENT_INTERPOLATION_OFFSET 0.5 FRAGMENT_INTERPOLATION_OFFSET_BITS 4 MAX_VIEWPORT_DIMS[0] 8192 MAX_VIEWPORT_DIMS[1] 8192 MAX_SAMPLE_MASK_WORDS 1 MAX_COLOR_TEXTURE_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_DEPTH_TEXTURE_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_INTEGER_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_SERVER_WAIT_TIMEOUT 0 LAYER_PROVOKING_VERTEX FIRST_VERTEX_CONVENTION LAST_VERTEX_CONVENTION PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED FALSE MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 2047 MAX_VERTEX_ATTRIB_BINDINGS 16 MAX_VERTEX_ATTRIB_STRIDE 2048 MAX_ELEMENTS_INDICES MAX_ELEMENTS_VERTICES MAX_ELEMENT_INDEX 0xFFFFFFFF MAX_TEXTURE_BUFFER_SIZE 2^24 NUM_COMPRESSED_TEXTURE_FORMATS 49 COMPRESSED_TEXTURE_FORMATS NUM_PROGRAM_BINARY_FORMATS 0 PROGRAM_BINARY_FORMATS NUM_SHADER_BINARY_FORMATS 0 SHADER_BINARY_FORMATS SHADER_COMPILER TEXTURE_BUFFER_OFFSET_ALIGNMENT 256 MAX_TEXTURE_MAX_ANISOTROPY_EXT 16 MAX_VERTEX_ATTRIBS 16 MAX_VERTEX_UNIFORM_COMPONENTS 1024 MAX_VERTEX_UNIFORM_VECTORS 256 MAX_VERTEX_UNIFORM_BLOCKS 12 MAX_VERTEX_OUTPUT_COMPONENTS 128 MAX_VERTEX_TEXTURE_IMAGE_UNITS 16 MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0 MAX_VERTEX_ATOMIC_COUNTERS 0 MAX_VERTEX_SHADER_STORAGE_BLOCKS 0 MAX_TESS_GEN_LEVEL 64 MAX_PATCH_VERTICES 32 MAX_TESS_CONTROL_UNIFORM_COMPONENTS 1024 MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 16 MAX_TESS_CONTROL_OUTPUT_COMPONENTS 128 MAX_TESS_PATCH_COMPONENTS 120 MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 4096 MAX_TESS_CONTROL_INPUT_COMPONENTS 128 MAX_TESS_CONTROL_UNIFORM_BLOCKS 12 MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0 MAX_TESS_CONTROL_ATOMIC_COUNTERS 0 MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0 MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 1024 MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 16 MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 128 MAX_TESS_EVALUATION_INPUT_COMPONENTS 128 MAX_TESS_EVALUATION_UNIFORM_BLOCKS 12 MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0 MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0 MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0 MAX_GEOMETRY_UNIFORM_COMPONENTS 1024 MAX_GEOMETRY_UNIFORM_BLOCKS 12 MAX_GEOMETRY_INPUT_COMPONENTS 128 MAX_GEOMETRY_OUTPUT_COMPONENTS 128 MAX_GEOMETRY_OUTPUT_VERTICES 256 MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 1024 MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 16 MAX_GEOMETRY_SHADER_INVOCATIONS 32 MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0 MAX_GEOMETRY_ATOMIC_COUNTERS 0 MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0 MAX_FRAGMENT_UNIFORM_COMPONENTS 1024 MAX_FRAGMENT_UNIFORM_VECTORS 256 MAX_FRAGMENT_UNIFORM_BLOCKS 12 MAX_FRAGMENT_INPUT_COMPONENTS 128 MAX_TEXTURE_IMAGE_UNITS 16 MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 1 MAX_FRAGMENT_ATOMIC_COUNTERS 8 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 8 MIN_PROGRAM_TEXTURE_GATHER_OFFSET -8 MAX_PROGRAM_TEXTURE_GATHER_OFFSET 7 MIN_PROGRAM_TEXEL_OFFSET -8 MAX_PROGRAM_TEXEL_OFFSET 7 MAX_COMPUTE_WORK_GROUP_COUNT[0] 65535 MAX_COMPUTE_WORK_GROUP_COUNT[1] 65535 MAX_COMPUTE_WORK_GROUP_COUNT[2] 65535 MAX_COMPUTE_WORK_GROUP_SIZE[0] 1024 MAX_COMPUTE_WORK_GROUP_SIZE[1] 1024 MAX_COMPUTE_WORK_GROUP_SIZE[2] 64 MAX_COMPUTE_WORK_GROUP_INVOCATIONS 1024 MAX_COMPUTE_UNIFORM_BLOCKS 12 MAX_COMPUTE_TEXTURE_IMAGE_UNITS 16 MAX_COMPUTE_SHARED_MEMORY_SIZE 32768 MAX_COMPUTE_UNIFORM_COMPONENTS 1024 MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 1 MAX_COMPUTE_ATOMIC_COUNTERS 8 MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 50176 MAX_COMPUTE_SHADER_STORAGE_BLOCKS 8 MAX_UNIFORM_BUFFER_BINDINGS 72 MAX_UNIFORM_BLOCK_SIZE 16384 UNIFORM_BUFFER_OFFSET_ALIGNMENT 16 MAX_COMBINED_UNIFORM_BLOCKS 72 MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 50176 MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 50176 MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 50176 MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 50176 MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 50176 MAX_VARYING_COMPONENTS 124 MAX_VARYING_VECTORS 31 MAX_COMBINED_TEXTURE_IMAGE_UNITS 96 MAX_COMBINED_SHADER_OUTPUT_RESOURCES 20 MAX_UNIFORM_LOCATIONS 1024 MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 1 MAX_ATOMIC_COUNTER_BUFFER_SIZE 32 MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 1 MAX_COMBINED_ATOMIC_COUNTERS 8 MAX_IMAGE_UNITS 8 MAX_VERTEX_IMAGE_UNIFORMS 0 MAX_TESS_CONTROL_IMAGE_UNIFORMS 0 MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0 MAX_GEOMETRY_IMAGE_UNIFORMS 0 MAX_FRAGMENT_IMAGE_UNIFORMS 8 MAX_COMPUTE_IMAGE_UNIFORMS 8 MAX_COMBINED_IMAGE_UNIFORMS 8 MAX_SHADER_STORAGE_BUFFER_BINDINGS 4 MAX_SHADER_STORAGE_BLOCK_SIZE 2^27 MAX_COMBINED_SHADER_STORAGE_BLOCKS 8 SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 256 MAX_LABEL_LENGTH 256 MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 64 MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 4 MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 4 MAX_SAMPLES 4 MAX_SERVER_WAIT_TIMEOUT 0 MAX_VIEWS_OVR 6 8.2. Extension OpenGL ES, EGL and Vulkan extension for HiVoyager V100 chip are listed in this chapter. 8.2.1. OpenGL ES Extension OpenGL ES Extension GL_EXT_multi_draw_indirect GL_EXT_debug_marker GL_ARM_rgba8 GL_ARM_mali_shader_binary GL_OES_depth24 GL_OES_depth_texture GL_OES_depth_texture_cube_map GL_OES_packed_depth_stencil GL_OES_rgb8_rgba8 GL_EXT_read_format_bgra GL_OES_compressed_paletted_texture GL_OES_compressed_ETC1_RGB8_texture GL_OES_standard_derivatives GL_OES_EGL_image GL_OES_EGL_image_external GL_OES_EGL_image_external_essl3 GL_OES_EGL_sync GL_OES_texture_npot GL_OES_vertex_half_float GL_OES_required_internalformat GL_OES_vertex_array_object GL_OES_mapbuffer GL_EXT_texture_format_BGRA8888 GL_EXT_texture_rg GL_EXT_texture_type_2_10_10_10_REV GL_OES_fbo_render_mipmap GL_OES_element_index_uint GL_EXT_shadow_samplers GL_KHR_texture_compression_astc_ldr GL_KHR_debug GL_EXT_occlusion_query_boolean GL_EXT_disjoint_timer_query GL_EXT_blend_minmax GL_EXT_discard_framebuffer GL_OES_get_program_binary GL_OES_texture_3D GL_EXT_texture_storage GL_EXT_multisampled_render_to_texture GL_OES_surfaceless_context GL_OES_texture_stencil8 GL_EXT_shader_pixel_local_storage GL_ARM_shader_framebuffer_fetch GL_ARM_shader_framebuffer_fetch_depth_stencil GL_EXT_shader_framebuffer_fetch_non_coherent GL_ARM_mali_program_binary GL_EXT_sRGB GL_EXT_sRGB_write_control GL_EXT_texture_sRGB_decode GL_EXT_texture_sRGB_R8 GL_EXT_texture_sRGB_RG8 GL_KHR_blend_equation_advanced GL_KHR_blend_equation_advanced_coherent GL_OES_texture_storage_multisample_2d_array GL_OES_shader_image_atomic GL_EXT_robustness GL_EXT_draw_buffers_indexed GL_OES_draw_buffers_indexed GL_EXT_texture_border_clamp GL_OES_texture_border_clamp GL_EXT_texture_cube_map_array GL_OES_texture_cube_map_array GL_OES_sample_variables GL_OES_sample_shading GL_OES_shader_multisample_interpolation GL_EXT_shader_io_blocks GL_OES_shader_io_blocks GL_EXT_tessellation_shader GL_OES_tessellation_shader GL_EXT_primitive_bounding_box GL_OES_primitive_bounding_box GL_EXT_geometry_shader GL_OES_geometry_shader GL_ANDROID_extension_pack_es31a GL_EXT_gpu_shader5 GL_OES_gpu_shader5 GL_EXT_texture_buffer GL_OES_texture_buffer GL_EXT_copy_image GL_OES_copy_image GL_EXT_shader_non_constant_global_initializers GL_EXT_color_buffer_half_float GL_EXT_color_buffer_float GL_EXT_YUV_target GL_OVR_multiview GL_OVR_multiview2 GL_OVR_multiview_multisampled_render_to_texture GL_KHR_robustness GL_KHR_robust_buffer_access_behavior GL_EXT_draw_elements_base_vertex GL_OES_draw_elements_base_vertex GL_EXT_protected_textures GL_EXT_geometry_point_size GL_OES_geometry_point_size GL_EXT_tessellation_point_size GL_OES_tessellation_point_size GL_OES_draw_texture 8.2.2. EGL Extension EGL extensions EGL_KHR_get_all_proc_addresses EGL_ANDROID_presentation_time EGL_KHR_swap_buffes_witn_damage EGL_ANDROID_get_native_client_buffer EGL_ANDROID_front_buffer_auto_refresh EGL_ANDROID_get_frame_timestamps EGL_KHR_image EGL_KHR_image_base EGL_KHR_gl_colorspace EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_gl_renderbuffer_image EGL_KHR_fence_sync EGL_KHR_create_context EGL_KHR_config_attribs EGL_KHR_surfaceless_context EGL_EXT_create_context_robustness EGL_ANDROID_image_native_buffer EGL_KHR_wait_sync EGL_ANDROID_recordable EGL_KHR_partial_update EGL_KHR_mutable_render_buffer EGL_EXT_protected_content EGL_IMG_context_priority 8.2.3. Vulkan Extension Vulkan Extension storageBuffer8BitAccess[ 1 ] m[ 2 ] VK_KHR_create_renderpass2 [ 3 ] M VK_KHR_depth_stencil_resolve M supportedDepthResolveModes m supportedStencilResolveModes m VK_KHR_driver_properties M VK_KHR_image_format_list M VK_KHR_imageless_framebuffer M VK_KHR_separate_depth_stencil_layouts M VK_KHR_spirv_1_4 M VK_KHR_timeline_semaphore M VK_KHR_uniform_buffer_standard_layout M uniformBufferStandardLayout M VK_KHR_vulkan_memory_model M vulkanMemoryModel M VK_EXT_buffer_device_address M shaderUniformTexelBufferArrayDynamicIndexing m shaderStorageTexelBufferArrayDynamicIndexing m shaderSampledImageArrayNonUniformIndexing m shaderStorageBufferArrayNonUniformIndexing m shaderUniformTexelBufferArrayNonUniformIndexing m descriptorBindingSampledImageUpdateAfterBind m descriptorBindingStorageBufferUpdateAfterBind m descriptorBindingUniformTexelBufferUpdateAfterBind m descriptorBindingStorageTexelBufferUpdateAfterBind m descriptorBindingUpdateUnusedWhilePending m descriptorBindingPartiallyBound m descriptorBindingVariableDescriptorCount m VK_EXT_host_query_reset M VK_EXT_separate_stencil_usage M VK_KHR_16bit_storage M VK_KHR_bind_memory2 M VK_KHR_dedicated_allocation M VK_KHR_descriptor_update_template M VK_KHR_device_group M VK_KHR_device_group_creation M VK_KHR_external_fence M VK_KHR_external_fence_capabilities M VK_KHR_external_memory M VK_KHR_external_memory_capabilities M VK_KHR_external_semaphore M VK_KHR_external_semaphore_capabilities M VK_KHR_get_memory_requirements2 M VK_KHR_get_physical_device_properties2 M VK_KHR_maintenance1 M VK_KHR_maintenance2 M VK_KHR_maintenance3 M VK_KHR_multiview M multiview m VK_KHR_relaxed_block_layout M VK_KHR_sampler_ycbcr_conversion M VK_KHR_shader_draw_parameters M VK_KHR_storage_buffer_storage_class M VK_KHR_variable_pointers M subgroup M protected memory M instance version enumeration M VkPhysicalDeviceVulkan12Features M imagelessFramebuffer m uniformBufferStandardLayout m separateDepthStencilLayouts m hostQueryReset m timelineSemaphore m subgroupBroadcastDynamicId m VkPhysicalDeviceVulkan11Features M storageBuffer16BitAccess m multiview m VkPhysicalDeviceFeatures M robustBufferAccess M VkPhysicalDeviceSparseProperties O[ 4 ] VkPhysicalDeviceLimits M Linear Formats [ 5 ] M Optimal Formats [ 5 ] M Buffer Formats [ 5 ] M Lowercase character means this is subfunction of the above vulkan extension. M/m means current extension MUST support. Capital character means this is a main vulkan extension. O means current extension OPTIONALLY support. Details of Linear Formats, Optimal Formats and Buffer Formats are shown in Format_constraint_table_1 and Format_constraint_table_2 .","title":"\u603b\u89c8"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#_1","text":"","title":"\u603b\u89c8"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vk-extensions","text":"","title":"Vk Extensions"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#angle-vk-ext-es","text":"Vk Extensions in ANGLE \u5df2\u652f\u6301 vk\u5185\u90e8 es\u6838\u5fc3 es Ext EGL \u5176\u4ed6 Instance Level: WSI: VK_KHR_ANDROID_SURFACE / VK_KHR_WIN32_SURFACE M* \u2714 VK_KHR_SURFACE M* \u2714 VK_EXT_DEBUG_UTILS / VK_EXT_DEBUG_REPORT ?? \u2714 VK_EXT_SWAPCHAIN_COLOR_SPACE ?? \u2714 VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2 \u2714 \u2714 Device Level : VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER \u2714 VK_EXT_QUEUE_FAMILY_FOREIGN \u2714 VK_EXT_DEPTH_CLIP_ENABLE Nvidia VK_EXT_EXTERNAL_MEMORY_HOST MAC VK_EXT_INDEX_TYPE_UINT8 \u2714 VK_EXT_LINE_RASTERIZATION \u2714 VK_EXT_PROVOKING_VERTEX ANGLE EXT VK_EXT_SHADER_STENCIL_EXPORT \u2714 VK_EXT_TRANSFORM_FEEDBACK \u2714 VK_EXT_VERTEX_ATTRIBUTE_DIVISOR \u2714 VK_FUCHSIA_EXTERNAL_MEMORY FUCHSIA VK_FUCHSIA_EXTERNAL_SEMAPHORE FUCHSIA VK_GOOGLE_SAMPLER_FILTERING_PRECISION ANGLE EXT VK_GGP_FRAME_TOKEN Stadia VK_KHR_BIND_MEMORY_2 \u2714 \u2714 VK_KHR_CREATE_RENDERPASS_2 \u2714 \u2714 VK_KHR_DEPTH_STENCIL_RESOLVE \u2714 \u2714 VK_KHR_EXTERNAL_FENCE_CAPABILITIES \u2714 \u2714 VK_KHR_EXTERNAL_FENCE_FD U VK_KHR_EXTERNAL_MEMORY \u2714 \u2714 VK_KHR_EXTERNAL_MEMORY_FD U VK_KHR_EXTERNAL_SEMAPHORE \u2714 \u2714 VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES \u2714 \u2714 VK_KHR_EXTERNAL_SEMAPHORE_FD U VK_KHR_GET_MEMORY_REQUIREMENTS_2 \u2714 \u2714 VK_KHR_IMAGE_FORMAT_LIST \u2714 AMD VK_KHR_INCREMENTAL_PRESENT U VK_KHR_MAINTENANCE1 \u2714 \u2714 VK_KHR_SAMPLER_YCBCR_CONVERSION \u2714 \u2714 VK_KHR_SHADER_FLOAT16_INT8 \u2714 VK_KHR_SWAPCHAIN \u2714 VK_QCOM_render_pass_store_ops \u2714 *M \u8868\u793a\u4e3aVulkan\u5fc5\u987b\u6269\u5c55, \u4f46 v100 \u6587\u6863\u6ca1\u6709\u6807\u51fa. \u56e0\u6b64\u5bf9\u4e8e\u4e0b\u9762\u7684 VK_EXT_SWAPCHAIN_COLOR_SPACE \u662f\u5426\u5df2\u652f\u6301\u8868\u793a\u5b58\u7591. \u6709\u5176\u4ed6\u6587\u6863\u663e\u793av100,v200\u5747\u652f\u6301. *U \u8868\u793a\u975e\u5fc5\u987b: \u5176\u5bf9\u5e94\u7684 GLES / EGL Extension \u4e0d\u5728 v100 \u7684\u652f\u6301\u5217\u8868\u4e2d.","title":"ANGLE \u4e2d vk Ext \u5bf9\u5e94es\u529f\u80fd"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vk-extensions_1","text":"\u5c06\u4e0a\u8868\u4e2d\u7684\u6570\u636e, \u5220\u53bb\"'\u5df2\u652f\u6301\u7684\", \"vk\u5185\u90e8\u4f7f\u7528\", \u548c\"\u5176\u4ed6\u5e73\u53f0\"\u7684\u6269\u5c55, \u5269\u4e0b\u7684\u5373 v100 \u5c1a\u672a\u652f\u6301\u7684\u6269\u5c55\u9700\u6c42\u8868\u5982\u4e0b: Vk Extensions \u6240\u9700 Feature \u5206\u7c7b \u5fc5\u9700 \u652f\u6301 es \u529f\u80fd VK_EXT_SWAPCHAIN_COLOR_SPACE -- EGL \u2714 EGL_KHR_gl_colorspace VK_ANDROID_EXTERNAL_MEMORY _ANDROID_HARDWARE_BUFFER VK_EXT_QUEUE_FAMILY_FOREIGN -- EGL \u2714 EGL_ANDROID_image_native_buffer VK_EXT_INDEX_TYPE_UINT8 indexTypeUint8 es2.0 \u5339\u914d Draw \u7684 indexType \u53c2\u6570, \u4ee5\u4f18\u5316\u6027\u80fd VK_EXT_LINE_RASTERIZATION bresenhamLines es2.0 \u7ba1\u7ebf\u7b97\u6cd5\u652f\u6301 VK_EXT_SHADER_STENCIL_EXPORT -- es2.0 VK_EXT_TRANSFORM_FEEDBACK transformFeedback es3.1 \u2714 \u5b9e\u73b0 Transform Feedback \u76f8\u5173 API VK_EXT_VERTEX_ATTRIBUTE_DIVISOR vertexAttributeInstanceRateDivisor es2.0 VK_KHR_SHADER_FLOAT16_INT8 shaderFloat16 es2.0 VK_KHR_EXTERNAL_FENCE_FD -- EGL U EGL_ANDROID_native_fence VK_KHR_EXTERNAL_MEMORY_FD -- EXT U GL_EXT_memory_object_fd VK_KHR_EXTERNAL_SEMAPHORE_FD -- EXT U GL_EXT_semaphore_fd VK_KHR_INCREMENTAL_PRESENT -- EGL U EGL_KHR_swap_buffers_with_damage *U \u8868\u793a\u975e\u5fc5\u987b: \u5176\u5bf9\u5e94\u7684 GLES / EGL Extension \u4e0d\u5728 v100 \u7684\u652f\u6301\u5217\u8868\u4e2d.","title":"\u589e\u52a0 Vk Extensions \u7684\u9700\u6c42"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vk-features","text":"\u5bf9\u6bd4 v100 \u652f\u6301\u60c5\u51b5: \u4ec5 inheritedQueries \u4e0d\u652f\u6301 \u4e14\u5fc5\u9700. \u6b64\u5916\u867d\u7136 vertexPipelineStoresAndAtomics \u4e0d\u652f\u6301, \u4f46 ANGLE \u63a8\u8350\u7528 VK_EXT_TRANSFORM_FEEDBACK \u53d6\u4ee3. \u5176\u4f59Features \u5747\u5728 v100 \u4e2d\u652f\u6301: Vk Features in ANGLE \u5bf9\u5e94 GLES Note inheritedQueries es 3.0, Query vertexPipelineStoresAndAtomics transform feedback \u6a21\u62df\u5b9e\u73b0 transform feedback, \u5e94\u7528 VK_EXT_TRANSFORM_FEEDBACK \u4ee3\u66ff imageCubeArray cubemap array \u4ec5\u5728\u975e SwiftShader \u548c\u975e Qualcomm \u4e0b\u542f\u7528 independentBlend fbo \u591a\u4e2a attachments robustBufferAccess \u8bbf\u95ee robust buffer samplerAnisotropy Anisotropic filtering wideLines wide lines fragmentStoresAndAtomics storage buffers \u5b9e\u73b0 fragment shader \u4e2d storage buffers \u548c images geometryShader geometry shaders shaderImageGatherExtended EXT_gpu_shader5 shaderUniformBufferArrayDynamicIndexing EXT_gpu_shader5 shaderSampledImageArrayDynamicIndexing EXT_gpu_shader5 \u652f\u6301 EXT_gpu_shader5 \u5e76\u6a21\u62df\u5b9e\u73b0 sampler array shaderStorageBufferArrayDynamicIndexing \u6a21\u62df\u5b9e\u73b0 atomic counter shaderClipDistance APPLE_clip_distance sampleRateShading OES_sample_shading depthClamp OES_sample_shading support depth clears through draw calls. sampleRateShading OES_sample_variables *\u7c97\u4f53 Features\u4e3a\u6838\u5fc3API\u6240\u5fc5\u9700\u7279\u6027.","title":"Vk Features"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#limits","text":"\u672c\u8868\u5217\u51fa ANGLE \u4e2d\u8bb0\u4e86\u6570\u5b57\u9700\u6c42\u7684 Limits. [ ] \u5bf9\u5e94 v100 GLES Limits * \u662f\u6307 ANGLE \u5728\u6a21\u62df\u5b9e\u73b0 GLES \u65f6, \u9700\u8981\u5360\u7528\u90e8\u5206\u8d44\u6e90, \u5bfc\u81f4 v100 \u4e2d\u6807\u8bb0\u7684 GLES Limits \u4e0d\u518d\u80fd\u6ee1\u8db3. \u672c\u8868\u5047\u8bbe VK_EXT_TRANSFORM_FEEDBACK \u4e0e VK_EXT_LINE_RASTERIZATION \u5df2\u6ee1\u8db3. \u5426\u5219\u4e00\u4e9b\u6240\u9700\u503c\u4f1a\u589e\u52a0, \u4f46\u4e0d\u4f1a\u6539\u53d8\u5f53\u524d\u6ee1\u8db3\u60c5\u51b5. Vk Limits in ANGLE \u6240\u9700\u503c Limits in v100 v100 \u5df2\u6ee1\u8db3 \u5bf9\u5e94 GLES EXT / Cap maxPerStageDescriptorStorageBuffers >=12 / 16 8 \u4e0d\u6ee1\u8db3 es3.0, 12 \u4e3a\u6ee1\u8db3 ANGLE es3.0 16 \u4e3a\u6ee1\u8db3 v100 GLES Limits maxPerStageDescriptorUniformBuffers >=14 12 \u4e0d\u6ee1\u8db3 v100 GLES Limits* maxDescriptorSetUniformBuffers >=76 72 \u4e0d\u6ee1\u8db3 v100 GLES Limits* maxVertexOutputComponents \u4e0e maxFragmentInputComponents >=136 128 \u4e0d\u6ee1\u8db3 v100 GLES Limits* standardSampleLocations true true textureStorageMultisample2DArrayOES maxSamplerAnisotropy > 1.0f; 16 textureFilterAnisotropic maxTextureAnisotropy maxInterpolationOffset >= 0.5; 0.4375 \u4e0d\u6ee1\u8db3 OES_shader_multisample_interpolation maxVertexInputAttributeOffset >=2047 2047 es3.1","title":"Limits"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#angle-vk-extensions","text":"","title":"ANGLE : Vk Extensions"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles-core","text":"","title":"GLES Core"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vk_ext_transform_feedback","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es3.0 APIs \u5bf9\u5e94\u529f\u80fd Transform Feedback \u5fc5\u8981\u6027 \u5b9e\u73b0 Transform Feedback \u5fc5\u9700 \u6240\u9700 FeaturesEXT transformFeedback angle doc: TransformFeedbackViaExtension angle issue: http://anglebug.com/3206 ANGLE\u4f7f\u7528Vulkan\u4e2d\u7684vertexPipelineStoresAndAtomics\u529f\u80fd\u6a21\u62df\u53d8\u6362\u53cd\u9988\u3002\u4f46\u662f\u67d0\u4e9b Driver \u4e0d\u652f\u6301\u6b64\u7279\u6027\u3002\u540c\u6837\uff0c\u5728GLES 3.2\u4e2d\uff0c\u4eff\u771f\u53d8\u5f97\u66f4\u52a0\u56f0\u96be\u3002\u56e0\u6b64\uff0c ANGLE\u5fc5\u987b\u652f\u6301\u4f7f\u7528 VK_EXT_transform_feedback \u6269\u5c55 \u3002\u5e76\u4e14\u5f53\u4f7f\u7528\u6b64\u6269\u5c55\u65f6\uff0c\u6211\u4eec\u4e5f\u671f\u671b\u6027\u80fd\u63d0\u9ad8\u3002","title":"VK_EXT_TRANSFORM_FEEDBACK"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#counterbuffer","text":"Vulkan\u6269\u5c55\u6ca1\u6709\u4e3a glPauseTransformFeedback / glEndTransformFeedback \u5206\u522b\u63d0\u4f9b\u5355\u72ec\u7684API \u3002 \u76f8\u53cd\uff0cVulkan\u5728 vkCmdBeginTransformFeedbackEXT / vkCmdEndTransformFeedbackEXT \u4e2d \u5f15\u5165\u4e86\u8ba1\u6570\u5668\u7f13\u51b2\u533a\u4f5c\u4e3aAPI\u53c2\u6570\u3002 \u8981\u6682\u505cFB\uff0c\u8c03\u7528 vkCmdEndTransformFeedbackEXT \u5e76\u5728 pCounterBuffers \u6570\u7ec4\u4e2d\u63d0\u4f9b\u6709\u6548\u7684\u7f13\u51b2\u533a\u53e5\u67c4, \u5728 pCounterBufferOffsets \u6570\u7ec4\u4e2d\u63d0\u4f9b\u6709\u6548\u7684\u504f\u79fb\u91cf\uff0c\u4ee5\u5b9e\u73b0\u4fdd\u5b58\u6062\u590d\u70b9\u7684\u5b9e\u73b0\u3002 \u8981\u6062\u590dFB\uff0c\u6211\u4eec\u8c03\u7528 vkCmdBeginTransformFeedbackEXT \u5e76\u4f20\u5165\u5148\u524d\u7684 pCounterBuffers \u548c pCounterBufferOffsets \u503c\u3002 \u6682\u505c\u548c\u6062\u590d\u4e4b\u95f4, \u9700\u8981\u6709\u4e00\u4e2a\u5b58\u50a8\u963b\u6321 (memory barrier), \u7528\u4e8e\u4e0e\u8bbf\u95ee\u6e90\u5230\u8bbf\u95ee\u6a21\u677f\u7684\u8ba1\u6570\u5668\u7f13\u51b2\u5668. \u8bbf\u95ee\u6e90: Pipeline Stage \u7684 VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT \u4e2d\u7684 VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT \u8bbf\u95ee\u76ee\u6807 Pipeline Stage \u7684 VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT \u4e2d\u7684 VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT","title":"\u4f7f\u7528CounterBuffer\u5b9e\u73b0\u6682\u505c/\u6062\u590d"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gltransformfeedbackvaryings","text":"Vulkan\u4e2d\u6ca1\u6709 glTransformFeedbackVaryings \u7684\u7b49\u6548\u51fd\u6570\u3002 Vulkan\u89c4\u8303\u6307\u51fa\uff0c\u5fc5\u987b\u4f7f\u7528XFB\u6267\u884c\u6a21\u5f0f\u58f0\u660e\u6700\u540e\u4e00\u4e2a\u9876\u70b9\u5904\u7406\u9636\u6bb5\u7740\u8272\u5668\u3002 SPIR-V \u8f6c\u6362\u5668\u8d1f\u8d23\u6dfb\u52a0\u6b64\u6267\u884c\u6a21\u5f0f\uff0c\u5e76\u4fee\u9970\u9700\u8981\u6355\u83b7\u7684\u53d8\u91cf\u3002 ANGLE \u4e3a Vulkan \u5750\u6807\u7cfb\u4fee\u6539\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684 gl_position.z \u3002\u56e0\u6b64\uff0c\u5982\u679c\u6211\u4eec\u5728XFB\u7f13\u51b2\u533a\u4e2d\u6355\u83b7\u201c gl_position\u201d\u7684\u503c\uff0c\u5219\u6355\u83b7\u7684\u503c\u5c06\u662f\u9519\u8bef\u7684\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u58f0\u660e\u4e00\u4e2a\u5185\u90e8 position \u53d8\u5316\u91cf\uff0c\u7136\u540e\u590d\u5236'gl_position'\u7684\u503c\u3002\u6211\u4eec\u6355\u83b7\u4e86\u53d8\u6362\u53cd\u9988\u64cd\u4f5c(transform feedback)\u671f\u95f4\u5185\u90e8 position \u53d8\u5316\u91cf\u7684\u53d8\u5316\u3002\u4e3a\u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u4f1a\u5bf9\u6bcf\u4e2a\u6355\u83b7\u7684\u53d8\u5316\u90fd\u8fdb\u884c\u6b64\u64cd\u4f5c, \u800c\u6ca1\u6709\u7528 gl_PerVertex \u76f4\u63a5\u5728SPIR-V\u4e2d\u88c5\u9970\u7ed3\u6784\u4f53\u3002","title":"glTransformFeedbackVaryings \u7684\u5b9e\u73b0"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#transform-feedback-queries","text":"GLES \u6709\u4e24\u4e2a\u4e0d\u540c\u7684\u67e5\u8be2\uff1a GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN \u548c GL_PRIMITIVES_GENERATED \u3002 \u4f46\u662f\u5728Vulkan\u4e2d\uff0c\u8fd9\u4e9b\u662f\u7531\u6765\u81ea VK_EXT_transform_feedback \u7684\u5355\u4e2a\u67e5\u8be2\u63d0\u4f9b\u7684\u3002 \u6b64\u5916\uff0cVulkan\u8981\u6c42\u4e00\u6b21\u53ea\u80fd\u6fc0\u6d3b\u67d0\u7c7b\u578b\u7684\u4e00\u4e2a\u67e5\u8be2\u3002 \u5f53\u4e24\u4e2a Transform Feedback \u67e5\u8be2\u90fd\u5904\u4e8e\u6d3b\u52a8\u72b6\u6001\u65f6\uff0c\u8fd9\u5c06\u8feb\u4f7fANGLE\u4f7f\u4e24\u4e2aGL\u67e5\u8be2\u5171\u4eab\u5176Vulkan\u67e5\u8be2\u3002","title":"Transform Feedback Queries"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles-api","text":"","title":"\u5bf9\u5e94 GLES API"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#transform-feedback","text":"glBeginTransformFeedback/ glPauseTransformFeedback /glResumeTransformFeedback/ glEndTransformFeedback / glTransformFeedbackVaryings Buffer glBufferData / glBufferStorage / glDeleteBuffers glsl glDispatchComputeIndirect / glDispatchCompute / glLinkProgram / glCreateShaderProgramv Query glBeginQuery / glEndQuery","title":"Transform Feedback"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vulkan","text":"Features : \u4ec5\u9700\u542f\u7528 transformFeedback // Provided by VK_EXT_transform_feedback typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 transformFeedback; VkBool32 geometryStreams; } VkPhysicalDeviceTransformFeedbackFeaturesEXT; \u6269\u5c55\u547d\u4ee4: vkCmdBeginQueryIndexedEXT vkCmdBeginTransformFeedbackEXT vkCmdBindTransformFeedbackBuffersEXT vkCmdDrawIndirectByteCountEXT vkCmdEndQueryIndexedEXT vkCmdEndTransformFeedbackEXT","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#angle-gles-on-vk","text":"/API\u8f83\u591a, \u5f85\u5206\u6790/ \u7ed3\u675f","title":"ANGLE : GLES on Vk"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vk_ext_index_type_uint8","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 APIs \u5bf9\u5e94\u529f\u80fd \u6307\u5b9a\u4e86 IndexType \u7684 Draw \u5fc5\u8981\u6027 \u6027\u80fd\u4f18\u5316, \u53ef\u7ed5\u8fc7 \u6240\u9700 FeaturesEXT indexTypeUint8 angle issue: http://anglebug.com/4405 \u6b64\u6269\u5c55\u4e3a\u89e3\u51b3\u4e00\u4e2a\u6027\u80fd\u95ee\u9898: \u67d0\u4e9bGLES\u57fa\u51c6\uff08\u4f8b\u5982T-Rex\uff09\u5728 draw \u65f6\u4f7f\u7528 8bit \u7684 indices \u3002 \u4f46\u662f, Vulkan \u4e2d\u9ed8\u8ba4\u6ca1\u6709 8bit index, \u56e0\u6b64ANGLE \u9700\u8981\u4f7f\u7528 CPU, \u6216GPU\u7684\u8ba1\u7b97\u7740\u8272\u5668, \u5c068\u4f4d\u7d22\u5f15\u8f6c\u6362\u4e3a16\u4f4d\u3002 \u800c\u5982\u679c driver \u652f\u6301 VK_EXT_index_type_uint8 \uff0c\u5219\u4e0d\u9700\u8981\u6b64\u8f6c\u6362.","title":"VK_EXT_INDEX_TYPE_UINT8 (.)"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles","text":"\u6240\u6709\u6307\u5b9a\u4e86 IndexType \u7684 Draw. (DrawArrays, DrawElements.....) \u4f8b: glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices); \u5176\u4e2d index \u7c7b\u578b\u4e3a\u4ee5\u4e0b\u679a\u4e3e\u503c\u4e4b\u4e00: GL_UNSIGNED_BYTE , GL_UNSIGNED_SHORT , or GL_UNSIGNED_INT , \u5206\u522b\u5bf9\u5e94\u4e86 8bit, 16bit, \u548c 32bit.","title":"\u5bf9\u5e94 GLES \u529f\u80fd"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vulkan_1","text":"\u6b64\u6269\u5c55\u5141\u8bb8\u5728 vkCmdBindIndexBuffer \u547d\u4ee4\u4e2d\u4f7f\u7528 uint8_t indices, \u5bf9\u5e94\u679a\u4e3e: VkIndexType: VK_INDEX_TYPE_UINT8_EXT \u800c\u5728\u6ca1\u6709\u6b64\u6269\u5c55\u65f6, \u4ec5\u652f\u6301 VK_INDEX_TYPE_UINT16 \u548c VK_INDEX_TYPE_UINT32, \u5206\u522b\u5bf9\u5e94 16bit \u548c 32bit Features : \u4ec5\u9700\u542f\u7528 indexTypeUint8 // Provided by VK_EXT_index_type_uint8 typedef struct VkPhysicalDeviceIndexTypeUint8FeaturesEXT { VkStructureType sType; void* pNext; VkBool32 indexTypeUint8; } VkPhysicalDeviceIndexTypeUint8FeaturesEXT; vkCmdBindIndexBuffer \u547d\u4ee4: // Provided by VK_VERSION_1_0 void vkCmdBindIndexBuffer( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType); \u5176\u4e2d indexType \u5bf9\u5e94\u679a\u4e3e: // Provided by VK_VERSION_1_0 typedef enum VkIndexType { VK_INDEX_TYPE_UINT16 = 0, VK_INDEX_TYPE_UINT32 = 1, // Provided by VK_KHR_acceleration_structure VK_INDEX_TYPE_NONE_KHR = 1000165000, // Provided by VK_EXT_index_type_uint8 VK_INDEX_TYPE_UINT8_EXT = 1000265000, // Provided by VK_NV_ray_tracing VK_INDEX_TYPE_NONE_NV = VK_INDEX_TYPE_NONE_KHR, } VkIndexType;","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#angle-gles-on-vk_1","text":"// Init gles-vulkan index type map mIndexTypeMap[UnsignedByte] = supportsIndexTypeUint8 ? VK_INDEX_TYPE_UINT8_EXT : VK_INDEX_TYPE_UINT16; mIndexTypeMap[UnsignedShort] = VK_INDEX_TYPE_UINT16; mIndexTypeMap[UnsignedInt] = VK_INDEX_TYPE_UINT32; mIndexTypeMap \u7528\u4e8e \u6267\u884c vkCmdBindIndexBuffer \u8bbe\u7f6e\u7c7b\u578b UnsignedByte : VK_INDEX_TYPE_UINT8_EXT (\u539f\u5148 VK_INDEX_TYPE_UINT16) UnsignedShort : VK_INDEX_TYPE_UINT16 UnsignedInt : VK_INDEX_TYPE_UINT32 \u5982\u679c\u4e0d\u652f\u6301, \u5728 DrawXXX \u5b9e\u73b0\u4e2d\u5904\u7406 indices \u65f6 (\u4f8b\u5982\u5206\u914d\u5185\u5b58\u7a7a\u95f4) \u9700\u8981\u5c06 GLubyte \u8f6c\u4e3a GLushort \u540e\u518d\u5904\u7406. TODO: \u5206\u6790\u73b0\u6709DDK\u5b9e\u73b0, \u68c0\u67e5\u662f\u5426\u9700\u8981","title":"ANGLE : GLES on Vk"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vk_ext_line_rasterization","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 \u5bf9\u5e94\u529f\u80fd \u5149\u6805\u5316: \u5355\u6837\u672c\u6e32\u67d3 \u5fc5\u8981\u6027 \u975e\u5fc5\u9700: \u4fdd\u6301\u7b97\u6cd5\u4e00\u81f4\u6027 \u6240\u9700 FeaturesEXT bresenhamLines angle doc: OpenGLLineSegmentRasterization \u7531\u4e8e Vk \u5728\u5149\u6805\u5316\u7684\u5355\u6837\u672c\u6e32\u67d3\u91c7\u6837\u4e86\u4e0d\u540c\u7684\u7ebf\u6bb5\u6e32\u67d3\u7b97\u6cd5, \u9700\u8981\u6b64\u6269\u5c55\u6765\u4fdd\u6301 GLES \u4e0e\u539f\u6709\u7b97\u6cd5\u7684\u4e00\u81f4\u6027: \u5728\u5149\u6805\u5316\u9636\u6bb5, OpenGL\u548cVulkan\u90fd\u5c06\u7ebf\u6bb5\u6e32\u67d3\u4e3a\u4e24\u70b9\u4e4b\u95f4\u7684\u4e00\u7cfb\u5217\u50cf\u7d20\u3002\u5b83\u4eec\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u8986\u76d6\u7ebf\u7684\u50cf\u7d20\u3002 \u5bf9\u4e8e\u5355\u6837\u672c\u6e32\u67d3\uff0cVulkan\u4f7f\u7528 \u57fa\u4e8e\u56db\u8fb9\u5f62\u8986\u76d6\u7387\u7684\u7b97\u6cd5 \u3002\u8f83\u5c0f\u7684\u5f62\u72b6\u56f4\u7ed5\u7ebf\u6bb5\u6324\u51fa\u3002\u5f62\u72b6\u6240\u8986\u76d6\u7684\u6837\u672c\u5c06\u4ee3\u8868\u7ebf\u6bb5\u3002 OpenGL\u7684\u7b97\u6cd5 \u57fa\u4e8eBresenham\u7684line\u7b97\u6cd5 \u3002\u5728\u4e24\u4e2a\u5206\u6bb5\u70b9\u4e4b\u95f4\u7684\u7ebf\u4e0a\u9009\u62e9\u50cf\u7d20\u3002\u6ce8\u610fBresenham\u4e0d\u652f\u6301\u591a\u91cd\u91c7\u6837\u3002 \u5728\u89c6\u89c9\u4e0a\u8fdb\u884c\u6bd4\u8f83\u65f6\uff0cVulkan\u7ebf\u6bb5\u6805\u683c\u5316\u7b97\u6cd5\u59cb\u7ec8\u9009\u62e9\u5728OpenGL\u4e2d\u6805\u683c\u5316\u7684\u7ebf\u6bb5\u50cf\u7d20\u7684\u8d85\u96c6\u3002 \u8be6\u7ec6\u533a\u522b\u89c1 ANGLE \u6587\u6863: OpenGLLineSegmentRasterization","title":"VK_EXT_LINE_RASTERIZATION (.)"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles_1","text":"\u7ba1\u7ebf\u7684\u5149\u6805\u5316, \u65e0API\u5bf9\u5e94","title":"\u5bf9\u5e94 GLES"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vulkan_2","text":"Features : \u4ec5\u9700\u542f\u7528 bresenhamLines. // Provided by VK_EXT_line_rasterization typedef struct VkPhysicalDeviceLineRasterizationFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 rectangularLines; VkBool32 bresenhamLines; VkBool32 smoothLines; VkBool32 stippledRectangularLines; VkBool32 stippledBresenhamLines; VkBool32 stippledSmoothLines; } VkPhysicalDeviceLineRasterizationFeaturesEXT; \u63d0\u4f9b Pipeline State \u6269\u5c55: // Provided by VK_EXT_line_rasterization typedef struct VkPipelineRasterizationLineStateCreateInfoEXT { VkStructureType sType; const void* pNext; VkLineRasterizationModeEXT lineRasterizationMode; VkBool32 stippledLineEnable; uint32_t lineStippleFactor; uint16_t lineStipplePattern; } VkPipelineRasterizationLineStateCreateInfoEXT; \u5176\u4e2d lineRasterizationMode \u5bf9\u5e94\u679a\u4e3e: // Provided by VK_EXT_line_rasterization typedef enum VkLineRasterizationModeEXT { VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0, VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1, VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2, VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3, } VkLineRasterizationModeEXT; \u5176\u4e2d VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT \u6839\u636e Bresenham Line Segment Rasterization \u7b97\u6cd5\u4e2d\u7684\u5b9a\u4e49\uff0c\u6307\u5b9a\u901a\u8fc7\u786e\u5b9a\u7ebf\u6761\u76f8\u4ea4\u548c\u79bb\u5f00\u7684\u50cf\u7d20\u83f1\u5f62\u7ed8\u5236\u7684\u7ebf\u6761\u3002","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles-on-vulkan","text":"TODO: \u4e0e\u786c\u4ef6\u6c9f\u901a\u65f6, \u8bbe\u7f6e\u9009\u62e9\u7b97\u6cd5\u7684\u53c2\u6570. \u5728\u975e\u591a\u91cd\u91c7\u6837\u65f6, \u5728\u5b9a\u4e49 Pipeline \u7684 VkPipelineRasterizationStateCreateInfo \u65f6, \u4e3a\u5176 pNext \u94fe\u4e0a\u6dfb\u52a0 VkPipelineRasterizationLineStateCreateInfoEXT \u5373\u53ef. \u8bbe\u7f6e lineRasterizationMode \u4e3a VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT VkPipelineRasterizationStateCreateInfo rasterState = {}; ... const void **pNextPtr = &rasterState.pNext; VkPipelineRasterizationLineStateCreateInfoEXT rasterLineState = {}; rasterLineState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT; // Enable Bresenham line rasterization if available and not multisampling. if (rasterizationSamples <= 1 && bresenhamLineRasterization.enabled) { rasterLineState.lineRasterizationMode = VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT; *pNextPtr = &rasterLineState; pNextPtr = &rasterLineState.pNext; }","title":"GLES on Vulkan"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vk_ext_shader_stencil_export","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 \u5bf9\u5e94\u529f\u80fd glBlitFramebuffer: stencil buffer \u7684 resolve \u548c unresolve \u5fc5\u8981\u6027 \u975e\u5fc5\u987b, \u53ef\u6a21\u62df\u5b9e\u73b0 \u6240\u9700 FeaturesEXT \u65e0 \u6b64\u6269\u5c55\u7528\u4e8e\u6267\u884c\u6a21\u677f\u7f13\u51b2\u533a\u7684\u591a\u91c7\u6837\u89e3\u6790(multisampled resolve of stencil buffer)\u3002 \u5982\u679c\u6b64\u6269\u5c55\u4e0d\u53ef\u7528\uff0c\u5219\u4f7f\u7528\u591a\u6b65\u9aa4\u6a21\u62df\u5b9e\u73b0\u3002","title":"VK_EXT_SHADER_STENCIL_EXPORT"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles_2","text":"Framebuffer \u7684 resolve \u548c unresolve, \u53d1\u751f\u5728\u8bfb\u53d6\u548c\u590d\u5236\u8fc7\u7a0b\u4e2d, \u5982 glBlitFramebuffer","title":"\u5bf9\u5e94 GLES \u529f\u80fd"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vulkan_3","text":"\u6b64\u6269\u5c55\u63d0\u4f9b\u4e00\u79cd\u673a\u5236\uff0c\u4f7f\u7740\u8272\u5668\u53ef\u4ee5\u5728\u6bcf\u6b21\u8c03\u7528\u65f6\u751f\u6210\u6a21\u677f\u5f15\u7528\u503c\u3002\u5728\u542f\u7528\u6a21\u677f\u6d4b\u8bd5\u65f6\uff0c\u8fd9\u5141\u8bb8\u9488\u5bf9\u7740\u8272\u5668\u4e2d\u751f\u6210\u7684\u503c\u6267\u884c\u6d4b\u8bd5\u3002 \u6b64\u6269\u5c55\u4f9d\u8d56 SPV_EXT_shader_stencil_export \u6b64\u6269\u5c55\u4e3aGLES\u7684shader\u6269\u5c55: GL_ARB_shader_stencil_export \u63d0\u4f9b API \u652f\u6301 \u6b64\u6269\u4e3a\u4e0d\u589e\u52a0\u5176\u4ed6\u7ed3\u6784\u4f53\u548c\u6307\u4ee4.","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles-on-vk","text":"\u5f85\u5206\u6790","title":"GLES on Vk"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vk_ext_vertex_attribute_divisor","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 APIs \u5bf9\u5e94\u529f\u80fd Vertex \u7ed1\u5b9a, GL_EXT_instanced_arrays \u5fc5\u8981\u6027 \u6240\u9700 FeaturesEXT vertexAttributeInstanceRateDivisor","title":"VK_EXT_VERTEX_ATTRIBUTE_DIVISOR"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles_3","text":"Vertex \u7ed1\u5b9a GL_EXT_instanced_arrays glDrawArraysInstancedEXT glDrawElementsInstancedEXT glVertexAttribDivisorEXT","title":"\u5bf9\u5e94 GLES \u529f\u80fd"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vulkan_4","text":"Vertex Attribute Divisor in Instanced Rendering structure controls how vertex attributes are assigned to an instance when instanced rendering is enabled. VkPipelineVertexInputStateCreateInfo // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPipelineVertexInputDivisorStateCreateInfoEXT { VkStructureType sType; const void* pNext; uint32_t vertexBindingDivisorCount; const VkVertexInputBindingDivisorDescriptionEXT* pVertexBindingDivisors; } VkPipelineVertexInputDivisorStateCreateInfoEXT; // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkVertexInputBindingDivisorDescriptionEXT { uint32_t binding; uint32_t divisor; } VkVertexInputBindingDivisorDescriptionEXT; binding is the binding number for which the divisor is specified. divisor is the number of successive instances that will use the same value of the vertex attribute when instanced rendering is enabled. For example, if the divisor is N, the same vertex attribute will be applied to N successive instances before moving on to the next vertex attribute. The maximum value of divisor is implementation dependent and can be queried using VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT :: maxVertexAttribDivisor . A value of 0 can be used for the divisor if the vertexAttributeInstanceRateZeroDivisor feature is enabled. In this case, the same vertex attribute will be applied to all instances.","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles-on-vk_1","text":"\u53c2\u8003Spec, \u4e3a Pipeline \u914d\u7f6e VkPipelineVertexInputDivisorStateCreateInfoEXT \u5373\u53ef.","title":"GLES on Vk"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vk_khr_shader_float16_int8","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 APIs \u5bf9\u5e94\u529f\u80fd glGenerateMipmap \u5fc5\u8981\u6027 \u975e\u5fc5\u8981: \u6027\u80fd\u4f18\u5316 \u6240\u9700 FeaturesEXT shaderFloat16 angle issue: http://anglebug.com/4551","title":"VK_KHR_SHADER_FLOAT16_INT8 (.)"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles-api_1","text":"glGenerateMipmap \u7528\u4e8e\u8fdb\u884c\u751f\u6210Mipmap \u8ba1\u7b97\u65f6, \u5728\u7740\u8272\u5668\u4e2d\u542f\u7528 float 16 \u6765\u52a0\u901f\u8fd0\u7b97","title":"\u5bf9\u5e94GLES API"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vulkan_5","text":"\u6b64\u6269\u5c55\u5c06\u63d0\u5347\u81f3 Vulkan 1.2 Core \u6b64\u6269\u5c55\u5141\u8bb8\u5728\u7740\u8272\u5668\u4e2d\u4f7f\u752816\u4f4d\u6d6e\u70b9\u7c7b\u578b\u548c8\u4f4d\u6574\u6570\u7c7b\u578b\u8fdb\u884c\u7b97\u672f\u8fd0\u7b97\u3002 Features : \u4ec5\u9700\u542f\u7528 shaderFloat16 typedef struct VkPhysicalDeviceShaderFloat16Int8Features { VkStructureType sType; void* pNext; VkBool32 shaderFloat16; VkBool32 shaderInt8; } VkPhysicalDeviceShaderFloat16Int8Features;","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles-on-vk_2","text":"\u5728 GenerateMipmap \u8fc7\u7a0b\u4e2d, \u53d6 shader \u8fdb\u884c\u8ba1\u7b97\u65f6, \u5982\u679c\u56fe\u7247\u7684 bits-per-component (eg: redBits) \u4e3a 8 \u6216 16\u65f6, \u4f7f\u7528\u6269\u5c55\u63d0\u4f9b\u7684 float16 \u6765\u8ba1\u7b97\u4ee5\u83b7\u53d6\u66f4\u5feb\u7684\u8ba1\u7b97\u901f\u5ea6. if (actualFormat.redBits <= 8) { flags = hasShaderFloat16 ? GenerateMipmap_comp::kIsRGBA8_UseHalf : GenerateMipmap_comp::kIsRGBA8; } else if (actualFormat.redBits <= 16) { flags = hasShaderFloat16 ? GenerateMipmap_comp::kIsRGBA16_UseHalf : GenerateMipmap_comp::kIsRGBA16; } else { flags = GenerateMipmap_comp::kIsRGBA32F; } \u5404 flag \u5206\u522b\u5404\u81ea\u5bf9\u5e94\u4e00\u4e2a\u9884\u751f\u6210\u7684 compressedShaderCode.","title":"GLES on VK"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#egl","text":"","title":"EGL"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vk_ext_swapchain_color_space","text":"V100 \u5df2\u652f\u6301 \u5426 ? \u5bf9\u5e94 GLES EGL Extension \u5bf9\u5e94\u529f\u80fd EGL_KHR_gl_colorspace (v100\u652f\u6301) \u5fc5\u8981\u6027 \u652f\u6301 EGL EXT \u5fc5\u987b \u6240\u9700 FeaturesEXT \u65e0 angle issue: http://anglebug.com/2514 \u652f\u6301\u6269\u5c55 EGL_KHR_gl_colorspace (v100\u652f\u6301), \u8fdb\u800c\u652f\u6301 EGL_EXT_image_gl_colorspace \u7b49 colorspace \u6269\u5c55.","title":"VK_EXT_SWAPCHAIN_COLOR_SPACE(.)"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles_4","text":"\u6269\u5c55 EGL_KHR_gl_colorspace \u683c\u5f0f: EGL_GL_COLORSPACE_KHR EGL_GL_COLORSPACE_SRGB_KHR EGL_GL_COLORSPACE_LINEAR_KHR","title":"\u5bf9\u5e94 GLES \u529f\u80fd"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vulkan_6","text":"\u63d0\u4f9b\u6269\u5c55: VkColorSpaceKHR : VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT VK_COLOR_SPACE_BT2020_LINEAR_EXT VK_COLOR_SPACE_BT709_LINEAR_EXT VK_COLOR_SPACE_BT709_NONLINEAR_EXT VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT VK_COLOR_SPACE_DOLBYVISION_EXT VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT VK_COLOR_SPACE_HDR10_HLG_EXT VK_COLOR_SPACE_HDR10_ST2084_EXT VK_COLOR_SPACE_PASS_THROUGH_EXT","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles-on-vulkan_1","text":"\u5bf9 EGL \u7684 Format \u5411 Vk Format \u8fdb\u884c\u6620\u5c04: static VkColorSpaceKHR MapEglColorSpaceToVkColorSpace(EGLenum EGLColorspace) { switch (EGLColorspace) { case EGL_NONE: case EGL_GL_COLORSPACE_LINEAR: case EGL_GL_COLORSPACE_SRGB_KHR: case EGL_GL_COLORSPACE_DISPLAY_P3_PASSTHROUGH_EXT: return VK_COLOR_SPACE_SRGB_NONLINEAR_KHR; case EGL_GL_COLORSPACE_DISPLAY_P3_LINEAR_EXT: return VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT; case EGL_GL_COLORSPACE_DISPLAY_P3_EXT: return VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT; case EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT: return VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT; case EGL_GL_COLORSPACE_SCRGB_EXT: return VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT; default: UNREACHABLE(); return VK_COLOR_SPACE_SRGB_NONLINEAR_KHR; } }","title":"GLES on Vulkan"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vk_android_external_memory_android_hardware_buffer-vk_ext_queue_family_foreign","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES EGL Extension (\u4ec5\u5b89\u5353) \u5bf9\u5e94\u529f\u80fd EGL_ANDROID_image_native_buffer (v100\u652f\u6301) \u5fc5\u8981\u6027 \u652f\u6301 EGL EXT \u5fc5\u987b \u6240\u9700 FeaturesEXT \u65e0","title":"VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER \u548c VK_EXT_QUEUE_FAMILY_FOREIGN"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles_5","text":"\u652f\u6301 ANativeWindowBuffer : EGL_NATIVE_BUFFER_ANDROID \u793a\u4f8b: ANativeWindowBuffer* sSrcBuffer = graphicBuffer->getNativeBuffer(); EGLint attrs[] = { EGL_IMAGE_PRESERVED_KHR, EGL_TRUE, EGL_NONE, }; EGLImageKHR eglSrcImage =eglCreateImageKHR(eglDisplay, EGL_NO_CONTEXT, EGL_NATIVE_BUFFER_ANDROID, (EGLClientBuffer)&sSrcBuffer, attrs);","title":"\u5bf9\u5e94 GLES \u529f\u80fd"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vulkan_7","text":"1. VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER \u6b64\u6269\u5c55\u4f7f\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5c06\u5728Vulkan\u8bbe\u5907\u5916\u90e8\u521b\u5efa\u7684Android AHardwareBuffer\u5bf9\u8c61\u5bfc\u5165Vulkan\u5185\u5b58\u5bf9\u8c61\uff0c\u5728\u5176\u4e2d\u53ef\u4ee5\u5c06\u5b83\u4eec\u7ed1\u5b9a\u5230\u56fe\u50cf\u548c\u7f13\u51b2\u533a\u3002 \u5b83\u8fd8\u5141\u8bb8\u4eceVulkan\u5185\u5b58\u5bf9\u8c61\u4e2d\u5bfc\u51faAHardwareBuffer\uff0c\u4ee5\u4e0e\u5176\u4ed6\u64cd\u4f5c\u7cfb\u7edf\u5bf9\u79f0\u3002 \u4f46\u662f\uff0c\u7531\u4e8e\u5e76\u975e\u6240\u6709AHardwareBuffer\u7528\u6cd5\u548c\u683c\u5f0f\u90fd\u5177\u6709Vulkan\u7b49\u6548\u9879\uff0c\u56e0\u6b64\u4eceVulkan\u5bfc\u51fa\u4e0e\u63d0\u4f9b\u5916\u90e8AHardwareBuffer\u5e76\u5bfc\u5165\u76f8\u6bd4\uff0c\u63d0\u4f9b\u7684\u529f\u80fd\u8981\u5c11\u5f97\u591a\u3002 \u67d0\u4e9bAHardwareBuffer\u6620\u50cf\u5177\u6709\u5b9e\u73b0\u5b9a\u4e49\u7684\u5916\u90e8\u683c\u5f0f\uff0c\u8fd9\u4e9b\u683c\u5f0f\u53ef\u80fd\u4e0eVulkan\u683c\u5f0f\u4e0d\u5bf9\u5e94\u3002 \u91c7\u6837\u5668Y'CBCR\u8f6c\u6362\u53ef\u7528\u4e8e\u4ece\u8fd9\u4e9b\u56fe\u50cf\u4e2d\u91c7\u6837\u5e76\u5c06\u5b83\u4eec\u8f6c\u6362\u4e3a\u5df2\u77e5\u7684\u8272\u5f69\u7a7a\u95f4\u3002 \u6269\u5c55\u547d\u4ee4\u5305\u62ec: vkGetAndroidHardwareBufferPropertiesANDROID vkGetMemoryAndroidHardwareBufferANDROID 2. VK_EXT_QUEUE_FAMILY_FOREIGN \u6b64\u6269\u5c55\u5b9a\u4e49\u4e86\u4e00\u4e2a\u7279\u6b8a\u7684\u961f\u5217\u65cf (Queue Family): VK_QUEUE_FAMILY_FOREIGN_EXT : \u7528\u4e8e\u5c06\u5916\u90e8\u5b58\u50a8\u5668\u652f\u6301\u7684\u8d44\u6e90\u6240\u6709\u6743\u8f6c\u79fb\u5230\u5916\u90e8\u5916\u90e8\u961f\u5217\u3002 \u8fd9\u7c7b\u4f3c\u4e8e VK_KHR_external_memory \u4e2d\u5b9a\u4e49\u7684 VK_QUEUE_FAMILY_EXTERNAL_KHR \u3002 \u4e24\u8005\u4e4b\u95f4\u7684\u4e3b\u8981\u533a\u522b\u662f\uff1a VK_QUEUE_FAMILY_EXTERNAL_KHR \u8868\u793a\u7684\u961f\u5217\u5fc5\u987b\u4e0e\u5f53\u524dVkInstance\u5171\u4eab\u76f8\u540c\u7684\u7269\u7406\u8bbe\u5907\u548c\u76f8\u540c\u7684\u9a71\u52a8\u7a0b\u5e8f\u7248\u672c\u3002 VK_QUEUE_FAMILY_FOREIGN_EXT \u6ca1\u6709\u8fd9\u6837\u7684\u9650\u5236\u3002 \u5b83\u53ef\u4ee5\u4ee3\u8868\u5176\u4ed6\u4f9b\u5e94\u5546\u7684\u8bbe\u5907\u548c\u9a71\u52a8\u7a0b\u5e8f\uff0c\u751a\u81f3\u53ef\u4ee5\u4ee3\u8868\u4e0d\u5177\u6709Vulkan\u529f\u80fd\u7684\u8bbe\u5907\u3002 \u5916\u90e8\u5b58\u50a8\u5668\u652f\u6301\u7684\u6240\u6709\u8d44\u6e90\u5747\u652f\u6301 VK_QUEUE_FAMILY_EXTERNAL_KHR \u3002 \u5bf9 VK_QUEUE_FAMILY_FOREIGN_EXT \u7684\u652f\u6301\u66f4\u5177\u9650\u5236\u6027\u3002 \u5e94\u7528\u7a0b\u5e8f\u5e94\u8be5\u671f\u671b\u5230 VK_QUEUE_FAMILY_FOREIGN_EXT \u7684\u8f6c\u6362\u6bd4\u4ece VK_QUEUE_FAMILY_EXTERNAL_KHR \u7684\u8f6c\u6362\u8981\u6602\u8d35\u3002","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles-on-vulkan_2","text":"Android\u5e73\u53f0\u7279\u6b8a\u4ee3\u7801 (src\\libANGLE\\renderer\\vulkan\\android). \u4e3aimage\u521b\u5efabuffer\u65f6, \u7528\u4e8e\u83b7\u53d6 BufferMemory \u7b49\u5e95\u5c42\u4fe1\u606f. \u5177\u4f53\u5185\u5bb9\u5f85\u5206\u6790. VK_KHR_EXTERNAL_FENCE_FD \u6709\u5219\u542f\u7528 supportsExternalFenceFd \u652f\u6301: EGL_ANDROID_native_fence VK_KHR_INCREMENTAL_PRESENT \u6709\u5219\u542f\u7528 supportsIncrementalPresent \u652f\u6301 EGL_KHR_swap_buffers_with_damage eglSwapBuffersWithDamageEXT SurfaceVk::present SurfaceVk::swapImpl","title":"GLES on Vulkan"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles-ext","text":"VK_KHR_EXTERNAL_MEMORY_FD \u6709\u5219\u542f\u7528 supportsExternalMemoryFd \u652f\u6301: GL_EXT_memory_object_fd VK_KHR_EXTERNAL_SEMAPHORE_FD \u6709\u5219\u542f\u7528 supportsExternalSemaphoreFd \u652f\u6301: GL_EXT_semaphore_fd","title":"GLES EXT"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vulkan_8","text":"VK_KHR_SURFACE && VK_KHR_ANDROID_SURFACE WSI , \u975e\u53ef\u9009 Extension VK_EXT_DEBUG_UTILS / VK_EXT_DEBUG_REPORT Vulkan ValidationLayers VK_KHR_SWAPCHAIN \u975e\u53ef\u9009 Extension VK_QCOM_render_pass_store_ops \u6709\u5219\u542f\u7528 supportsRenderPassStoreOpNoneQCOM VK_ATTACHMENT_STORE_OP_NONE_QCOM http://anglebug.com/5505 For read only depth stencil, we can use StoreOpNone if available. DONT_CARE is still preferred, so do this after finish the DONT_CARE handling.","title":"Vulkan \u81ea\u7528"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#_2","text":"","title":"\u5176\u4ed6\u5e73\u53f0"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#nvidia","text":"VK_EXT_DEPTH_CLIP_ENABLE \u6709\u5219\u542f\u7528 FeatureVk.depthClamping \u542f\u7528 : isNvidia && Features.depthClamp && EXT The workaround requires the VK_EXT_depth_clip_enable extension and the 'depthClamp' physical device feature. This workaround caused test failures on Quadro P400/driver 418.56/Linux. Therefore, on Linux we require a major version > 418. On some NVIDIA drivers the depth value is not clamped to [0,1] for floating point depth buffers. This is NVIDIA bug 3171019, see http://anglebug.com/3970 for details. When depth clamping is used, depth clipping is automatically disabled. When the 'depthClamping' feature is enabled, we'll be using depth clamping to work around a driver issue, not as an alternative to depth clipping. Therefore we need to explicitly re-enable depth clipping. \u5bf9\u5e94 vk: VkPipelineRasterizationState.depthClampEnable","title":"Nvidia"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#mac","text":"VK_EXT_EXTERNAL_MEMORY_HOST \u6709\u5219\u542f\u7528 FeatureVk.supportsExternalMemoryHost Whether the VkDevice supports the VK_EXT_external_memory_host extension, on which the ANGLE_iosurface_client_buffer extension can be layered. IOSurfaceSurfaceVkMac.mm OffscreenSurfaceVk::AttachmentImage::initializeWithExternalMemory RendererVk.mMinImportedHostPointerAlignment vkGetMemoryHostPointerPropertiesEXT IOSurfaceSurfaceVkMac.mm","title":"MAC"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#ggpstadia","text":"VK_GGP_FRAME_TOKEN if PLANTFORM_GGP \u6709\u5219\u542f\u7528 supportsGGPFrameToken \u652f\u6301 : EGL_ANGLE_swap_with_frame_token eglSwapBuffersWithFrameTokenANGLE","title":"GGP(Stadia)"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#fuchsia","text":"VK_FUCHSIA_EXTERNAL_MEMORY \u6709\u5219\u542f\u7528 supportsExternalMemoryFuchsia \u652f\u6301: GL_ANGLE_memory_object_fuchsia VK_FUCHSIA_EXTERNAL_SEMAPHORE \u6709\u5219\u542f\u7528 supportsExternalSemaphoreFuchsia \u652f\u6301: GL_ANGLE_semaphore_fuchsia","title":"Fuchsia"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#angle","text":"VK_EXT_PROVOKING_VERTEX GL_ANGLE_provoking_vertex glProvokingVertexANGLE VK_GOOGLE_SAMPLER_FILTERING_PRECISION \u672a\u542f\u7528, ANGLE\u81ea\u5b9a\u4e49 supportsFilteringPrecision \u652f\u6301: GL_CHROMIUM_texture_filtering_hint gHint(GL_TEXTURE_FILTERING_HINT_CHROMIUM)","title":"ANGLE"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#v100-ext","text":"","title":"v100 \u5df2\u652f\u6301\u7684Ext"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles_6","text":"VK_KHR_DEPTH_STENCIL_RESOLVE \u542f\u7528 if supportsRenderpass2.enabled && mDepthStencilResolveProperties.independentResolveNone supportsDepthStencilResolve http://anglebug.com/5065 RenderbufferVk::setStorageImpl \u4e3a multisampled depth/stenci \u542f\u7528 render render to texture \u53ef\u542f\u7528 VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT // If multisampled render to texture, an implicit multisampled image is created which is used as // the color or depth/stencil attachment. At the end of the render pass, this image is // automatically resolved into |mImage| and its contents are discarded. \u652f\u6301 depth/stencil images, \u975e\u5fc5\u9700, \u53ef\u7ed5\u8fc7 VK_KHR_EXTERNAL_FENCE_CAPABILITIES \u6709\u5219\u542f\u7528 supportsExternalFenceCapabilities supportsAndroidNativeFenceSync (supportsExternalFenceCapabilities && supportsExternalSemaphoreCapabilities ) || (supportsExternalFenceFd&& supportsExternalSemaphoreFd) VK_KHR_EXTERNAL_SEMAPHORE \u542f\u7528 if supportsExternalSemaphoreFd || supportsExternalSemaphoreFuchsia \u4e8c\u8005\u7684\u524d\u7f6e? \u65e0EXT\u5b58\u5728\u68c0\u67e5 \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES \u6709\u5219\u542f\u7528 supportsExternalSemaphoreCapabilities VK_KHR_MAINTENANCE1 PhysicalDeviceProperties.apiVersion < VK_MAKE_VERSION(1, 1, 0) Enable KHR_MAINTENANCE1 to support viewport flipping. VK_KHR_SAMPLER_YCBCR_CONVERSION \u542f\u7528 if SamplerYcbcrConversionFeatures.samplerYcbcrConversion supportsYUVSamplerConversion","title":"GLES"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vulkan_9","text":"VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2 \u6709\u5219\u542f\u7528 VK_KHR_GET_MEMORY_REQUIREMENTS_2 \u6709\u5219\u542f\u7528 \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_BIND_MEMORY_2 \u6709\u5219\u542f\u7528 \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_EXTERNAL_MEMORY \u542f\u7528 if supportsAndroidHardwareBuffer || supportsExternalMemoryFd|| supportsExternalMemoryFuchsia \u53ef\u80fd\u4e3a\u4e09\u8005\u7684\u524d\u7f6e: \u65e0EXT\u652f\u6301\u68c0\u67e5, \u6761\u4ef6\u6ee1\u8db3\u76f4\u63a5\u542f\u7528. \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_CREATE_RENDERPASS_2 \u6709\u5219\u542f\u7528 supportsRenderpass2 vkCreateRenderPass2KHR VK_KHR_DEPTH_STENCIL_RESOLVE \u4f9d\u8d56\u6b64\u6269\u5c55","title":"Vulkan \u81ea\u7528"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#amd","text":"VK_KHR_IMAGE_FORMAT_LIST \u542f\u7528 if AMD supportsImageFormatList EGL_EXT_image_gl_colorspace","title":"AMD"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#angle-ext","text":"TODO \u5206\u6790\u5bf9\u5e94\u529f\u80fd \u4ee5\u4e0b\u591aExtension\u5c1a\u672a\u5217\u5165 Vulkan Spec, \u662f ANGLE \u671f\u671b\u4e3a\u652f\u6301GLES \u800c\u63d0\u51fa\u7684. VK_KHR_shader_terminate_invocation VK_EXT_primitive_topology_list_restart VK_EXT_vertex_attribute_aliasing VK_EXT_generate_mipmap VK_EXT_pipeline_robustness VK_EXT_image_robustness VK_EXT_custom_border_color VK_EXT_blend_operation_advanced \u51fa\u73b0\u5728\u4ee3\u7801\u4e2d\u4f46\u5c1a\u672a\u542f\u7528\u7684Feature. textureCompressionETC2","title":"ANGLE \u671f\u671b\u5c06\u6765\u52a0\u5165\u7684 EXT"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#angle-vk-features","text":"","title":"ANGLE: Vk Features"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#inheritedqueries","text":"3.0 \u5fc5\u987b","title":"inheritedQueries"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles_7","text":"glBeginQuery glEndQuery glGetQueryiv \u652f\u6301GLES \u6269\u5c55: GL_EXT_occlusion_query_boolean glGenQueriesEXT glDeleteQueriesEXT glIsQueryEXT glBeginQueryEXT glEndQueryEXT glGetQueryivEXT glGetQueryObjectuivEXT","title":"\u652f\u6301 GLES \u529f\u80fd:"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vertexpipelinestoresandatomics","text":"\u7528\u4e8e\u6a21\u62df\u5b9e\u73b0 transform feedback \u529f\u80fd, \u4f5c\u4e3a\u4e0d\u652f\u6301\u6269\u5c55 VK_EXT_ransform_feedback \u65f6\u7684\u66ff\u4ee3. \u4f46 es3.2 \u4e2d\u53ef\u80fd\u51fa\u73b0\u65e0\u6cd5\u652f\u6301\u529f\u80fd.","title":"vertexPipelineStoresAndAtomics"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#angle-vk-limits","text":"","title":"ANGLE: Vk Limits"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#maxperstagedescriptorstoragebuffers","text":"\u5f53\u524d\u503c \u671f\u5f85\u503c 8 12 / 16 ANGLE \u4e2d, Vulkan Limit: maxPerStageDescriptorStorageBuffers \u4e3a GLES \u540c\u65f6\u63d0\u4f9b StorageBuffers \u548c CounterBuffers, \u5bf9\u5e94\u7684 GLES \u7684 Limits \u4e3a: StorageBuffers: MAX_VERTEX_SHADER_STORAGE_BLOCKS MAX_FRAGMENT_SHADER_STORAGE_BLOCKS MAX_COMPUTE_SHADER_STORAGE_BLOCKS AtomicCounterBuffers: MAX_VERTEX_ATOMIC_COUNTER_BUFFERS MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS \u5404\u7ec4\u503c\u5206\u522b\u8ba1\u7b97, \u4f8b\u5982 VERTEX \u7684\u4e24\u8005\u76f8\u52a0\u4e3aBuffer \u7684 Limit \u503c: MAX_VERTEX_SHADER_STORAGE_BLOCKS + MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = maxPerStageDescriptorStorageBuffers, FRAGMENT, COMPUTE \u540c\u7406. (GEOMETRY \u7684 StorageBuffers \u5bf9\u5e94 vkLimit: maxPerStageResources) \u5728 ANGLE \u4e2d, \u671f\u5f85\u503c StorageBuffers >=4, AtomicCounterBuffers =8, \u56e0\u6b64\u5bf9 GLES 3.1 \u8981\u6c42 maxPerStageDescriptorStorageBuffers >=12 \u82e5\u4e0d\u6ee1\u8db3, \u9650\u5236\u7248\u672c\u4e3a3.0, \u5e76\u8bbe AtomicCounterBuffers \u4e3a 0. \u540c\u65f6, \u82e5\u6ee1\u8db3 AtomicCounterBuffers =8 \u540e, \u8981\u540c\u65f6\u6ee1\u8db3 v100 GLES Limits \u4e2d MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 8, \u5219\u9700 maxPerStageDescriptorStorageBuffers = 16 \u5bf9\u5e943.1\u529f\u80fd: MAX_VERTEX_SHADER_STORAGE_BLOCKS \u548c MAX_VERTEX_ATOMIC_COUNTER_BUFFERS \u9700\u8981 vk \u7279\u6027 vertexPipelineStoresAndAtomics, \u800c\u6b64\u7279\u6027\u5728\u652f\u6301 VK_EXT_TRANSFORM_FEEDBACK \u6269\u5c55\u65f6\u4e0d\u518d\u9700\u8981. \u56e0\u6b64\u5b9e\u73b0 VK_EXT_TRANSFORM_FEEDBACK \u540e\u8be5\u7ec4\u53ef\u5ffd\u7565 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS \u548c MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS \u9700\u8981 vk \u7279\u6027 fragmentStoresAndAtomics (v100\u5df2\u652f\u6301).","title":"maxPerStageDescriptorStorageBuffers"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#maxperstagedescriptoruniformbuffers","text":"\u5f53\u524d\u503c \u671f\u5f85\u503c 12 14 \u4e3a kReservedDriverUniformBindingCount, kReservedPerStageDefaultUniformBindingCount \u5404\u7559\u51fa1\u4e2a. \u5f71\u54cd GLES Limits: MAX_VERTEX_UNIFORM_BLOCKS MAX_FRAGMENT_UNIFORM_BLOCKS MAX_COMPUTE_UNIFORM_BLOCKS MAX_GEOMETRY_UNIFORM_BLOCKS MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS","title":"maxPerStageDescriptorUniformBuffers"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#maxdescriptorsetuniformbuffers","text":"\u5f53\u524d\u503c \u671f\u5f85\u503c 72 72+4 = 76 \u4e3a kReservedDriverUniformBindingCount , kReservedDefaultUniformBindingCount \u9884\u7559\u51fa1 + 3 = 4\u4e2a. constexpr uint32_t kTotalReservedUniformBuffers = kReservedDriverUniformBindingCount + kReservedDefaultUniformBindingCount; const int32_t maxCombinedUniformBuffers = LimitToInt(limitsVk.maxDescriptorSetUniformBuffers - kTotalReservedUniformBuffers); \u5f71\u54cd GLES Limits: MAX_UNIFORM_BUFFER_BINDINGS MAX_COMBINED_UNIFORM_BLOCKS","title":"maxDescriptorSetUniformBuffers"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#maxvertexoutputcomponents-maxfragmentinputcomponents","text":"\u5f53\u524d\u503c \u671f\u5f85\u503c 128 128 + 4*2 = 136 \u5f53\u524d\u503c 128, \u5047\u8bbe EXT \u5747\u5f97\u5230\u652f\u6301, \u4e14\u8981\u6ee1\u8db3GLES Limits, \u82e5 \u4e0d \u652f\u6301 VK_EXT_LINE_RASTERIZATION, \u5219\u9884\u7559 1 \u4e3a\u4e86\u652f\u6301 VK_EXT_TRANSFORM_FEEDBACK, \u9700\u8981\u9884\u7559 2 \u5f71\u54cd GLES Limits: MAX_VARYING_VECTORS \u9884\u7559\u524d 31\u521a\u597d\u6ee1\u8db3. MAX_VARYING_COMPONENTS \u9884\u7559\u524d 124 \u521a\u597d\u6ee1\u8db3. (Vector * 4 = Components )","title":"maxVertexOutputComponents \u4e0e maxFragmentInputComponents"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#maxinterpolationoffset","text":"\u5f53\u524d\u503c \u671f\u5f85\u503c 0.4375 0.5","title":"maxInterpolationOffset"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#gles-limits","text":"\u672c\u8868\u57fa\u4e8e ANGLE \u5185\u7684\u8ba1\u7b97\u65b9\u5f0f, \u5e26\u5165 v100 \u7684 Vulkan Limits \u503c, \u68c0\u67e5\u7ed3\u679c\u662f\u5426\u6ee1\u8db3 GLES Limits \u7684\u8981\u6c42. [*] \u5e26\u6b64\u6807\u8bb0\u7684\u8ba1\u7b97\u516c\u5f0f\u57fa\u4e8e\u5047\u8bbe: \u4e0a\u9762\u63d0\u53ca\u7684\u6269\u5c55 TransForm_feedback \u548c Line_Rasterization \u5df2\u5f97\u5230\u652f\u6301. \u800c\u76f8\u5e94\u7684\u7531\u4e8e\u6a21\u62df\u7684Feature\u4e0d\u518d\u542f\u7528. maxPerStageDescriptorStorageBuffers \u4ee5 12 \u8ba1\u7b97 1 GLES Limits GLES Limits in V100 Vk(v100)\u503c\u5e26\u5165 ANGLE ANGLE \u8ba1\u7b97\u516c\u5f0f 2 SUBPIXEL_BITS 8 8 subPixelPrecisionBits 3 MAX_3D_TEXTURE_SIZE 256 256 maxImageDimension3D 4 MAX_TEXTURE_SIZE 8192 8192 min(maxFramebufferWidth, maxImageDimension2D); 5 MAX_ARRAY_TEXTURE_LAYERS 256 256 maxImageArrayLayers 6 MAX_TEXTURE_LOD_BIAS 14 14 maxSamplerLodBias 7 MAX_CUBE_MAP_TEXTURE_SIZE 8192 8192 maxImageDimensionCube 8 MAX_RENDERBUFFER_SIZE 8192 8192 min(maxImageDimension2D, maxFramebufferWidth, maxFramebufferHeight); 9 ALIASED_LINE_WIDTH_RANGE[0] 1 1 1 10 ALIASED_LINE_WIDTH_RANGE[1] 4095.9375 1 1 11 ALIASED_POINT_SIZE_RANGE[0] 1 1 max(1.0f, pointSizeRange[0]) 12 ALIASED_POINT_SIZE_RANGE[1] 1024 1024 pointSizeRange[1] 13 MULTISAMPLE_LINE_WIDTH_RANGE [1.0, 4095.9375] - - 14 MULTISAMPLE_LINE_WIDTH_GRANULARITY 0.125 - - 15 MAX_DRAW_BUFFERS 4 4 min(maxColorAttachments, maxFragmentOutputAttachments); 16 MAX_FRAMEBUFFER_WIDTH 8192 8192 maxFramebufferWidth 17 MAX_FRAMEBUFFER_HEIGHT 8192 8192 maxFramebufferHeight 18 MAX_FRAMEBUFFER_LAYERS 256 256 maxFramebufferLayers 19 MAX_FRAMEBUFFER_SAMPLES SAMPLECOUNT1 - SAMPLE_COUNT_4 4 \u540c maxSamples 21 MAX_COLOR_ATTACHMENTS 4 4 maxColorAttachments 22 MIN_FRAGMENT_INTERPOLATION_OFFSET -0.5 -0.5 minInterpolationOffset 23 MAX_FRAGMENT_INTERPOLATION_OFFSET 0.5 0.4375 maxInterpolationOffset 24 FRAGMENT_INTERPOLATION_OFFSET_BITS 4 4 subPixelInterpolationOffsetBits 25 MAX_VIEWPORT_DIMS[0] 8192 8192 maxViewportDimensions[0] 26 MAX_VIEWPORT_DIMS[1] 8192 8192 maxViewportDimensions[1] 27 MAX_SAMPLE_MASK_WORDS 1 1 maxSampleMaskWords 28 MAX_COLOR_TEXTURE_SAMPLES SAMPLECOUNT1 ??? SAMPLECOUNT1-SAMPLECOUNT4? sampledImageColorSampleCounts&31 29 SAMPLE_COUNT_4 - - 30 MAX_DEPTH_TEXTURE_SAMPLES SAMPLECOUNT1 ??? SAMPLECOUNT1-SAMPLECOUNT4? sampledImageDepthSampleCounts&31 31 SAMPLE_COUNT_4 - - 32 MAX_INTEGER_SAMPLES SAMPLECOUNT1 ??? SAMPLECOUNT1-SAMPLECOUNT4? sampledImageIntegerSampleCounts&31 33 SAMPLE_COUNT_4 - - 34 MAX_SERVER_WAIT_TIMEOUT 0 - UNIMPLEMENT 35 LAYER_PROVOKING_VERTEX FIRSTVERTEXCONVENTION - GL_LAST_VERTEX_CONVENTION_EXT 36 LAST_VERTEX_CONVENTION - -- 37 PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED FALSE - -- 38 MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 2047 2047 min(maxVertexInputAttributeOffset, (int16_max -1)) 39 MAX_VERTEX_ATTRIB_BINDINGS 16 16 maxVertexInputBindings 40 MAX_VERTEX_ATTRIB_STRIDE 2048 2048 min(maxVertexInputBindingStride, int16_max) 41 MAX_ELEMENTS_INDICES INT_MAX INT_MAX 42 MAX_ELEMENTS_VERTICES INT_MAX INT_MAX 43 MAX_ELEMENT_INDEX 0xFFFFFFFF UINT_MAX - 1 UINT_MAX - 1 44 MAX_TEXTURE_BUFFER_SIZE 2^24 ??? 224 maxTexelBufferElements 45 NUM_COMPRESSED_TEXTURE_FORMATS 49 -- -- // size of Compressed Texture Formats 46 COMPRESSED_TEXTURE_FORMATS -- -- 47 NUM_PROGRAM_BINARY_FORMATS 0 -- -- 48 PROGRAM_BINARY_FORMATS -- -- 49 NUM_SHADER_BINARY_FORMATS 0 -- -- 50 SHADER_BINARY_FORMATS -- -- 51 SHADER_COMPILER TRUE TRUE 52 TEXTURE_BUFFER_OFFSET_ALIGNMENT 256 256 minTexelBufferOffsetAlignment 53 MAX_TEXTURE_MAX_ANISOTROPY_EXT 16 16 maxSamplerAnisotropy 54 MAX_VERTEX_ATTRIBS 16 16 maxVertexInputAttributes 55 MAX_VERTEX_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 56 MAX_VERTEX_UNIFORM_VECTORS 256 1024 maxUniformBufferRange / (sizeof(float) *4) 57 MAX_VERTEX_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 58 MAX_VERTEX_OUTPUT_COMPONENTS 128 128 maxVertexOutputComponents 59 MAX_VERTEX_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 60 MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0 0 0* 61 MAX_VERTEX_ATOMIC_COUNTERS 0 0 0* 62 MAX_VERTEX_SHADER_STORAGE_BLOCKS 0 0 0* 63 MAX_TESS_GEN_LEVEL 64 -- 64 MAX_PATCH_VERTICES 32 -- 65 MAX_TESS_CONTROL_UNIFORM_COMPONENTS 1024 -- 66 MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 16 -- 67 MAX_TESS_CONTROL_OUTPUT_COMPONENTS 128 -- 68 MAX_TESS_PATCH_COMPONENTS 120 -- 69 MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 4096 -- 70 MAX_TESS_CONTROL_INPUT_COMPONENTS 128 -- 71 MAX_TESS_CONTROL_UNIFORM_BLOCKS 12 -- 72 MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0 -- 73 MAX_TESS_CONTROL_ATOMIC_COUNTERS 0 -- 74 MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0 -- 75 MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 1024 -- 76 MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 16 -- 77 MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 128 -- 78 MAX_TESS_EVALUATION_INPUT_COMPONENTS 128 -- 79 MAX_TESS_EVALUATION_UNIFORM_BLOCKS 12 -- 80 MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0 -- 81 MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0 -- 82 MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0 -- 83 MAX_GEOMETRY_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 84 MAX_GEOMETRY_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 85 MAX_GEOMETRY_INPUT_COMPONENTS 128 128 maxGeometryInputComponents 86 MAX_GEOMETRY_OUTPUT_COMPONENTS 128 128 maxGeometryOutputComponents 87 MAX_GEOMETRY_OUTPUT_VERTICES 256 256 maxGeometryOutputVertices 88 MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 1024 1024 maxGeometryTotalOutputComponents 89 MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 90 MAX_GEOMETRY_SHADER_INVOCATIONS 32 32 maxGeometryShaderInvocations 91 MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0 8* 8* 92 MAX_GEOMETRY_ATOMIC_COUNTERS 0 56 maxStorageBufferRange / sizeof(uint32_t) 93 MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0 45 maxPerStageResources-7 94 MAX_FRAGMENT_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 95 MAX_FRAGMENT_UNIFORM_VECTORS 256 1024 maxUniformBufferRange / (sizeof(float) *4) 96 MAX_FRAGMENT_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 97 MAX_FRAGMENT_INPUT_COMPONENTS 128 4,096\u202c maxUniformBufferRange / sizeof(float) 98 MAX_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 99 MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 1 8 8* 100 MAX_FRAGMENT_ATOMIC_COUNTERS 8 56 maxStorageBufferRange / sizeof(uint32_t) 101 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 8 4 4* 102 MIN_PROGRAM_TEXTURE_GATHER_OFFSET -8 -8 minTexelGatherOffset 103 MAX_PROGRAM_TEXTURE_GATHER_OFFSET 7 7 maxTexelGatherOffset 104 MIN_PROGRAM_TEXEL_OFFSET -8 -8 minTexelOffset 105 MAX_PROGRAM_TEXEL_OFFSET 7 7 maxTexelOffset 106 MAX_COMPUTE_WORK_GROUP_COUNT[0] 65535 65535 maxComputeWorkGroupCount[0] 107 MAX_COMPUTE_WORK_GROUP_COUNT[1] 65535 65535 maxComputeWorkGroupCount[1] 108 MAX_COMPUTE_WORK_GROUP_COUNT[2] 65535 65535 maxComputeWorkGroupCount[2] 109 MAX_COMPUTE_WORK_GROUP_SIZE[0] 1024 1024 [vulkan] maxComputeWorkGroupSize[0] 110 MAX_COMPUTE_WORK_GROUP_SIZE[1] 1024 1024 [vulkan] maxComputeWorkGroupSize[1] 111 MAX_COMPUTE_WORK_GROUP_SIZE[2] 64 64 [vulkan] maxComputeWorkGroupSize[2] 112 MAX_COMPUTE_WORK_GROUP_INVOCATIONS 1024 1024 [vulkan] maxComputeWorkGroupInvocations 113 MAX_COMPUTE_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 114 MAX_COMPUTE_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 115 MAX_COMPUTE_SHARED_MEMORY_SIZE 32768 32768 maxComputeSharedMemorySize 116 MAX_COMPUTE_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 117 MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 1 8 8* 118 MAX_COMPUTE_ATOMIC_COUNTERS 8 56 maxStorageBufferRange / sizeof(uint32_t) 119 MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 120 MAX_COMPUTE_SHADER_STORAGE_BLOCKS 8 4 maxPerStageDescriptorStorageBuffers - 8 121 MAX_UNIFORM_BUFFER_BINDINGS 72 68 maxDescriptorSetUniformBuffers -4 122 MAX_UNIFORM_BLOCK_SIZE 16384 16384 maxUniformBufferRange 123 UNIFORM_BUFFER_OFFSET_ALIGNMENT 16 16 minUniformBufferOffsetAlignment 124 MAX_COMBINED_UNIFORM_BLOCKS 72 68 maxDescriptorSetUniformBuffers -4 125 MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 126 MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 50176 -- 127 MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 50176 -- 128 MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 129 MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 130 MAX_VARYING_COMPONENTS 124 116 (min(maxVertexOutputComponents, maxFragmentInputComponents) /4 - 3)*4 131 MAX_VARYING_VECTORS 31 29 min(maxVertexOutputComponents, maxFragmentInputComponents) /4 - 3 132 MAX_COMBINED_TEXTURE_IMAGE_UNITS 96 96 min(maxDescriptorSetSamplers, maxDescriptorSetSampledImages); 133 MAX_COMBINED_SHADER_OUTPUT_RESOURCES 20 45 maxPerStageResources-7 134 MAX_UNIFORM_LOCATIONS 1024 1024 maxUniformBufferRange / (sizeof(float) *4) 135 MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 1 8 8* 136 MAX_ATOMIC_COUNTER_BUFFER_SIZE 32 227 maxStorageBufferRange 137 MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 1 8 8* 138 MAX_COMBINED_ATOMIC_COUNTERS 8 56 maxStorageBufferRange / sizeof(uint32_t) 139 MAX_IMAGE_UNITS 8 48 maxDescriptorSetStorageImages 140 MAX_VERTEX_IMAGE_UNIFORMS 0 0 0* 141 MAX_TESS_CONTROL_IMAGE_UNIFORMS 0 -- -- 142 MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0 -- -- 143 MAX_GEOMETRY_IMAGE_UNIFORMS 0 0 0* 144 MAX_FRAGMENT_IMAGE_UNIFORMS 8 8 maxPerStageDescriptorStorageImages* 145 MAX_COMPUTE_IMAGE_UNIFORMS 8 8 maxPerStageDescriptorStorageImages* 146 MAX_COMBINED_IMAGE_UNIFORMS 8 48 maxDescriptorSetStorageImages 147 MAX_SHADER_STORAGE_BUFFER_BINDINGS 4 40 maxDescriptorSetStorageBuffers - 8* 148 MAX_SHADER_STORAGE_BLOCK_SIZE 2^27 ??? 227 maxStorageBufferRange 149 MAX_COMBINED_SHADER_STORAGE_BLOCKS 8 40 maxDescriptorSetStorageBuffers - 8* 150 SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 256 256 minStorageBufferOffsetAlignment 151 MAX_LABEL_LENGTH 256 1024 1024 152 MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 64 128 128 153 MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 4 4 4 154 MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 4 4 4 155 MAX_SAMPLES 4 4 SAMPLE_COUNT_1 - SAMPLE_COUNT_4 156 MAX_SERVER_WAIT_TIMEOUT 0 -- UNIMPLEMENT 157 MAX_VIEWS_OVR 6 1 1","title":"\u9644\u8868: GLES Limits \u6ee1\u8db3\u60c5\u51b5\u8be6\u60c5"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#properties","text":"// Provided by VK_VERSION_1_0 typedef struct VkQueueFamilyProperties { VkQueueFlags queueFlags; uint32_t queueCount; uint32_t timestampValidBits; VkExtent3D minImageTransferGranularity; } VkQueueFamilyProperties; \u9700\u6c42: VkQueueFamilyProperties. timestampValidBits > 0 \u652f\u6301 GLES EXT: GL_EXT_disjoint_timer_query disjointTimerQuery","title":"\u5176\u4ed6 Properties"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#_3","text":"","title":"\u9644\u5f55"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#v100-gles-extension","text":"\u4ece GLES Extensions \u89c6\u89d2, \u67e5\u8be2\u6240\u9700\u7684 Vk \u652f\u6301. OpenGL ES Extension in v100 ANGLE \u652f\u6301 ANGLE \u652f\u6301\u6761\u4ef6 Vulkan (v100) \u6ee1\u8db3 GL_EXT_multi_draw_indirect UNIMPLEMENTED GL_EXT_debug_marker Y GL_ARM_rgba8 GL_ARM_mali_shader_binary GL_OES_depth24 Y GL_OES_depth_texture Y GL_OES_depth_texture_cube_map Y GL_OES_packed_depth_stencil Y GL_OES_rgb8_rgba8 Y GL_EXT_read_format_bgra Y GL_OES_compressed_paletted_texture GL_OES_compressed_ETC1_RGB8_texture Y GL_OES_standard_derivatives Y GL_OES_EGL_image Y GL_OES_EGL_image_external Y GL_OES_EGL_image_external_essl3 Y GL_OES_EGL_sync Y GL_OES_texture_npot Y GL_OES_vertex_half_float Y GL_OES_required_internalformat GL_OES_vertex_array_object Y GL_OES_mapbuffer Y GL_EXT_texture_format_BGRA8888 Y GL_EXT_texture_rg Y GL_EXT_texture_type_2_10_10_10_REV Y GL_OES_fbo_render_mipmap Y GL_OES_element_index_uint Y GL_EXT_shadow_samplers Y GL_KHR_texture_compression_astc_ldr GL_KHR_debug Y GL_EXT_occlusion_query_boolean Y GL_EXT_disjoint_timer_query Y GL_EXT_blend_minmax Y GL_EXT_discard_framebuffer Y GL_OES_get_program_binary Y GL_OES_texture_3D Y GL_EXT_texture_storage Y GL_EXT_multisampled_render_to_texture Y GL_OES_surfaceless_context Y GL_OES_texture_stencil8 Y GL_EXT_shader_pixel_local_storage GL_ARM_shader_framebuffer_fetch GL_ARM_shader_framebuffer_fetch_depth_stencil GL_EXT_shader_framebuffer_fetch_non_coherent GL_ARM_mali_program_binary GL_EXT_sRGB Y GL_EXT_sRGB_write_control GL_EXT_texture_sRGB_decode Y GL_EXT_texture_sRGB_R8 Y GL_EXT_texture_sRGB_RG8 GL_KHR_blend_equation_advanced GL_KHR_blend_equation_advanced_coherent GL_OES_texture_storage_multisample_2d_array Y GL_OES_shader_image_atomic Y GL_EXT_robustness Y GL_EXT_draw_buffers_indexed Y GL_OES_draw_buffers_indexed Y GL_EXT_texture_border_clamp GL_OES_texture_border_clamp GL_EXT_texture_cube_map_array Y GL_OES_texture_cube_map_array Y GL_OES_sample_variables Y GL_OES_sample_shading Y GL_OES_shader_multisample_interpolation GL_EXT_shader_io_blocks GL_OES_shader_io_blocks GL_EXT_tessellation_shader GL_OES_tessellation_shader GL_EXT_primitive_bounding_box GL_OES_primitive_bounding_box GL_EXT_geometry_shader Y GL_OES_geometry_shader GL_ANDROID_extension_pack_es31a GL_EXT_gpu_shader5 Y GL_OES_gpu_shader5 GL_EXT_texture_buffer Y GL_OES_texture_buffer Y GL_EXT_copy_image Y GL_OES_copy_image GL_EXT_shader_non_constant_global_initializers Y GL_EXT_color_buffer_half_float Y GL_EXT_color_buffer_float Y GL_EXT_YUV_target GL_OVR_multiview GL_OVR_multiview2 GL_OVR_multiview_multisampled_render_to_texture GL_KHR_robustness GL_KHR_robust_buffer_access_behavior GL_EXT_draw_elements_base_vertex Y GL_OES_draw_elements_base_vertex Y GL_EXT_protected_textures GL_EXT_geometry_point_size GL_OES_geometry_point_size GL_EXT_tessellation_point_size GL_OES_tessellation_point_size GL_OES_draw_texture","title":"v100 GLES Extension \u652f\u6301\u60c5\u51b5"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#v100-egl-extension","text":"EGL extensions EGL_KHR_get_all_proc_addresses EGL_ANDROID_presentation_time EGL_KHR_swap_buffes_witn_damage EGL_ANDROID_get_native_client_buffer EGL_ANDROID_front_buffer_auto_refresh EGL_ANDROID_get_frame_timestamps EGL_KHR_image EGL_KHR_image_base EGL_KHR_gl_colorspace EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_gl_renderbuffer_image EGL_KHR_fence_sync EGL_KHR_create_context EGL_KHR_config_attribs EGL_KHR_surfaceless_context EGL_EXT_create_context_robustness EGL_ANDROID_image_native_buffer EGL_KHR_wait_sync EGL_ANDROID_recordable EGL_KHR_partial_update EGL_KHR_mutable_render_buffer EGL_EXT_protected_content EGL_IMG_context_priority","title":"v100 EGL Extension"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#angle-vk-features_1","text":"","title":"ANGLE \u4e2d\u542f\u7528\u7684 Vk Features"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#vulkan_1_0-features","text":"// Select additional features to be enabled. mPhysicalDeviceFeatures{ // Used to support cubemap array: only enable when not SwiftShader or not Qualcomm imageCubeArray; // Used to support framebuffers with multiple attachments: independentBlend; // Used to support robust buffer access: robustBufferAccess; // Used to support Anisotropic filtering: samplerAnisotropy; // Used to support wide lines: wideLines; // Used to emulate transform feedback: vertexPipelineStoresAndAtomics; // Used to implement storage buffers and images in the fragment shader: fragmentStoresAndAtomics; // Used to support geometry shaders: geometryShader // Used to support EXT_gpu_shader5: shaderImageGatherExtended; // Used to support EXT_gpu_shader5: shaderUniformBufferArrayDynamicIndexing // Used to support EXT_gpu_shader5 and sampler array of array emulation: shaderSampledImageArrayDynamicIndexing; // Used to support atomic counter emulation: shaderStorageBufferArrayDynamicIndexing; // Used to support APPLE_clip_distance shaderClipDistance // Used to support OES_sample_shading sampleRateShading; // Used to support depth clears through draw calls. depthClamp; // if (!vk::CommandBuffer::ExecutesInline()) inheritedQueries; // Used to support OES_sample_variables sampleRateShading; } Extension Features: VkPhysicalDeviceLineRasterizationFeaturesEXT VkPhysicalDeviceProvokingVertexFeaturesEXT VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT VkPhysicalDeviceTransformFeedbackFeaturesEXT VkPhysicalDeviceIndexTypeUint8FeaturesEXT VkPhysicalDeviceShaderFloat16Int8FeaturesKHR VkPhysicalDeviceSamplerYcbcrConversionFeatures","title":"Vulkan_1_0 Features:"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#8-appendix","text":"","title":"8. Appendix"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#81-capability","text":"The recommended value for vulkan 1.1 features and limits report for HiVoyager V100 chip are listed in this chapter.","title":"8.1. Capability"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#811-physical-device-features","text":"Feature Supported on HiVoyager V100 robustBufferAccess yes fullDrawIndexUint32 yes imageCubeArray yes independentBlend yes geometryShader yes tessellationShader yes sampleRateShading yes dualSrcBlend no logicOp no multiDrawIndirect yes drawIndirectFirstInstance yes depthClamp yes depthBiasClamp yes fillModeNonSolid yes depthBounds yes wideLines yes largePoints yes alphaToOne yes multiViewport no samplerAnisotropy yes textureCompressionETC2 yes textureCompressionASTC_LDR yes textureCompressionBC no occlusionQueryPrecise yes pipelineStatisticsQuery no vertexPipelineStoresAndAtomics no fragmentStoresAndAtomics yes shaderTessellationAndGeometryPointSize yes shaderImageGatherExtended yes shaderStorageImageExtendedFormats yes shaderStorageImageMultisample no shaderStorageImageReadWithoutFormat yes shaderStorageImageWriteWithoutFormat yes shaderUniformBufferArrayDynamicIndexing yes shaderSampledImageArrayDynamicIndexing yes shaderStorageBufferArrayDynamicIndexing yes shaderStorageImageArrayDynamicIndexing yes shaderClipDistance yes shaderCullDistance yes shaderFloat64 no shaderInt64 no shaderInt16 yes shaderResourceResidency no shaderResourceMinLod no sparseBinding no sparseResidencyBuffer no sparseResidencyImage2D no sparseResidencyImage3D no sparseResidency2Samples no sparseResidency4Samples no sparseResidency8Samples no sparseResidency16Samples no sparseResidencyAliased no variableMultisampleRate no inheritedQueries no","title":"8.1.1. Physical Device Features"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#812-physical-device-limits","text":"Name Limit of HiVoyager V100 maxImageDimension1D 8192 maxImageDimension2D 8192[ 1 ] maxImageDimension3D 256 maxImageDimensionCube 8192 maxImageArrayLayers 256 maxTexelBufferElements 224 maxUniformBufferRange 16384 maxStorageBufferRange 227 maxPushConstantsSize 256 maxMemoryAllocationCount 232-1 maxSamplerAllocationCount 223 bufferImageGranularity 4096 sparseAddressSpaceSize 0 maxBoundDescriptorSets 4 maxPerStageDescriptorSamplers 16 maxPerStageDescriptorUniformBuffers 12 maxPerStageDescriptorStorageBuffers 8 maxPerStageDescriptorSampledImages 16 maxPerStageDescriptorStorageImages 8[ 2 ] maxPerStageDescriptorInputAttachments 4 maxPerStageResources 52 maxDescriptorSetSamplers 96 maxDescriptorSetUniformBuffers 72 maxDescriptorSetUniformBuffersDynamic 8 maxDescriptorSetStorageBuffers 48 maxDescriptorSetStorageBuffersDynamic 4 maxDescriptorSetSampledImages 96 maxDescriptorSetStorageImages 48 maxDescriptorSetInputAttachments 4 maxVertexInputAttributes 16 maxVertexInputBindings 16 maxVertexInputAttributeOffset 2047 maxVertexInputBindingStride 2048 maxVertexOutputComponents 128 maxTessellationGenerationLevel 64 maxTessellationPatchSize 32 maxTessellationControlPerVertexInputComponents 128 maxTessellationControlPerVertexOutputComponents 128 maxTessellationControlPerPatchOutputComponents 120 maxTessellationControlTotalOutputComponents 4096 maxTessellationEvaluationInputComponents 128 maxTessellationEvaluationOutputComponents 128 maxGeometryShaderInvocations 32 maxGeometryInputComponents 128 maxGeometryOutputComponents 128 maxGeometryOutputVertices 256 maxGeometryTotalOutputComponents 1024 maxFragmentInputComponents 128 maxFragmentOutputAttachments 4 maxFragmentDualSrcAttachments 1 maxFragmentCombinedOutputResources 20 maxComputeSharedMemorySize 32768 maxComputeWorkGroupCount[0] 65535 maxComputeWorkGroupCount[1] 65535 maxComputeWorkGroupCount[2] 65535 maxComputeWorkGroupInvocations 384 [v120, opencl] maxComputeWorkGroupInvocations 256 [v100, opencl] maxComputeWorkGroupInvocations 1024 [vulkan] maxComputeWorkGroupSize[0] 256 [opencl] maxComputeWorkGroupSize[0] 1024 [vulkan] maxComputeWorkGroupSize[1] 256 [v120, opencl] maxComputeWorkGroupSize[1] 32 [v100, opencl] maxComputeWorkGroupSize[1] 1024 [vulkan] maxComputeWorkGroupSize[2] 64 [v120, opencl] maxComputeWorkGroupSize[2] 2 [v100, opencl] maxComputeWorkGroupSize[2] 64 [vulkan] subPixelPrecisionBits 8 subTexelPrecisionBits 8 mipmapPrecisionBits 6 maxDrawIndexedIndexValue 0xFFFFFFFF maxDrawIndirectCount 232-1 maxSamplerLodBias 14 maxSamplerAnisotropy 16 maxViewports 1 maxViewportDimensions[0] 8192 maxViewportDimensions[1] 8192 viewportBoundsRange[0] -16384 viewportBoundsRange[1] 16383 viewportSubPixelBits 0 minMemoryMapAlignment 64 minTexelBufferOffsetAlignment 256 minUniformBufferOffsetAlignment 16 minStorageBufferOffsetAlignment 256 minTexelOffset -8 maxTexelOffset 7 minTexelGatherOffset -8 maxTexelGatherOffset 7 minInterpolationOffset -0.5 maxInterpolationOffset 0.4375 subPixelInterpolationOffsetBits 4 maxFramebufferWidth 8192 maxFramebufferHeight 8192 maxFramebufferLayers 256 framebufferColorSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 framebufferDepthSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 framebufferStencilSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 framebufferNoAttachmentsSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 maxColorAttachments 4 sampledImageColorSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 sampledImageIntegerSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 sampledImageDepthSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 sampledImageStencilSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 storageImageSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 maxSampleMaskWords 1 timestampComputeAndGraphics yes timestampPeriod 52.083333333 (1000/19.2) maxClipDistances 8 maxCullDistances 8 maxCombinedClipAndCullDistances 8 discreteQueuePriorities 2 pointSizeRange[0] 1.0 pointSizeRange[1] 1024.0 lineWidthRange[0] 1.0 lineWidthRange[1] 4095.9375 pointSizeGranularity 0.1 lineWidthGranularity 0.1 strictLines yes standardSampleLocations yes optimalBufferCopyOffsetAlignment 512 optimalBufferCopyRowPitchAlignment 512 nonCoherentAtomSize 64 maxUpdateAfterBindDescriptorsInAllPools 500000 maxMultiviewViewCount 6 Actually the hardware ability of maxImageDimension2D is 16384 . According to driver\u2019s requirement, maxImageDimension2D is set to 8192 . Do not support image load store for vertex pipeline in GLES; Do not support image store for vertex pipeline in Vulkan.","title":"8.1.2. Physical Device Limits"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#813-physical-device-limits-opengles","text":"Name Limit of HiVoyager V100 SUBPIXEL_BITS 8 MAX_3D_TEXTURE_SIZE 256 MAX_TEXTURE_SIZE 8192 MAX_ARRAY_TEXTURE_LAYERS 256 MAX_TEXTURE_LOD_BIAS 14 MAX_CUBE_MAP_TEXTURE_SIZE 8192 MAX_RENDERBUFFER_SIZE 8192 ALIASED_LINE_WIDTH_RANGE[0] 1.0 ALIASED_LINE_WIDTH_RANGE[1] 4095.9375 ALIASED_POINT_SIZE_RANGE[0] 1.0 ALIASED_POINT_SIZE_RANGE[1] 1024.0 MULTISAMPLE_LINE_WIDTH_RANGE [1.0, 4095.9375] MULTISAMPLE_LINE_WIDTH_GRANULARITY 0.125 MAX_DRAW_BUFFERS 4 MAX_FRAMEBUFFER_WIDTH 8192 MAX_FRAMEBUFFER_HEIGHT 8192 MAX_FRAMEBUFFER_LAYERS 256 MAX_FRAMEBUFFER_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_COLOR_ATTACHMENTS 4 MIN_FRAGMENT_INTERPOLATION_OFFSET -0.5 MAX_FRAGMENT_INTERPOLATION_OFFSET 0.5 FRAGMENT_INTERPOLATION_OFFSET_BITS 4 MAX_VIEWPORT_DIMS[0] 8192 MAX_VIEWPORT_DIMS[1] 8192 MAX_SAMPLE_MASK_WORDS 1 MAX_COLOR_TEXTURE_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_DEPTH_TEXTURE_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_INTEGER_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_SERVER_WAIT_TIMEOUT 0 LAYER_PROVOKING_VERTEX FIRST_VERTEX_CONVENTION LAST_VERTEX_CONVENTION PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED FALSE MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 2047 MAX_VERTEX_ATTRIB_BINDINGS 16 MAX_VERTEX_ATTRIB_STRIDE 2048 MAX_ELEMENTS_INDICES MAX_ELEMENTS_VERTICES MAX_ELEMENT_INDEX 0xFFFFFFFF MAX_TEXTURE_BUFFER_SIZE 2^24 NUM_COMPRESSED_TEXTURE_FORMATS 49 COMPRESSED_TEXTURE_FORMATS NUM_PROGRAM_BINARY_FORMATS 0 PROGRAM_BINARY_FORMATS NUM_SHADER_BINARY_FORMATS 0 SHADER_BINARY_FORMATS SHADER_COMPILER TEXTURE_BUFFER_OFFSET_ALIGNMENT 256 MAX_TEXTURE_MAX_ANISOTROPY_EXT 16 MAX_VERTEX_ATTRIBS 16 MAX_VERTEX_UNIFORM_COMPONENTS 1024 MAX_VERTEX_UNIFORM_VECTORS 256 MAX_VERTEX_UNIFORM_BLOCKS 12 MAX_VERTEX_OUTPUT_COMPONENTS 128 MAX_VERTEX_TEXTURE_IMAGE_UNITS 16 MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0 MAX_VERTEX_ATOMIC_COUNTERS 0 MAX_VERTEX_SHADER_STORAGE_BLOCKS 0 MAX_TESS_GEN_LEVEL 64 MAX_PATCH_VERTICES 32 MAX_TESS_CONTROL_UNIFORM_COMPONENTS 1024 MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 16 MAX_TESS_CONTROL_OUTPUT_COMPONENTS 128 MAX_TESS_PATCH_COMPONENTS 120 MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 4096 MAX_TESS_CONTROL_INPUT_COMPONENTS 128 MAX_TESS_CONTROL_UNIFORM_BLOCKS 12 MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0 MAX_TESS_CONTROL_ATOMIC_COUNTERS 0 MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0 MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 1024 MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 16 MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 128 MAX_TESS_EVALUATION_INPUT_COMPONENTS 128 MAX_TESS_EVALUATION_UNIFORM_BLOCKS 12 MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0 MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0 MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0 MAX_GEOMETRY_UNIFORM_COMPONENTS 1024 MAX_GEOMETRY_UNIFORM_BLOCKS 12 MAX_GEOMETRY_INPUT_COMPONENTS 128 MAX_GEOMETRY_OUTPUT_COMPONENTS 128 MAX_GEOMETRY_OUTPUT_VERTICES 256 MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 1024 MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 16 MAX_GEOMETRY_SHADER_INVOCATIONS 32 MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0 MAX_GEOMETRY_ATOMIC_COUNTERS 0 MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0 MAX_FRAGMENT_UNIFORM_COMPONENTS 1024 MAX_FRAGMENT_UNIFORM_VECTORS 256 MAX_FRAGMENT_UNIFORM_BLOCKS 12 MAX_FRAGMENT_INPUT_COMPONENTS 128 MAX_TEXTURE_IMAGE_UNITS 16 MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 1 MAX_FRAGMENT_ATOMIC_COUNTERS 8 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 8 MIN_PROGRAM_TEXTURE_GATHER_OFFSET -8 MAX_PROGRAM_TEXTURE_GATHER_OFFSET 7 MIN_PROGRAM_TEXEL_OFFSET -8 MAX_PROGRAM_TEXEL_OFFSET 7 MAX_COMPUTE_WORK_GROUP_COUNT[0] 65535 MAX_COMPUTE_WORK_GROUP_COUNT[1] 65535 MAX_COMPUTE_WORK_GROUP_COUNT[2] 65535 MAX_COMPUTE_WORK_GROUP_SIZE[0] 1024 MAX_COMPUTE_WORK_GROUP_SIZE[1] 1024 MAX_COMPUTE_WORK_GROUP_SIZE[2] 64 MAX_COMPUTE_WORK_GROUP_INVOCATIONS 1024 MAX_COMPUTE_UNIFORM_BLOCKS 12 MAX_COMPUTE_TEXTURE_IMAGE_UNITS 16 MAX_COMPUTE_SHARED_MEMORY_SIZE 32768 MAX_COMPUTE_UNIFORM_COMPONENTS 1024 MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 1 MAX_COMPUTE_ATOMIC_COUNTERS 8 MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 50176 MAX_COMPUTE_SHADER_STORAGE_BLOCKS 8 MAX_UNIFORM_BUFFER_BINDINGS 72 MAX_UNIFORM_BLOCK_SIZE 16384 UNIFORM_BUFFER_OFFSET_ALIGNMENT 16 MAX_COMBINED_UNIFORM_BLOCKS 72 MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 50176 MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 50176 MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 50176 MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 50176 MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 50176 MAX_VARYING_COMPONENTS 124 MAX_VARYING_VECTORS 31 MAX_COMBINED_TEXTURE_IMAGE_UNITS 96 MAX_COMBINED_SHADER_OUTPUT_RESOURCES 20 MAX_UNIFORM_LOCATIONS 1024 MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 1 MAX_ATOMIC_COUNTER_BUFFER_SIZE 32 MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 1 MAX_COMBINED_ATOMIC_COUNTERS 8 MAX_IMAGE_UNITS 8 MAX_VERTEX_IMAGE_UNIFORMS 0 MAX_TESS_CONTROL_IMAGE_UNIFORMS 0 MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0 MAX_GEOMETRY_IMAGE_UNIFORMS 0 MAX_FRAGMENT_IMAGE_UNIFORMS 8 MAX_COMPUTE_IMAGE_UNIFORMS 8 MAX_COMBINED_IMAGE_UNIFORMS 8 MAX_SHADER_STORAGE_BUFFER_BINDINGS 4 MAX_SHADER_STORAGE_BLOCK_SIZE 2^27 MAX_COMBINED_SHADER_STORAGE_BLOCKS 8 SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 256 MAX_LABEL_LENGTH 256 MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 64 MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 4 MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 4 MAX_SAMPLES 4 MAX_SERVER_WAIT_TIMEOUT 0 MAX_VIEWS_OVR 6","title":"8.1.3. Physical Device Limits OpenGLES"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#82-extension","text":"OpenGL ES, EGL and Vulkan extension for HiVoyager V100 chip are listed in this chapter.","title":"8.2. Extension"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#821-opengl-es-extension","text":"OpenGL ES Extension GL_EXT_multi_draw_indirect GL_EXT_debug_marker GL_ARM_rgba8 GL_ARM_mali_shader_binary GL_OES_depth24 GL_OES_depth_texture GL_OES_depth_texture_cube_map GL_OES_packed_depth_stencil GL_OES_rgb8_rgba8 GL_EXT_read_format_bgra GL_OES_compressed_paletted_texture GL_OES_compressed_ETC1_RGB8_texture GL_OES_standard_derivatives GL_OES_EGL_image GL_OES_EGL_image_external GL_OES_EGL_image_external_essl3 GL_OES_EGL_sync GL_OES_texture_npot GL_OES_vertex_half_float GL_OES_required_internalformat GL_OES_vertex_array_object GL_OES_mapbuffer GL_EXT_texture_format_BGRA8888 GL_EXT_texture_rg GL_EXT_texture_type_2_10_10_10_REV GL_OES_fbo_render_mipmap GL_OES_element_index_uint GL_EXT_shadow_samplers GL_KHR_texture_compression_astc_ldr GL_KHR_debug GL_EXT_occlusion_query_boolean GL_EXT_disjoint_timer_query GL_EXT_blend_minmax GL_EXT_discard_framebuffer GL_OES_get_program_binary GL_OES_texture_3D GL_EXT_texture_storage GL_EXT_multisampled_render_to_texture GL_OES_surfaceless_context GL_OES_texture_stencil8 GL_EXT_shader_pixel_local_storage GL_ARM_shader_framebuffer_fetch GL_ARM_shader_framebuffer_fetch_depth_stencil GL_EXT_shader_framebuffer_fetch_non_coherent GL_ARM_mali_program_binary GL_EXT_sRGB GL_EXT_sRGB_write_control GL_EXT_texture_sRGB_decode GL_EXT_texture_sRGB_R8 GL_EXT_texture_sRGB_RG8 GL_KHR_blend_equation_advanced GL_KHR_blend_equation_advanced_coherent GL_OES_texture_storage_multisample_2d_array GL_OES_shader_image_atomic GL_EXT_robustness GL_EXT_draw_buffers_indexed GL_OES_draw_buffers_indexed GL_EXT_texture_border_clamp GL_OES_texture_border_clamp GL_EXT_texture_cube_map_array GL_OES_texture_cube_map_array GL_OES_sample_variables GL_OES_sample_shading GL_OES_shader_multisample_interpolation GL_EXT_shader_io_blocks GL_OES_shader_io_blocks GL_EXT_tessellation_shader GL_OES_tessellation_shader GL_EXT_primitive_bounding_box GL_OES_primitive_bounding_box GL_EXT_geometry_shader GL_OES_geometry_shader GL_ANDROID_extension_pack_es31a GL_EXT_gpu_shader5 GL_OES_gpu_shader5 GL_EXT_texture_buffer GL_OES_texture_buffer GL_EXT_copy_image GL_OES_copy_image GL_EXT_shader_non_constant_global_initializers GL_EXT_color_buffer_half_float GL_EXT_color_buffer_float GL_EXT_YUV_target GL_OVR_multiview GL_OVR_multiview2 GL_OVR_multiview_multisampled_render_to_texture GL_KHR_robustness GL_KHR_robust_buffer_access_behavior GL_EXT_draw_elements_base_vertex GL_OES_draw_elements_base_vertex GL_EXT_protected_textures GL_EXT_geometry_point_size GL_OES_geometry_point_size GL_EXT_tessellation_point_size GL_OES_tessellation_point_size GL_OES_draw_texture","title":"8.2.1. OpenGL ES Extension"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#822-egl-extension","text":"EGL extensions EGL_KHR_get_all_proc_addresses EGL_ANDROID_presentation_time EGL_KHR_swap_buffes_witn_damage EGL_ANDROID_get_native_client_buffer EGL_ANDROID_front_buffer_auto_refresh EGL_ANDROID_get_frame_timestamps EGL_KHR_image EGL_KHR_image_base EGL_KHR_gl_colorspace EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_gl_renderbuffer_image EGL_KHR_fence_sync EGL_KHR_create_context EGL_KHR_config_attribs EGL_KHR_surfaceless_context EGL_EXT_create_context_robustness EGL_ANDROID_image_native_buffer EGL_KHR_wait_sync EGL_ANDROID_recordable EGL_KHR_partial_update EGL_KHR_mutable_render_buffer EGL_EXT_protected_content EGL_IMG_context_priority","title":"8.2.2. EGL Extension"},{"location":"ANGLE/172%20ANGLE_Vk_Extensions/#823-vulkan-extension","text":"Vulkan Extension storageBuffer8BitAccess[ 1 ] m[ 2 ] VK_KHR_create_renderpass2 [ 3 ] M VK_KHR_depth_stencil_resolve M supportedDepthResolveModes m supportedStencilResolveModes m VK_KHR_driver_properties M VK_KHR_image_format_list M VK_KHR_imageless_framebuffer M VK_KHR_separate_depth_stencil_layouts M VK_KHR_spirv_1_4 M VK_KHR_timeline_semaphore M VK_KHR_uniform_buffer_standard_layout M uniformBufferStandardLayout M VK_KHR_vulkan_memory_model M vulkanMemoryModel M VK_EXT_buffer_device_address M shaderUniformTexelBufferArrayDynamicIndexing m shaderStorageTexelBufferArrayDynamicIndexing m shaderSampledImageArrayNonUniformIndexing m shaderStorageBufferArrayNonUniformIndexing m shaderUniformTexelBufferArrayNonUniformIndexing m descriptorBindingSampledImageUpdateAfterBind m descriptorBindingStorageBufferUpdateAfterBind m descriptorBindingUniformTexelBufferUpdateAfterBind m descriptorBindingStorageTexelBufferUpdateAfterBind m descriptorBindingUpdateUnusedWhilePending m descriptorBindingPartiallyBound m descriptorBindingVariableDescriptorCount m VK_EXT_host_query_reset M VK_EXT_separate_stencil_usage M VK_KHR_16bit_storage M VK_KHR_bind_memory2 M VK_KHR_dedicated_allocation M VK_KHR_descriptor_update_template M VK_KHR_device_group M VK_KHR_device_group_creation M VK_KHR_external_fence M VK_KHR_external_fence_capabilities M VK_KHR_external_memory M VK_KHR_external_memory_capabilities M VK_KHR_external_semaphore M VK_KHR_external_semaphore_capabilities M VK_KHR_get_memory_requirements2 M VK_KHR_get_physical_device_properties2 M VK_KHR_maintenance1 M VK_KHR_maintenance2 M VK_KHR_maintenance3 M VK_KHR_multiview M multiview m VK_KHR_relaxed_block_layout M VK_KHR_sampler_ycbcr_conversion M VK_KHR_shader_draw_parameters M VK_KHR_storage_buffer_storage_class M VK_KHR_variable_pointers M subgroup M protected memory M instance version enumeration M VkPhysicalDeviceVulkan12Features M imagelessFramebuffer m uniformBufferStandardLayout m separateDepthStencilLayouts m hostQueryReset m timelineSemaphore m subgroupBroadcastDynamicId m VkPhysicalDeviceVulkan11Features M storageBuffer16BitAccess m multiview m VkPhysicalDeviceFeatures M robustBufferAccess M VkPhysicalDeviceSparseProperties O[ 4 ] VkPhysicalDeviceLimits M Linear Formats [ 5 ] M Optimal Formats [ 5 ] M Buffer Formats [ 5 ] M Lowercase character means this is subfunction of the above vulkan extension. M/m means current extension MUST support. Capital character means this is a main vulkan extension. O means current extension OPTIONALLY support. Details of Linear Formats, Optimal Formats and Buffer Formats are shown in Format_constraint_table_1 and Format_constraint_table_2 .","title":"8.2.3. Vulkan Extension"},{"location":"ANGLE/2.%20ANGLE%20dEQP%20Testing/","text":"1. \u9009\u62e9\u540e\u53f0 \u5728 ANGLE \u751f\u6210\u9879\u76ee\u4e2d, \u521d\u59cb\u5316 EGL \u65f6, \u901a\u8fc7\u8bbe\u7f6e PlantformParam \u6765\u9009\u62e9\u6240\u8981\u8fd0\u884c\u540e\u53f0.","title":"1. \u9009\u62e9\u540e\u53f0"},{"location":"ANGLE/2.%20ANGLE%20dEQP%20Testing/#1","text":"\u5728 ANGLE \u751f\u6210\u9879\u76ee\u4e2d, \u521d\u59cb\u5316 EGL \u65f6, \u901a\u8fc7\u8bbe\u7f6e PlantformParam \u6765\u9009\u62e9\u6240\u8981\u8fd0\u884c\u540e\u53f0.","title":"1. \u9009\u62e9\u540e\u53f0"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/","text":"\u603b\u89c8 Vk Extensions ANGLE \u4e2d vk Ext \u5bf9\u5e94es\u529f\u80fd Vk Extensions in ANGLE \u5df2\u652f\u6301 vk\u5185\u90e8 es\u6838\u5fc3 es Ext EGL \u5176\u4ed6 Instance Level: WSI: VK_KHR_ANDROID_SURFACE / VK_KHR_WIN32_SURFACE M* \u2714 VK_KHR_SURFACE M* \u2714 VK_EXT_DEBUG_UTILS / VK_EXT_DEBUG_REPORT ?? \u2714 VK_EXT_SWAPCHAIN_COLOR_SPACE ?? \u2714 VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2 \u2714 \u2714 Device Level : VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER \u2714 VK_EXT_QUEUE_FAMILY_FOREIGN \u2714 VK_EXT_DEPTH_CLIP_ENABLE Nvidia VK_EXT_EXTERNAL_MEMORY_HOST MAC VK_EXT_INDEX_TYPE_UINT8 \u2714 VK_EXT_LINE_RASTERIZATION \u2714 VK_EXT_PROVOKING_VERTEX ANGLE EXT VK_EXT_SHADER_STENCIL_EXPORT \u2714 VK_EXT_TRANSFORM_FEEDBACK \u2714 VK_EXT_VERTEX_ATTRIBUTE_DIVISOR \u2714 VK_FUCHSIA_EXTERNAL_MEMORY FUCHSIA VK_FUCHSIA_EXTERNAL_SEMAPHORE FUCHSIA VK_GOOGLE_SAMPLER_FILTERING_PRECISION ANGLE EXT VK_GGP_FRAME_TOKEN Stadia VK_KHR_BIND_MEMORY_2 \u2714 \u2714 VK_KHR_CREATE_RENDERPASS_2 \u2714 \u2714 VK_KHR_DEPTH_STENCIL_RESOLVE \u2714 \u2714 VK_KHR_EXTERNAL_FENCE_CAPABILITIES \u2714 \u2714 VK_KHR_EXTERNAL_FENCE_FD U VK_KHR_EXTERNAL_MEMORY \u2714 \u2714 VK_KHR_EXTERNAL_MEMORY_FD U VK_KHR_EXTERNAL_SEMAPHORE \u2714 \u2714 VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES \u2714 \u2714 VK_KHR_EXTERNAL_SEMAPHORE_FD U VK_KHR_GET_MEMORY_REQUIREMENTS_2 \u2714 \u2714 VK_KHR_IMAGE_FORMAT_LIST \u2714 AMD VK_KHR_INCREMENTAL_PRESENT U VK_KHR_MAINTENANCE1 \u2714 \u2714 VK_KHR_SAMPLER_YCBCR_CONVERSION \u2714 \u2714 VK_KHR_SHADER_FLOAT16_INT8 \u2714 VK_KHR_SWAPCHAIN \u2714 VK_QCOM_render_pass_store_ops \u2714 *M \u8868\u793a\u4e3aVulkan\u5fc5\u987b\u6269\u5c55, \u4f46 v100 \u6587\u6863\u6ca1\u6709\u6807\u51fa. \u56e0\u6b64\u5bf9\u4e8e\u4e0b\u9762\u7684 VK_EXT_SWAPCHAIN_COLOR_SPACE \u662f\u5426\u5df2\u652f\u6301\u8868\u793a\u5b58\u7591. \u6709\u5176\u4ed6\u6587\u6863\u663e\u793av100,v200\u5747\u652f\u6301. *U \u8868\u793a\u975e\u5fc5\u987b: \u5176\u5bf9\u5e94\u7684 GLES / EGL Extension \u4e0d\u5728 v100 \u7684\u652f\u6301\u5217\u8868\u4e2d. \u589e\u52a0 Vk Extensions \u7684\u9700\u6c42 \u5c06\u4e0a\u8868\u4e2d\u7684\u6570\u636e, \u5220\u53bb\"'\u5df2\u652f\u6301\u7684\", \"vk\u5185\u90e8\u4f7f\u7528\", \u548c\"\u5176\u4ed6\u5e73\u53f0\"\u7684\u6269\u5c55, \u5269\u4e0b\u7684\u5373 v100 \u5c1a\u672a\u652f\u6301\u7684\u6269\u5c55\u9700\u6c42\u8868\u5982\u4e0b: Vk Extensions \u6240\u9700 Feature \u5206\u7c7b \u5fc5\u9700 \u652f\u6301 es \u529f\u80fd VK_EXT_SWAPCHAIN_COLOR_SPACE -- EGL \u2714 EGL_KHR_gl_colorspace VK_ANDROID_EXTERNAL_MEMORY _ANDROID_HARDWARE_BUFFER VK_EXT_QUEUE_FAMILY_FOREIGN -- EGL \u2714 EGL_ANDROID_image_native_buffer VK_EXT_INDEX_TYPE_UINT8 indexTypeUint8 es2.0 \u5339\u914d Draw \u7684 indexType \u53c2\u6570, \u4ee5\u4f18\u5316\u6027\u80fd VK_EXT_LINE_RASTERIZATION bresenhamLines es2.0 \u7ba1\u7ebf\u7b97\u6cd5\u652f\u6301 VK_EXT_SHADER_STENCIL_EXPORT -- es2.0 VK_EXT_TRANSFORM_FEEDBACK transformFeedback es3.1 \u2714 \u5b9e\u73b0 Transform Feedback \u76f8\u5173 API VK_EXT_VERTEX_ATTRIBUTE_DIVISOR vertexAttributeInstanceRateDivisor es2.0 VK_KHR_SHADER_FLOAT16_INT8 shaderFloat16 es2.0 VK_KHR_EXTERNAL_FENCE_FD -- EGL U EGL_ANDROID_native_fence VK_KHR_EXTERNAL_MEMORY_FD -- EXT U GL_EXT_memory_object_fd VK_KHR_EXTERNAL_SEMAPHORE_FD -- EXT U GL_EXT_semaphore_fd VK_KHR_INCREMENTAL_PRESENT -- EGL U EGL_KHR_swap_buffers_with_damage *U \u8868\u793a\u975e\u5fc5\u987b: \u5176\u5bf9\u5e94\u7684 GLES / EGL Extension \u4e0d\u5728 v100 \u7684\u652f\u6301\u5217\u8868\u4e2d. Vk Features \u5bf9\u6bd4 v100 \u652f\u6301\u60c5\u51b5: \u4ec5 inheritedQueries \u4e0d\u652f\u6301 \u4e14\u5fc5\u9700. \u6b64\u5916\u867d\u7136 vertexPipelineStoresAndAtomics \u4e0d\u652f\u6301, \u4f46 ANGLE \u63a8\u8350\u7528 VK_EXT_TRANSFORM_FEEDBACK \u53d6\u4ee3. \u5176\u4f59Features \u5747\u5728 v100 \u4e2d\u652f\u6301: Vk Features in ANGLE \u5bf9\u5e94 GLES Note inheritedQueries es 3.0, Query vertexPipelineStoresAndAtomics transform feedback \u6a21\u62df\u5b9e\u73b0 transform feedback, \u5e94\u7528 VK_EXT_TRANSFORM_FEEDBACK \u4ee3\u66ff imageCubeArray cubemap array \u4ec5\u5728\u975e SwiftShader \u548c\u975e Qualcomm \u4e0b\u542f\u7528 independentBlend fbo \u591a\u4e2a attachments robustBufferAccess \u8bbf\u95ee robust buffer samplerAnisotropy Anisotropic filtering wideLines wide lines fragmentStoresAndAtomics storage buffers \u5b9e\u73b0 fragment shader \u4e2d storage buffers \u548c images geometryShader geometry shaders shaderImageGatherExtended EXT_gpu_shader5 shaderUniformBufferArrayDynamicIndexing EXT_gpu_shader5 shaderSampledImageArrayDynamicIndexing EXT_gpu_shader5 \u652f\u6301 EXT_gpu_shader5 \u5e76\u6a21\u62df\u5b9e\u73b0 sampler array shaderStorageBufferArrayDynamicIndexing \u6a21\u62df\u5b9e\u73b0 atomic counter shaderClipDistance APPLE_clip_distance sampleRateShading OES_sample_shading depthClamp OES_sample_shading support depth clears through draw calls. sampleRateShading OES_sample_variables *\u7c97\u4f53 Features\u4e3a\u6838\u5fc3API\u6240\u5fc5\u9700\u7279\u6027. Limits \u672c\u8868\u5217\u51fa ANGLE \u4e2d\u8bb0\u4e86\u6570\u5b57\u9700\u6c42\u7684 Limits. [ ] \u5bf9\u5e94 v100 GLES Limits * \u662f\u6307 ANGLE \u5728\u6a21\u62df\u5b9e\u73b0 GLES \u65f6, \u9700\u8981\u5360\u7528\u90e8\u5206\u8d44\u6e90, \u5bfc\u81f4 v100 \u4e2d\u6807\u8bb0\u7684 GLES Limits \u4e0d\u518d\u80fd\u6ee1\u8db3. \u672c\u8868\u5047\u8bbe VK_EXT_TRANSFORM_FEEDBACK \u4e0e VK_EXT_LINE_RASTERIZATION \u5df2\u6ee1\u8db3. \u5426\u5219\u4e00\u4e9b\u6240\u9700\u503c\u4f1a\u589e\u52a0, \u4f46\u4e0d\u4f1a\u6539\u53d8\u5f53\u524d\u6ee1\u8db3\u60c5\u51b5. Vk Limits in ANGLE \u6240\u9700\u503c Limits in v100 v100 \u5df2\u6ee1\u8db3 \u5bf9\u5e94 GLES EXT / Cap maxPerStageDescriptorStorageBuffers >=12 / 16 8 \u4e0d\u6ee1\u8db3 es3.0, 12 \u4e3a\u6ee1\u8db3 ANGLE es3.0 16 \u4e3a\u6ee1\u8db3 v100 GLES Limits maxPerStageDescriptorUniformBuffers >=14 12 \u4e0d\u6ee1\u8db3 v100 GLES Limits* maxDescriptorSetUniformBuffers >=76 72 \u4e0d\u6ee1\u8db3 v100 GLES Limits* maxVertexOutputComponents \u4e0e maxFragmentInputComponents >=136 128 \u4e0d\u6ee1\u8db3 v100 GLES Limits* standardSampleLocations true true textureStorageMultisample2DArrayOES maxSamplerAnisotropy > 1.0f; 16 textureFilterAnisotropic maxTextureAnisotropy maxInterpolationOffset >= 0.5; 0.4375 \u4e0d\u6ee1\u8db3 OES_shader_multisample_interpolation maxVertexInputAttributeOffset >=2047 2047 es3.1 ANGLE : Vk Extensions GLES Core VK_EXT_TRANSFORM_FEEDBACK V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es3.0 APIs \u5bf9\u5e94\u529f\u80fd Transform Feedback \u5fc5\u8981\u6027 \u5b9e\u73b0 Transform Feedback \u5fc5\u9700 \u6240\u9700 FeaturesEXT transformFeedback angle doc: TransformFeedbackViaExtension angle issue: http://anglebug.com/3206 ANGLE\u4f7f\u7528Vulkan\u4e2d\u7684vertexPipelineStoresAndAtomics\u529f\u80fd\u6a21\u62df\u53d8\u6362\u53cd\u9988\u3002\u4f46\u662f\u67d0\u4e9b Driver \u4e0d\u652f\u6301\u6b64\u7279\u6027\u3002\u540c\u6837\uff0c\u5728GLES 3.2\u4e2d\uff0c\u4eff\u771f\u53d8\u5f97\u66f4\u52a0\u56f0\u96be\u3002\u56e0\u6b64\uff0c ANGLE\u5fc5\u987b\u652f\u6301\u4f7f\u7528 VK_EXT_transform_feedback \u6269\u5c55 \u3002\u5e76\u4e14\u5f53\u4f7f\u7528\u6b64\u6269\u5c55\u65f6\uff0c\u6211\u4eec\u4e5f\u671f\u671b\u6027\u80fd\u63d0\u9ad8\u3002 \u4f7f\u7528CounterBuffer\u5b9e\u73b0\u6682\u505c/\u6062\u590d Vulkan\u6269\u5c55\u6ca1\u6709\u4e3a glPauseTransformFeedback / glEndTransformFeedback \u5206\u522b\u63d0\u4f9b\u5355\u72ec\u7684API \u3002 \u76f8\u53cd\uff0cVulkan\u5728 vkCmdBeginTransformFeedbackEXT / vkCmdEndTransformFeedbackEXT \u4e2d \u5f15\u5165\u4e86\u8ba1\u6570\u5668\u7f13\u51b2\u533a\u4f5c\u4e3aAPI\u53c2\u6570\u3002 \u8981\u6682\u505cFB\uff0c\u8c03\u7528 vkCmdEndTransformFeedbackEXT \u5e76\u5728 pCounterBuffers \u6570\u7ec4\u4e2d\u63d0\u4f9b\u6709\u6548\u7684\u7f13\u51b2\u533a\u53e5\u67c4, \u5728 pCounterBufferOffsets \u6570\u7ec4\u4e2d\u63d0\u4f9b\u6709\u6548\u7684\u504f\u79fb\u91cf\uff0c\u4ee5\u5b9e\u73b0\u4fdd\u5b58\u6062\u590d\u70b9\u7684\u5b9e\u73b0\u3002 \u8981\u6062\u590dFB\uff0c\u6211\u4eec\u8c03\u7528 vkCmdBeginTransformFeedbackEXT \u5e76\u4f20\u5165\u5148\u524d\u7684 pCounterBuffers \u548c pCounterBufferOffsets \u503c\u3002 \u6682\u505c\u548c\u6062\u590d\u4e4b\u95f4, \u9700\u8981\u6709\u4e00\u4e2a\u5b58\u50a8\u963b\u6321 (memory barrier), \u7528\u4e8e\u4e0e\u8bbf\u95ee\u6e90\u5230\u8bbf\u95ee\u6a21\u677f\u7684\u8ba1\u6570\u5668\u7f13\u51b2\u5668. \u8bbf\u95ee\u6e90: Pipeline Stage \u7684 VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT \u4e2d\u7684 VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT \u8bbf\u95ee\u76ee\u6807 Pipeline Stage \u7684 VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT \u4e2d\u7684 VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT glTransformFeedbackVaryings \u7684\u5b9e\u73b0 Vulkan\u4e2d\u6ca1\u6709 glTransformFeedbackVaryings \u7684\u7b49\u6548\u51fd\u6570\u3002 Vulkan\u89c4\u8303\u6307\u51fa\uff0c\u5fc5\u987b\u4f7f\u7528XFB\u6267\u884c\u6a21\u5f0f\u58f0\u660e\u6700\u540e\u4e00\u4e2a\u9876\u70b9\u5904\u7406\u9636\u6bb5\u7740\u8272\u5668\u3002 SPIR-V \u8f6c\u6362\u5668\u8d1f\u8d23\u6dfb\u52a0\u6b64\u6267\u884c\u6a21\u5f0f\uff0c\u5e76\u4fee\u9970\u9700\u8981\u6355\u83b7\u7684\u53d8\u91cf\u3002 ANGLE \u4e3a Vulkan \u5750\u6807\u7cfb\u4fee\u6539\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684 gl_position.z \u3002\u56e0\u6b64\uff0c\u5982\u679c\u6211\u4eec\u5728XFB\u7f13\u51b2\u533a\u4e2d\u6355\u83b7\u201c gl_position\u201d\u7684\u503c\uff0c\u5219\u6355\u83b7\u7684\u503c\u5c06\u662f\u9519\u8bef\u7684\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u58f0\u660e\u4e00\u4e2a\u5185\u90e8 position \u53d8\u5316\u91cf\uff0c\u7136\u540e\u590d\u5236'gl_position'\u7684\u503c\u3002\u6211\u4eec\u6355\u83b7\u4e86\u53d8\u6362\u53cd\u9988\u64cd\u4f5c(transform feedback)\u671f\u95f4\u5185\u90e8 position \u53d8\u5316\u91cf\u7684\u53d8\u5316\u3002\u4e3a\u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u4f1a\u5bf9\u6bcf\u4e2a\u6355\u83b7\u7684\u53d8\u5316\u90fd\u8fdb\u884c\u6b64\u64cd\u4f5c, \u800c\u6ca1\u6709\u7528 gl_PerVertex \u76f4\u63a5\u5728SPIR-V\u4e2d\u88c5\u9970\u7ed3\u6784\u4f53\u3002 Transform Feedback Queries GLES \u6709\u4e24\u4e2a\u4e0d\u540c\u7684\u67e5\u8be2\uff1a GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN \u548c GL_PRIMITIVES_GENERATED \u3002 \u4f46\u662f\u5728Vulkan\u4e2d\uff0c\u8fd9\u4e9b\u662f\u7531\u6765\u81ea VK_EXT_transform_feedback \u7684\u5355\u4e2a\u67e5\u8be2\u63d0\u4f9b\u7684\u3002 \u6b64\u5916\uff0cVulkan\u8981\u6c42\u4e00\u6b21\u53ea\u80fd\u6fc0\u6d3b\u67d0\u7c7b\u578b\u7684\u4e00\u4e2a\u67e5\u8be2\u3002 \u5f53\u4e24\u4e2a Transform Feedback \u67e5\u8be2\u90fd\u5904\u4e8e\u6d3b\u52a8\u72b6\u6001\u65f6\uff0c\u8fd9\u5c06\u8feb\u4f7fANGLE\u4f7f\u4e24\u4e2aGL\u67e5\u8be2\u5171\u4eab\u5176Vulkan\u67e5\u8be2\u3002 \u5bf9\u5e94 GLES API Transform Feedback glBeginTransformFeedback/ glPauseTransformFeedback /glResumeTransformFeedback/ glEndTransformFeedback / glTransformFeedbackVaryings Buffer glBufferData / glBufferStorage / glDeleteBuffers glsl glDispatchComputeIndirect / glDispatchCompute / glLinkProgram / glCreateShaderProgramv Query glBeginQuery / glEndQuery Vulkan \u5b9a\u4e49 Features : \u4ec5\u9700\u542f\u7528 transformFeedback // Provided by VK_EXT_transform_feedback typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 transformFeedback; VkBool32 geometryStreams; } VkPhysicalDeviceTransformFeedbackFeaturesEXT; \u6269\u5c55\u547d\u4ee4: vkCmdBeginQueryIndexedEXT vkCmdBeginTransformFeedbackEXT vkCmdBindTransformFeedbackBuffersEXT vkCmdDrawIndirectByteCountEXT vkCmdEndQueryIndexedEXT vkCmdEndTransformFeedbackEXT ANGLE : GLES on Vk API\u8f83\u591a, \u5f85\u5206\u6790 ANGLE \u4e2d, \u6b64 EXT \u4e0e VkPhysicalDeviceFeatures.vertexPipelineStoresAndAtomics \u4e8c\u8005\u81f3\u5c11\u6709\u4e00, \u5426\u5219\u4e0d\u652f\u6301 3.0 \u7684 transform feedback, \u964d\u4f4e\u7248\u672c supportsTransformFeedbackExtension http://anglebug.com/3206 Features.vertexPipelineStoresAndAtomics: emulateTransformFeedback http://anglebug.com/3205 Vulkan Description: This extension adds transform feedback to the Vulkan API by exposing the SPIR-V TransformFeedback and GeometryStreams capabilities to capture vertex, tessellation or geometry shader outputs to one or more buffers. It adds API functionality to bind transform feedback buffers to capture the primitives emitted by the graphics pipeline from SPIR-V outputs decorated for transform feedback. The transform feedback capture can be paused and resumed by way of storing and retrieving a byte counter. The captured data can be drawn again where the vertex count is derived from the byte counter without CPU intervention. If the implementation is capable, a vertex stream other than zero can be rasterized. All these features are designed to match the full capabilities of OpenGL core transform feedback functionality and beyond. Many of the features are optional to allow base OpenGL ES GPUs to also implement this extension. The primary purpose of the functionality exposed by this extension is to support translation layers from other 3D APIs. This functionality is not considered forward looking, and is not expected to be promoted to a KHR extension or to core Vulkan. Unless this is needed for translation, it is recommended that developers use alternative techniques of using the GPU to process and capture vertex data. supportsTransformFeedbackExtension BufferVk.cpp setExternalBufferData & setDataWithMemoryType BufferVk::setDataWithUsageFlags Buffer::bufferDataImpl Buffer::bufferData glBufferData Buffer::bufferStorage glBufferStorage Buffer::bufferExternalDataImpl glBufferStorageExternalEXT ContextVk.cpp ContextVk() mGraphicsDirtyBitHandlers[DIRTY_BIT_TRANSFORM_FEEDBACK_BUFFERS] = &ContextVk::handleDirtyGraphicsTransformFeedbackBuffersExtension; mGraphicsDirtyBitHandlers[DIRTY_BIT_TRANSFORM_FEEDBACK_STATE] = &ContextVk::handleDirtyGraphicsTransformFeedbackState; mGraphicsDirtyBitHandlers[DIRTY_BIT_TRANSFORM_FEEDBACK_RESUME] = &ContextVk::handleDirtyGraphicsTransformFeedbackResume; initialize mQueryPools[gl::QueryType::TransformFeedbackPrimitivesWritten].init( this, VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT, vk::kDefaultTransformFeedbackQueryPoolSize) onMakeCurrent mGraphicsDirtyBits.set(DIRTY_BIT_TRANSFORM_FEEDBACK_RESUME); mGraphicsDirtyBits.set(DIRTY_BIT_TRANSFORM_FEEDBACK_STATE); mGraphicsDirtyBits.set(DIRTY_BIT_TRANSFORM_FEEDBACK_BUFFERS); invalidateCurrentTransformFeedbackBuffers ContextVk: bindIndexedBuffer TransformFeedbackVk: bindIndexedBuffer TransformFeedbackVk: detachBuffer State: detachBuffer Context: deleteBuffer glDeleteBuffers onTransformFeedbackStateChanged onBeginTransformFeedback TransformFeedbackVk: begin TransformFeedback: begin Context: beginTransformFeedback glBeginTransformFeedback TransformFeedbackVk: resume TransformFeedback: resume Context: resumeTransformFeedback glResumeTransformFeedback onEndTransformFeedback TransformFeedbackVk: end TransformFeedback: end Context: endTransformFeedback glEndTransformFeedback onPauseTransformFeedback TransformFeedback: Pause Context: PauseTransformFeedback glPauseTransformFeedback resumeTransformFeedbackIfStarted handleDirtyGraphicsPipeline flushCommandsAndEndRenderPass GlslangWrapperVk.cpp GlslangAssignLocations \u200b rx::ProgramPipelineVk::link \u200b gl::ProgramPipeline::link \u200b gl::Context::prepareForDispatch \u200b gl::Context::dispatchComputeIndirect \u200b gl::DispatchComputeIndirect \u200b gl::Context::dispatchCompute \u200b gl::DispatchCompute \u200b rx::GlslangGetShaderSource \u200b rx::GlslangWrapperVk::GetShaderSource \u200b rx::ProgramVk::link \u200b gl::Program::linkImpl \u200b gl::Program::link \u200b gl::Context::linkProgram \u200b gl::LinkProgram \u200b angle::FrameCapture::ReplayCall \u200b gl::Context::createShaderProgramv \u200b glCreateShaderProgramv QueryVk.cpp QueryVk: begin Context: beginQuery QueryVk: end Context: endQuery TransformFeedback Mode vk_cache_utils.cpp GraphicsPipelineDesc::initializePipeline() VkPipelineRasterizationStateStreamCreateInfoEXT rasterStreamState = {}; rasterStreamState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT; if (contextVk->getFeatures().supportsTransformFeedbackExtension.enabled) { rasterStreamState.rasterizationStream = 0; rasterState.pNext = &rasterLineState; } vk_caps_utils.cpp reservedVaryingVectorCount += kReservedVaryingForTransformFeedbackExtension; angle::FrameCapture::ReplayCall VK_EXT_INDEX_TYPE_UINT8 (.) V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 APIs \u5bf9\u5e94\u529f\u80fd \u6307\u5b9a\u4e86 IndexType \u7684 Draw \u5fc5\u8981\u6027 \u6027\u80fd\u4f18\u5316, \u53ef\u7ed5\u8fc7 \u6240\u9700 FeaturesEXT indexTypeUint8 angle issue: http://anglebug.com/4405 \u6b64\u6269\u5c55\u4e3a\u89e3\u51b3\u4e00\u4e2a\u6027\u80fd\u95ee\u9898: \u67d0\u4e9bGLES\u57fa\u51c6\uff08\u4f8b\u5982T-Rex\uff09\u5728 draw \u65f6\u4f7f\u7528 8bit \u7684 indices \u3002 \u4f46\u662f, Vulkan \u4e2d\u9ed8\u8ba4\u6ca1\u6709 8bit index, \u56e0\u6b64ANGLE \u9700\u8981\u4f7f\u7528 CPU, \u6216GPU\u7684\u8ba1\u7b97\u7740\u8272\u5668, \u5c068\u4f4d\u7d22\u5f15\u8f6c\u6362\u4e3a16\u4f4d\u3002 \u800c\u5982\u679c driver \u652f\u6301 VK_EXT_index_type_uint8 \uff0c\u5219\u4e0d\u9700\u8981\u6b64\u8f6c\u6362. \u5bf9\u5e94 GLES \u529f\u80fd \u6240\u6709\u6307\u5b9a\u4e86 IndexType \u7684 Draw. (DrawArrays, DrawElements.....) \u4f8b: glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices); \u5176\u4e2d index \u7c7b\u578b\u4e3a\u4ee5\u4e0b\u679a\u4e3e\u503c\u4e4b\u4e00: GL_UNSIGNED_BYTE , GL_UNSIGNED_SHORT , or GL_UNSIGNED_INT , \u5206\u522b\u5bf9\u5e94\u4e86 8bit, 16bit, \u548c 32bit. Vulkan \u5b9a\u4e49 \u6b64\u6269\u5c55\u5141\u8bb8\u5728 vkCmdBindIndexBuffer \u547d\u4ee4\u4e2d\u4f7f\u7528 uint8_t indices, \u5bf9\u5e94\u679a\u4e3e: VkIndexType: VK_INDEX_TYPE_UINT8_EXT \u800c\u5728\u6ca1\u6709\u6b64\u6269\u5c55\u65f6, \u4ec5\u652f\u6301 VK_INDEX_TYPE_UINT16 \u548c VK_INDEX_TYPE_UINT32, \u5206\u522b\u5bf9\u5e94 16bit \u548c 32bit Features : \u4ec5\u9700\u542f\u7528 indexTypeUint8 // Provided by VK_EXT_index_type_uint8 typedef struct VkPhysicalDeviceIndexTypeUint8FeaturesEXT { VkStructureType sType; void* pNext; VkBool32 indexTypeUint8; } VkPhysicalDeviceIndexTypeUint8FeaturesEXT; vkCmdBindIndexBuffer \u547d\u4ee4: // Provided by VK_VERSION_1_0 void vkCmdBindIndexBuffer( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType); \u5176\u4e2d indexType \u5bf9\u5e94\u679a\u4e3e: // Provided by VK_VERSION_1_0 typedef enum VkIndexType { VK_INDEX_TYPE_UINT16 = 0, VK_INDEX_TYPE_UINT32 = 1, // Provided by VK_KHR_acceleration_structure VK_INDEX_TYPE_NONE_KHR = 1000165000, // Provided by VK_EXT_index_type_uint8 VK_INDEX_TYPE_UINT8_EXT = 1000265000, // Provided by VK_NV_ray_tracing VK_INDEX_TYPE_NONE_NV = VK_INDEX_TYPE_NONE_KHR, } VkIndexType; ANGLE : GLES on Vk // Init gles-vulkan index type map mIndexTypeMap[UnsignedByte] = supportsIndexTypeUint8 ? VK_INDEX_TYPE_UINT8_EXT : VK_INDEX_TYPE_UINT16; mIndexTypeMap[UnsignedShort] = VK_INDEX_TYPE_UINT16; mIndexTypeMap[UnsignedInt] = VK_INDEX_TYPE_UINT32; mIndexTypeMap \u7528\u4e8e \u6267\u884c vkCmdBindIndexBuffer \u8bbe\u7f6e\u7c7b\u578b UnsignedByte : VK_INDEX_TYPE_UINT8_EXT (\u539f\u5148 VK_INDEX_TYPE_UINT16) UnsignedShort : VK_INDEX_TYPE_UINT16 UnsignedInt : VK_INDEX_TYPE_UINT32 \u5982\u679c\u4e0d\u652f\u6301, \u5728 DrawXXX \u5b9e\u73b0\u4e2d\u5904\u7406 indices \u65f6 (\u4f8b\u5982\u5206\u914d\u5185\u5b58\u7a7a\u95f4) \u9700\u8981\u5c06 GLubyte \u8f6c\u4e3a GLushort \u540e\u518d\u5904\u7406. void createIndexBuffer() { VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size(); VkBuffer stagingBuffer; VkDeviceMemory stagingBufferMemory; createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory); void* data; vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data); memcpy(data, indices.data(), (size_t) bufferSize); vkUnmapMemory(device, stagingBufferMemory); createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, indexBuffer, indexBufferMemory); copyBuffer(stagingBuffer, indexBuffer, bufferSize); vkDestroyBuffer(device, stagingBuffer, nullptr); vkFreeMemory(device, stagingBufferMemory, nullptr); } \u4f7f\u7528 IndexBuffer vkCmdBindVertexBuffers(commandBuffers[i], 0, 1, vertexBuffers, offsets); vkCmdBindIndexBuffer(commandBuffers[i], indexBuffer, 0, VK_INDEX_TYPE_UINT16); // <-- VK_INDEX_TYPE_UINT8_EXT vkCmdDrawIndexed(commandBuffers[i], static_cast<uint32_t>(indices.size()), 1, 0, 0, 0); \u5206\u6790\u8fc7\u7a0b supportsIndexTypeUint8 vk_helper.cpp HandlePrimitiveRestart CopyLineLoopIndicesWithRestart (indexCount, srcPtr, outPtr); ContextVk initIndexTypeMap() initialize() shouldConvertUint8VkIndexType LineLoopHelper: streamIndices VertexArrayVk: handleLineLoop ContextVk: setupLineLoopDraw ALL Draw Call VertexArrayVk: convertIndexBufferCPU ContextVk: setupIndexedDraw DrawElements.... gl::DrawElementsType::UnsignedByte setupIndexedDraw VK_EXT_LINE_RASTERIZATION (.) V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 \u5bf9\u5e94\u529f\u80fd \u5149\u6805\u5316: \u5355\u6837\u672c\u6e32\u67d3 \u5fc5\u8981\u6027 \u975e\u5fc5\u9700: \u4fdd\u6301\u7b97\u6cd5\u4e00\u81f4\u6027 \u6240\u9700 FeaturesEXT bresenhamLines angle doc: OpenGLLineSegmentRasterization \u7531\u4e8e Vk \u5728\u5149\u6805\u5316\u7684\u5355\u6837\u672c\u6e32\u67d3\u91c7\u6837\u4e86\u4e0d\u540c\u7684\u7ebf\u6bb5\u6e32\u67d3\u7b97\u6cd5, \u9700\u8981\u6b64\u6269\u5c55\u6765\u4fdd\u6301 GLES \u4e0e\u539f\u6709\u7b97\u6cd5\u7684\u4e00\u81f4\u6027: \u5728\u5149\u6805\u5316\u9636\u6bb5, OpenGL\u548cVulkan\u90fd\u5c06\u7ebf\u6bb5\u6e32\u67d3\u4e3a\u4e24\u70b9\u4e4b\u95f4\u7684\u4e00\u7cfb\u5217\u50cf\u7d20\u3002\u5b83\u4eec\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u8986\u76d6\u7ebf\u7684\u50cf\u7d20\u3002 \u5bf9\u4e8e\u5355\u6837\u672c\u6e32\u67d3\uff0cVulkan\u4f7f\u7528 \u57fa\u4e8e\u56db\u8fb9\u5f62\u8986\u76d6\u7387\u7684\u7b97\u6cd5 \u3002\u8f83\u5c0f\u7684\u5f62\u72b6\u56f4\u7ed5\u7ebf\u6bb5\u6324\u51fa\u3002\u5f62\u72b6\u6240\u8986\u76d6\u7684\u6837\u672c\u5c06\u4ee3\u8868\u7ebf\u6bb5\u3002 OpenGL\u7684\u7b97\u6cd5 \u57fa\u4e8eBresenham\u7684line\u7b97\u6cd5 \u3002\u5728\u4e24\u4e2a\u5206\u6bb5\u70b9\u4e4b\u95f4\u7684\u7ebf\u4e0a\u9009\u62e9\u50cf\u7d20\u3002\u6ce8\u610fBresenham\u4e0d\u652f\u6301\u591a\u91cd\u91c7\u6837\u3002 \u5728\u89c6\u89c9\u4e0a\u8fdb\u884c\u6bd4\u8f83\u65f6\uff0cVulkan\u7ebf\u6bb5\u6805\u683c\u5316\u7b97\u6cd5\u59cb\u7ec8\u9009\u62e9\u5728OpenGL\u4e2d\u6805\u683c\u5316\u7684\u7ebf\u6bb5\u50cf\u7d20\u7684\u8d85\u96c6\u3002 \u8be6\u7ec6\u533a\u522b\u89c1 ANGLE \u6587\u6863: OpenGLLineSegmentRasterization \u5bf9\u5e94 GLES \u7ba1\u7ebf\u7684\u5149\u6805\u5316, \u65e0API\u5bf9\u5e94 Vulkan \u5b9a\u4e49 Features : \u4ec5\u9700\u542f\u7528 bresenhamLines. // Provided by VK_EXT_line_rasterization typedef struct VkPhysicalDeviceLineRasterizationFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 rectangularLines; VkBool32 bresenhamLines; VkBool32 smoothLines; VkBool32 stippledRectangularLines; VkBool32 stippledBresenhamLines; VkBool32 stippledSmoothLines; } VkPhysicalDeviceLineRasterizationFeaturesEXT; \u63d0\u4f9b Pipeline State \u6269\u5c55: // Provided by VK_EXT_line_rasterization typedef struct VkPipelineRasterizationLineStateCreateInfoEXT { VkStructureType sType; const void* pNext; VkLineRasterizationModeEXT lineRasterizationMode; VkBool32 stippledLineEnable; uint32_t lineStippleFactor; uint16_t lineStipplePattern; } VkPipelineRasterizationLineStateCreateInfoEXT; \u5176\u4e2d lineRasterizationMode \u5bf9\u5e94\u679a\u4e3e: // Provided by VK_EXT_line_rasterization typedef enum VkLineRasterizationModeEXT { VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0, VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1, VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2, VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3, } VkLineRasterizationModeEXT; \u5176\u4e2d VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT \u6839\u636e Bresenham Line Segment Rasterization \u7b97\u6cd5\u4e2d\u7684\u5b9a\u4e49\uff0c\u6307\u5b9a\u901a\u8fc7\u786e\u5b9a\u7ebf\u6761\u76f8\u4ea4\u548c\u79bb\u5f00\u7684\u50cf\u7d20\u83f1\u5f62\u7ed8\u5236\u7684\u7ebf\u6761\u3002 GLES on Vulkan \u5728\u975e\u591a\u91cd\u91c7\u6837\u65f6, \u5728\u5b9a\u4e49 Pipeline \u7684 VkPipelineRasterizationStateCreateInfo \u65f6, \u4e3a\u5176 pNext \u94fe\u4e0a\u6dfb\u52a0 VkPipelineRasterizationLineStateCreateInfoEXT \u5373\u53ef. \u8bbe\u7f6e lineRasterizationMode \u4e3a VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT VkPipelineRasterizationStateCreateInfo rasterState = {}; ... const void **pNextPtr = &rasterState.pNext; VkPipelineRasterizationLineStateCreateInfoEXT rasterLineState = {}; rasterLineState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT; // Enable Bresenham line rasterization if available and not multisampling. if (rasterizationSamples <= 1 && bresenhamLineRasterization.enabled) { rasterLineState.lineRasterizationMode = VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT; *pNextPtr = &rasterLineState; pNextPtr = &rasterLineState.pNext; } VK_EXT_SHADER_STENCIL_EXPORT V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 \u5bf9\u5e94\u529f\u80fd glBlitFramebuffer: stencil buffer \u7684 resolve \u548c unresolve \u5fc5\u8981\u6027 \u975e\u5fc5\u987b, \u53ef\u6a21\u62df\u5b9e\u73b0 \u6240\u9700 FeaturesEXT \u65e0 \u6b64\u6269\u5c55\u7528\u4e8e\u6267\u884c\u6a21\u677f\u7f13\u51b2\u533a\u7684\u591a\u91c7\u6837\u89e3\u6790(multisampled resolve of stencil buffer)\u3002 \u5982\u679c\u6b64\u6269\u5c55\u4e0d\u53ef\u7528\uff0c\u5219\u4f7f\u7528\u591a\u6b65\u9aa4\u6a21\u62df\u5b9e\u73b0\u3002 \u5bf9\u5e94 GLES \u529f\u80fd Framebuffer \u7684 resolve \u548c unresolve, \u53d1\u751f\u5728\u8bfb\u53d6\u548c\u590d\u5236\u8fc7\u7a0b\u4e2d, \u5982 glBlitFramebuffer Vulkan \u5b9a\u4e49 \u6b64\u6269\u5c55\u63d0\u4f9b\u4e00\u79cd\u673a\u5236\uff0c\u4f7f\u7740\u8272\u5668\u53ef\u4ee5\u5728\u6bcf\u6b21\u8c03\u7528\u65f6\u751f\u6210\u6a21\u677f\u5f15\u7528\u503c\u3002\u5728\u542f\u7528\u6a21\u677f\u6d4b\u8bd5\u65f6\uff0c\u8fd9\u5141\u8bb8\u9488\u5bf9\u7740\u8272\u5668\u4e2d\u751f\u6210\u7684\u503c\u6267\u884c\u6d4b\u8bd5\u3002 \u6b64\u6269\u5c55\u4f9d\u8d56 SPV_EXT_shader_stencil_export \u6b64\u6269\u5c55\u4e3aGLES\u7684shader\u6269\u5c55: GL_ARB_shader_stencil_export \u63d0\u4f9b API \u652f\u6301 \u6b64\u6269\u4e3a\u4e0d\u589e\u52a0\u5176\u4ed6\u7ed3\u6784\u4f53\u548c\u6307\u4ee4. GLES on Vk \u5f85\u5206\u6790 \u5206\u6790\u8fc7\u7a0b: BlitResolveStencilNoExport.comp: Blit stencil images or resolve multisampled ones into a buffer. // This is used where VK_EXT_shader_stencil_export is not available, to output the resolved stencil // into a temporary buffer, which is then copied into the stencil aspect of the final image. UtilsVk::stencilBlitResolveNoShaderExport \u63d2\u4ef6\u65e0\u6548\u65f6\u7684\u66ff\u4ee3\u65b9\u6cd5. supportsShaderStencilExport \u5224\u65ad: FramebufferVk::startNewRenderPass UtilsVk::SetStencilForShaderExport FramebufferVk::colorBlitResolve FramebufferVk::depthStencilBlitResolve FramebufferVk::blit UntilVk: unresolve VK_EXT_VERTEX_ATTRIBUTE_DIVISOR V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 APIs \u5bf9\u5e94\u529f\u80fd Vertex \u7ed1\u5b9a, GL_EXT_instanced_arrays \u5fc5\u8981\u6027 \u6240\u9700 FeaturesEXT vertexAttributeInstanceRateDivisor \u5bf9\u5e94 GLES \u529f\u80fd Vertex \u7ed1\u5b9a GL_EXT_instanced_arrays glDrawArraysInstancedEXT glDrawElementsInstancedEXT glVertexAttribDivisorEXT Vulkan \u5b9a\u4e49 Vertex Attribute Divisor in Instanced Rendering structure controls how vertex attributes are assigned to an instance when instanced rendering is enabled. VkPipelineVertexInputStateCreateInfo // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPipelineVertexInputDivisorStateCreateInfoEXT { VkStructureType sType; const void* pNext; uint32_t vertexBindingDivisorCount; const VkVertexInputBindingDivisorDescriptionEXT* pVertexBindingDivisors; } VkPipelineVertexInputDivisorStateCreateInfoEXT; // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkVertexInputBindingDivisorDescriptionEXT { uint32_t binding; uint32_t divisor; } VkVertexInputBindingDivisorDescriptionEXT; binding is the binding number for which the divisor is specified. divisor is the number of successive instances that will use the same value of the vertex attribute when instanced rendering is enabled. For example, if the divisor is N, the same vertex attribute will be applied to N successive instances before moving on to the next vertex attribute. The maximum value of divisor is implementation dependent and can be queried using VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT :: maxVertexAttribDivisor . A value of 0 can be used for the divisor if the vertexAttributeInstanceRateZeroDivisor feature is enabled. In this case, the same vertex attribute will be applied to all instances. Features : // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 vertexAttributeInstanceRateDivisor; VkBool32 vertexAttributeInstanceRateZeroDivisor; } VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT; \u2022 sType is the type of this structure. \u2022 pNext is NULL or a pointer to a structure extending this structure. \u2022 vertexAttributeInstanceRateDivisor specifies whether vertex attribute fetching may be repeated in case of instanced rendering. \u2022 vertexAttributeInstanceRateZeroDivisor specifies whether a zero value for VkVertexInputBindingDivisorDescriptionEXT::divisor is supported. Limits : VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::maxVertexAttribDivisor GLES on Vk API \u53c2\u8003Spec, \u4e3a Pipeline \u914d\u7f6e VkPipelineVertexInputDivisorStateCreateInfoEXT \u5373\u53ef. DDK: GLES on gfx \u5206\u6790\u8fc7\u7a0b RendererVk.mMaxVertexAttribDivisor mVertexAttributeDivisorProperties.maxVertexAttribDivisor We only store 8 bit divisor in GraphicsPipelineDesc so capping value & we emulate if exceeded RendererVk::getMaxVertexAttribDivisor ContextVk : onVertexAttributeChange VertexArrayVk::syncDirtyAttrib gl::VertexArray::DIRTY_BIT_ATTRIB_0 + INDEX: gl::VertexArray::DIRTY_BIT_BINDING_0 + INDEX: VertexArrayVk::updateStreamedAttribs VK_KHR_SHADER_FLOAT16_INT8 (.) V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 APIs \u5bf9\u5e94\u529f\u80fd glGenerateMipmap \u5fc5\u8981\u6027 \u975e\u5fc5\u8981: \u6027\u80fd\u4f18\u5316 \u6240\u9700 FeaturesEXT shaderFloat16 angle issue: http://anglebug.com/4551 \u5bf9\u5e94GLES API glGenerateMipmap \u7528\u4e8e\u8fdb\u884c\u751f\u6210Mipmap \u8ba1\u7b97\u65f6, \u5728\u7740\u8272\u5668\u4e2d\u542f\u7528 float 16 \u6765\u52a0\u901f\u8fd0\u7b97 Vulkan \u5b9a\u4e49 \u6b64\u6269\u5c55\u5c06\u63d0\u5347\u81f3 Vulkan 1.2 Core \u6b64\u6269\u5c55\u5141\u8bb8\u5728\u7740\u8272\u5668\u4e2d\u4f7f\u752816\u4f4d\u6d6e\u70b9\u7c7b\u578b\u548c8\u4f4d\u6574\u6570\u7c7b\u578b\u8fdb\u884c\u7b97\u672f\u8fd0\u7b97\u3002 Features : \u4ec5\u9700\u542f\u7528 shaderFloat16 typedef struct VkPhysicalDeviceShaderFloat16Int8Features { VkStructureType sType; void* pNext; VkBool32 shaderFloat16; VkBool32 shaderInt8; } VkPhysicalDeviceShaderFloat16Int8Features; GLES on VK \u5728 GenerateMipmap \u8fc7\u7a0b\u4e2d, \u53d6 shader \u8fdb\u884c\u8ba1\u7b97\u65f6, \u5982\u679c\u56fe\u7247\u7684 bits-per-component (eg: redBits) \u4e3a 8 \u6216 16\u65f6, \u4f7f\u7528\u6269\u5c55\u63d0\u4f9b\u7684 float16 \u6765\u8ba1\u7b97\u4ee5\u83b7\u53d6\u66f4\u5feb\u7684\u8ba1\u7b97\u901f\u5ea6. if (actualFormat.redBits <= 8) { flags = hasShaderFloat16 ? GenerateMipmap_comp::kIsRGBA8_UseHalf : GenerateMipmap_comp::kIsRGBA8; } else if (actualFormat.redBits <= 16) { flags = hasShaderFloat16 ? GenerateMipmap_comp::kIsRGBA16_UseHalf : GenerateMipmap_comp::kIsRGBA16; } else { flags = GenerateMipmap_comp::kIsRGBA32F; } \u5404 flag \u5206\u522b\u5404\u81ea\u5bf9\u5e94\u4e00\u4e2a\u9884\u751f\u6210\u7684 compressedShaderCode. \u5206\u6790\u8fc7\u7a0b supportsShaderFloat16 \u652f\u6301: `` UtilsVk.cpp: GetGenerateMipmapFlags UtilsVk::generateMipmapFlags TextureVk::generateMipmapsWithCompute TextureVk::generateMipmap Texture : generateMipmap Context : generateMipmap // Note: If bits-per-component is 8 or 16 and float16 is supported in the shader, use that for faster math. flag \u4f5c\u7528: contextVk->getShaderLibrary().getGenerateMipmap_comp(contextVk, flags, &shader) uint32_t GetGenerateMipmapFlags(ContextVk *contextVk, const vk::Format &format) { const angle::Format &actualFormat = format.actualImageFormat(); uint32_t flags = 0; // Note: const bool hasShaderFloat16 = contextVk->getRenderer()->getFeatures().supportsShaderFloat16.enabled; if (actualFormat.redBits <= 8) { flags = hasShaderFloat16 ? GenerateMipmap_comp::kIsRGBA8_UseHalf : GenerateMipmap_comp::kIsRGBA8; } else if (actualFormat.redBits <= 16) { flags = hasShaderFloat16 ? GenerateMipmap_comp::kIsRGBA16_UseHalf : GenerateMipmap_comp::kIsRGBA16; } else { flags = GenerateMipmap_comp::kIsRGBA32F; } flags |= UtilsVk::GetGenerateMipmapMaxLevels(contextVk) == UtilsVk::kGenerateMipmapMaxLevels ? GenerateMipmap_comp::kDestSize6 : GenerateMipmap_comp::kDestSize4; return flags; } EGL VK_EXT_SWAPCHAIN_COLOR_SPACE (.) V100 \u5df2\u652f\u6301 \u5426 ? \u5bf9\u5e94 GLES EGL Extension \u5bf9\u5e94\u529f\u80fd EGL_KHR_gl_colorspace (v100\u652f\u6301) \u5fc5\u8981\u6027 \u652f\u6301 EGL EXT \u5fc5\u987b \u6240\u9700 FeaturesEXT \u65e0 angle issue: http://anglebug.com/2514 \u652f\u6301\u6269\u5c55 EGL_KHR_gl_colorspace (v100\u652f\u6301), \u8fdb\u800c\u652f\u6301 EGL_EXT_image_gl_colorspace \u7b49 colorspace \u6269\u5c55. \u5bf9\u5e94 GLES \u529f\u80fd \u6269\u5c55 EGL_KHR_gl_colorspace \u683c\u5f0f: EGL_GL_COLORSPACE_KHR EGL_GL_COLORSPACE_SRGB_KHR EGL_GL_COLORSPACE_LINEAR_KHR Vulkan \u5b9a\u4e49 \u63d0\u4f9b\u6269\u5c55: VkColorSpaceKHR : VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT VK_COLOR_SPACE_BT2020_LINEAR_EXT VK_COLOR_SPACE_BT709_LINEAR_EXT VK_COLOR_SPACE_BT709_NONLINEAR_EXT VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT VK_COLOR_SPACE_DOLBYVISION_EXT VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT VK_COLOR_SPACE_HDR10_HLG_EXT VK_COLOR_SPACE_HDR10_ST2084_EXT VK_COLOR_SPACE_PASS_THROUGH_EXT GLES on Vulkan \u5bf9 EGL \u7684 Format \u5411 Vk Format \u8fdb\u884c\u6620\u5c04: static VkColorSpaceKHR MapEglColorSpaceToVkColorSpace(EGLenum EGLColorspace) { switch (EGLColorspace) { case EGL_NONE: case EGL_GL_COLORSPACE_LINEAR: case EGL_GL_COLORSPACE_SRGB_KHR: case EGL_GL_COLORSPACE_DISPLAY_P3_PASSTHROUGH_EXT: return VK_COLOR_SPACE_SRGB_NONLINEAR_KHR; case EGL_GL_COLORSPACE_DISPLAY_P3_LINEAR_EXT: return VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT; case EGL_GL_COLORSPACE_DISPLAY_P3_EXT: return VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT; case EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT: return VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT; case EGL_GL_COLORSPACE_SCRGB_EXT: return VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT; default: UNREACHABLE(); return VK_COLOR_SPACE_SRGB_NONLINEAR_KHR; } } VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER \u548c VK_EXT_QUEUE_FAMILY_FOREIGN V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES EGL Extension (\u4ec5\u5b89\u5353) \u5bf9\u5e94\u529f\u80fd EGL_ANDROID_image_native_buffer (v100\u652f\u6301) \u5fc5\u8981\u6027 \u652f\u6301 EGL EXT \u5fc5\u987b \u6240\u9700 FeaturesEXT \u65e0 \u5bf9\u5e94 GLES \u529f\u80fd \u652f\u6301 ANativeWindowBuffer : EGL_NATIVE_BUFFER_ANDROID \u793a\u4f8b: ANativeWindowBuffer* sSrcBuffer = graphicBuffer->getNativeBuffer(); EGLint attrs[] = { EGL_IMAGE_PRESERVED_KHR, EGL_TRUE, EGL_NONE, }; EGLImageKHR eglSrcImage =eglCreateImageKHR(eglDisplay, EGL_NO_CONTEXT, EGL_NATIVE_BUFFER_ANDROID, (EGLClientBuffer)&sSrcBuffer, attrs); Vulkan \u5b9a\u4e49 1. VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER \u6b64\u6269\u5c55\u4f7f\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5c06\u5728Vulkan\u8bbe\u5907\u5916\u90e8\u521b\u5efa\u7684Android AHardwareBuffer\u5bf9\u8c61\u5bfc\u5165Vulkan\u5185\u5b58\u5bf9\u8c61\uff0c\u5728\u5176\u4e2d\u53ef\u4ee5\u5c06\u5b83\u4eec\u7ed1\u5b9a\u5230\u56fe\u50cf\u548c\u7f13\u51b2\u533a\u3002 \u5b83\u8fd8\u5141\u8bb8\u4eceVulkan\u5185\u5b58\u5bf9\u8c61\u4e2d\u5bfc\u51faAHardwareBuffer\uff0c\u4ee5\u4e0e\u5176\u4ed6\u64cd\u4f5c\u7cfb\u7edf\u5bf9\u79f0\u3002 \u4f46\u662f\uff0c\u7531\u4e8e\u5e76\u975e\u6240\u6709AHardwareBuffer\u7528\u6cd5\u548c\u683c\u5f0f\u90fd\u5177\u6709Vulkan\u7b49\u6548\u9879\uff0c\u56e0\u6b64\u4eceVulkan\u5bfc\u51fa\u4e0e\u63d0\u4f9b\u5916\u90e8AHardwareBuffer\u5e76\u5bfc\u5165\u76f8\u6bd4\uff0c\u63d0\u4f9b\u7684\u529f\u80fd\u8981\u5c11\u5f97\u591a\u3002 \u67d0\u4e9bAHardwareBuffer\u6620\u50cf\u5177\u6709\u5b9e\u73b0\u5b9a\u4e49\u7684\u5916\u90e8\u683c\u5f0f\uff0c\u8fd9\u4e9b\u683c\u5f0f\u53ef\u80fd\u4e0eVulkan\u683c\u5f0f\u4e0d\u5bf9\u5e94\u3002 \u91c7\u6837\u5668Y'CBCR\u8f6c\u6362\u53ef\u7528\u4e8e\u4ece\u8fd9\u4e9b\u56fe\u50cf\u4e2d\u91c7\u6837\u5e76\u5c06\u5b83\u4eec\u8f6c\u6362\u4e3a\u5df2\u77e5\u7684\u8272\u5f69\u7a7a\u95f4\u3002 \u6269\u5c55\u547d\u4ee4\u5305\u62ec: vkGetAndroidHardwareBufferPropertiesANDROID vkGetMemoryAndroidHardwareBufferANDROID 2. VK_EXT_QUEUE_FAMILY_FOREIGN \u6b64\u6269\u5c55\u5b9a\u4e49\u4e86\u4e00\u4e2a\u7279\u6b8a\u7684\u961f\u5217\u65cf (Queue Family): VK_QUEUE_FAMILY_FOREIGN_EXT : \u7528\u4e8e\u5c06\u5916\u90e8\u5b58\u50a8\u5668\u652f\u6301\u7684\u8d44\u6e90\u6240\u6709\u6743\u8f6c\u79fb\u5230\u5916\u90e8\u5916\u90e8\u961f\u5217\u3002 \u8fd9\u7c7b\u4f3c\u4e8e VK_KHR_external_memory \u4e2d\u5b9a\u4e49\u7684 VK_QUEUE_FAMILY_EXTERNAL_KHR \u3002 \u4e24\u8005\u4e4b\u95f4\u7684\u4e3b\u8981\u533a\u522b\u662f\uff1a VK_QUEUE_FAMILY_EXTERNAL_KHR \u8868\u793a\u7684\u961f\u5217\u5fc5\u987b\u4e0e\u5f53\u524dVkInstance\u5171\u4eab\u76f8\u540c\u7684\u7269\u7406\u8bbe\u5907\u548c\u76f8\u540c\u7684\u9a71\u52a8\u7a0b\u5e8f\u7248\u672c\u3002 VK_QUEUE_FAMILY_FOREIGN_EXT \u6ca1\u6709\u8fd9\u6837\u7684\u9650\u5236\u3002 \u5b83\u53ef\u4ee5\u4ee3\u8868\u5176\u4ed6\u4f9b\u5e94\u5546\u7684\u8bbe\u5907\u548c\u9a71\u52a8\u7a0b\u5e8f\uff0c\u751a\u81f3\u53ef\u4ee5\u4ee3\u8868\u4e0d\u5177\u6709Vulkan\u529f\u80fd\u7684\u8bbe\u5907\u3002 \u5916\u90e8\u5b58\u50a8\u5668\u652f\u6301\u7684\u6240\u6709\u8d44\u6e90\u5747\u652f\u6301 VK_QUEUE_FAMILY_EXTERNAL_KHR \u3002 \u5bf9 VK_QUEUE_FAMILY_FOREIGN_EXT \u7684\u652f\u6301\u66f4\u5177\u9650\u5236\u6027\u3002 \u5e94\u7528\u7a0b\u5e8f\u5e94\u8be5\u671f\u671b\u5230 VK_QUEUE_FAMILY_FOREIGN_EXT \u7684\u8f6c\u6362\u6bd4\u4ece VK_QUEUE_FAMILY_EXTERNAL_KHR \u7684\u8f6c\u6362\u8981\u6602\u8d35\u3002 GLES on Vulkan Android\u5e73\u53f0\u7279\u6b8a\u4ee3\u7801 (src\\libANGLE\\renderer\\vulkan\\android). \u4e3aimage\u521b\u5efabuffer\u65f6, \u7528\u4e8e\u83b7\u53d6 BufferMemory \u7b49\u5e95\u5c42\u4fe1\u606f. \u5177\u4f53\u5185\u5bb9\u5f85\u5206\u6790. if ANDROID \u6709\u5219\u542f\u7528 supportsAndroidHardwareBuffer VK_QUEUE_FAMILY_FOREIGN_EXT VK_KHR_EXTERNAL_FENCE_FD \u6709\u5219\u542f\u7528 supportsExternalFenceFd \u652f\u6301: EGL_ANDROID_native_fence VK_KHR_INCREMENTAL_PRESENT \u6709\u5219\u542f\u7528 supportsIncrementalPresent \u652f\u6301 EGL_KHR_swap_buffers_with_damage eglSwapBuffersWithDamageEXT SurfaceVk::present SurfaceVk::swapImpl GLES EXT VK_KHR_EXTERNAL_MEMORY_FD \u6709\u5219\u542f\u7528 supportsExternalMemoryFd \u652f\u6301: GL_EXT_memory_object_fd VK_KHR_EXTERNAL_SEMAPHORE_FD \u6709\u5219\u542f\u7528 supportsExternalSemaphoreFd \u652f\u6301: GL_EXT_semaphore_fd Vulkan \u81ea\u7528 VK_KHR_SURFACE && VK_KHR_ANDROID_SURFACE WSI , \u975e\u53ef\u9009 Extension VK_EXT_DEBUG_UTILS / VK_EXT_DEBUG_REPORT Vulkan ValidationLayers VK_KHR_SWAPCHAIN \u975e\u53ef\u9009 Extension VK_QCOM_render_pass_store_ops \u6709\u5219\u542f\u7528 supportsRenderPassStoreOpNoneQCOM VK_ATTACHMENT_STORE_OP_NONE_QCOM http://anglebug.com/5505 For read only depth stencil, we can use StoreOpNone if available. DONT_CARE is still preferred, so do this after finish the DONT_CARE handling. \u5176\u4ed6\u5e73\u53f0 Nvidia VK_EXT_DEPTH_CLIP_ENABLE \u6709\u5219\u542f\u7528 FeatureVk.depthClamping \u542f\u7528 : isNvidia && Features.depthClamp && EXT The workaround requires the VK_EXT_depth_clip_enable extension and the 'depthClamp' physical device feature. This workaround caused test failures on Quadro P400/driver 418.56/Linux. Therefore, on Linux we require a major version > 418. On some NVIDIA drivers the depth value is not clamped to [0,1] for floating point depth buffers. This is NVIDIA bug 3171019, see http://anglebug.com/3970 for details. When depth clamping is used, depth clipping is automatically disabled. When the 'depthClamping' feature is enabled, we'll be using depth clamping to work around a driver issue, not as an alternative to depth clipping. Therefore we need to explicitly re-enable depth clipping. \u5bf9\u5e94 vk: VkPipelineRasterizationState.depthClampEnable MAC VK_EXT_EXTERNAL_MEMORY_HOST \u6709\u5219\u542f\u7528 FeatureVk.supportsExternalMemoryHost Whether the VkDevice supports the VK_EXT_external_memory_host extension, on which the ANGLE_iosurface_client_buffer extension can be layered. IOSurfaceSurfaceVkMac.mm OffscreenSurfaceVk::AttachmentImage::initializeWithExternalMemory RendererVk.mMinImportedHostPointerAlignment vkGetMemoryHostPointerPropertiesEXT IOSurfaceSurfaceVkMac.mm GGP(Stadia) VK_GGP_FRAME_TOKEN if PLANTFORM_GGP \u6709\u5219\u542f\u7528 supportsGGPFrameToken \u652f\u6301 : EGL_ANGLE_swap_with_frame_token eglSwapBuffersWithFrameTokenANGLE Fuchsia VK_FUCHSIA_EXTERNAL_MEMORY \u6709\u5219\u542f\u7528 supportsExternalMemoryFuchsia \u652f\u6301: GL_ANGLE_memory_object_fuchsia VK_FUCHSIA_EXTERNAL_SEMAPHORE \u6709\u5219\u542f\u7528 supportsExternalSemaphoreFuchsia \u652f\u6301: GL_ANGLE_semaphore_fuchsia ANGLE VK_EXT_PROVOKING_VERTEX GL_ANGLE_provoking_vertex glProvokingVertexANGLE VK_GOOGLE_SAMPLER_FILTERING_PRECISION \u672a\u542f\u7528, ANGLE\u81ea\u5b9a\u4e49 supportsFilteringPrecision \u652f\u6301: GL_CHROMIUM_texture_filtering_hint gHint(GL_TEXTURE_FILTERING_HINT_CHROMIUM) v100 \u5df2\u652f\u6301\u7684Ext GLES VK_KHR_DEPTH_STENCIL_RESOLVE \u542f\u7528 if supportsRenderpass2.enabled && mDepthStencilResolveProperties.independentResolveNone supportsDepthStencilResolve http://anglebug.com/5065 RenderbufferVk::setStorageImpl \u4e3a multisampled depth/stenci \u542f\u7528 render render to texture \u53ef\u542f\u7528 VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT // If multisampled render to texture, an implicit multisampled image is created which is used as // the color or depth/stencil attachment. At the end of the render pass, this image is // automatically resolved into |mImage| and its contents are discarded. \u652f\u6301 depth/stencil images, \u975e\u5fc5\u9700, \u53ef\u7ed5\u8fc7 VK_KHR_EXTERNAL_FENCE_CAPABILITIES \u6709\u5219\u542f\u7528 supportsExternalFenceCapabilities supportsAndroidNativeFenceSync (supportsExternalFenceCapabilities && supportsExternalSemaphoreCapabilities ) || (supportsExternalFenceFd&& supportsExternalSemaphoreFd) VK_KHR_EXTERNAL_SEMAPHORE \u542f\u7528 if supportsExternalSemaphoreFd || supportsExternalSemaphoreFuchsia \u4e8c\u8005\u7684\u524d\u7f6e? \u65e0EXT\u5b58\u5728\u68c0\u67e5 \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES \u6709\u5219\u542f\u7528 supportsExternalSemaphoreCapabilities VK_KHR_MAINTENANCE1 PhysicalDeviceProperties.apiVersion < VK_MAKE_VERSION(1, 1, 0) Enable KHR_MAINTENANCE1 to support viewport flipping. VK_KHR_SAMPLER_YCBCR_CONVERSION \u542f\u7528 if SamplerYcbcrConversionFeatures.samplerYcbcrConversion supportsYUVSamplerConversion Vulkan \u81ea\u7528 VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2 \u6709\u5219\u542f\u7528 VK_KHR_GET_MEMORY_REQUIREMENTS_2 \u6709\u5219\u542f\u7528 \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_BIND_MEMORY_2 \u6709\u5219\u542f\u7528 \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_EXTERNAL_MEMORY \u542f\u7528 if supportsAndroidHardwareBuffer || supportsExternalMemoryFd|| supportsExternalMemoryFuchsia \u53ef\u80fd\u4e3a\u4e09\u8005\u7684\u524d\u7f6e: \u65e0EXT\u652f\u6301\u68c0\u67e5, \u6761\u4ef6\u6ee1\u8db3\u76f4\u63a5\u542f\u7528. \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_CREATE_RENDERPASS_2 \u6709\u5219\u542f\u7528 supportsRenderpass2 vkCreateRenderPass2KHR VK_KHR_DEPTH_STENCIL_RESOLVE \u4f9d\u8d56\u6b64\u6269\u5c55 AMD VK_KHR_IMAGE_FORMAT_LIST \u542f\u7528 if AMD supportsImageFormatList EGL_EXT_image_gl_colorspace ANGLE \u671f\u671b\u5c06\u6765\u52a0\u5165\u7684 EXT \u4ee5\u4e0b\u591aExtension\u5c1a\u672a\u5217\u5165 Vulkan Spec, \u662f ANGLE \u671f\u671b\u4e3a\u652f\u6301GLES \u800c\u63d0\u51fa\u7684. VK_KHR_shader_terminate_invocation VK_EXT_primitive_topology_list_restart VK_EXT_vertext_attribute_aliasing VK_EXT_generate_mipmap VK_EXT_pipeline_robustness VK_EXT_image_robustness VK_EXT_custom_border_color VK_EXT_blend_operation_advanced \u51fa\u73b0\u5728\u4ee3\u7801\u4e2d\u4f46\u5c1a\u672a\u542f\u7528\u7684Feature. textureCompressionETC2 ANGLE: Vk Features inheritedQueries 3.0 \u5fc5\u987b // We use secondary command buffers almost everywhere and they require a feature to be // able to execute in the presence of queries. As a result, we won't support queries // unless that feature is available. mNativeExtensions.occlusionQueryBoolean = \u652f\u6301 GLES \u529f\u80fd: QueryType glBeginQuery glEndQuery glGetQueryiv case QueryType::AnySamplesConservative: GLES \u6269\u5c55 GL_EXT_occlusion_query_boolean glGenQueriesEXT glDeleteQueriesEXT glIsQueryEXT glBeginQueryEXT glEndQueryEXT glGetQueryivEXT glGetQueryObjectuivEXT vertexPipelineStoresAndAtomics \u7528\u4e8e\u6a21\u62df\u5b9e\u73b0 transform feedback \u529f\u80fd, \u4f5c\u4e3a\u4e0d\u652f\u6301\u6269\u5c55 VK_EXT_ransform_feedback \u65f6\u7684\u66ff\u4ee3. \u4f46 es3.2 \u4e2d\u53ef\u80fd\u51fa\u73b0\u65e0\u6cd5\u652f\u6301\u529f\u80fd. ANGLE: Vk Limits maxPerStageDescriptorStorageBuffers \u5f53\u524d\u503c \u671f\u5f85\u503c 8 12 / 16 ANGLE \u4e2d, Vulkan Limit: maxPerStageDescriptorStorageBuffers \u4e3a GLES \u540c\u65f6\u63d0\u4f9b StorageBuffers \u548c CounterBuffers, \u5bf9\u5e94\u7684 GLES \u7684 Limits \u4e3a: StorageBuffers: MAX_VERTEX_SHADER_STORAGE_BLOCKS MAX_FRAGMENT_SHADER_STORAGE_BLOCKS MAX_COMPUTE_SHADER_STORAGE_BLOCKS AtomicCounterBuffers: MAX_VERTEX_ATOMIC_COUNTER_BUFFERS MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS \u5404\u7ec4\u503c\u5206\u522b\u8ba1\u7b97, \u4f8b\u5982 VERTEX \u7684\u4e24\u8005\u76f8\u52a0\u4e3aBuffer \u7684 Limit \u503c: MAX_VERTEX_SHADER_STORAGE_BLOCKS + MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = maxPerStageDescriptorStorageBuffers, FRAGMENT, COMPUTE \u540c\u7406. (GEOMETRY \u7684 StorageBuffers \u5bf9\u5e94 vkLimit: maxPerStageResources) \u5728 ANGLE \u4e2d, \u671f\u5f85\u503c StorageBuffers >=4, AtomicCounterBuffers =8, \u56e0\u6b64\u5bf9 GLES 3.1 \u8981\u6c42 maxPerStageDescriptorStorageBuffers >=12 \u82e5\u4e0d\u6ee1\u8db3, \u9650\u5236\u7248\u672c\u4e3a3.0, \u5e76\u8bbe AtomicCounterBuffers \u4e3a 0. \u540c\u65f6, \u82e5\u6ee1\u8db3 AtomicCounterBuffers =8 \u540e, \u8981\u540c\u65f6\u6ee1\u8db3 v100 GLES Limits \u4e2d MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 8, \u5219\u9700 maxPerStageDescriptorStorageBuffers = 16 \u5bf9\u5e943.1\u529f\u80fd: MAX_VERTEX_SHADER_STORAGE_BLOCKS \u548c MAX_VERTEX_ATOMIC_COUNTER_BUFFERS \u9700\u8981 vk \u7279\u6027 vertexPipelineStoresAndAtomics, \u800c\u6b64\u7279\u6027\u5728\u652f\u6301 VK_EXT_TRANSFORM_FEEDBACK \u6269\u5c55\u65f6\u4e0d\u518d\u9700\u8981. \u56e0\u6b64\u5b9e\u73b0 VK_EXT_TRANSFORM_FEEDBACK \u540e\u8be5\u7ec4\u53ef\u5ffd\u7565 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS \u548c MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS \u9700\u8981 vk \u7279\u6027 fragmentStoresAndAtomics (v100\u5df2\u652f\u6301). maxPerStageDescriptorUniformBuffers \u5f53\u524d\u503c \u671f\u5f85\u503c 12 14 \u4e3a kReservedDriverUniformBindingCount, kReservedPerStageDefaultUniformBindingCount \u5404\u7559\u51fa1\u4e2a. \u5f71\u54cd GLES Limits: MAX_VERTEX_UNIFORM_BLOCKS MAX_FRAGMENT_UNIFORM_BLOCKS MAX_COMPUTE_UNIFORM_BLOCKS MAX_GEOMETRY_UNIFORM_BLOCKS MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS maxDescriptorSetUniformBuffers \u5f53\u524d\u503c \u671f\u5f85\u503c 72 72+4 = 76 \u4e3a kReservedDriverUniformBindingCount , kReservedDefaultUniformBindingCount \u9884\u7559\u51fa1 + 3 = 4\u4e2a. constexpr uint32_t kTotalReservedUniformBuffers = kReservedDriverUniformBindingCount + kReservedDefaultUniformBindingCount; const int32_t maxCombinedUniformBuffers = LimitToInt(limitsVk.maxDescriptorSetUniformBuffers - kTotalReservedUniformBuffers); \u5f71\u54cd GLES Limits: MAX_UNIFORM_BUFFER_BINDINGS MAX_COMBINED_UNIFORM_BLOCKS maxVertexOutputComponents \u4e0e maxFragmentInputComponents \u5f53\u524d\u503c \u671f\u5f85\u503c 128 128 + 4*2 = 136 \u5f53\u524d\u503c 128, \u5047\u8bbe EXT \u5747\u5f97\u5230\u652f\u6301, \u4e14\u8981\u6ee1\u8db3GLES Limits, \u82e5 \u4e0d \u652f\u6301 VK_EXT_LINE_RASTERIZATION, \u5219\u9884\u7559 1 \u4e3a\u4e86\u652f\u6301 VK_EXT_TRANSFORM_FEEDBACK, \u9700\u8981\u9884\u7559 2 \u5f71\u54cd GLES Limits: MAX_VARYING_VECTORS \u9884\u7559\u524d 31\u521a\u597d\u6ee1\u8db3. MAX_VARYING_COMPONENTS \u9884\u7559\u524d 124 \u521a\u597d\u6ee1\u8db3. (Vector * 4 = Components ) // The max vertex output components should not include gl_Position. // The gles2.0 section 2.10 states that \"gl_Position is not a varying variable and does // not count against this limit.\", but the Vulkan spec has no such mention in its Built-in // vars section. It is implicit that we need to actually reserve it for Vulkan in that case. GLint reservedVaryingVectorCount = 1; // reserve 1 extra for ANGLEPosition when GLLineRasterization is enabled constexpr GLint kRservedVaryingForGLLineRasterization = 1; // reserve 2 extra for builtin varables when feedback is enabled // possible capturable out varable: gl_Position, gl_PointSize // https://www.khronos.org/registry/OpenGL/specs/es/3.1/GLSL_ES_Specification_3.10.withchanges.pdf // page 105 constexpr GLint kReservedVaryingForTransformFeedbackExtension = 2; if (getFeatures().basicGLLineRasterization.enabled) { reservedVaryingVectorCount += kRservedVaryingForGLLineRasterization; } if (getFeatures().supportsTransformFeedbackExtension.enabled) { reservedVaryingVectorCount += kReservedVaryingForTransformFeedbackExtension; } const GLint maxVaryingCount = std::min(limitsVk.maxVertexOutputComponents, limitsVk.maxFragmentInputComponents); // 128, 128 mNativeCaps.maxVaryingVectors = LimitToInt((maxVaryingCount / kComponentsPerVector(4)) - reservedVaryingVectorCount); maxInterpolationOffset \u5f53\u524d\u503c \u671f\u5f85\u503c 0.4375 0.5 \u9644\u8868: GLES Limits \u6ee1\u8db3\u60c5\u51b5\u8be6\u60c5 \u672c\u8868\u57fa\u4e8e ANGLE \u5185\u7684\u8ba1\u7b97\u65b9\u5f0f, \u5e26\u5165 v100 \u7684 Vulkan Limits \u503c, \u68c0\u67e5\u7ed3\u679c\u662f\u5426\u6ee1\u8db3 GLES Limits \u7684\u8981\u6c42. [*] \u5e26\u6b64\u6807\u8bb0\u7684\u8ba1\u7b97\u516c\u5f0f\u57fa\u4e8e\u5047\u8bbe: \u4e0a\u9762\u63d0\u53ca\u7684\u6269\u5c55 TransForm_feedback \u548c Line_Rasterization \u5df2\u5f97\u5230\u652f\u6301. \u800c\u76f8\u5e94\u7684\u7531\u4e8e\u6a21\u62df\u7684Feature\u4e0d\u518d\u542f\u7528. maxPerStageDescriptorStorageBuffers \u4ee5 12 \u8ba1\u7b97 1 GLES Limits GLES Limits in V100 Vk(v100)\u503c\u5e26\u5165 ANGLE ANGLE \u8ba1\u7b97\u516c\u5f0f 2 SUBPIXEL_BITS 8 8 subPixelPrecisionBits 3 MAX_3D_TEXTURE_SIZE 256 256 maxImageDimension3D 4 MAX_TEXTURE_SIZE 8192 8192 min(maxFramebufferWidth, maxImageDimension2D); 5 MAX_ARRAY_TEXTURE_LAYERS 256 256 maxImageArrayLayers 6 MAX_TEXTURE_LOD_BIAS 14 14 maxSamplerLodBias 7 MAX_CUBE_MAP_TEXTURE_SIZE 8192 8192 maxImageDimensionCube 8 MAX_RENDERBUFFER_SIZE 8192 8192 min(maxImageDimension2D, maxFramebufferWidth, maxFramebufferHeight); 9 ALIASED_LINE_WIDTH_RANGE[0] 1 1 1 10 ALIASED_LINE_WIDTH_RANGE[1] 4095.9375 1 1 11 ALIASED_POINT_SIZE_RANGE[0] 1 1 max(1.0f, pointSizeRange[0]) 12 ALIASED_POINT_SIZE_RANGE[1] 1024 1024 pointSizeRange[1] 13 MULTISAMPLE_LINE_WIDTH_RANGE [1.0, 4095.9375] - - 14 MULTISAMPLE_LINE_WIDTH_GRANULARITY 0.125 - - 15 MAX_DRAW_BUFFERS 4 4 min(maxColorAttachments, maxFragmentOutputAttachments); 16 MAX_FRAMEBUFFER_WIDTH 8192 8192 maxFramebufferWidth 17 MAX_FRAMEBUFFER_HEIGHT 8192 8192 maxFramebufferHeight 18 MAX_FRAMEBUFFER_LAYERS 256 256 maxFramebufferLayers 19 MAX_FRAMEBUFFER_SAMPLES SAMPLECOUNT1 - SAMPLE_COUNT_4 4 \u540c maxSamples 21 MAX_COLOR_ATTACHMENTS 4 4 maxColorAttachments 22 MIN_FRAGMENT_INTERPOLATION_OFFSET -0.5 -0.5 minInterpolationOffset 23 MAX_FRAGMENT_INTERPOLATION_OFFSET 0.5 0.4375 maxInterpolationOffset 24 FRAGMENT_INTERPOLATION_OFFSET_BITS 4 4 subPixelInterpolationOffsetBits 25 MAX_VIEWPORT_DIMS[0] 8192 8192 maxViewportDimensions[0] 26 MAX_VIEWPORT_DIMS[1] 8192 8192 maxViewportDimensions[1] 27 MAX_SAMPLE_MASK_WORDS 1 1 maxSampleMaskWords 28 MAX_COLOR_TEXTURE_SAMPLES SAMPLECOUNT1 ??? SAMPLECOUNT1-SAMPLECOUNT4? sampledImageColorSampleCounts&31 29 SAMPLE_COUNT_4 - - 30 MAX_DEPTH_TEXTURE_SAMPLES SAMPLECOUNT1 ??? SAMPLECOUNT1-SAMPLECOUNT4? sampledImageDepthSampleCounts&31 31 SAMPLE_COUNT_4 - - 32 MAX_INTEGER_SAMPLES SAMPLECOUNT1 ??? SAMPLECOUNT1-SAMPLECOUNT4? sampledImageIntegerSampleCounts&31 33 SAMPLE_COUNT_4 - - 34 MAX_SERVER_WAIT_TIMEOUT 0 - UNIMPLEMENT 35 LAYER_PROVOKING_VERTEX FIRSTVERTEXCONVENTION - GL_LAST_VERTEX_CONVENTION_EXT 36 LAST_VERTEX_CONVENTION - -- 37 PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED FALSE - -- 38 MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 2047 2047 min(maxVertexInputAttributeOffset, (int16_max -1)) 39 MAX_VERTEX_ATTRIB_BINDINGS 16 16 maxVertexInputBindings 40 MAX_VERTEX_ATTRIB_STRIDE 2048 2048 min(maxVertexInputBindingStride, int16_max) 41 MAX_ELEMENTS_INDICES INT_MAX INT_MAX 42 MAX_ELEMENTS_VERTICES INT_MAX INT_MAX 43 MAX_ELEMENT_INDEX 0xFFFFFFFF UINT_MAX - 1 UINT_MAX - 1 44 MAX_TEXTURE_BUFFER_SIZE 2^24 ??? 224 maxTexelBufferElements 45 NUM_COMPRESSED_TEXTURE_FORMATS 49 -- -- // size of Compressed Texture Formats 46 COMPRESSED_TEXTURE_FORMATS -- -- 47 NUM_PROGRAM_BINARY_FORMATS 0 -- -- 48 PROGRAM_BINARY_FORMATS -- -- 49 NUM_SHADER_BINARY_FORMATS 0 -- -- 50 SHADER_BINARY_FORMATS -- -- 51 SHADER_COMPILER TRUE TRUE 52 TEXTURE_BUFFER_OFFSET_ALIGNMENT 256 256 minTexelBufferOffsetAlignment 53 MAX_TEXTURE_MAX_ANISOTROPY_EXT 16 16 maxSamplerAnisotropy 54 MAX_VERTEX_ATTRIBS 16 16 maxVertexInputAttributes 55 MAX_VERTEX_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 56 MAX_VERTEX_UNIFORM_VECTORS 256 1024 maxUniformBufferRange / (sizeof(float) *4) 57 MAX_VERTEX_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 58 MAX_VERTEX_OUTPUT_COMPONENTS 128 128 maxVertexOutputComponents 59 MAX_VERTEX_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 60 MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0 0 0* 61 MAX_VERTEX_ATOMIC_COUNTERS 0 0 0* 62 MAX_VERTEX_SHADER_STORAGE_BLOCKS 0 0 0* 63 MAX_TESS_GEN_LEVEL 64 -- 64 MAX_PATCH_VERTICES 32 -- 65 MAX_TESS_CONTROL_UNIFORM_COMPONENTS 1024 -- 66 MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 16 -- 67 MAX_TESS_CONTROL_OUTPUT_COMPONENTS 128 -- 68 MAX_TESS_PATCH_COMPONENTS 120 -- 69 MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 4096 -- 70 MAX_TESS_CONTROL_INPUT_COMPONENTS 128 -- 71 MAX_TESS_CONTROL_UNIFORM_BLOCKS 12 -- 72 MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0 -- 73 MAX_TESS_CONTROL_ATOMIC_COUNTERS 0 -- 74 MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0 -- 75 MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 1024 -- 76 MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 16 -- 77 MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 128 -- 78 MAX_TESS_EVALUATION_INPUT_COMPONENTS 128 -- 79 MAX_TESS_EVALUATION_UNIFORM_BLOCKS 12 -- 80 MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0 -- 81 MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0 -- 82 MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0 -- 83 MAX_GEOMETRY_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 84 MAX_GEOMETRY_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 85 MAX_GEOMETRY_INPUT_COMPONENTS 128 128 maxGeometryInputComponents 86 MAX_GEOMETRY_OUTPUT_COMPONENTS 128 128 maxGeometryOutputComponents 87 MAX_GEOMETRY_OUTPUT_VERTICES 256 256 maxGeometryOutputVertices 88 MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 1024 1024 maxGeometryTotalOutputComponents 89 MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 90 MAX_GEOMETRY_SHADER_INVOCATIONS 32 32 maxGeometryShaderInvocations 91 MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0 8* 8* 92 MAX_GEOMETRY_ATOMIC_COUNTERS 0 56 maxStorageBufferRange / sizeof(uint32_t) 93 MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0 45 maxPerStageResources-7 94 MAX_FRAGMENT_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 95 MAX_FRAGMENT_UNIFORM_VECTORS 256 1024 maxUniformBufferRange / (sizeof(float) *4) 96 MAX_FRAGMENT_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 97 MAX_FRAGMENT_INPUT_COMPONENTS 128 4,096\u202c maxUniformBufferRange / sizeof(float) 98 MAX_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 99 MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 1 8 8* 100 MAX_FRAGMENT_ATOMIC_COUNTERS 8 56 maxStorageBufferRange / sizeof(uint32_t) 101 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 8 4 4* 102 MIN_PROGRAM_TEXTURE_GATHER_OFFSET -8 -8 minTexelGatherOffset 103 MAX_PROGRAM_TEXTURE_GATHER_OFFSET 7 7 maxTexelGatherOffset 104 MIN_PROGRAM_TEXEL_OFFSET -8 -8 minTexelOffset 105 MAX_PROGRAM_TEXEL_OFFSET 7 7 maxTexelOffset 106 MAX_COMPUTE_WORK_GROUP_COUNT[0] 65535 65535 maxComputeWorkGroupCount[0] 107 MAX_COMPUTE_WORK_GROUP_COUNT[1] 65535 65535 maxComputeWorkGroupCount[1] 108 MAX_COMPUTE_WORK_GROUP_COUNT[2] 65535 65535 maxComputeWorkGroupCount[2] 109 MAX_COMPUTE_WORK_GROUP_SIZE[0] 1024 1024 [vulkan] maxComputeWorkGroupSize[0] 110 MAX_COMPUTE_WORK_GROUP_SIZE[1] 1024 1024 [vulkan] maxComputeWorkGroupSize[1] 111 MAX_COMPUTE_WORK_GROUP_SIZE[2] 64 64 [vulkan] maxComputeWorkGroupSize[2] 112 MAX_COMPUTE_WORK_GROUP_INVOCATIONS 1024 1024 [vulkan] maxComputeWorkGroupInvocations 113 MAX_COMPUTE_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 114 MAX_COMPUTE_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 115 MAX_COMPUTE_SHARED_MEMORY_SIZE 32768 32768 maxComputeSharedMemorySize 116 MAX_COMPUTE_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 117 MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 1 8 8* 118 MAX_COMPUTE_ATOMIC_COUNTERS 8 56 maxStorageBufferRange / sizeof(uint32_t) 119 MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 120 MAX_COMPUTE_SHADER_STORAGE_BLOCKS 8 4 maxPerStageDescriptorStorageBuffers - 8 121 MAX_UNIFORM_BUFFER_BINDINGS 72 68 maxDescriptorSetUniformBuffers -4 122 MAX_UNIFORM_BLOCK_SIZE 16384 16384 maxUniformBufferRange 123 UNIFORM_BUFFER_OFFSET_ALIGNMENT 16 16 minUniformBufferOffsetAlignment 124 MAX_COMBINED_UNIFORM_BLOCKS 72 68 maxDescriptorSetUniformBuffers -4 125 MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 126 MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 50176 -- 127 MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 50176 -- 128 MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 129 MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 130 MAX_VARYING_COMPONENTS 124 116 (min(maxVertexOutputComponents, maxFragmentInputComponents) /4 - 3)*4 131 MAX_VARYING_VECTORS 31 29 min(maxVertexOutputComponents, maxFragmentInputComponents) /4 - 3 132 MAX_COMBINED_TEXTURE_IMAGE_UNITS 96 96 min(maxDescriptorSetSamplers, maxDescriptorSetSampledImages); 133 MAX_COMBINED_SHADER_OUTPUT_RESOURCES 20 45 maxPerStageResources-7 134 MAX_UNIFORM_LOCATIONS 1024 1024 maxUniformBufferRange / (sizeof(float) *4) 135 MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 1 8 8* 136 MAX_ATOMIC_COUNTER_BUFFER_SIZE 32 227 maxStorageBufferRange 137 MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 1 8 8* 138 MAX_COMBINED_ATOMIC_COUNTERS 8 56 maxStorageBufferRange / sizeof(uint32_t) 139 MAX_IMAGE_UNITS 8 48 maxDescriptorSetStorageImages 140 MAX_VERTEX_IMAGE_UNIFORMS 0 0 0* 141 MAX_TESS_CONTROL_IMAGE_UNIFORMS 0 -- -- 142 MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0 -- -- 143 MAX_GEOMETRY_IMAGE_UNIFORMS 0 0 0* 144 MAX_FRAGMENT_IMAGE_UNIFORMS 8 8 maxPerStageDescriptorStorageImages* 145 MAX_COMPUTE_IMAGE_UNIFORMS 8 8 maxPerStageDescriptorStorageImages* 146 MAX_COMBINED_IMAGE_UNIFORMS 8 48 maxDescriptorSetStorageImages 147 MAX_SHADER_STORAGE_BUFFER_BINDINGS 4 40 maxDescriptorSetStorageBuffers - 8* 148 MAX_SHADER_STORAGE_BLOCK_SIZE 2^27 ??? 227 maxStorageBufferRange 149 MAX_COMBINED_SHADER_STORAGE_BLOCKS 8 40 maxDescriptorSetStorageBuffers - 8* 150 SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 256 256 minStorageBufferOffsetAlignment 151 MAX_LABEL_LENGTH 256 1024 1024 152 MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 64 128 128 153 MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 4 4 4 154 MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 4 4 4 155 MAX_SAMPLES 4 4 SAMPLE_COUNT_1 - SAMPLE_COUNT_4 156 MAX_SERVER_WAIT_TIMEOUT 0 -- UNIMPLEMENT 157 MAX_VIEWS_OVR 6 1 1 \u5176\u4ed6 Properties // Provided by VK_VERSION_1_0 typedef struct VkQueueFamilyProperties { VkQueueFlags queueFlags; uint32_t queueCount; uint32_t timestampValidBits; VkExtent3D minImageTransferGranularity; } VkQueueFamilyProperties; GL_EXT_disjoint_timer_query disjointTimerQuery VkQueueFamilyProperties. timestampValidBits > 0 \u9644\u5f55 v100 GLES Extension \u652f\u6301\u60c5\u51b5 \u4ece GLES Extensions \u89c6\u89d2, \u67e5\u8be2\u6240\u9700\u7684 Vk \u652f\u6301. OpenGL ES Extension in v100 ANGLE \u652f\u6301 ANGLE \u652f\u6301\u6761\u4ef6 Vulkan (v100) \u6ee1\u8db3 GL_EXT_multi_draw_indirect UNIMPLEMENTED GL_EXT_debug_marker Y GL_ARM_rgba8 GL_ARM_mali_shader_binary GL_OES_depth24 Y GL_OES_depth_texture Y GL_OES_depth_texture_cube_map Y GL_OES_packed_depth_stencil Y GL_OES_rgb8_rgba8 Y GL_EXT_read_format_bgra Y GL_OES_compressed_paletted_texture GL_OES_compressed_ETC1_RGB8_texture Y GL_OES_standard_derivatives Y GL_OES_EGL_image Y GL_OES_EGL_image_external Y GL_OES_EGL_image_external_essl3 Y GL_OES_EGL_sync Y GL_OES_texture_npot Y GL_OES_vertex_half_float Y GL_OES_required_internalformat GL_OES_vertex_array_object Y GL_OES_mapbuffer Y GL_EXT_texture_format_BGRA8888 Y GL_EXT_texture_rg Y GL_EXT_texture_type_2_10_10_10_REV Y GL_OES_fbo_render_mipmap Y GL_OES_element_index_uint Y GL_EXT_shadow_samplers Y GL_KHR_texture_compression_astc_ldr GL_KHR_debug Y GL_EXT_occlusion_query_boolean Y GL_EXT_disjoint_timer_query Y GL_EXT_blend_minmax Y GL_EXT_discard_framebuffer Y GL_OES_get_program_binary Y GL_OES_texture_3D Y GL_EXT_texture_storage Y GL_EXT_multisampled_render_to_texture Y GL_OES_surfaceless_context Y GL_OES_texture_stencil8 Y GL_EXT_shader_pixel_local_storage GL_ARM_shader_framebuffer_fetch GL_ARM_shader_framebuffer_fetch_depth_stencil GL_EXT_shader_framebuffer_fetch_non_coherent GL_ARM_mali_program_binary GL_EXT_sRGB Y GL_EXT_sRGB_write_control GL_EXT_texture_sRGB_decode Y GL_EXT_texture_sRGB_R8 Y GL_EXT_texture_sRGB_RG8 GL_KHR_blend_equation_advanced GL_KHR_blend_equation_advanced_coherent GL_OES_texture_storage_multisample_2d_array Y GL_OES_shader_image_atomic Y GL_EXT_robustness Y GL_EXT_draw_buffers_indexed Y GL_OES_draw_buffers_indexed Y GL_EXT_texture_border_clamp GL_OES_texture_border_clamp GL_EXT_texture_cube_map_array Y GL_OES_texture_cube_map_array Y GL_OES_sample_variables Y GL_OES_sample_shading Y GL_OES_shader_multisample_interpolation GL_EXT_shader_io_blocks GL_OES_shader_io_blocks GL_EXT_tessellation_shader GL_OES_tessellation_shader GL_EXT_primitive_bounding_box GL_OES_primitive_bounding_box GL_EXT_geometry_shader Y GL_OES_geometry_shader GL_ANDROID_extension_pack_es31a GL_EXT_gpu_shader5 Y GL_OES_gpu_shader5 GL_EXT_texture_buffer Y GL_OES_texture_buffer Y GL_EXT_copy_image Y GL_OES_copy_image GL_EXT_shader_non_constant_global_initializers Y GL_EXT_color_buffer_half_float Y GL_EXT_color_buffer_float Y GL_EXT_YUV_target GL_OVR_multiview GL_OVR_multiview2 GL_OVR_multiview_multisampled_render_to_texture GL_KHR_robustness GL_KHR_robust_buffer_access_behavior GL_EXT_draw_elements_base_vertex Y GL_OES_draw_elements_base_vertex Y GL_EXT_protected_textures GL_EXT_geometry_point_size GL_OES_geometry_point_size GL_EXT_tessellation_point_size GL_OES_tessellation_point_size GL_OES_draw_texture v100 EGL Extension EGL extensions EGL_KHR_get_all_proc_addresses EGL_ANDROID_presentation_time EGL_KHR_swap_buffes_witn_damage EGL_ANDROID_get_native_client_buffer EGL_ANDROID_front_buffer_auto_refresh EGL_ANDROID_get_frame_timestamps EGL_KHR_image EGL_KHR_image_base EGL_KHR_gl_colorspace EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_gl_renderbuffer_image EGL_KHR_fence_sync EGL_KHR_create_context EGL_KHR_config_attribs EGL_KHR_surfaceless_context EGL_EXT_create_context_robustness EGL_ANDROID_image_native_buffer EGL_KHR_wait_sync EGL_ANDROID_recordable EGL_KHR_partial_update EGL_KHR_mutable_render_buffer EGL_EXT_protected_content EGL_IMG_context_priority ANGLE \u4e2d\u542f\u7528\u7684 Vk Features Vulkan_1_0 Features: // Select additional features to be enabled. mPhysicalDeviceFeatures{ // Used to support cubemap array: only enable when not SwiftShader or not Qualcomm imageCubeArray; // Used to support framebuffers with multiple attachments: independentBlend; // Used to support robust buffer access: robustBufferAccess; // Used to support Anisotropic filtering: samplerAnisotropy; // Used to support wide lines: wideLines; // Used to emulate transform feedback: vertexPipelineStoresAndAtomics; // Used to implement storage buffers and images in the fragment shader: fragmentStoresAndAtomics; // Used to support geometry shaders: geometryShader // Used to support EXT_gpu_shader5: shaderImageGatherExtended; // Used to support EXT_gpu_shader5: shaderUniformBufferArrayDynamicIndexing // Used to support EXT_gpu_shader5 and sampler array of array emulation: shaderSampledImageArrayDynamicIndexing; // Used to support atomic counter emulation: shaderStorageBufferArrayDynamicIndexing; // Used to support APPLE_clip_distance shaderClipDistance // Used to support OES_sample_shading sampleRateShading; // Used to support depth clears through draw calls. depthClamp; // if (!vk::CommandBuffer::ExecutesInline()) inheritedQueries; // Used to support OES_sample_variables sampleRateShading; } Extension Features: VkPhysicalDeviceLineRasterizationFeaturesEXT VkPhysicalDeviceProvokingVertexFeaturesEXT VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT VkPhysicalDeviceTransformFeedbackFeaturesEXT VkPhysicalDeviceIndexTypeUint8FeaturesEXT VkPhysicalDeviceShaderFloat16Int8FeaturesKHR VkPhysicalDeviceSamplerYcbcrConversionFeatures 8. Appendix 8.1. Capability The recommended value for vulkan 1.1 features and limits report for HiVoyager V100 chip are listed in this chapter. 8.1.1. Physical Device Features Feature Supported on HiVoyager V100 robustBufferAccess yes fullDrawIndexUint32 yes imageCubeArray yes independentBlend yes geometryShader yes tessellationShader yes sampleRateShading yes dualSrcBlend no logicOp no multiDrawIndirect yes drawIndirectFirstInstance yes depthClamp yes depthBiasClamp yes fillModeNonSolid yes depthBounds yes wideLines yes largePoints yes alphaToOne yes multiViewport no samplerAnisotropy yes textureCompressionETC2 yes textureCompressionASTC_LDR yes textureCompressionBC no occlusionQueryPrecise yes pipelineStatisticsQuery no vertexPipelineStoresAndAtomics no fragmentStoresAndAtomics yes shaderTessellationAndGeometryPointSize yes shaderImageGatherExtended yes shaderStorageImageExtendedFormats yes shaderStorageImageMultisample no shaderStorageImageReadWithoutFormat yes shaderStorageImageWriteWithoutFormat yes shaderUniformBufferArrayDynamicIndexing yes shaderSampledImageArrayDynamicIndexing yes shaderStorageBufferArrayDynamicIndexing yes shaderStorageImageArrayDynamicIndexing yes shaderClipDistance yes shaderCullDistance yes shaderFloat64 no shaderInt64 no shaderInt16 yes shaderResourceResidency no shaderResourceMinLod no sparseBinding no sparseResidencyBuffer no sparseResidencyImage2D no sparseResidencyImage3D no sparseResidency2Samples no sparseResidency4Samples no sparseResidency8Samples no sparseResidency16Samples no sparseResidencyAliased no variableMultisampleRate no inheritedQueries no 8.1.2. Physical Device Limits Name Limit of HiVoyager V100 maxImageDimension1D 8192 maxImageDimension2D 8192[ 1 ] maxImageDimension3D 256 maxImageDimensionCube 8192 maxImageArrayLayers 256 maxTexelBufferElements 224 maxUniformBufferRange 16384 maxStorageBufferRange 227 maxPushConstantsSize 256 maxMemoryAllocationCount 232-1 maxSamplerAllocationCount 223 bufferImageGranularity 4096 sparseAddressSpaceSize 0 maxBoundDescriptorSets 4 maxPerStageDescriptorSamplers 16 maxPerStageDescriptorUniformBuffers 12 maxPerStageDescriptorStorageBuffers 8 maxPerStageDescriptorSampledImages 16 maxPerStageDescriptorStorageImages 8[ 2 ] maxPerStageDescriptorInputAttachments 4 maxPerStageResources 52 maxDescriptorSetSamplers 96 maxDescriptorSetUniformBuffers 72 maxDescriptorSetUniformBuffersDynamic 8 maxDescriptorSetStorageBuffers 48 maxDescriptorSetStorageBuffersDynamic 4 maxDescriptorSetSampledImages 96 maxDescriptorSetStorageImages 48 maxDescriptorSetInputAttachments 4 maxVertexInputAttributes 16 maxVertexInputBindings 16 maxVertexInputAttributeOffset 2047 maxVertexInputBindingStride 2048 maxVertexOutputComponents 128 maxTessellationGenerationLevel 64 maxTessellationPatchSize 32 maxTessellationControlPerVertexInputComponents 128 maxTessellationControlPerVertexOutputComponents 128 maxTessellationControlPerPatchOutputComponents 120 maxTessellationControlTotalOutputComponents 4096 maxTessellationEvaluationInputComponents 128 maxTessellationEvaluationOutputComponents 128 maxGeometryShaderInvocations 32 maxGeometryInputComponents 128 maxGeometryOutputComponents 128 maxGeometryOutputVertices 256 maxGeometryTotalOutputComponents 1024 maxFragmentInputComponents 128 maxFragmentOutputAttachments 4 maxFragmentDualSrcAttachments 1 maxFragmentCombinedOutputResources 20 maxComputeSharedMemorySize 32768 maxComputeWorkGroupCount[0] 65535 maxComputeWorkGroupCount[1] 65535 maxComputeWorkGroupCount[2] 65535 maxComputeWorkGroupInvocations 384 [v120, opencl] maxComputeWorkGroupInvocations 256 [v100, opencl] maxComputeWorkGroupInvocations 1024 [vulkan] maxComputeWorkGroupSize[0] 256 [opencl] maxComputeWorkGroupSize[0] 1024 [vulkan] maxComputeWorkGroupSize[1] 256 [v120, opencl] maxComputeWorkGroupSize[1] 32 [v100, opencl] maxComputeWorkGroupSize[1] 1024 [vulkan] maxComputeWorkGroupSize[2] 64 [v120, opencl] maxComputeWorkGroupSize[2] 2 [v100, opencl] maxComputeWorkGroupSize[2] 64 [vulkan] subPixelPrecisionBits 8 subTexelPrecisionBits 8 mipmapPrecisionBits 6 maxDrawIndexedIndexValue 0xFFFFFFFF maxDrawIndirectCount 232-1 maxSamplerLodBias 14 maxSamplerAnisotropy 16 maxViewports 1 maxViewportDimensions[0] 8192 maxViewportDimensions[1] 8192 viewportBoundsRange[0] -16384 viewportBoundsRange[1] 16383 viewportSubPixelBits 0 minMemoryMapAlignment 64 minTexelBufferOffsetAlignment 256 minUniformBufferOffsetAlignment 16 minStorageBufferOffsetAlignment 256 minTexelOffset -8 maxTexelOffset 7 minTexelGatherOffset -8 maxTexelGatherOffset 7 minInterpolationOffset -0.5 maxInterpolationOffset 0.4375 subPixelInterpolationOffsetBits 4 maxFramebufferWidth 8192 maxFramebufferHeight 8192 maxFramebufferLayers 256 framebufferColorSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 framebufferDepthSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 framebufferStencilSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 framebufferNoAttachmentsSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 maxColorAttachments 4 sampledImageColorSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 sampledImageIntegerSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 sampledImageDepthSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 sampledImageStencilSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 storageImageSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 maxSampleMaskWords 1 timestampComputeAndGraphics yes timestampPeriod 52.083333333 (1000/19.2) maxClipDistances 8 maxCullDistances 8 maxCombinedClipAndCullDistances 8 discreteQueuePriorities 2 pointSizeRange[0] 1.0 pointSizeRange[1] 1024.0 lineWidthRange[0] 1.0 lineWidthRange[1] 4095.9375 pointSizeGranularity 0.1 lineWidthGranularity 0.1 strictLines yes standardSampleLocations yes optimalBufferCopyOffsetAlignment 512 optimalBufferCopyRowPitchAlignment 512 nonCoherentAtomSize 64 maxUpdateAfterBindDescriptorsInAllPools 500000 maxMultiviewViewCount 6 Actually the hardware ability of maxImageDimension2D is 16384 . According to driver\u2019s requirement, maxImageDimension2D is set to 8192 . Do not support image load store for vertex pipeline in GLES; Do not support image store for vertex pipeline in Vulkan. 8.1.3. Physical Device Limits OpenGLES Name Limit of HiVoyager V100 SUBPIXEL_BITS 8 MAX_3D_TEXTURE_SIZE 256 MAX_TEXTURE_SIZE 8192 MAX_ARRAY_TEXTURE_LAYERS 256 MAX_TEXTURE_LOD_BIAS 14 MAX_CUBE_MAP_TEXTURE_SIZE 8192 MAX_RENDERBUFFER_SIZE 8192 ALIASED_LINE_WIDTH_RANGE[0] 1.0 ALIASED_LINE_WIDTH_RANGE[1] 4095.9375 ALIASED_POINT_SIZE_RANGE[0] 1.0 ALIASED_POINT_SIZE_RANGE[1] 1024.0 MULTISAMPLE_LINE_WIDTH_RANGE [1.0, 4095.9375] MULTISAMPLE_LINE_WIDTH_GRANULARITY 0.125 MAX_DRAW_BUFFERS 4 MAX_FRAMEBUFFER_WIDTH 8192 MAX_FRAMEBUFFER_HEIGHT 8192 MAX_FRAMEBUFFER_LAYERS 256 MAX_FRAMEBUFFER_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_COLOR_ATTACHMENTS 4 MIN_FRAGMENT_INTERPOLATION_OFFSET -0.5 MAX_FRAGMENT_INTERPOLATION_OFFSET 0.5 FRAGMENT_INTERPOLATION_OFFSET_BITS 4 MAX_VIEWPORT_DIMS[0] 8192 MAX_VIEWPORT_DIMS[1] 8192 MAX_SAMPLE_MASK_WORDS 1 MAX_COLOR_TEXTURE_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_DEPTH_TEXTURE_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_INTEGER_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_SERVER_WAIT_TIMEOUT 0 LAYER_PROVOKING_VERTEX FIRST_VERTEX_CONVENTION LAST_VERTEX_CONVENTION PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED FALSE MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 2047 MAX_VERTEX_ATTRIB_BINDINGS 16 MAX_VERTEX_ATTRIB_STRIDE 2048 MAX_ELEMENTS_INDICES MAX_ELEMENTS_VERTICES MAX_ELEMENT_INDEX 0xFFFFFFFF MAX_TEXTURE_BUFFER_SIZE 2^24 NUM_COMPRESSED_TEXTURE_FORMATS 49 COMPRESSED_TEXTURE_FORMATS NUM_PROGRAM_BINARY_FORMATS 0 PROGRAM_BINARY_FORMATS NUM_SHADER_BINARY_FORMATS 0 SHADER_BINARY_FORMATS SHADER_COMPILER TEXTURE_BUFFER_OFFSET_ALIGNMENT 256 MAX_TEXTURE_MAX_ANISOTROPY_EXT 16 MAX_VERTEX_ATTRIBS 16 MAX_VERTEX_UNIFORM_COMPONENTS 1024 MAX_VERTEX_UNIFORM_VECTORS 256 MAX_VERTEX_UNIFORM_BLOCKS 12 MAX_VERTEX_OUTPUT_COMPONENTS 128 MAX_VERTEX_TEXTURE_IMAGE_UNITS 16 MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0 MAX_VERTEX_ATOMIC_COUNTERS 0 MAX_VERTEX_SHADER_STORAGE_BLOCKS 0 MAX_TESS_GEN_LEVEL 64 MAX_PATCH_VERTICES 32 MAX_TESS_CONTROL_UNIFORM_COMPONENTS 1024 MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 16 MAX_TESS_CONTROL_OUTPUT_COMPONENTS 128 MAX_TESS_PATCH_COMPONENTS 120 MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 4096 MAX_TESS_CONTROL_INPUT_COMPONENTS 128 MAX_TESS_CONTROL_UNIFORM_BLOCKS 12 MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0 MAX_TESS_CONTROL_ATOMIC_COUNTERS 0 MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0 MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 1024 MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 16 MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 128 MAX_TESS_EVALUATION_INPUT_COMPONENTS 128 MAX_TESS_EVALUATION_UNIFORM_BLOCKS 12 MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0 MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0 MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0 MAX_GEOMETRY_UNIFORM_COMPONENTS 1024 MAX_GEOMETRY_UNIFORM_BLOCKS 12 MAX_GEOMETRY_INPUT_COMPONENTS 128 MAX_GEOMETRY_OUTPUT_COMPONENTS 128 MAX_GEOMETRY_OUTPUT_VERTICES 256 MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 1024 MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 16 MAX_GEOMETRY_SHADER_INVOCATIONS 32 MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0 MAX_GEOMETRY_ATOMIC_COUNTERS 0 MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0 MAX_FRAGMENT_UNIFORM_COMPONENTS 1024 MAX_FRAGMENT_UNIFORM_VECTORS 256 MAX_FRAGMENT_UNIFORM_BLOCKS 12 MAX_FRAGMENT_INPUT_COMPONENTS 128 MAX_TEXTURE_IMAGE_UNITS 16 MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 1 MAX_FRAGMENT_ATOMIC_COUNTERS 8 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 8 MIN_PROGRAM_TEXTURE_GATHER_OFFSET -8 MAX_PROGRAM_TEXTURE_GATHER_OFFSET 7 MIN_PROGRAM_TEXEL_OFFSET -8 MAX_PROGRAM_TEXEL_OFFSET 7 MAX_COMPUTE_WORK_GROUP_COUNT[0] 65535 MAX_COMPUTE_WORK_GROUP_COUNT[1] 65535 MAX_COMPUTE_WORK_GROUP_COUNT[2] 65535 MAX_COMPUTE_WORK_GROUP_SIZE[0] 1024 MAX_COMPUTE_WORK_GROUP_SIZE[1] 1024 MAX_COMPUTE_WORK_GROUP_SIZE[2] 64 MAX_COMPUTE_WORK_GROUP_INVOCATIONS 1024 MAX_COMPUTE_UNIFORM_BLOCKS 12 MAX_COMPUTE_TEXTURE_IMAGE_UNITS 16 MAX_COMPUTE_SHARED_MEMORY_SIZE 32768 MAX_COMPUTE_UNIFORM_COMPONENTS 1024 MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 1 MAX_COMPUTE_ATOMIC_COUNTERS 8 MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 50176 MAX_COMPUTE_SHADER_STORAGE_BLOCKS 8 MAX_UNIFORM_BUFFER_BINDINGS 72 MAX_UNIFORM_BLOCK_SIZE 16384 UNIFORM_BUFFER_OFFSET_ALIGNMENT 16 MAX_COMBINED_UNIFORM_BLOCKS 72 MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 50176 MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 50176 MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 50176 MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 50176 MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 50176 MAX_VARYING_COMPONENTS 124 MAX_VARYING_VECTORS 31 MAX_COMBINED_TEXTURE_IMAGE_UNITS 96 MAX_COMBINED_SHADER_OUTPUT_RESOURCES 20 MAX_UNIFORM_LOCATIONS 1024 MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 1 MAX_ATOMIC_COUNTER_BUFFER_SIZE 32 MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 1 MAX_COMBINED_ATOMIC_COUNTERS 8 MAX_IMAGE_UNITS 8 MAX_VERTEX_IMAGE_UNIFORMS 0 MAX_TESS_CONTROL_IMAGE_UNIFORMS 0 MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0 MAX_GEOMETRY_IMAGE_UNIFORMS 0 MAX_FRAGMENT_IMAGE_UNIFORMS 8 MAX_COMPUTE_IMAGE_UNIFORMS 8 MAX_COMBINED_IMAGE_UNIFORMS 8 MAX_SHADER_STORAGE_BUFFER_BINDINGS 4 MAX_SHADER_STORAGE_BLOCK_SIZE 2^27 MAX_COMBINED_SHADER_STORAGE_BLOCKS 8 SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 256 MAX_LABEL_LENGTH 256 MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 64 MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 4 MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 4 MAX_SAMPLES 4 MAX_SERVER_WAIT_TIMEOUT 0 MAX_VIEWS_OVR 6 8.2. Extension OpenGL ES, EGL and Vulkan extension for HiVoyager V100 chip are listed in this chapter. 8.2.1. OpenGL ES Extension OpenGL ES Extension GL_EXT_multi_draw_indirect GL_EXT_debug_marker GL_ARM_rgba8 GL_ARM_mali_shader_binary GL_OES_depth24 GL_OES_depth_texture GL_OES_depth_texture_cube_map GL_OES_packed_depth_stencil GL_OES_rgb8_rgba8 GL_EXT_read_format_bgra GL_OES_compressed_paletted_texture GL_OES_compressed_ETC1_RGB8_texture GL_OES_standard_derivatives GL_OES_EGL_image GL_OES_EGL_image_external GL_OES_EGL_image_external_essl3 GL_OES_EGL_sync GL_OES_texture_npot GL_OES_vertex_half_float GL_OES_required_internalformat GL_OES_vertex_array_object GL_OES_mapbuffer GL_EXT_texture_format_BGRA8888 GL_EXT_texture_rg GL_EXT_texture_type_2_10_10_10_REV GL_OES_fbo_render_mipmap GL_OES_element_index_uint GL_EXT_shadow_samplers GL_KHR_texture_compression_astc_ldr GL_KHR_debug GL_EXT_occlusion_query_boolean GL_EXT_disjoint_timer_query GL_EXT_blend_minmax GL_EXT_discard_framebuffer GL_OES_get_program_binary GL_OES_texture_3D GL_EXT_texture_storage GL_EXT_multisampled_render_to_texture GL_OES_surfaceless_context GL_OES_texture_stencil8 GL_EXT_shader_pixel_local_storage GL_ARM_shader_framebuffer_fetch GL_ARM_shader_framebuffer_fetch_depth_stencil GL_EXT_shader_framebuffer_fetch_non_coherent GL_ARM_mali_program_binary GL_EXT_sRGB GL_EXT_sRGB_write_control GL_EXT_texture_sRGB_decode GL_EXT_texture_sRGB_R8 GL_EXT_texture_sRGB_RG8 GL_KHR_blend_equation_advanced GL_KHR_blend_equation_advanced_coherent GL_OES_texture_storage_multisample_2d_array GL_OES_shader_image_atomic GL_EXT_robustness GL_EXT_draw_buffers_indexed GL_OES_draw_buffers_indexed GL_EXT_texture_border_clamp GL_OES_texture_border_clamp GL_EXT_texture_cube_map_array GL_OES_texture_cube_map_array GL_OES_sample_variables GL_OES_sample_shading GL_OES_shader_multisample_interpolation GL_EXT_shader_io_blocks GL_OES_shader_io_blocks GL_EXT_tessellation_shader GL_OES_tessellation_shader GL_EXT_primitive_bounding_box GL_OES_primitive_bounding_box GL_EXT_geometry_shader GL_OES_geometry_shader GL_ANDROID_extension_pack_es31a GL_EXT_gpu_shader5 GL_OES_gpu_shader5 GL_EXT_texture_buffer GL_OES_texture_buffer GL_EXT_copy_image GL_OES_copy_image GL_EXT_shader_non_constant_global_initializers GL_EXT_color_buffer_half_float GL_EXT_color_buffer_float GL_EXT_YUV_target GL_OVR_multiview GL_OVR_multiview2 GL_OVR_multiview_multisampled_render_to_texture GL_KHR_robustness GL_KHR_robust_buffer_access_behavior GL_EXT_draw_elements_base_vertex GL_OES_draw_elements_base_vertex GL_EXT_protected_textures GL_EXT_geometry_point_size GL_OES_geometry_point_size GL_EXT_tessellation_point_size GL_OES_tessellation_point_size GL_OES_draw_texture 8.2.2. EGL Extension EGL extensions EGL_KHR_get_all_proc_addresses EGL_ANDROID_presentation_time EGL_KHR_swap_buffes_witn_damage EGL_ANDROID_get_native_client_buffer EGL_ANDROID_front_buffer_auto_refresh EGL_ANDROID_get_frame_timestamps EGL_KHR_image EGL_KHR_image_base EGL_KHR_gl_colorspace EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_gl_renderbuffer_image EGL_KHR_fence_sync EGL_KHR_create_context EGL_KHR_config_attribs EGL_KHR_surfaceless_context EGL_EXT_create_context_robustness EGL_ANDROID_image_native_buffer EGL_KHR_wait_sync EGL_ANDROID_recordable EGL_KHR_partial_update EGL_KHR_mutable_render_buffer EGL_EXT_protected_content EGL_IMG_context_priority 8.2.3. Vulkan Extension Vulkan Extension storageBuffer8BitAccess[ 1 ] m[ 2 ] VK_KHR_create_renderpass2 [ 3 ] M VK_KHR_depth_stencil_resolve M supportedDepthResolveModes m supportedStencilResolveModes m VK_KHR_driver_properties M VK_KHR_image_format_list M VK_KHR_imageless_framebuffer M VK_KHR_separate_depth_stencil_layouts M VK_KHR_spirv_1_4 M VK_KHR_timeline_semaphore M VK_KHR_uniform_buffer_standard_layout M uniformBufferStandardLayout M VK_KHR_vulkan_memory_model M vulkanMemoryModel M VK_EXT_buffer_device_address M shaderUniformTexelBufferArrayDynamicIndexing m shaderStorageTexelBufferArrayDynamicIndexing m shaderSampledImageArrayNonUniformIndexing m shaderStorageBufferArrayNonUniformIndexing m shaderUniformTexelBufferArrayNonUniformIndexing m descriptorBindingSampledImageUpdateAfterBind m descriptorBindingStorageBufferUpdateAfterBind m descriptorBindingUniformTexelBufferUpdateAfterBind m descriptorBindingStorageTexelBufferUpdateAfterBind m descriptorBindingUpdateUnusedWhilePending m descriptorBindingPartiallyBound m descriptorBindingVariableDescriptorCount m VK_EXT_host_query_reset M VK_EXT_separate_stencil_usage M VK_KHR_16bit_storage M VK_KHR_bind_memory2 M VK_KHR_dedicated_allocation M VK_KHR_descriptor_update_template M VK_KHR_device_group M VK_KHR_device_group_creation M VK_KHR_external_fence M VK_KHR_external_fence_capabilities M VK_KHR_external_memory M VK_KHR_external_memory_capabilities M VK_KHR_external_semaphore M VK_KHR_external_semaphore_capabilities M VK_KHR_get_memory_requirements2 M VK_KHR_get_physical_device_properties2 M VK_KHR_maintenance1 M VK_KHR_maintenance2 M VK_KHR_maintenance3 M VK_KHR_multiview M multiview m VK_KHR_relaxed_block_layout M VK_KHR_sampler_ycbcr_conversion M VK_KHR_shader_draw_parameters M VK_KHR_storage_buffer_storage_class M VK_KHR_variable_pointers M subgroup M protected memory M instance version enumeration M VkPhysicalDeviceVulkan12Features M imagelessFramebuffer m uniformBufferStandardLayout m separateDepthStencilLayouts m hostQueryReset m timelineSemaphore m subgroupBroadcastDynamicId m VkPhysicalDeviceVulkan11Features M storageBuffer16BitAccess m multiview m VkPhysicalDeviceFeatures M robustBufferAccess M VkPhysicalDeviceSparseProperties O[ 4 ] VkPhysicalDeviceLimits M Linear Formats [ 5 ] M Optimal Formats [ 5 ] M Buffer Formats [ 5 ] M Lowercase character means this is subfunction of the above vulkan extension. M/m means current extension MUST support. Capital character means this is a main vulkan extension. O means current extension OPTIONALLY support. Details of Linear Formats, Optimal Formats and Buffer Formats are shown in Format_constraint_table_1 and Format_constraint_table_2 .","title":"\u603b\u89c8"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#_1","text":"","title":"\u603b\u89c8"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vk-extensions","text":"","title":"Vk Extensions"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#angle-vk-ext-es","text":"Vk Extensions in ANGLE \u5df2\u652f\u6301 vk\u5185\u90e8 es\u6838\u5fc3 es Ext EGL \u5176\u4ed6 Instance Level: WSI: VK_KHR_ANDROID_SURFACE / VK_KHR_WIN32_SURFACE M* \u2714 VK_KHR_SURFACE M* \u2714 VK_EXT_DEBUG_UTILS / VK_EXT_DEBUG_REPORT ?? \u2714 VK_EXT_SWAPCHAIN_COLOR_SPACE ?? \u2714 VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2 \u2714 \u2714 Device Level : VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER \u2714 VK_EXT_QUEUE_FAMILY_FOREIGN \u2714 VK_EXT_DEPTH_CLIP_ENABLE Nvidia VK_EXT_EXTERNAL_MEMORY_HOST MAC VK_EXT_INDEX_TYPE_UINT8 \u2714 VK_EXT_LINE_RASTERIZATION \u2714 VK_EXT_PROVOKING_VERTEX ANGLE EXT VK_EXT_SHADER_STENCIL_EXPORT \u2714 VK_EXT_TRANSFORM_FEEDBACK \u2714 VK_EXT_VERTEX_ATTRIBUTE_DIVISOR \u2714 VK_FUCHSIA_EXTERNAL_MEMORY FUCHSIA VK_FUCHSIA_EXTERNAL_SEMAPHORE FUCHSIA VK_GOOGLE_SAMPLER_FILTERING_PRECISION ANGLE EXT VK_GGP_FRAME_TOKEN Stadia VK_KHR_BIND_MEMORY_2 \u2714 \u2714 VK_KHR_CREATE_RENDERPASS_2 \u2714 \u2714 VK_KHR_DEPTH_STENCIL_RESOLVE \u2714 \u2714 VK_KHR_EXTERNAL_FENCE_CAPABILITIES \u2714 \u2714 VK_KHR_EXTERNAL_FENCE_FD U VK_KHR_EXTERNAL_MEMORY \u2714 \u2714 VK_KHR_EXTERNAL_MEMORY_FD U VK_KHR_EXTERNAL_SEMAPHORE \u2714 \u2714 VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES \u2714 \u2714 VK_KHR_EXTERNAL_SEMAPHORE_FD U VK_KHR_GET_MEMORY_REQUIREMENTS_2 \u2714 \u2714 VK_KHR_IMAGE_FORMAT_LIST \u2714 AMD VK_KHR_INCREMENTAL_PRESENT U VK_KHR_MAINTENANCE1 \u2714 \u2714 VK_KHR_SAMPLER_YCBCR_CONVERSION \u2714 \u2714 VK_KHR_SHADER_FLOAT16_INT8 \u2714 VK_KHR_SWAPCHAIN \u2714 VK_QCOM_render_pass_store_ops \u2714 *M \u8868\u793a\u4e3aVulkan\u5fc5\u987b\u6269\u5c55, \u4f46 v100 \u6587\u6863\u6ca1\u6709\u6807\u51fa. \u56e0\u6b64\u5bf9\u4e8e\u4e0b\u9762\u7684 VK_EXT_SWAPCHAIN_COLOR_SPACE \u662f\u5426\u5df2\u652f\u6301\u8868\u793a\u5b58\u7591. \u6709\u5176\u4ed6\u6587\u6863\u663e\u793av100,v200\u5747\u652f\u6301. *U \u8868\u793a\u975e\u5fc5\u987b: \u5176\u5bf9\u5e94\u7684 GLES / EGL Extension \u4e0d\u5728 v100 \u7684\u652f\u6301\u5217\u8868\u4e2d.","title":"ANGLE \u4e2d vk Ext \u5bf9\u5e94es\u529f\u80fd"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vk-extensions_1","text":"\u5c06\u4e0a\u8868\u4e2d\u7684\u6570\u636e, \u5220\u53bb\"'\u5df2\u652f\u6301\u7684\", \"vk\u5185\u90e8\u4f7f\u7528\", \u548c\"\u5176\u4ed6\u5e73\u53f0\"\u7684\u6269\u5c55, \u5269\u4e0b\u7684\u5373 v100 \u5c1a\u672a\u652f\u6301\u7684\u6269\u5c55\u9700\u6c42\u8868\u5982\u4e0b: Vk Extensions \u6240\u9700 Feature \u5206\u7c7b \u5fc5\u9700 \u652f\u6301 es \u529f\u80fd VK_EXT_SWAPCHAIN_COLOR_SPACE -- EGL \u2714 EGL_KHR_gl_colorspace VK_ANDROID_EXTERNAL_MEMORY _ANDROID_HARDWARE_BUFFER VK_EXT_QUEUE_FAMILY_FOREIGN -- EGL \u2714 EGL_ANDROID_image_native_buffer VK_EXT_INDEX_TYPE_UINT8 indexTypeUint8 es2.0 \u5339\u914d Draw \u7684 indexType \u53c2\u6570, \u4ee5\u4f18\u5316\u6027\u80fd VK_EXT_LINE_RASTERIZATION bresenhamLines es2.0 \u7ba1\u7ebf\u7b97\u6cd5\u652f\u6301 VK_EXT_SHADER_STENCIL_EXPORT -- es2.0 VK_EXT_TRANSFORM_FEEDBACK transformFeedback es3.1 \u2714 \u5b9e\u73b0 Transform Feedback \u76f8\u5173 API VK_EXT_VERTEX_ATTRIBUTE_DIVISOR vertexAttributeInstanceRateDivisor es2.0 VK_KHR_SHADER_FLOAT16_INT8 shaderFloat16 es2.0 VK_KHR_EXTERNAL_FENCE_FD -- EGL U EGL_ANDROID_native_fence VK_KHR_EXTERNAL_MEMORY_FD -- EXT U GL_EXT_memory_object_fd VK_KHR_EXTERNAL_SEMAPHORE_FD -- EXT U GL_EXT_semaphore_fd VK_KHR_INCREMENTAL_PRESENT -- EGL U EGL_KHR_swap_buffers_with_damage *U \u8868\u793a\u975e\u5fc5\u987b: \u5176\u5bf9\u5e94\u7684 GLES / EGL Extension \u4e0d\u5728 v100 \u7684\u652f\u6301\u5217\u8868\u4e2d.","title":"\u589e\u52a0 Vk Extensions \u7684\u9700\u6c42"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vk-features","text":"\u5bf9\u6bd4 v100 \u652f\u6301\u60c5\u51b5: \u4ec5 inheritedQueries \u4e0d\u652f\u6301 \u4e14\u5fc5\u9700. \u6b64\u5916\u867d\u7136 vertexPipelineStoresAndAtomics \u4e0d\u652f\u6301, \u4f46 ANGLE \u63a8\u8350\u7528 VK_EXT_TRANSFORM_FEEDBACK \u53d6\u4ee3. \u5176\u4f59Features \u5747\u5728 v100 \u4e2d\u652f\u6301: Vk Features in ANGLE \u5bf9\u5e94 GLES Note inheritedQueries es 3.0, Query vertexPipelineStoresAndAtomics transform feedback \u6a21\u62df\u5b9e\u73b0 transform feedback, \u5e94\u7528 VK_EXT_TRANSFORM_FEEDBACK \u4ee3\u66ff imageCubeArray cubemap array \u4ec5\u5728\u975e SwiftShader \u548c\u975e Qualcomm \u4e0b\u542f\u7528 independentBlend fbo \u591a\u4e2a attachments robustBufferAccess \u8bbf\u95ee robust buffer samplerAnisotropy Anisotropic filtering wideLines wide lines fragmentStoresAndAtomics storage buffers \u5b9e\u73b0 fragment shader \u4e2d storage buffers \u548c images geometryShader geometry shaders shaderImageGatherExtended EXT_gpu_shader5 shaderUniformBufferArrayDynamicIndexing EXT_gpu_shader5 shaderSampledImageArrayDynamicIndexing EXT_gpu_shader5 \u652f\u6301 EXT_gpu_shader5 \u5e76\u6a21\u62df\u5b9e\u73b0 sampler array shaderStorageBufferArrayDynamicIndexing \u6a21\u62df\u5b9e\u73b0 atomic counter shaderClipDistance APPLE_clip_distance sampleRateShading OES_sample_shading depthClamp OES_sample_shading support depth clears through draw calls. sampleRateShading OES_sample_variables *\u7c97\u4f53 Features\u4e3a\u6838\u5fc3API\u6240\u5fc5\u9700\u7279\u6027.","title":"Vk Features"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#limits","text":"\u672c\u8868\u5217\u51fa ANGLE \u4e2d\u8bb0\u4e86\u6570\u5b57\u9700\u6c42\u7684 Limits. [ ] \u5bf9\u5e94 v100 GLES Limits * \u662f\u6307 ANGLE \u5728\u6a21\u62df\u5b9e\u73b0 GLES \u65f6, \u9700\u8981\u5360\u7528\u90e8\u5206\u8d44\u6e90, \u5bfc\u81f4 v100 \u4e2d\u6807\u8bb0\u7684 GLES Limits \u4e0d\u518d\u80fd\u6ee1\u8db3. \u672c\u8868\u5047\u8bbe VK_EXT_TRANSFORM_FEEDBACK \u4e0e VK_EXT_LINE_RASTERIZATION \u5df2\u6ee1\u8db3. \u5426\u5219\u4e00\u4e9b\u6240\u9700\u503c\u4f1a\u589e\u52a0, \u4f46\u4e0d\u4f1a\u6539\u53d8\u5f53\u524d\u6ee1\u8db3\u60c5\u51b5. Vk Limits in ANGLE \u6240\u9700\u503c Limits in v100 v100 \u5df2\u6ee1\u8db3 \u5bf9\u5e94 GLES EXT / Cap maxPerStageDescriptorStorageBuffers >=12 / 16 8 \u4e0d\u6ee1\u8db3 es3.0, 12 \u4e3a\u6ee1\u8db3 ANGLE es3.0 16 \u4e3a\u6ee1\u8db3 v100 GLES Limits maxPerStageDescriptorUniformBuffers >=14 12 \u4e0d\u6ee1\u8db3 v100 GLES Limits* maxDescriptorSetUniformBuffers >=76 72 \u4e0d\u6ee1\u8db3 v100 GLES Limits* maxVertexOutputComponents \u4e0e maxFragmentInputComponents >=136 128 \u4e0d\u6ee1\u8db3 v100 GLES Limits* standardSampleLocations true true textureStorageMultisample2DArrayOES maxSamplerAnisotropy > 1.0f; 16 textureFilterAnisotropic maxTextureAnisotropy maxInterpolationOffset >= 0.5; 0.4375 \u4e0d\u6ee1\u8db3 OES_shader_multisample_interpolation maxVertexInputAttributeOffset >=2047 2047 es3.1","title":"Limits"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#angle-vk-extensions","text":"","title":"ANGLE : Vk Extensions"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles-core","text":"","title":"GLES Core"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vk_ext_transform_feedback","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es3.0 APIs \u5bf9\u5e94\u529f\u80fd Transform Feedback \u5fc5\u8981\u6027 \u5b9e\u73b0 Transform Feedback \u5fc5\u9700 \u6240\u9700 FeaturesEXT transformFeedback angle doc: TransformFeedbackViaExtension angle issue: http://anglebug.com/3206 ANGLE\u4f7f\u7528Vulkan\u4e2d\u7684vertexPipelineStoresAndAtomics\u529f\u80fd\u6a21\u62df\u53d8\u6362\u53cd\u9988\u3002\u4f46\u662f\u67d0\u4e9b Driver \u4e0d\u652f\u6301\u6b64\u7279\u6027\u3002\u540c\u6837\uff0c\u5728GLES 3.2\u4e2d\uff0c\u4eff\u771f\u53d8\u5f97\u66f4\u52a0\u56f0\u96be\u3002\u56e0\u6b64\uff0c ANGLE\u5fc5\u987b\u652f\u6301\u4f7f\u7528 VK_EXT_transform_feedback \u6269\u5c55 \u3002\u5e76\u4e14\u5f53\u4f7f\u7528\u6b64\u6269\u5c55\u65f6\uff0c\u6211\u4eec\u4e5f\u671f\u671b\u6027\u80fd\u63d0\u9ad8\u3002","title":"VK_EXT_TRANSFORM_FEEDBACK"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#counterbuffer","text":"Vulkan\u6269\u5c55\u6ca1\u6709\u4e3a glPauseTransformFeedback / glEndTransformFeedback \u5206\u522b\u63d0\u4f9b\u5355\u72ec\u7684API \u3002 \u76f8\u53cd\uff0cVulkan\u5728 vkCmdBeginTransformFeedbackEXT / vkCmdEndTransformFeedbackEXT \u4e2d \u5f15\u5165\u4e86\u8ba1\u6570\u5668\u7f13\u51b2\u533a\u4f5c\u4e3aAPI\u53c2\u6570\u3002 \u8981\u6682\u505cFB\uff0c\u8c03\u7528 vkCmdEndTransformFeedbackEXT \u5e76\u5728 pCounterBuffers \u6570\u7ec4\u4e2d\u63d0\u4f9b\u6709\u6548\u7684\u7f13\u51b2\u533a\u53e5\u67c4, \u5728 pCounterBufferOffsets \u6570\u7ec4\u4e2d\u63d0\u4f9b\u6709\u6548\u7684\u504f\u79fb\u91cf\uff0c\u4ee5\u5b9e\u73b0\u4fdd\u5b58\u6062\u590d\u70b9\u7684\u5b9e\u73b0\u3002 \u8981\u6062\u590dFB\uff0c\u6211\u4eec\u8c03\u7528 vkCmdBeginTransformFeedbackEXT \u5e76\u4f20\u5165\u5148\u524d\u7684 pCounterBuffers \u548c pCounterBufferOffsets \u503c\u3002 \u6682\u505c\u548c\u6062\u590d\u4e4b\u95f4, \u9700\u8981\u6709\u4e00\u4e2a\u5b58\u50a8\u963b\u6321 (memory barrier), \u7528\u4e8e\u4e0e\u8bbf\u95ee\u6e90\u5230\u8bbf\u95ee\u6a21\u677f\u7684\u8ba1\u6570\u5668\u7f13\u51b2\u5668. \u8bbf\u95ee\u6e90: Pipeline Stage \u7684 VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT \u4e2d\u7684 VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT \u8bbf\u95ee\u76ee\u6807 Pipeline Stage \u7684 VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT \u4e2d\u7684 VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT","title":"\u4f7f\u7528CounterBuffer\u5b9e\u73b0\u6682\u505c/\u6062\u590d"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gltransformfeedbackvaryings","text":"Vulkan\u4e2d\u6ca1\u6709 glTransformFeedbackVaryings \u7684\u7b49\u6548\u51fd\u6570\u3002 Vulkan\u89c4\u8303\u6307\u51fa\uff0c\u5fc5\u987b\u4f7f\u7528XFB\u6267\u884c\u6a21\u5f0f\u58f0\u660e\u6700\u540e\u4e00\u4e2a\u9876\u70b9\u5904\u7406\u9636\u6bb5\u7740\u8272\u5668\u3002 SPIR-V \u8f6c\u6362\u5668\u8d1f\u8d23\u6dfb\u52a0\u6b64\u6267\u884c\u6a21\u5f0f\uff0c\u5e76\u4fee\u9970\u9700\u8981\u6355\u83b7\u7684\u53d8\u91cf\u3002 ANGLE \u4e3a Vulkan \u5750\u6807\u7cfb\u4fee\u6539\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684 gl_position.z \u3002\u56e0\u6b64\uff0c\u5982\u679c\u6211\u4eec\u5728XFB\u7f13\u51b2\u533a\u4e2d\u6355\u83b7\u201c gl_position\u201d\u7684\u503c\uff0c\u5219\u6355\u83b7\u7684\u503c\u5c06\u662f\u9519\u8bef\u7684\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u58f0\u660e\u4e00\u4e2a\u5185\u90e8 position \u53d8\u5316\u91cf\uff0c\u7136\u540e\u590d\u5236'gl_position'\u7684\u503c\u3002\u6211\u4eec\u6355\u83b7\u4e86\u53d8\u6362\u53cd\u9988\u64cd\u4f5c(transform feedback)\u671f\u95f4\u5185\u90e8 position \u53d8\u5316\u91cf\u7684\u53d8\u5316\u3002\u4e3a\u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u4f1a\u5bf9\u6bcf\u4e2a\u6355\u83b7\u7684\u53d8\u5316\u90fd\u8fdb\u884c\u6b64\u64cd\u4f5c, \u800c\u6ca1\u6709\u7528 gl_PerVertex \u76f4\u63a5\u5728SPIR-V\u4e2d\u88c5\u9970\u7ed3\u6784\u4f53\u3002","title":"glTransformFeedbackVaryings \u7684\u5b9e\u73b0"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#transform-feedback-queries","text":"GLES \u6709\u4e24\u4e2a\u4e0d\u540c\u7684\u67e5\u8be2\uff1a GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN \u548c GL_PRIMITIVES_GENERATED \u3002 \u4f46\u662f\u5728Vulkan\u4e2d\uff0c\u8fd9\u4e9b\u662f\u7531\u6765\u81ea VK_EXT_transform_feedback \u7684\u5355\u4e2a\u67e5\u8be2\u63d0\u4f9b\u7684\u3002 \u6b64\u5916\uff0cVulkan\u8981\u6c42\u4e00\u6b21\u53ea\u80fd\u6fc0\u6d3b\u67d0\u7c7b\u578b\u7684\u4e00\u4e2a\u67e5\u8be2\u3002 \u5f53\u4e24\u4e2a Transform Feedback \u67e5\u8be2\u90fd\u5904\u4e8e\u6d3b\u52a8\u72b6\u6001\u65f6\uff0c\u8fd9\u5c06\u8feb\u4f7fANGLE\u4f7f\u4e24\u4e2aGL\u67e5\u8be2\u5171\u4eab\u5176Vulkan\u67e5\u8be2\u3002","title":"Transform Feedback Queries"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles-api","text":"","title":"\u5bf9\u5e94 GLES API"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#transform-feedback","text":"glBeginTransformFeedback/ glPauseTransformFeedback /glResumeTransformFeedback/ glEndTransformFeedback / glTransformFeedbackVaryings Buffer glBufferData / glBufferStorage / glDeleteBuffers glsl glDispatchComputeIndirect / glDispatchCompute / glLinkProgram / glCreateShaderProgramv Query glBeginQuery / glEndQuery","title":"Transform Feedback"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vulkan","text":"Features : \u4ec5\u9700\u542f\u7528 transformFeedback // Provided by VK_EXT_transform_feedback typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 transformFeedback; VkBool32 geometryStreams; } VkPhysicalDeviceTransformFeedbackFeaturesEXT; \u6269\u5c55\u547d\u4ee4: vkCmdBeginQueryIndexedEXT vkCmdBeginTransformFeedbackEXT vkCmdBindTransformFeedbackBuffersEXT vkCmdDrawIndirectByteCountEXT vkCmdEndQueryIndexedEXT vkCmdEndTransformFeedbackEXT","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#angle-gles-on-vk","text":"API\u8f83\u591a, \u5f85\u5206\u6790 ANGLE \u4e2d, \u6b64 EXT \u4e0e VkPhysicalDeviceFeatures.vertexPipelineStoresAndAtomics \u4e8c\u8005\u81f3\u5c11\u6709\u4e00, \u5426\u5219\u4e0d\u652f\u6301 3.0 \u7684 transform feedback, \u964d\u4f4e\u7248\u672c supportsTransformFeedbackExtension http://anglebug.com/3206 Features.vertexPipelineStoresAndAtomics: emulateTransformFeedback http://anglebug.com/3205 Vulkan Description: This extension adds transform feedback to the Vulkan API by exposing the SPIR-V TransformFeedback and GeometryStreams capabilities to capture vertex, tessellation or geometry shader outputs to one or more buffers. It adds API functionality to bind transform feedback buffers to capture the primitives emitted by the graphics pipeline from SPIR-V outputs decorated for transform feedback. The transform feedback capture can be paused and resumed by way of storing and retrieving a byte counter. The captured data can be drawn again where the vertex count is derived from the byte counter without CPU intervention. If the implementation is capable, a vertex stream other than zero can be rasterized. All these features are designed to match the full capabilities of OpenGL core transform feedback functionality and beyond. Many of the features are optional to allow base OpenGL ES GPUs to also implement this extension. The primary purpose of the functionality exposed by this extension is to support translation layers from other 3D APIs. This functionality is not considered forward looking, and is not expected to be promoted to a KHR extension or to core Vulkan. Unless this is needed for translation, it is recommended that developers use alternative techniques of using the GPU to process and capture vertex data. supportsTransformFeedbackExtension BufferVk.cpp setExternalBufferData & setDataWithMemoryType BufferVk::setDataWithUsageFlags Buffer::bufferDataImpl Buffer::bufferData glBufferData Buffer::bufferStorage glBufferStorage Buffer::bufferExternalDataImpl glBufferStorageExternalEXT ContextVk.cpp ContextVk() mGraphicsDirtyBitHandlers[DIRTY_BIT_TRANSFORM_FEEDBACK_BUFFERS] = &ContextVk::handleDirtyGraphicsTransformFeedbackBuffersExtension; mGraphicsDirtyBitHandlers[DIRTY_BIT_TRANSFORM_FEEDBACK_STATE] = &ContextVk::handleDirtyGraphicsTransformFeedbackState; mGraphicsDirtyBitHandlers[DIRTY_BIT_TRANSFORM_FEEDBACK_RESUME] = &ContextVk::handleDirtyGraphicsTransformFeedbackResume; initialize mQueryPools[gl::QueryType::TransformFeedbackPrimitivesWritten].init( this, VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT, vk::kDefaultTransformFeedbackQueryPoolSize) onMakeCurrent mGraphicsDirtyBits.set(DIRTY_BIT_TRANSFORM_FEEDBACK_RESUME); mGraphicsDirtyBits.set(DIRTY_BIT_TRANSFORM_FEEDBACK_STATE); mGraphicsDirtyBits.set(DIRTY_BIT_TRANSFORM_FEEDBACK_BUFFERS); invalidateCurrentTransformFeedbackBuffers ContextVk: bindIndexedBuffer TransformFeedbackVk: bindIndexedBuffer TransformFeedbackVk: detachBuffer State: detachBuffer Context: deleteBuffer glDeleteBuffers onTransformFeedbackStateChanged onBeginTransformFeedback TransformFeedbackVk: begin TransformFeedback: begin Context: beginTransformFeedback glBeginTransformFeedback TransformFeedbackVk: resume TransformFeedback: resume Context: resumeTransformFeedback glResumeTransformFeedback onEndTransformFeedback TransformFeedbackVk: end TransformFeedback: end Context: endTransformFeedback glEndTransformFeedback onPauseTransformFeedback TransformFeedback: Pause Context: PauseTransformFeedback glPauseTransformFeedback resumeTransformFeedbackIfStarted handleDirtyGraphicsPipeline flushCommandsAndEndRenderPass GlslangWrapperVk.cpp GlslangAssignLocations \u200b rx::ProgramPipelineVk::link \u200b gl::ProgramPipeline::link \u200b gl::Context::prepareForDispatch \u200b gl::Context::dispatchComputeIndirect \u200b gl::DispatchComputeIndirect \u200b gl::Context::dispatchCompute \u200b gl::DispatchCompute \u200b rx::GlslangGetShaderSource \u200b rx::GlslangWrapperVk::GetShaderSource \u200b rx::ProgramVk::link \u200b gl::Program::linkImpl \u200b gl::Program::link \u200b gl::Context::linkProgram \u200b gl::LinkProgram \u200b angle::FrameCapture::ReplayCall \u200b gl::Context::createShaderProgramv \u200b glCreateShaderProgramv QueryVk.cpp QueryVk: begin Context: beginQuery QueryVk: end Context: endQuery TransformFeedback Mode vk_cache_utils.cpp GraphicsPipelineDesc::initializePipeline() VkPipelineRasterizationStateStreamCreateInfoEXT rasterStreamState = {}; rasterStreamState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT; if (contextVk->getFeatures().supportsTransformFeedbackExtension.enabled) { rasterStreamState.rasterizationStream = 0; rasterState.pNext = &rasterLineState; } vk_caps_utils.cpp reservedVaryingVectorCount += kReservedVaryingForTransformFeedbackExtension; angle::FrameCapture::ReplayCall","title":"ANGLE : GLES on Vk"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vk_ext_index_type_uint8","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 APIs \u5bf9\u5e94\u529f\u80fd \u6307\u5b9a\u4e86 IndexType \u7684 Draw \u5fc5\u8981\u6027 \u6027\u80fd\u4f18\u5316, \u53ef\u7ed5\u8fc7 \u6240\u9700 FeaturesEXT indexTypeUint8 angle issue: http://anglebug.com/4405 \u6b64\u6269\u5c55\u4e3a\u89e3\u51b3\u4e00\u4e2a\u6027\u80fd\u95ee\u9898: \u67d0\u4e9bGLES\u57fa\u51c6\uff08\u4f8b\u5982T-Rex\uff09\u5728 draw \u65f6\u4f7f\u7528 8bit \u7684 indices \u3002 \u4f46\u662f, Vulkan \u4e2d\u9ed8\u8ba4\u6ca1\u6709 8bit index, \u56e0\u6b64ANGLE \u9700\u8981\u4f7f\u7528 CPU, \u6216GPU\u7684\u8ba1\u7b97\u7740\u8272\u5668, \u5c068\u4f4d\u7d22\u5f15\u8f6c\u6362\u4e3a16\u4f4d\u3002 \u800c\u5982\u679c driver \u652f\u6301 VK_EXT_index_type_uint8 \uff0c\u5219\u4e0d\u9700\u8981\u6b64\u8f6c\u6362.","title":"VK_EXT_INDEX_TYPE_UINT8 (.)"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles","text":"\u6240\u6709\u6307\u5b9a\u4e86 IndexType \u7684 Draw. (DrawArrays, DrawElements.....) \u4f8b: glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices); \u5176\u4e2d index \u7c7b\u578b\u4e3a\u4ee5\u4e0b\u679a\u4e3e\u503c\u4e4b\u4e00: GL_UNSIGNED_BYTE , GL_UNSIGNED_SHORT , or GL_UNSIGNED_INT , \u5206\u522b\u5bf9\u5e94\u4e86 8bit, 16bit, \u548c 32bit.","title":"\u5bf9\u5e94 GLES \u529f\u80fd"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vulkan_1","text":"\u6b64\u6269\u5c55\u5141\u8bb8\u5728 vkCmdBindIndexBuffer \u547d\u4ee4\u4e2d\u4f7f\u7528 uint8_t indices, \u5bf9\u5e94\u679a\u4e3e: VkIndexType: VK_INDEX_TYPE_UINT8_EXT \u800c\u5728\u6ca1\u6709\u6b64\u6269\u5c55\u65f6, \u4ec5\u652f\u6301 VK_INDEX_TYPE_UINT16 \u548c VK_INDEX_TYPE_UINT32, \u5206\u522b\u5bf9\u5e94 16bit \u548c 32bit Features : \u4ec5\u9700\u542f\u7528 indexTypeUint8 // Provided by VK_EXT_index_type_uint8 typedef struct VkPhysicalDeviceIndexTypeUint8FeaturesEXT { VkStructureType sType; void* pNext; VkBool32 indexTypeUint8; } VkPhysicalDeviceIndexTypeUint8FeaturesEXT; vkCmdBindIndexBuffer \u547d\u4ee4: // Provided by VK_VERSION_1_0 void vkCmdBindIndexBuffer( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType); \u5176\u4e2d indexType \u5bf9\u5e94\u679a\u4e3e: // Provided by VK_VERSION_1_0 typedef enum VkIndexType { VK_INDEX_TYPE_UINT16 = 0, VK_INDEX_TYPE_UINT32 = 1, // Provided by VK_KHR_acceleration_structure VK_INDEX_TYPE_NONE_KHR = 1000165000, // Provided by VK_EXT_index_type_uint8 VK_INDEX_TYPE_UINT8_EXT = 1000265000, // Provided by VK_NV_ray_tracing VK_INDEX_TYPE_NONE_NV = VK_INDEX_TYPE_NONE_KHR, } VkIndexType;","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#angle-gles-on-vk_1","text":"// Init gles-vulkan index type map mIndexTypeMap[UnsignedByte] = supportsIndexTypeUint8 ? VK_INDEX_TYPE_UINT8_EXT : VK_INDEX_TYPE_UINT16; mIndexTypeMap[UnsignedShort] = VK_INDEX_TYPE_UINT16; mIndexTypeMap[UnsignedInt] = VK_INDEX_TYPE_UINT32; mIndexTypeMap \u7528\u4e8e \u6267\u884c vkCmdBindIndexBuffer \u8bbe\u7f6e\u7c7b\u578b UnsignedByte : VK_INDEX_TYPE_UINT8_EXT (\u539f\u5148 VK_INDEX_TYPE_UINT16) UnsignedShort : VK_INDEX_TYPE_UINT16 UnsignedInt : VK_INDEX_TYPE_UINT32 \u5982\u679c\u4e0d\u652f\u6301, \u5728 DrawXXX \u5b9e\u73b0\u4e2d\u5904\u7406 indices \u65f6 (\u4f8b\u5982\u5206\u914d\u5185\u5b58\u7a7a\u95f4) \u9700\u8981\u5c06 GLubyte \u8f6c\u4e3a GLushort \u540e\u518d\u5904\u7406. void createIndexBuffer() { VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size(); VkBuffer stagingBuffer; VkDeviceMemory stagingBufferMemory; createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory); void* data; vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data); memcpy(data, indices.data(), (size_t) bufferSize); vkUnmapMemory(device, stagingBufferMemory); createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, indexBuffer, indexBufferMemory); copyBuffer(stagingBuffer, indexBuffer, bufferSize); vkDestroyBuffer(device, stagingBuffer, nullptr); vkFreeMemory(device, stagingBufferMemory, nullptr); } \u4f7f\u7528 IndexBuffer vkCmdBindVertexBuffers(commandBuffers[i], 0, 1, vertexBuffers, offsets); vkCmdBindIndexBuffer(commandBuffers[i], indexBuffer, 0, VK_INDEX_TYPE_UINT16); // <-- VK_INDEX_TYPE_UINT8_EXT vkCmdDrawIndexed(commandBuffers[i], static_cast<uint32_t>(indices.size()), 1, 0, 0, 0); \u5206\u6790\u8fc7\u7a0b supportsIndexTypeUint8 vk_helper.cpp HandlePrimitiveRestart CopyLineLoopIndicesWithRestart (indexCount, srcPtr, outPtr); ContextVk initIndexTypeMap() initialize() shouldConvertUint8VkIndexType LineLoopHelper: streamIndices VertexArrayVk: handleLineLoop ContextVk: setupLineLoopDraw ALL Draw Call VertexArrayVk: convertIndexBufferCPU ContextVk: setupIndexedDraw DrawElements.... gl::DrawElementsType::UnsignedByte setupIndexedDraw","title":"ANGLE : GLES on Vk"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vk_ext_line_rasterization","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 \u5bf9\u5e94\u529f\u80fd \u5149\u6805\u5316: \u5355\u6837\u672c\u6e32\u67d3 \u5fc5\u8981\u6027 \u975e\u5fc5\u9700: \u4fdd\u6301\u7b97\u6cd5\u4e00\u81f4\u6027 \u6240\u9700 FeaturesEXT bresenhamLines angle doc: OpenGLLineSegmentRasterization \u7531\u4e8e Vk \u5728\u5149\u6805\u5316\u7684\u5355\u6837\u672c\u6e32\u67d3\u91c7\u6837\u4e86\u4e0d\u540c\u7684\u7ebf\u6bb5\u6e32\u67d3\u7b97\u6cd5, \u9700\u8981\u6b64\u6269\u5c55\u6765\u4fdd\u6301 GLES \u4e0e\u539f\u6709\u7b97\u6cd5\u7684\u4e00\u81f4\u6027: \u5728\u5149\u6805\u5316\u9636\u6bb5, OpenGL\u548cVulkan\u90fd\u5c06\u7ebf\u6bb5\u6e32\u67d3\u4e3a\u4e24\u70b9\u4e4b\u95f4\u7684\u4e00\u7cfb\u5217\u50cf\u7d20\u3002\u5b83\u4eec\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u8986\u76d6\u7ebf\u7684\u50cf\u7d20\u3002 \u5bf9\u4e8e\u5355\u6837\u672c\u6e32\u67d3\uff0cVulkan\u4f7f\u7528 \u57fa\u4e8e\u56db\u8fb9\u5f62\u8986\u76d6\u7387\u7684\u7b97\u6cd5 \u3002\u8f83\u5c0f\u7684\u5f62\u72b6\u56f4\u7ed5\u7ebf\u6bb5\u6324\u51fa\u3002\u5f62\u72b6\u6240\u8986\u76d6\u7684\u6837\u672c\u5c06\u4ee3\u8868\u7ebf\u6bb5\u3002 OpenGL\u7684\u7b97\u6cd5 \u57fa\u4e8eBresenham\u7684line\u7b97\u6cd5 \u3002\u5728\u4e24\u4e2a\u5206\u6bb5\u70b9\u4e4b\u95f4\u7684\u7ebf\u4e0a\u9009\u62e9\u50cf\u7d20\u3002\u6ce8\u610fBresenham\u4e0d\u652f\u6301\u591a\u91cd\u91c7\u6837\u3002 \u5728\u89c6\u89c9\u4e0a\u8fdb\u884c\u6bd4\u8f83\u65f6\uff0cVulkan\u7ebf\u6bb5\u6805\u683c\u5316\u7b97\u6cd5\u59cb\u7ec8\u9009\u62e9\u5728OpenGL\u4e2d\u6805\u683c\u5316\u7684\u7ebf\u6bb5\u50cf\u7d20\u7684\u8d85\u96c6\u3002 \u8be6\u7ec6\u533a\u522b\u89c1 ANGLE \u6587\u6863: OpenGLLineSegmentRasterization","title":"VK_EXT_LINE_RASTERIZATION (.)"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles_1","text":"\u7ba1\u7ebf\u7684\u5149\u6805\u5316, \u65e0API\u5bf9\u5e94","title":"\u5bf9\u5e94 GLES"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vulkan_2","text":"Features : \u4ec5\u9700\u542f\u7528 bresenhamLines. // Provided by VK_EXT_line_rasterization typedef struct VkPhysicalDeviceLineRasterizationFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 rectangularLines; VkBool32 bresenhamLines; VkBool32 smoothLines; VkBool32 stippledRectangularLines; VkBool32 stippledBresenhamLines; VkBool32 stippledSmoothLines; } VkPhysicalDeviceLineRasterizationFeaturesEXT; \u63d0\u4f9b Pipeline State \u6269\u5c55: // Provided by VK_EXT_line_rasterization typedef struct VkPipelineRasterizationLineStateCreateInfoEXT { VkStructureType sType; const void* pNext; VkLineRasterizationModeEXT lineRasterizationMode; VkBool32 stippledLineEnable; uint32_t lineStippleFactor; uint16_t lineStipplePattern; } VkPipelineRasterizationLineStateCreateInfoEXT; \u5176\u4e2d lineRasterizationMode \u5bf9\u5e94\u679a\u4e3e: // Provided by VK_EXT_line_rasterization typedef enum VkLineRasterizationModeEXT { VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0, VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1, VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2, VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3, } VkLineRasterizationModeEXT; \u5176\u4e2d VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT \u6839\u636e Bresenham Line Segment Rasterization \u7b97\u6cd5\u4e2d\u7684\u5b9a\u4e49\uff0c\u6307\u5b9a\u901a\u8fc7\u786e\u5b9a\u7ebf\u6761\u76f8\u4ea4\u548c\u79bb\u5f00\u7684\u50cf\u7d20\u83f1\u5f62\u7ed8\u5236\u7684\u7ebf\u6761\u3002","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles-on-vulkan","text":"\u5728\u975e\u591a\u91cd\u91c7\u6837\u65f6, \u5728\u5b9a\u4e49 Pipeline \u7684 VkPipelineRasterizationStateCreateInfo \u65f6, \u4e3a\u5176 pNext \u94fe\u4e0a\u6dfb\u52a0 VkPipelineRasterizationLineStateCreateInfoEXT \u5373\u53ef. \u8bbe\u7f6e lineRasterizationMode \u4e3a VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT VkPipelineRasterizationStateCreateInfo rasterState = {}; ... const void **pNextPtr = &rasterState.pNext; VkPipelineRasterizationLineStateCreateInfoEXT rasterLineState = {}; rasterLineState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT; // Enable Bresenham line rasterization if available and not multisampling. if (rasterizationSamples <= 1 && bresenhamLineRasterization.enabled) { rasterLineState.lineRasterizationMode = VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT; *pNextPtr = &rasterLineState; pNextPtr = &rasterLineState.pNext; }","title":"GLES on Vulkan"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vk_ext_shader_stencil_export","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 \u5bf9\u5e94\u529f\u80fd glBlitFramebuffer: stencil buffer \u7684 resolve \u548c unresolve \u5fc5\u8981\u6027 \u975e\u5fc5\u987b, \u53ef\u6a21\u62df\u5b9e\u73b0 \u6240\u9700 FeaturesEXT \u65e0 \u6b64\u6269\u5c55\u7528\u4e8e\u6267\u884c\u6a21\u677f\u7f13\u51b2\u533a\u7684\u591a\u91c7\u6837\u89e3\u6790(multisampled resolve of stencil buffer)\u3002 \u5982\u679c\u6b64\u6269\u5c55\u4e0d\u53ef\u7528\uff0c\u5219\u4f7f\u7528\u591a\u6b65\u9aa4\u6a21\u62df\u5b9e\u73b0\u3002","title":"VK_EXT_SHADER_STENCIL_EXPORT"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles_2","text":"Framebuffer \u7684 resolve \u548c unresolve, \u53d1\u751f\u5728\u8bfb\u53d6\u548c\u590d\u5236\u8fc7\u7a0b\u4e2d, \u5982 glBlitFramebuffer","title":"\u5bf9\u5e94 GLES \u529f\u80fd"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vulkan_3","text":"\u6b64\u6269\u5c55\u63d0\u4f9b\u4e00\u79cd\u673a\u5236\uff0c\u4f7f\u7740\u8272\u5668\u53ef\u4ee5\u5728\u6bcf\u6b21\u8c03\u7528\u65f6\u751f\u6210\u6a21\u677f\u5f15\u7528\u503c\u3002\u5728\u542f\u7528\u6a21\u677f\u6d4b\u8bd5\u65f6\uff0c\u8fd9\u5141\u8bb8\u9488\u5bf9\u7740\u8272\u5668\u4e2d\u751f\u6210\u7684\u503c\u6267\u884c\u6d4b\u8bd5\u3002 \u6b64\u6269\u5c55\u4f9d\u8d56 SPV_EXT_shader_stencil_export \u6b64\u6269\u5c55\u4e3aGLES\u7684shader\u6269\u5c55: GL_ARB_shader_stencil_export \u63d0\u4f9b API \u652f\u6301 \u6b64\u6269\u4e3a\u4e0d\u589e\u52a0\u5176\u4ed6\u7ed3\u6784\u4f53\u548c\u6307\u4ee4.","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles-on-vk","text":"\u5f85\u5206\u6790 \u5206\u6790\u8fc7\u7a0b: BlitResolveStencilNoExport.comp: Blit stencil images or resolve multisampled ones into a buffer. // This is used where VK_EXT_shader_stencil_export is not available, to output the resolved stencil // into a temporary buffer, which is then copied into the stencil aspect of the final image. UtilsVk::stencilBlitResolveNoShaderExport \u63d2\u4ef6\u65e0\u6548\u65f6\u7684\u66ff\u4ee3\u65b9\u6cd5. supportsShaderStencilExport \u5224\u65ad: FramebufferVk::startNewRenderPass UtilsVk::SetStencilForShaderExport FramebufferVk::colorBlitResolve FramebufferVk::depthStencilBlitResolve FramebufferVk::blit UntilVk: unresolve","title":"GLES on Vk"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vk_ext_vertex_attribute_divisor","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 APIs \u5bf9\u5e94\u529f\u80fd Vertex \u7ed1\u5b9a, GL_EXT_instanced_arrays \u5fc5\u8981\u6027 \u6240\u9700 FeaturesEXT vertexAttributeInstanceRateDivisor","title":"VK_EXT_VERTEX_ATTRIBUTE_DIVISOR"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles_3","text":"Vertex \u7ed1\u5b9a GL_EXT_instanced_arrays glDrawArraysInstancedEXT glDrawElementsInstancedEXT glVertexAttribDivisorEXT","title":"\u5bf9\u5e94 GLES \u529f\u80fd"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vulkan_4","text":"Vertex Attribute Divisor in Instanced Rendering structure controls how vertex attributes are assigned to an instance when instanced rendering is enabled. VkPipelineVertexInputStateCreateInfo // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPipelineVertexInputDivisorStateCreateInfoEXT { VkStructureType sType; const void* pNext; uint32_t vertexBindingDivisorCount; const VkVertexInputBindingDivisorDescriptionEXT* pVertexBindingDivisors; } VkPipelineVertexInputDivisorStateCreateInfoEXT; // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkVertexInputBindingDivisorDescriptionEXT { uint32_t binding; uint32_t divisor; } VkVertexInputBindingDivisorDescriptionEXT; binding is the binding number for which the divisor is specified. divisor is the number of successive instances that will use the same value of the vertex attribute when instanced rendering is enabled. For example, if the divisor is N, the same vertex attribute will be applied to N successive instances before moving on to the next vertex attribute. The maximum value of divisor is implementation dependent and can be queried using VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT :: maxVertexAttribDivisor . A value of 0 can be used for the divisor if the vertexAttributeInstanceRateZeroDivisor feature is enabled. In this case, the same vertex attribute will be applied to all instances. Features : // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 vertexAttributeInstanceRateDivisor; VkBool32 vertexAttributeInstanceRateZeroDivisor; } VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT; \u2022 sType is the type of this structure. \u2022 pNext is NULL or a pointer to a structure extending this structure. \u2022 vertexAttributeInstanceRateDivisor specifies whether vertex attribute fetching may be repeated in case of instanced rendering. \u2022 vertexAttributeInstanceRateZeroDivisor specifies whether a zero value for VkVertexInputBindingDivisorDescriptionEXT::divisor is supported. Limits : VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::maxVertexAttribDivisor","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles-on-vk-api","text":"\u53c2\u8003Spec, \u4e3a Pipeline \u914d\u7f6e VkPipelineVertexInputDivisorStateCreateInfoEXT \u5373\u53ef.","title":"GLES on Vk API"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#ddk-gles-on-gfx","text":"\u5206\u6790\u8fc7\u7a0b RendererVk.mMaxVertexAttribDivisor mVertexAttributeDivisorProperties.maxVertexAttribDivisor We only store 8 bit divisor in GraphicsPipelineDesc so capping value & we emulate if exceeded RendererVk::getMaxVertexAttribDivisor ContextVk : onVertexAttributeChange VertexArrayVk::syncDirtyAttrib gl::VertexArray::DIRTY_BIT_ATTRIB_0 + INDEX: gl::VertexArray::DIRTY_BIT_BINDING_0 + INDEX: VertexArrayVk::updateStreamedAttribs","title":"DDK: GLES on gfx"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vk_khr_shader_float16_int8","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES es2.0 APIs \u5bf9\u5e94\u529f\u80fd glGenerateMipmap \u5fc5\u8981\u6027 \u975e\u5fc5\u8981: \u6027\u80fd\u4f18\u5316 \u6240\u9700 FeaturesEXT shaderFloat16 angle issue: http://anglebug.com/4551","title":"VK_KHR_SHADER_FLOAT16_INT8 (.)"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles-api_1","text":"glGenerateMipmap \u7528\u4e8e\u8fdb\u884c\u751f\u6210Mipmap \u8ba1\u7b97\u65f6, \u5728\u7740\u8272\u5668\u4e2d\u542f\u7528 float 16 \u6765\u52a0\u901f\u8fd0\u7b97","title":"\u5bf9\u5e94GLES API"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vulkan_5","text":"\u6b64\u6269\u5c55\u5c06\u63d0\u5347\u81f3 Vulkan 1.2 Core \u6b64\u6269\u5c55\u5141\u8bb8\u5728\u7740\u8272\u5668\u4e2d\u4f7f\u752816\u4f4d\u6d6e\u70b9\u7c7b\u578b\u548c8\u4f4d\u6574\u6570\u7c7b\u578b\u8fdb\u884c\u7b97\u672f\u8fd0\u7b97\u3002 Features : \u4ec5\u9700\u542f\u7528 shaderFloat16 typedef struct VkPhysicalDeviceShaderFloat16Int8Features { VkStructureType sType; void* pNext; VkBool32 shaderFloat16; VkBool32 shaderInt8; } VkPhysicalDeviceShaderFloat16Int8Features;","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles-on-vk_1","text":"\u5728 GenerateMipmap \u8fc7\u7a0b\u4e2d, \u53d6 shader \u8fdb\u884c\u8ba1\u7b97\u65f6, \u5982\u679c\u56fe\u7247\u7684 bits-per-component (eg: redBits) \u4e3a 8 \u6216 16\u65f6, \u4f7f\u7528\u6269\u5c55\u63d0\u4f9b\u7684 float16 \u6765\u8ba1\u7b97\u4ee5\u83b7\u53d6\u66f4\u5feb\u7684\u8ba1\u7b97\u901f\u5ea6. if (actualFormat.redBits <= 8) { flags = hasShaderFloat16 ? GenerateMipmap_comp::kIsRGBA8_UseHalf : GenerateMipmap_comp::kIsRGBA8; } else if (actualFormat.redBits <= 16) { flags = hasShaderFloat16 ? GenerateMipmap_comp::kIsRGBA16_UseHalf : GenerateMipmap_comp::kIsRGBA16; } else { flags = GenerateMipmap_comp::kIsRGBA32F; } \u5404 flag \u5206\u522b\u5404\u81ea\u5bf9\u5e94\u4e00\u4e2a\u9884\u751f\u6210\u7684 compressedShaderCode. \u5206\u6790\u8fc7\u7a0b supportsShaderFloat16 \u652f\u6301: `` UtilsVk.cpp: GetGenerateMipmapFlags UtilsVk::generateMipmapFlags TextureVk::generateMipmapsWithCompute TextureVk::generateMipmap Texture : generateMipmap Context : generateMipmap // Note: If bits-per-component is 8 or 16 and float16 is supported in the shader, use that for faster math. flag \u4f5c\u7528: contextVk->getShaderLibrary().getGenerateMipmap_comp(contextVk, flags, &shader) uint32_t GetGenerateMipmapFlags(ContextVk *contextVk, const vk::Format &format) { const angle::Format &actualFormat = format.actualImageFormat(); uint32_t flags = 0; // Note: const bool hasShaderFloat16 = contextVk->getRenderer()->getFeatures().supportsShaderFloat16.enabled; if (actualFormat.redBits <= 8) { flags = hasShaderFloat16 ? GenerateMipmap_comp::kIsRGBA8_UseHalf : GenerateMipmap_comp::kIsRGBA8; } else if (actualFormat.redBits <= 16) { flags = hasShaderFloat16 ? GenerateMipmap_comp::kIsRGBA16_UseHalf : GenerateMipmap_comp::kIsRGBA16; } else { flags = GenerateMipmap_comp::kIsRGBA32F; } flags |= UtilsVk::GetGenerateMipmapMaxLevels(contextVk) == UtilsVk::kGenerateMipmapMaxLevels ? GenerateMipmap_comp::kDestSize6 : GenerateMipmap_comp::kDestSize4; return flags; }","title":"GLES on VK"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#egl","text":"","title":"EGL"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vk_ext_swapchain_color_space","text":"V100 \u5df2\u652f\u6301 \u5426 ? \u5bf9\u5e94 GLES EGL Extension \u5bf9\u5e94\u529f\u80fd EGL_KHR_gl_colorspace (v100\u652f\u6301) \u5fc5\u8981\u6027 \u652f\u6301 EGL EXT \u5fc5\u987b \u6240\u9700 FeaturesEXT \u65e0 angle issue: http://anglebug.com/2514 \u652f\u6301\u6269\u5c55 EGL_KHR_gl_colorspace (v100\u652f\u6301), \u8fdb\u800c\u652f\u6301 EGL_EXT_image_gl_colorspace \u7b49 colorspace \u6269\u5c55.","title":"VK_EXT_SWAPCHAIN_COLOR_SPACE (.)"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles_4","text":"\u6269\u5c55 EGL_KHR_gl_colorspace \u683c\u5f0f: EGL_GL_COLORSPACE_KHR EGL_GL_COLORSPACE_SRGB_KHR EGL_GL_COLORSPACE_LINEAR_KHR","title":"\u5bf9\u5e94 GLES \u529f\u80fd"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vulkan_6","text":"\u63d0\u4f9b\u6269\u5c55: VkColorSpaceKHR : VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT VK_COLOR_SPACE_BT2020_LINEAR_EXT VK_COLOR_SPACE_BT709_LINEAR_EXT VK_COLOR_SPACE_BT709_NONLINEAR_EXT VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT VK_COLOR_SPACE_DOLBYVISION_EXT VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT VK_COLOR_SPACE_HDR10_HLG_EXT VK_COLOR_SPACE_HDR10_ST2084_EXT VK_COLOR_SPACE_PASS_THROUGH_EXT","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles-on-vulkan_1","text":"\u5bf9 EGL \u7684 Format \u5411 Vk Format \u8fdb\u884c\u6620\u5c04: static VkColorSpaceKHR MapEglColorSpaceToVkColorSpace(EGLenum EGLColorspace) { switch (EGLColorspace) { case EGL_NONE: case EGL_GL_COLORSPACE_LINEAR: case EGL_GL_COLORSPACE_SRGB_KHR: case EGL_GL_COLORSPACE_DISPLAY_P3_PASSTHROUGH_EXT: return VK_COLOR_SPACE_SRGB_NONLINEAR_KHR; case EGL_GL_COLORSPACE_DISPLAY_P3_LINEAR_EXT: return VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT; case EGL_GL_COLORSPACE_DISPLAY_P3_EXT: return VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT; case EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT: return VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT; case EGL_GL_COLORSPACE_SCRGB_EXT: return VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT; default: UNREACHABLE(); return VK_COLOR_SPACE_SRGB_NONLINEAR_KHR; } }","title":"GLES on Vulkan"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vk_android_external_memory_android_hardware_buffer-vk_ext_queue_family_foreign","text":"V100 \u5df2\u652f\u6301 \u5426 \u5bf9\u5e94 GLES EGL Extension (\u4ec5\u5b89\u5353) \u5bf9\u5e94\u529f\u80fd EGL_ANDROID_image_native_buffer (v100\u652f\u6301) \u5fc5\u8981\u6027 \u652f\u6301 EGL EXT \u5fc5\u987b \u6240\u9700 FeaturesEXT \u65e0","title":"VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER \u548c VK_EXT_QUEUE_FAMILY_FOREIGN"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles_5","text":"\u652f\u6301 ANativeWindowBuffer : EGL_NATIVE_BUFFER_ANDROID \u793a\u4f8b: ANativeWindowBuffer* sSrcBuffer = graphicBuffer->getNativeBuffer(); EGLint attrs[] = { EGL_IMAGE_PRESERVED_KHR, EGL_TRUE, EGL_NONE, }; EGLImageKHR eglSrcImage =eglCreateImageKHR(eglDisplay, EGL_NO_CONTEXT, EGL_NATIVE_BUFFER_ANDROID, (EGLClientBuffer)&sSrcBuffer, attrs);","title":"\u5bf9\u5e94 GLES \u529f\u80fd"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vulkan_7","text":"1. VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER \u6b64\u6269\u5c55\u4f7f\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5c06\u5728Vulkan\u8bbe\u5907\u5916\u90e8\u521b\u5efa\u7684Android AHardwareBuffer\u5bf9\u8c61\u5bfc\u5165Vulkan\u5185\u5b58\u5bf9\u8c61\uff0c\u5728\u5176\u4e2d\u53ef\u4ee5\u5c06\u5b83\u4eec\u7ed1\u5b9a\u5230\u56fe\u50cf\u548c\u7f13\u51b2\u533a\u3002 \u5b83\u8fd8\u5141\u8bb8\u4eceVulkan\u5185\u5b58\u5bf9\u8c61\u4e2d\u5bfc\u51faAHardwareBuffer\uff0c\u4ee5\u4e0e\u5176\u4ed6\u64cd\u4f5c\u7cfb\u7edf\u5bf9\u79f0\u3002 \u4f46\u662f\uff0c\u7531\u4e8e\u5e76\u975e\u6240\u6709AHardwareBuffer\u7528\u6cd5\u548c\u683c\u5f0f\u90fd\u5177\u6709Vulkan\u7b49\u6548\u9879\uff0c\u56e0\u6b64\u4eceVulkan\u5bfc\u51fa\u4e0e\u63d0\u4f9b\u5916\u90e8AHardwareBuffer\u5e76\u5bfc\u5165\u76f8\u6bd4\uff0c\u63d0\u4f9b\u7684\u529f\u80fd\u8981\u5c11\u5f97\u591a\u3002 \u67d0\u4e9bAHardwareBuffer\u6620\u50cf\u5177\u6709\u5b9e\u73b0\u5b9a\u4e49\u7684\u5916\u90e8\u683c\u5f0f\uff0c\u8fd9\u4e9b\u683c\u5f0f\u53ef\u80fd\u4e0eVulkan\u683c\u5f0f\u4e0d\u5bf9\u5e94\u3002 \u91c7\u6837\u5668Y'CBCR\u8f6c\u6362\u53ef\u7528\u4e8e\u4ece\u8fd9\u4e9b\u56fe\u50cf\u4e2d\u91c7\u6837\u5e76\u5c06\u5b83\u4eec\u8f6c\u6362\u4e3a\u5df2\u77e5\u7684\u8272\u5f69\u7a7a\u95f4\u3002 \u6269\u5c55\u547d\u4ee4\u5305\u62ec: vkGetAndroidHardwareBufferPropertiesANDROID vkGetMemoryAndroidHardwareBufferANDROID 2. VK_EXT_QUEUE_FAMILY_FOREIGN \u6b64\u6269\u5c55\u5b9a\u4e49\u4e86\u4e00\u4e2a\u7279\u6b8a\u7684\u961f\u5217\u65cf (Queue Family): VK_QUEUE_FAMILY_FOREIGN_EXT : \u7528\u4e8e\u5c06\u5916\u90e8\u5b58\u50a8\u5668\u652f\u6301\u7684\u8d44\u6e90\u6240\u6709\u6743\u8f6c\u79fb\u5230\u5916\u90e8\u5916\u90e8\u961f\u5217\u3002 \u8fd9\u7c7b\u4f3c\u4e8e VK_KHR_external_memory \u4e2d\u5b9a\u4e49\u7684 VK_QUEUE_FAMILY_EXTERNAL_KHR \u3002 \u4e24\u8005\u4e4b\u95f4\u7684\u4e3b\u8981\u533a\u522b\u662f\uff1a VK_QUEUE_FAMILY_EXTERNAL_KHR \u8868\u793a\u7684\u961f\u5217\u5fc5\u987b\u4e0e\u5f53\u524dVkInstance\u5171\u4eab\u76f8\u540c\u7684\u7269\u7406\u8bbe\u5907\u548c\u76f8\u540c\u7684\u9a71\u52a8\u7a0b\u5e8f\u7248\u672c\u3002 VK_QUEUE_FAMILY_FOREIGN_EXT \u6ca1\u6709\u8fd9\u6837\u7684\u9650\u5236\u3002 \u5b83\u53ef\u4ee5\u4ee3\u8868\u5176\u4ed6\u4f9b\u5e94\u5546\u7684\u8bbe\u5907\u548c\u9a71\u52a8\u7a0b\u5e8f\uff0c\u751a\u81f3\u53ef\u4ee5\u4ee3\u8868\u4e0d\u5177\u6709Vulkan\u529f\u80fd\u7684\u8bbe\u5907\u3002 \u5916\u90e8\u5b58\u50a8\u5668\u652f\u6301\u7684\u6240\u6709\u8d44\u6e90\u5747\u652f\u6301 VK_QUEUE_FAMILY_EXTERNAL_KHR \u3002 \u5bf9 VK_QUEUE_FAMILY_FOREIGN_EXT \u7684\u652f\u6301\u66f4\u5177\u9650\u5236\u6027\u3002 \u5e94\u7528\u7a0b\u5e8f\u5e94\u8be5\u671f\u671b\u5230 VK_QUEUE_FAMILY_FOREIGN_EXT \u7684\u8f6c\u6362\u6bd4\u4ece VK_QUEUE_FAMILY_EXTERNAL_KHR \u7684\u8f6c\u6362\u8981\u6602\u8d35\u3002","title":"Vulkan \u5b9a\u4e49"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles-on-vulkan_2","text":"Android\u5e73\u53f0\u7279\u6b8a\u4ee3\u7801 (src\\libANGLE\\renderer\\vulkan\\android). \u4e3aimage\u521b\u5efabuffer\u65f6, \u7528\u4e8e\u83b7\u53d6 BufferMemory \u7b49\u5e95\u5c42\u4fe1\u606f. \u5177\u4f53\u5185\u5bb9\u5f85\u5206\u6790. if ANDROID \u6709\u5219\u542f\u7528 supportsAndroidHardwareBuffer VK_QUEUE_FAMILY_FOREIGN_EXT VK_KHR_EXTERNAL_FENCE_FD \u6709\u5219\u542f\u7528 supportsExternalFenceFd \u652f\u6301: EGL_ANDROID_native_fence VK_KHR_INCREMENTAL_PRESENT \u6709\u5219\u542f\u7528 supportsIncrementalPresent \u652f\u6301 EGL_KHR_swap_buffers_with_damage eglSwapBuffersWithDamageEXT SurfaceVk::present SurfaceVk::swapImpl","title":"GLES on Vulkan"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles-ext","text":"VK_KHR_EXTERNAL_MEMORY_FD \u6709\u5219\u542f\u7528 supportsExternalMemoryFd \u652f\u6301: GL_EXT_memory_object_fd VK_KHR_EXTERNAL_SEMAPHORE_FD \u6709\u5219\u542f\u7528 supportsExternalSemaphoreFd \u652f\u6301: GL_EXT_semaphore_fd","title":"GLES EXT"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vulkan_8","text":"VK_KHR_SURFACE && VK_KHR_ANDROID_SURFACE WSI , \u975e\u53ef\u9009 Extension VK_EXT_DEBUG_UTILS / VK_EXT_DEBUG_REPORT Vulkan ValidationLayers VK_KHR_SWAPCHAIN \u975e\u53ef\u9009 Extension VK_QCOM_render_pass_store_ops \u6709\u5219\u542f\u7528 supportsRenderPassStoreOpNoneQCOM VK_ATTACHMENT_STORE_OP_NONE_QCOM http://anglebug.com/5505 For read only depth stencil, we can use StoreOpNone if available. DONT_CARE is still preferred, so do this after finish the DONT_CARE handling.","title":"Vulkan \u81ea\u7528"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#_2","text":"","title":"\u5176\u4ed6\u5e73\u53f0"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#nvidia","text":"VK_EXT_DEPTH_CLIP_ENABLE \u6709\u5219\u542f\u7528 FeatureVk.depthClamping \u542f\u7528 : isNvidia && Features.depthClamp && EXT The workaround requires the VK_EXT_depth_clip_enable extension and the 'depthClamp' physical device feature. This workaround caused test failures on Quadro P400/driver 418.56/Linux. Therefore, on Linux we require a major version > 418. On some NVIDIA drivers the depth value is not clamped to [0,1] for floating point depth buffers. This is NVIDIA bug 3171019, see http://anglebug.com/3970 for details. When depth clamping is used, depth clipping is automatically disabled. When the 'depthClamping' feature is enabled, we'll be using depth clamping to work around a driver issue, not as an alternative to depth clipping. Therefore we need to explicitly re-enable depth clipping. \u5bf9\u5e94 vk: VkPipelineRasterizationState.depthClampEnable","title":"Nvidia"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#mac","text":"VK_EXT_EXTERNAL_MEMORY_HOST \u6709\u5219\u542f\u7528 FeatureVk.supportsExternalMemoryHost Whether the VkDevice supports the VK_EXT_external_memory_host extension, on which the ANGLE_iosurface_client_buffer extension can be layered. IOSurfaceSurfaceVkMac.mm OffscreenSurfaceVk::AttachmentImage::initializeWithExternalMemory RendererVk.mMinImportedHostPointerAlignment vkGetMemoryHostPointerPropertiesEXT IOSurfaceSurfaceVkMac.mm","title":"MAC"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#ggpstadia","text":"VK_GGP_FRAME_TOKEN if PLANTFORM_GGP \u6709\u5219\u542f\u7528 supportsGGPFrameToken \u652f\u6301 : EGL_ANGLE_swap_with_frame_token eglSwapBuffersWithFrameTokenANGLE","title":"GGP(Stadia)"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#fuchsia","text":"VK_FUCHSIA_EXTERNAL_MEMORY \u6709\u5219\u542f\u7528 supportsExternalMemoryFuchsia \u652f\u6301: GL_ANGLE_memory_object_fuchsia VK_FUCHSIA_EXTERNAL_SEMAPHORE \u6709\u5219\u542f\u7528 supportsExternalSemaphoreFuchsia \u652f\u6301: GL_ANGLE_semaphore_fuchsia","title":"Fuchsia"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#angle","text":"VK_EXT_PROVOKING_VERTEX GL_ANGLE_provoking_vertex glProvokingVertexANGLE VK_GOOGLE_SAMPLER_FILTERING_PRECISION \u672a\u542f\u7528, ANGLE\u81ea\u5b9a\u4e49 supportsFilteringPrecision \u652f\u6301: GL_CHROMIUM_texture_filtering_hint gHint(GL_TEXTURE_FILTERING_HINT_CHROMIUM)","title":"ANGLE"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#v100-ext","text":"","title":"v100 \u5df2\u652f\u6301\u7684Ext"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles_6","text":"VK_KHR_DEPTH_STENCIL_RESOLVE \u542f\u7528 if supportsRenderpass2.enabled && mDepthStencilResolveProperties.independentResolveNone supportsDepthStencilResolve http://anglebug.com/5065 RenderbufferVk::setStorageImpl \u4e3a multisampled depth/stenci \u542f\u7528 render render to texture \u53ef\u542f\u7528 VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT // If multisampled render to texture, an implicit multisampled image is created which is used as // the color or depth/stencil attachment. At the end of the render pass, this image is // automatically resolved into |mImage| and its contents are discarded. \u652f\u6301 depth/stencil images, \u975e\u5fc5\u9700, \u53ef\u7ed5\u8fc7 VK_KHR_EXTERNAL_FENCE_CAPABILITIES \u6709\u5219\u542f\u7528 supportsExternalFenceCapabilities supportsAndroidNativeFenceSync (supportsExternalFenceCapabilities && supportsExternalSemaphoreCapabilities ) || (supportsExternalFenceFd&& supportsExternalSemaphoreFd) VK_KHR_EXTERNAL_SEMAPHORE \u542f\u7528 if supportsExternalSemaphoreFd || supportsExternalSemaphoreFuchsia \u4e8c\u8005\u7684\u524d\u7f6e? \u65e0EXT\u5b58\u5728\u68c0\u67e5 \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES \u6709\u5219\u542f\u7528 supportsExternalSemaphoreCapabilities VK_KHR_MAINTENANCE1 PhysicalDeviceProperties.apiVersion < VK_MAKE_VERSION(1, 1, 0) Enable KHR_MAINTENANCE1 to support viewport flipping. VK_KHR_SAMPLER_YCBCR_CONVERSION \u542f\u7528 if SamplerYcbcrConversionFeatures.samplerYcbcrConversion supportsYUVSamplerConversion","title":"GLES"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vulkan_9","text":"VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2 \u6709\u5219\u542f\u7528 VK_KHR_GET_MEMORY_REQUIREMENTS_2 \u6709\u5219\u542f\u7528 \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_BIND_MEMORY_2 \u6709\u5219\u542f\u7528 \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_EXTERNAL_MEMORY \u542f\u7528 if supportsAndroidHardwareBuffer || supportsExternalMemoryFd|| supportsExternalMemoryFuchsia \u53ef\u80fd\u4e3a\u4e09\u8005\u7684\u524d\u7f6e: \u65e0EXT\u652f\u6301\u68c0\u67e5, \u6761\u4ef6\u6ee1\u8db3\u76f4\u63a5\u542f\u7528. \u65e0\u7ed1\u5b9a\u53c2\u6570 VK_KHR_CREATE_RENDERPASS_2 \u6709\u5219\u542f\u7528 supportsRenderpass2 vkCreateRenderPass2KHR VK_KHR_DEPTH_STENCIL_RESOLVE \u4f9d\u8d56\u6b64\u6269\u5c55","title":"Vulkan \u81ea\u7528"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#amd","text":"VK_KHR_IMAGE_FORMAT_LIST \u542f\u7528 if AMD supportsImageFormatList EGL_EXT_image_gl_colorspace","title":"AMD"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#angle-ext","text":"\u4ee5\u4e0b\u591aExtension\u5c1a\u672a\u5217\u5165 Vulkan Spec, \u662f ANGLE \u671f\u671b\u4e3a\u652f\u6301GLES \u800c\u63d0\u51fa\u7684. VK_KHR_shader_terminate_invocation VK_EXT_primitive_topology_list_restart VK_EXT_vertext_attribute_aliasing VK_EXT_generate_mipmap VK_EXT_pipeline_robustness VK_EXT_image_robustness VK_EXT_custom_border_color VK_EXT_blend_operation_advanced \u51fa\u73b0\u5728\u4ee3\u7801\u4e2d\u4f46\u5c1a\u672a\u542f\u7528\u7684Feature. textureCompressionETC2","title":"ANGLE \u671f\u671b\u5c06\u6765\u52a0\u5165\u7684 EXT"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#angle-vk-features","text":"","title":"ANGLE: Vk Features"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#inheritedqueries","text":"3.0 \u5fc5\u987b // We use secondary command buffers almost everywhere and they require a feature to be // able to execute in the presence of queries. As a result, we won't support queries // unless that feature is available. mNativeExtensions.occlusionQueryBoolean = \u652f\u6301 GLES \u529f\u80fd: QueryType glBeginQuery glEndQuery glGetQueryiv case QueryType::AnySamplesConservative: GLES \u6269\u5c55 GL_EXT_occlusion_query_boolean glGenQueriesEXT glDeleteQueriesEXT glIsQueryEXT glBeginQueryEXT glEndQueryEXT glGetQueryivEXT glGetQueryObjectuivEXT","title":"inheritedQueries"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vertexpipelinestoresandatomics","text":"\u7528\u4e8e\u6a21\u62df\u5b9e\u73b0 transform feedback \u529f\u80fd, \u4f5c\u4e3a\u4e0d\u652f\u6301\u6269\u5c55 VK_EXT_ransform_feedback \u65f6\u7684\u66ff\u4ee3. \u4f46 es3.2 \u4e2d\u53ef\u80fd\u51fa\u73b0\u65e0\u6cd5\u652f\u6301\u529f\u80fd.","title":"vertexPipelineStoresAndAtomics"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#angle-vk-limits","text":"","title":"ANGLE: Vk Limits"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#maxperstagedescriptorstoragebuffers","text":"\u5f53\u524d\u503c \u671f\u5f85\u503c 8 12 / 16 ANGLE \u4e2d, Vulkan Limit: maxPerStageDescriptorStorageBuffers \u4e3a GLES \u540c\u65f6\u63d0\u4f9b StorageBuffers \u548c CounterBuffers, \u5bf9\u5e94\u7684 GLES \u7684 Limits \u4e3a: StorageBuffers: MAX_VERTEX_SHADER_STORAGE_BLOCKS MAX_FRAGMENT_SHADER_STORAGE_BLOCKS MAX_COMPUTE_SHADER_STORAGE_BLOCKS AtomicCounterBuffers: MAX_VERTEX_ATOMIC_COUNTER_BUFFERS MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS \u5404\u7ec4\u503c\u5206\u522b\u8ba1\u7b97, \u4f8b\u5982 VERTEX \u7684\u4e24\u8005\u76f8\u52a0\u4e3aBuffer \u7684 Limit \u503c: MAX_VERTEX_SHADER_STORAGE_BLOCKS + MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = maxPerStageDescriptorStorageBuffers, FRAGMENT, COMPUTE \u540c\u7406. (GEOMETRY \u7684 StorageBuffers \u5bf9\u5e94 vkLimit: maxPerStageResources) \u5728 ANGLE \u4e2d, \u671f\u5f85\u503c StorageBuffers >=4, AtomicCounterBuffers =8, \u56e0\u6b64\u5bf9 GLES 3.1 \u8981\u6c42 maxPerStageDescriptorStorageBuffers >=12 \u82e5\u4e0d\u6ee1\u8db3, \u9650\u5236\u7248\u672c\u4e3a3.0, \u5e76\u8bbe AtomicCounterBuffers \u4e3a 0. \u540c\u65f6, \u82e5\u6ee1\u8db3 AtomicCounterBuffers =8 \u540e, \u8981\u540c\u65f6\u6ee1\u8db3 v100 GLES Limits \u4e2d MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 8, \u5219\u9700 maxPerStageDescriptorStorageBuffers = 16 \u5bf9\u5e943.1\u529f\u80fd: MAX_VERTEX_SHADER_STORAGE_BLOCKS \u548c MAX_VERTEX_ATOMIC_COUNTER_BUFFERS \u9700\u8981 vk \u7279\u6027 vertexPipelineStoresAndAtomics, \u800c\u6b64\u7279\u6027\u5728\u652f\u6301 VK_EXT_TRANSFORM_FEEDBACK \u6269\u5c55\u65f6\u4e0d\u518d\u9700\u8981. \u56e0\u6b64\u5b9e\u73b0 VK_EXT_TRANSFORM_FEEDBACK \u540e\u8be5\u7ec4\u53ef\u5ffd\u7565 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS \u548c MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS \u9700\u8981 vk \u7279\u6027 fragmentStoresAndAtomics (v100\u5df2\u652f\u6301).","title":"maxPerStageDescriptorStorageBuffers"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#maxperstagedescriptoruniformbuffers","text":"\u5f53\u524d\u503c \u671f\u5f85\u503c 12 14 \u4e3a kReservedDriverUniformBindingCount, kReservedPerStageDefaultUniformBindingCount \u5404\u7559\u51fa1\u4e2a. \u5f71\u54cd GLES Limits: MAX_VERTEX_UNIFORM_BLOCKS MAX_FRAGMENT_UNIFORM_BLOCKS MAX_COMPUTE_UNIFORM_BLOCKS MAX_GEOMETRY_UNIFORM_BLOCKS MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS","title":"maxPerStageDescriptorUniformBuffers"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#maxdescriptorsetuniformbuffers","text":"\u5f53\u524d\u503c \u671f\u5f85\u503c 72 72+4 = 76 \u4e3a kReservedDriverUniformBindingCount , kReservedDefaultUniformBindingCount \u9884\u7559\u51fa1 + 3 = 4\u4e2a. constexpr uint32_t kTotalReservedUniformBuffers = kReservedDriverUniformBindingCount + kReservedDefaultUniformBindingCount; const int32_t maxCombinedUniformBuffers = LimitToInt(limitsVk.maxDescriptorSetUniformBuffers - kTotalReservedUniformBuffers); \u5f71\u54cd GLES Limits: MAX_UNIFORM_BUFFER_BINDINGS MAX_COMBINED_UNIFORM_BLOCKS","title":"maxDescriptorSetUniformBuffers"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#maxvertexoutputcomponents-maxfragmentinputcomponents","text":"\u5f53\u524d\u503c \u671f\u5f85\u503c 128 128 + 4*2 = 136 \u5f53\u524d\u503c 128, \u5047\u8bbe EXT \u5747\u5f97\u5230\u652f\u6301, \u4e14\u8981\u6ee1\u8db3GLES Limits, \u82e5 \u4e0d \u652f\u6301 VK_EXT_LINE_RASTERIZATION, \u5219\u9884\u7559 1 \u4e3a\u4e86\u652f\u6301 VK_EXT_TRANSFORM_FEEDBACK, \u9700\u8981\u9884\u7559 2 \u5f71\u54cd GLES Limits: MAX_VARYING_VECTORS \u9884\u7559\u524d 31\u521a\u597d\u6ee1\u8db3. MAX_VARYING_COMPONENTS \u9884\u7559\u524d 124 \u521a\u597d\u6ee1\u8db3. (Vector * 4 = Components ) // The max vertex output components should not include gl_Position. // The gles2.0 section 2.10 states that \"gl_Position is not a varying variable and does // not count against this limit.\", but the Vulkan spec has no such mention in its Built-in // vars section. It is implicit that we need to actually reserve it for Vulkan in that case. GLint reservedVaryingVectorCount = 1; // reserve 1 extra for ANGLEPosition when GLLineRasterization is enabled constexpr GLint kRservedVaryingForGLLineRasterization = 1; // reserve 2 extra for builtin varables when feedback is enabled // possible capturable out varable: gl_Position, gl_PointSize // https://www.khronos.org/registry/OpenGL/specs/es/3.1/GLSL_ES_Specification_3.10.withchanges.pdf // page 105 constexpr GLint kReservedVaryingForTransformFeedbackExtension = 2; if (getFeatures().basicGLLineRasterization.enabled) { reservedVaryingVectorCount += kRservedVaryingForGLLineRasterization; } if (getFeatures().supportsTransformFeedbackExtension.enabled) { reservedVaryingVectorCount += kReservedVaryingForTransformFeedbackExtension; } const GLint maxVaryingCount = std::min(limitsVk.maxVertexOutputComponents, limitsVk.maxFragmentInputComponents); // 128, 128 mNativeCaps.maxVaryingVectors = LimitToInt((maxVaryingCount / kComponentsPerVector(4)) - reservedVaryingVectorCount);","title":"maxVertexOutputComponents \u4e0e maxFragmentInputComponents"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#maxinterpolationoffset","text":"\u5f53\u524d\u503c \u671f\u5f85\u503c 0.4375 0.5","title":"maxInterpolationOffset"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#gles-limits","text":"\u672c\u8868\u57fa\u4e8e ANGLE \u5185\u7684\u8ba1\u7b97\u65b9\u5f0f, \u5e26\u5165 v100 \u7684 Vulkan Limits \u503c, \u68c0\u67e5\u7ed3\u679c\u662f\u5426\u6ee1\u8db3 GLES Limits \u7684\u8981\u6c42. [*] \u5e26\u6b64\u6807\u8bb0\u7684\u8ba1\u7b97\u516c\u5f0f\u57fa\u4e8e\u5047\u8bbe: \u4e0a\u9762\u63d0\u53ca\u7684\u6269\u5c55 TransForm_feedback \u548c Line_Rasterization \u5df2\u5f97\u5230\u652f\u6301. \u800c\u76f8\u5e94\u7684\u7531\u4e8e\u6a21\u62df\u7684Feature\u4e0d\u518d\u542f\u7528. maxPerStageDescriptorStorageBuffers \u4ee5 12 \u8ba1\u7b97 1 GLES Limits GLES Limits in V100 Vk(v100)\u503c\u5e26\u5165 ANGLE ANGLE \u8ba1\u7b97\u516c\u5f0f 2 SUBPIXEL_BITS 8 8 subPixelPrecisionBits 3 MAX_3D_TEXTURE_SIZE 256 256 maxImageDimension3D 4 MAX_TEXTURE_SIZE 8192 8192 min(maxFramebufferWidth, maxImageDimension2D); 5 MAX_ARRAY_TEXTURE_LAYERS 256 256 maxImageArrayLayers 6 MAX_TEXTURE_LOD_BIAS 14 14 maxSamplerLodBias 7 MAX_CUBE_MAP_TEXTURE_SIZE 8192 8192 maxImageDimensionCube 8 MAX_RENDERBUFFER_SIZE 8192 8192 min(maxImageDimension2D, maxFramebufferWidth, maxFramebufferHeight); 9 ALIASED_LINE_WIDTH_RANGE[0] 1 1 1 10 ALIASED_LINE_WIDTH_RANGE[1] 4095.9375 1 1 11 ALIASED_POINT_SIZE_RANGE[0] 1 1 max(1.0f, pointSizeRange[0]) 12 ALIASED_POINT_SIZE_RANGE[1] 1024 1024 pointSizeRange[1] 13 MULTISAMPLE_LINE_WIDTH_RANGE [1.0, 4095.9375] - - 14 MULTISAMPLE_LINE_WIDTH_GRANULARITY 0.125 - - 15 MAX_DRAW_BUFFERS 4 4 min(maxColorAttachments, maxFragmentOutputAttachments); 16 MAX_FRAMEBUFFER_WIDTH 8192 8192 maxFramebufferWidth 17 MAX_FRAMEBUFFER_HEIGHT 8192 8192 maxFramebufferHeight 18 MAX_FRAMEBUFFER_LAYERS 256 256 maxFramebufferLayers 19 MAX_FRAMEBUFFER_SAMPLES SAMPLECOUNT1 - SAMPLE_COUNT_4 4 \u540c maxSamples 21 MAX_COLOR_ATTACHMENTS 4 4 maxColorAttachments 22 MIN_FRAGMENT_INTERPOLATION_OFFSET -0.5 -0.5 minInterpolationOffset 23 MAX_FRAGMENT_INTERPOLATION_OFFSET 0.5 0.4375 maxInterpolationOffset 24 FRAGMENT_INTERPOLATION_OFFSET_BITS 4 4 subPixelInterpolationOffsetBits 25 MAX_VIEWPORT_DIMS[0] 8192 8192 maxViewportDimensions[0] 26 MAX_VIEWPORT_DIMS[1] 8192 8192 maxViewportDimensions[1] 27 MAX_SAMPLE_MASK_WORDS 1 1 maxSampleMaskWords 28 MAX_COLOR_TEXTURE_SAMPLES SAMPLECOUNT1 ??? SAMPLECOUNT1-SAMPLECOUNT4? sampledImageColorSampleCounts&31 29 SAMPLE_COUNT_4 - - 30 MAX_DEPTH_TEXTURE_SAMPLES SAMPLECOUNT1 ??? SAMPLECOUNT1-SAMPLECOUNT4? sampledImageDepthSampleCounts&31 31 SAMPLE_COUNT_4 - - 32 MAX_INTEGER_SAMPLES SAMPLECOUNT1 ??? SAMPLECOUNT1-SAMPLECOUNT4? sampledImageIntegerSampleCounts&31 33 SAMPLE_COUNT_4 - - 34 MAX_SERVER_WAIT_TIMEOUT 0 - UNIMPLEMENT 35 LAYER_PROVOKING_VERTEX FIRSTVERTEXCONVENTION - GL_LAST_VERTEX_CONVENTION_EXT 36 LAST_VERTEX_CONVENTION - -- 37 PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED FALSE - -- 38 MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 2047 2047 min(maxVertexInputAttributeOffset, (int16_max -1)) 39 MAX_VERTEX_ATTRIB_BINDINGS 16 16 maxVertexInputBindings 40 MAX_VERTEX_ATTRIB_STRIDE 2048 2048 min(maxVertexInputBindingStride, int16_max) 41 MAX_ELEMENTS_INDICES INT_MAX INT_MAX 42 MAX_ELEMENTS_VERTICES INT_MAX INT_MAX 43 MAX_ELEMENT_INDEX 0xFFFFFFFF UINT_MAX - 1 UINT_MAX - 1 44 MAX_TEXTURE_BUFFER_SIZE 2^24 ??? 224 maxTexelBufferElements 45 NUM_COMPRESSED_TEXTURE_FORMATS 49 -- -- // size of Compressed Texture Formats 46 COMPRESSED_TEXTURE_FORMATS -- -- 47 NUM_PROGRAM_BINARY_FORMATS 0 -- -- 48 PROGRAM_BINARY_FORMATS -- -- 49 NUM_SHADER_BINARY_FORMATS 0 -- -- 50 SHADER_BINARY_FORMATS -- -- 51 SHADER_COMPILER TRUE TRUE 52 TEXTURE_BUFFER_OFFSET_ALIGNMENT 256 256 minTexelBufferOffsetAlignment 53 MAX_TEXTURE_MAX_ANISOTROPY_EXT 16 16 maxSamplerAnisotropy 54 MAX_VERTEX_ATTRIBS 16 16 maxVertexInputAttributes 55 MAX_VERTEX_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 56 MAX_VERTEX_UNIFORM_VECTORS 256 1024 maxUniformBufferRange / (sizeof(float) *4) 57 MAX_VERTEX_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 58 MAX_VERTEX_OUTPUT_COMPONENTS 128 128 maxVertexOutputComponents 59 MAX_VERTEX_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 60 MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0 0 0* 61 MAX_VERTEX_ATOMIC_COUNTERS 0 0 0* 62 MAX_VERTEX_SHADER_STORAGE_BLOCKS 0 0 0* 63 MAX_TESS_GEN_LEVEL 64 -- 64 MAX_PATCH_VERTICES 32 -- 65 MAX_TESS_CONTROL_UNIFORM_COMPONENTS 1024 -- 66 MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 16 -- 67 MAX_TESS_CONTROL_OUTPUT_COMPONENTS 128 -- 68 MAX_TESS_PATCH_COMPONENTS 120 -- 69 MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 4096 -- 70 MAX_TESS_CONTROL_INPUT_COMPONENTS 128 -- 71 MAX_TESS_CONTROL_UNIFORM_BLOCKS 12 -- 72 MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0 -- 73 MAX_TESS_CONTROL_ATOMIC_COUNTERS 0 -- 74 MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0 -- 75 MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 1024 -- 76 MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 16 -- 77 MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 128 -- 78 MAX_TESS_EVALUATION_INPUT_COMPONENTS 128 -- 79 MAX_TESS_EVALUATION_UNIFORM_BLOCKS 12 -- 80 MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0 -- 81 MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0 -- 82 MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0 -- 83 MAX_GEOMETRY_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 84 MAX_GEOMETRY_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 85 MAX_GEOMETRY_INPUT_COMPONENTS 128 128 maxGeometryInputComponents 86 MAX_GEOMETRY_OUTPUT_COMPONENTS 128 128 maxGeometryOutputComponents 87 MAX_GEOMETRY_OUTPUT_VERTICES 256 256 maxGeometryOutputVertices 88 MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 1024 1024 maxGeometryTotalOutputComponents 89 MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 90 MAX_GEOMETRY_SHADER_INVOCATIONS 32 32 maxGeometryShaderInvocations 91 MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0 8* 8* 92 MAX_GEOMETRY_ATOMIC_COUNTERS 0 56 maxStorageBufferRange / sizeof(uint32_t) 93 MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0 45 maxPerStageResources-7 94 MAX_FRAGMENT_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 95 MAX_FRAGMENT_UNIFORM_VECTORS 256 1024 maxUniformBufferRange / (sizeof(float) *4) 96 MAX_FRAGMENT_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 97 MAX_FRAGMENT_INPUT_COMPONENTS 128 4,096\u202c maxUniformBufferRange / sizeof(float) 98 MAX_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 99 MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 1 8 8* 100 MAX_FRAGMENT_ATOMIC_COUNTERS 8 56 maxStorageBufferRange / sizeof(uint32_t) 101 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 8 4 4* 102 MIN_PROGRAM_TEXTURE_GATHER_OFFSET -8 -8 minTexelGatherOffset 103 MAX_PROGRAM_TEXTURE_GATHER_OFFSET 7 7 maxTexelGatherOffset 104 MIN_PROGRAM_TEXEL_OFFSET -8 -8 minTexelOffset 105 MAX_PROGRAM_TEXEL_OFFSET 7 7 maxTexelOffset 106 MAX_COMPUTE_WORK_GROUP_COUNT[0] 65535 65535 maxComputeWorkGroupCount[0] 107 MAX_COMPUTE_WORK_GROUP_COUNT[1] 65535 65535 maxComputeWorkGroupCount[1] 108 MAX_COMPUTE_WORK_GROUP_COUNT[2] 65535 65535 maxComputeWorkGroupCount[2] 109 MAX_COMPUTE_WORK_GROUP_SIZE[0] 1024 1024 [vulkan] maxComputeWorkGroupSize[0] 110 MAX_COMPUTE_WORK_GROUP_SIZE[1] 1024 1024 [vulkan] maxComputeWorkGroupSize[1] 111 MAX_COMPUTE_WORK_GROUP_SIZE[2] 64 64 [vulkan] maxComputeWorkGroupSize[2] 112 MAX_COMPUTE_WORK_GROUP_INVOCATIONS 1024 1024 [vulkan] maxComputeWorkGroupInvocations 113 MAX_COMPUTE_UNIFORM_BLOCKS 12 10 maxPerStageDescriptorUniformBuffers-2 114 MAX_COMPUTE_TEXTURE_IMAGE_UNITS 16 16 min(maxPerStageDescriptorSamplers, maxPerStageDescriptorSampledImages); 115 MAX_COMPUTE_SHARED_MEMORY_SIZE 32768 32768 maxComputeSharedMemorySize 116 MAX_COMPUTE_UNIFORM_COMPONENTS 1024 4,096\u202c maxUniformBufferRange / sizeof(float) 117 MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 1 8 8* 118 MAX_COMPUTE_ATOMIC_COUNTERS 8 56 maxStorageBufferRange / sizeof(uint32_t) 119 MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 120 MAX_COMPUTE_SHADER_STORAGE_BLOCKS 8 4 maxPerStageDescriptorStorageBuffers - 8 121 MAX_UNIFORM_BUFFER_BINDINGS 72 68 maxDescriptorSetUniformBuffers -4 122 MAX_UNIFORM_BLOCK_SIZE 16384 16384 maxUniformBufferRange 123 UNIFORM_BUFFER_OFFSET_ALIGNMENT 16 16 minUniformBufferOffsetAlignment 124 MAX_COMBINED_UNIFORM_BLOCKS 72 68 maxDescriptorSetUniformBuffers -4 125 MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 126 MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 50176 -- 127 MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 50176 -- 128 MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 129 MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 50176 45,056 (maxPerStageDescriptorUniformBuffers-2 + 1) * maxUniformBufferRange / sizeof(float) 130 MAX_VARYING_COMPONENTS 124 116 (min(maxVertexOutputComponents, maxFragmentInputComponents) /4 - 3)*4 131 MAX_VARYING_VECTORS 31 29 min(maxVertexOutputComponents, maxFragmentInputComponents) /4 - 3 132 MAX_COMBINED_TEXTURE_IMAGE_UNITS 96 96 min(maxDescriptorSetSamplers, maxDescriptorSetSampledImages); 133 MAX_COMBINED_SHADER_OUTPUT_RESOURCES 20 45 maxPerStageResources-7 134 MAX_UNIFORM_LOCATIONS 1024 1024 maxUniformBufferRange / (sizeof(float) *4) 135 MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 1 8 8* 136 MAX_ATOMIC_COUNTER_BUFFER_SIZE 32 227 maxStorageBufferRange 137 MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 1 8 8* 138 MAX_COMBINED_ATOMIC_COUNTERS 8 56 maxStorageBufferRange / sizeof(uint32_t) 139 MAX_IMAGE_UNITS 8 48 maxDescriptorSetStorageImages 140 MAX_VERTEX_IMAGE_UNIFORMS 0 0 0* 141 MAX_TESS_CONTROL_IMAGE_UNIFORMS 0 -- -- 142 MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0 -- -- 143 MAX_GEOMETRY_IMAGE_UNIFORMS 0 0 0* 144 MAX_FRAGMENT_IMAGE_UNIFORMS 8 8 maxPerStageDescriptorStorageImages* 145 MAX_COMPUTE_IMAGE_UNIFORMS 8 8 maxPerStageDescriptorStorageImages* 146 MAX_COMBINED_IMAGE_UNIFORMS 8 48 maxDescriptorSetStorageImages 147 MAX_SHADER_STORAGE_BUFFER_BINDINGS 4 40 maxDescriptorSetStorageBuffers - 8* 148 MAX_SHADER_STORAGE_BLOCK_SIZE 2^27 ??? 227 maxStorageBufferRange 149 MAX_COMBINED_SHADER_STORAGE_BLOCKS 8 40 maxDescriptorSetStorageBuffers - 8* 150 SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 256 256 minStorageBufferOffsetAlignment 151 MAX_LABEL_LENGTH 256 1024 1024 152 MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 64 128 128 153 MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 4 4 4 154 MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 4 4 4 155 MAX_SAMPLES 4 4 SAMPLE_COUNT_1 - SAMPLE_COUNT_4 156 MAX_SERVER_WAIT_TIMEOUT 0 -- UNIMPLEMENT 157 MAX_VIEWS_OVR 6 1 1","title":"\u9644\u8868: GLES Limits \u6ee1\u8db3\u60c5\u51b5\u8be6\u60c5"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#properties","text":"// Provided by VK_VERSION_1_0 typedef struct VkQueueFamilyProperties { VkQueueFlags queueFlags; uint32_t queueCount; uint32_t timestampValidBits; VkExtent3D minImageTransferGranularity; } VkQueueFamilyProperties; GL_EXT_disjoint_timer_query disjointTimerQuery VkQueueFamilyProperties. timestampValidBits > 0","title":"\u5176\u4ed6 Properties"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#_3","text":"","title":"\u9644\u5f55"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#v100-gles-extension","text":"\u4ece GLES Extensions \u89c6\u89d2, \u67e5\u8be2\u6240\u9700\u7684 Vk \u652f\u6301. OpenGL ES Extension in v100 ANGLE \u652f\u6301 ANGLE \u652f\u6301\u6761\u4ef6 Vulkan (v100) \u6ee1\u8db3 GL_EXT_multi_draw_indirect UNIMPLEMENTED GL_EXT_debug_marker Y GL_ARM_rgba8 GL_ARM_mali_shader_binary GL_OES_depth24 Y GL_OES_depth_texture Y GL_OES_depth_texture_cube_map Y GL_OES_packed_depth_stencil Y GL_OES_rgb8_rgba8 Y GL_EXT_read_format_bgra Y GL_OES_compressed_paletted_texture GL_OES_compressed_ETC1_RGB8_texture Y GL_OES_standard_derivatives Y GL_OES_EGL_image Y GL_OES_EGL_image_external Y GL_OES_EGL_image_external_essl3 Y GL_OES_EGL_sync Y GL_OES_texture_npot Y GL_OES_vertex_half_float Y GL_OES_required_internalformat GL_OES_vertex_array_object Y GL_OES_mapbuffer Y GL_EXT_texture_format_BGRA8888 Y GL_EXT_texture_rg Y GL_EXT_texture_type_2_10_10_10_REV Y GL_OES_fbo_render_mipmap Y GL_OES_element_index_uint Y GL_EXT_shadow_samplers Y GL_KHR_texture_compression_astc_ldr GL_KHR_debug Y GL_EXT_occlusion_query_boolean Y GL_EXT_disjoint_timer_query Y GL_EXT_blend_minmax Y GL_EXT_discard_framebuffer Y GL_OES_get_program_binary Y GL_OES_texture_3D Y GL_EXT_texture_storage Y GL_EXT_multisampled_render_to_texture Y GL_OES_surfaceless_context Y GL_OES_texture_stencil8 Y GL_EXT_shader_pixel_local_storage GL_ARM_shader_framebuffer_fetch GL_ARM_shader_framebuffer_fetch_depth_stencil GL_EXT_shader_framebuffer_fetch_non_coherent GL_ARM_mali_program_binary GL_EXT_sRGB Y GL_EXT_sRGB_write_control GL_EXT_texture_sRGB_decode Y GL_EXT_texture_sRGB_R8 Y GL_EXT_texture_sRGB_RG8 GL_KHR_blend_equation_advanced GL_KHR_blend_equation_advanced_coherent GL_OES_texture_storage_multisample_2d_array Y GL_OES_shader_image_atomic Y GL_EXT_robustness Y GL_EXT_draw_buffers_indexed Y GL_OES_draw_buffers_indexed Y GL_EXT_texture_border_clamp GL_OES_texture_border_clamp GL_EXT_texture_cube_map_array Y GL_OES_texture_cube_map_array Y GL_OES_sample_variables Y GL_OES_sample_shading Y GL_OES_shader_multisample_interpolation GL_EXT_shader_io_blocks GL_OES_shader_io_blocks GL_EXT_tessellation_shader GL_OES_tessellation_shader GL_EXT_primitive_bounding_box GL_OES_primitive_bounding_box GL_EXT_geometry_shader Y GL_OES_geometry_shader GL_ANDROID_extension_pack_es31a GL_EXT_gpu_shader5 Y GL_OES_gpu_shader5 GL_EXT_texture_buffer Y GL_OES_texture_buffer Y GL_EXT_copy_image Y GL_OES_copy_image GL_EXT_shader_non_constant_global_initializers Y GL_EXT_color_buffer_half_float Y GL_EXT_color_buffer_float Y GL_EXT_YUV_target GL_OVR_multiview GL_OVR_multiview2 GL_OVR_multiview_multisampled_render_to_texture GL_KHR_robustness GL_KHR_robust_buffer_access_behavior GL_EXT_draw_elements_base_vertex Y GL_OES_draw_elements_base_vertex Y GL_EXT_protected_textures GL_EXT_geometry_point_size GL_OES_geometry_point_size GL_EXT_tessellation_point_size GL_OES_tessellation_point_size GL_OES_draw_texture","title":"v100 GLES Extension \u652f\u6301\u60c5\u51b5"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#v100-egl-extension","text":"EGL extensions EGL_KHR_get_all_proc_addresses EGL_ANDROID_presentation_time EGL_KHR_swap_buffes_witn_damage EGL_ANDROID_get_native_client_buffer EGL_ANDROID_front_buffer_auto_refresh EGL_ANDROID_get_frame_timestamps EGL_KHR_image EGL_KHR_image_base EGL_KHR_gl_colorspace EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_gl_renderbuffer_image EGL_KHR_fence_sync EGL_KHR_create_context EGL_KHR_config_attribs EGL_KHR_surfaceless_context EGL_EXT_create_context_robustness EGL_ANDROID_image_native_buffer EGL_KHR_wait_sync EGL_ANDROID_recordable EGL_KHR_partial_update EGL_KHR_mutable_render_buffer EGL_EXT_protected_content EGL_IMG_context_priority","title":"v100 EGL Extension"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#angle-vk-features_1","text":"","title":"ANGLE \u4e2d\u542f\u7528\u7684 Vk Features"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#vulkan_1_0-features","text":"// Select additional features to be enabled. mPhysicalDeviceFeatures{ // Used to support cubemap array: only enable when not SwiftShader or not Qualcomm imageCubeArray; // Used to support framebuffers with multiple attachments: independentBlend; // Used to support robust buffer access: robustBufferAccess; // Used to support Anisotropic filtering: samplerAnisotropy; // Used to support wide lines: wideLines; // Used to emulate transform feedback: vertexPipelineStoresAndAtomics; // Used to implement storage buffers and images in the fragment shader: fragmentStoresAndAtomics; // Used to support geometry shaders: geometryShader // Used to support EXT_gpu_shader5: shaderImageGatherExtended; // Used to support EXT_gpu_shader5: shaderUniformBufferArrayDynamicIndexing // Used to support EXT_gpu_shader5 and sampler array of array emulation: shaderSampledImageArrayDynamicIndexing; // Used to support atomic counter emulation: shaderStorageBufferArrayDynamicIndexing; // Used to support APPLE_clip_distance shaderClipDistance // Used to support OES_sample_shading sampleRateShading; // Used to support depth clears through draw calls. depthClamp; // if (!vk::CommandBuffer::ExecutesInline()) inheritedQueries; // Used to support OES_sample_variables sampleRateShading; } Extension Features: VkPhysicalDeviceLineRasterizationFeaturesEXT VkPhysicalDeviceProvokingVertexFeaturesEXT VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT VkPhysicalDeviceTransformFeedbackFeaturesEXT VkPhysicalDeviceIndexTypeUint8FeaturesEXT VkPhysicalDeviceShaderFloat16Int8FeaturesKHR VkPhysicalDeviceSamplerYcbcrConversionFeatures","title":"Vulkan_1_0 Features:"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#8-appendix","text":"","title":"8. Appendix"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#81-capability","text":"The recommended value for vulkan 1.1 features and limits report for HiVoyager V100 chip are listed in this chapter.","title":"8.1. Capability"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#811-physical-device-features","text":"Feature Supported on HiVoyager V100 robustBufferAccess yes fullDrawIndexUint32 yes imageCubeArray yes independentBlend yes geometryShader yes tessellationShader yes sampleRateShading yes dualSrcBlend no logicOp no multiDrawIndirect yes drawIndirectFirstInstance yes depthClamp yes depthBiasClamp yes fillModeNonSolid yes depthBounds yes wideLines yes largePoints yes alphaToOne yes multiViewport no samplerAnisotropy yes textureCompressionETC2 yes textureCompressionASTC_LDR yes textureCompressionBC no occlusionQueryPrecise yes pipelineStatisticsQuery no vertexPipelineStoresAndAtomics no fragmentStoresAndAtomics yes shaderTessellationAndGeometryPointSize yes shaderImageGatherExtended yes shaderStorageImageExtendedFormats yes shaderStorageImageMultisample no shaderStorageImageReadWithoutFormat yes shaderStorageImageWriteWithoutFormat yes shaderUniformBufferArrayDynamicIndexing yes shaderSampledImageArrayDynamicIndexing yes shaderStorageBufferArrayDynamicIndexing yes shaderStorageImageArrayDynamicIndexing yes shaderClipDistance yes shaderCullDistance yes shaderFloat64 no shaderInt64 no shaderInt16 yes shaderResourceResidency no shaderResourceMinLod no sparseBinding no sparseResidencyBuffer no sparseResidencyImage2D no sparseResidencyImage3D no sparseResidency2Samples no sparseResidency4Samples no sparseResidency8Samples no sparseResidency16Samples no sparseResidencyAliased no variableMultisampleRate no inheritedQueries no","title":"8.1.1. Physical Device Features"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#812-physical-device-limits","text":"Name Limit of HiVoyager V100 maxImageDimension1D 8192 maxImageDimension2D 8192[ 1 ] maxImageDimension3D 256 maxImageDimensionCube 8192 maxImageArrayLayers 256 maxTexelBufferElements 224 maxUniformBufferRange 16384 maxStorageBufferRange 227 maxPushConstantsSize 256 maxMemoryAllocationCount 232-1 maxSamplerAllocationCount 223 bufferImageGranularity 4096 sparseAddressSpaceSize 0 maxBoundDescriptorSets 4 maxPerStageDescriptorSamplers 16 maxPerStageDescriptorUniformBuffers 12 maxPerStageDescriptorStorageBuffers 8 maxPerStageDescriptorSampledImages 16 maxPerStageDescriptorStorageImages 8[ 2 ] maxPerStageDescriptorInputAttachments 4 maxPerStageResources 52 maxDescriptorSetSamplers 96 maxDescriptorSetUniformBuffers 72 maxDescriptorSetUniformBuffersDynamic 8 maxDescriptorSetStorageBuffers 48 maxDescriptorSetStorageBuffersDynamic 4 maxDescriptorSetSampledImages 96 maxDescriptorSetStorageImages 48 maxDescriptorSetInputAttachments 4 maxVertexInputAttributes 16 maxVertexInputBindings 16 maxVertexInputAttributeOffset 2047 maxVertexInputBindingStride 2048 maxVertexOutputComponents 128 maxTessellationGenerationLevel 64 maxTessellationPatchSize 32 maxTessellationControlPerVertexInputComponents 128 maxTessellationControlPerVertexOutputComponents 128 maxTessellationControlPerPatchOutputComponents 120 maxTessellationControlTotalOutputComponents 4096 maxTessellationEvaluationInputComponents 128 maxTessellationEvaluationOutputComponents 128 maxGeometryShaderInvocations 32 maxGeometryInputComponents 128 maxGeometryOutputComponents 128 maxGeometryOutputVertices 256 maxGeometryTotalOutputComponents 1024 maxFragmentInputComponents 128 maxFragmentOutputAttachments 4 maxFragmentDualSrcAttachments 1 maxFragmentCombinedOutputResources 20 maxComputeSharedMemorySize 32768 maxComputeWorkGroupCount[0] 65535 maxComputeWorkGroupCount[1] 65535 maxComputeWorkGroupCount[2] 65535 maxComputeWorkGroupInvocations 384 [v120, opencl] maxComputeWorkGroupInvocations 256 [v100, opencl] maxComputeWorkGroupInvocations 1024 [vulkan] maxComputeWorkGroupSize[0] 256 [opencl] maxComputeWorkGroupSize[0] 1024 [vulkan] maxComputeWorkGroupSize[1] 256 [v120, opencl] maxComputeWorkGroupSize[1] 32 [v100, opencl] maxComputeWorkGroupSize[1] 1024 [vulkan] maxComputeWorkGroupSize[2] 64 [v120, opencl] maxComputeWorkGroupSize[2] 2 [v100, opencl] maxComputeWorkGroupSize[2] 64 [vulkan] subPixelPrecisionBits 8 subTexelPrecisionBits 8 mipmapPrecisionBits 6 maxDrawIndexedIndexValue 0xFFFFFFFF maxDrawIndirectCount 232-1 maxSamplerLodBias 14 maxSamplerAnisotropy 16 maxViewports 1 maxViewportDimensions[0] 8192 maxViewportDimensions[1] 8192 viewportBoundsRange[0] -16384 viewportBoundsRange[1] 16383 viewportSubPixelBits 0 minMemoryMapAlignment 64 minTexelBufferOffsetAlignment 256 minUniformBufferOffsetAlignment 16 minStorageBufferOffsetAlignment 256 minTexelOffset -8 maxTexelOffset 7 minTexelGatherOffset -8 maxTexelGatherOffset 7 minInterpolationOffset -0.5 maxInterpolationOffset 0.4375 subPixelInterpolationOffsetBits 4 maxFramebufferWidth 8192 maxFramebufferHeight 8192 maxFramebufferLayers 256 framebufferColorSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 framebufferDepthSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 framebufferStencilSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 framebufferNoAttachmentsSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 maxColorAttachments 4 sampledImageColorSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 sampledImageIntegerSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 sampledImageDepthSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 sampledImageStencilSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 storageImageSampleCounts SAMPLE_COUNT_1 SAMPLE_COUNT_4 maxSampleMaskWords 1 timestampComputeAndGraphics yes timestampPeriod 52.083333333 (1000/19.2) maxClipDistances 8 maxCullDistances 8 maxCombinedClipAndCullDistances 8 discreteQueuePriorities 2 pointSizeRange[0] 1.0 pointSizeRange[1] 1024.0 lineWidthRange[0] 1.0 lineWidthRange[1] 4095.9375 pointSizeGranularity 0.1 lineWidthGranularity 0.1 strictLines yes standardSampleLocations yes optimalBufferCopyOffsetAlignment 512 optimalBufferCopyRowPitchAlignment 512 nonCoherentAtomSize 64 maxUpdateAfterBindDescriptorsInAllPools 500000 maxMultiviewViewCount 6 Actually the hardware ability of maxImageDimension2D is 16384 . According to driver\u2019s requirement, maxImageDimension2D is set to 8192 . Do not support image load store for vertex pipeline in GLES; Do not support image store for vertex pipeline in Vulkan.","title":"8.1.2. Physical Device Limits"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#813-physical-device-limits-opengles","text":"Name Limit of HiVoyager V100 SUBPIXEL_BITS 8 MAX_3D_TEXTURE_SIZE 256 MAX_TEXTURE_SIZE 8192 MAX_ARRAY_TEXTURE_LAYERS 256 MAX_TEXTURE_LOD_BIAS 14 MAX_CUBE_MAP_TEXTURE_SIZE 8192 MAX_RENDERBUFFER_SIZE 8192 ALIASED_LINE_WIDTH_RANGE[0] 1.0 ALIASED_LINE_WIDTH_RANGE[1] 4095.9375 ALIASED_POINT_SIZE_RANGE[0] 1.0 ALIASED_POINT_SIZE_RANGE[1] 1024.0 MULTISAMPLE_LINE_WIDTH_RANGE [1.0, 4095.9375] MULTISAMPLE_LINE_WIDTH_GRANULARITY 0.125 MAX_DRAW_BUFFERS 4 MAX_FRAMEBUFFER_WIDTH 8192 MAX_FRAMEBUFFER_HEIGHT 8192 MAX_FRAMEBUFFER_LAYERS 256 MAX_FRAMEBUFFER_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_COLOR_ATTACHMENTS 4 MIN_FRAGMENT_INTERPOLATION_OFFSET -0.5 MAX_FRAGMENT_INTERPOLATION_OFFSET 0.5 FRAGMENT_INTERPOLATION_OFFSET_BITS 4 MAX_VIEWPORT_DIMS[0] 8192 MAX_VIEWPORT_DIMS[1] 8192 MAX_SAMPLE_MASK_WORDS 1 MAX_COLOR_TEXTURE_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_DEPTH_TEXTURE_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_INTEGER_SAMPLES SAMPLE_COUNT_1 SAMPLE_COUNT_4 MAX_SERVER_WAIT_TIMEOUT 0 LAYER_PROVOKING_VERTEX FIRST_VERTEX_CONVENTION LAST_VERTEX_CONVENTION PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED FALSE MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 2047 MAX_VERTEX_ATTRIB_BINDINGS 16 MAX_VERTEX_ATTRIB_STRIDE 2048 MAX_ELEMENTS_INDICES MAX_ELEMENTS_VERTICES MAX_ELEMENT_INDEX 0xFFFFFFFF MAX_TEXTURE_BUFFER_SIZE 2^24 NUM_COMPRESSED_TEXTURE_FORMATS 49 COMPRESSED_TEXTURE_FORMATS NUM_PROGRAM_BINARY_FORMATS 0 PROGRAM_BINARY_FORMATS NUM_SHADER_BINARY_FORMATS 0 SHADER_BINARY_FORMATS SHADER_COMPILER TEXTURE_BUFFER_OFFSET_ALIGNMENT 256 MAX_TEXTURE_MAX_ANISOTROPY_EXT 16 MAX_VERTEX_ATTRIBS 16 MAX_VERTEX_UNIFORM_COMPONENTS 1024 MAX_VERTEX_UNIFORM_VECTORS 256 MAX_VERTEX_UNIFORM_BLOCKS 12 MAX_VERTEX_OUTPUT_COMPONENTS 128 MAX_VERTEX_TEXTURE_IMAGE_UNITS 16 MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0 MAX_VERTEX_ATOMIC_COUNTERS 0 MAX_VERTEX_SHADER_STORAGE_BLOCKS 0 MAX_TESS_GEN_LEVEL 64 MAX_PATCH_VERTICES 32 MAX_TESS_CONTROL_UNIFORM_COMPONENTS 1024 MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 16 MAX_TESS_CONTROL_OUTPUT_COMPONENTS 128 MAX_TESS_PATCH_COMPONENTS 120 MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 4096 MAX_TESS_CONTROL_INPUT_COMPONENTS 128 MAX_TESS_CONTROL_UNIFORM_BLOCKS 12 MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0 MAX_TESS_CONTROL_ATOMIC_COUNTERS 0 MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0 MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 1024 MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 16 MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 128 MAX_TESS_EVALUATION_INPUT_COMPONENTS 128 MAX_TESS_EVALUATION_UNIFORM_BLOCKS 12 MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0 MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0 MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0 MAX_GEOMETRY_UNIFORM_COMPONENTS 1024 MAX_GEOMETRY_UNIFORM_BLOCKS 12 MAX_GEOMETRY_INPUT_COMPONENTS 128 MAX_GEOMETRY_OUTPUT_COMPONENTS 128 MAX_GEOMETRY_OUTPUT_VERTICES 256 MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 1024 MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 16 MAX_GEOMETRY_SHADER_INVOCATIONS 32 MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0 MAX_GEOMETRY_ATOMIC_COUNTERS 0 MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0 MAX_FRAGMENT_UNIFORM_COMPONENTS 1024 MAX_FRAGMENT_UNIFORM_VECTORS 256 MAX_FRAGMENT_UNIFORM_BLOCKS 12 MAX_FRAGMENT_INPUT_COMPONENTS 128 MAX_TEXTURE_IMAGE_UNITS 16 MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 1 MAX_FRAGMENT_ATOMIC_COUNTERS 8 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 8 MIN_PROGRAM_TEXTURE_GATHER_OFFSET -8 MAX_PROGRAM_TEXTURE_GATHER_OFFSET 7 MIN_PROGRAM_TEXEL_OFFSET -8 MAX_PROGRAM_TEXEL_OFFSET 7 MAX_COMPUTE_WORK_GROUP_COUNT[0] 65535 MAX_COMPUTE_WORK_GROUP_COUNT[1] 65535 MAX_COMPUTE_WORK_GROUP_COUNT[2] 65535 MAX_COMPUTE_WORK_GROUP_SIZE[0] 1024 MAX_COMPUTE_WORK_GROUP_SIZE[1] 1024 MAX_COMPUTE_WORK_GROUP_SIZE[2] 64 MAX_COMPUTE_WORK_GROUP_INVOCATIONS 1024 MAX_COMPUTE_UNIFORM_BLOCKS 12 MAX_COMPUTE_TEXTURE_IMAGE_UNITS 16 MAX_COMPUTE_SHARED_MEMORY_SIZE 32768 MAX_COMPUTE_UNIFORM_COMPONENTS 1024 MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 1 MAX_COMPUTE_ATOMIC_COUNTERS 8 MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 50176 MAX_COMPUTE_SHADER_STORAGE_BLOCKS 8 MAX_UNIFORM_BUFFER_BINDINGS 72 MAX_UNIFORM_BLOCK_SIZE 16384 UNIFORM_BUFFER_OFFSET_ALIGNMENT 16 MAX_COMBINED_UNIFORM_BLOCKS 72 MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 50176 MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 50176 MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 50176 MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 50176 MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 50176 MAX_VARYING_COMPONENTS 124 MAX_VARYING_VECTORS 31 MAX_COMBINED_TEXTURE_IMAGE_UNITS 96 MAX_COMBINED_SHADER_OUTPUT_RESOURCES 20 MAX_UNIFORM_LOCATIONS 1024 MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 1 MAX_ATOMIC_COUNTER_BUFFER_SIZE 32 MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 1 MAX_COMBINED_ATOMIC_COUNTERS 8 MAX_IMAGE_UNITS 8 MAX_VERTEX_IMAGE_UNIFORMS 0 MAX_TESS_CONTROL_IMAGE_UNIFORMS 0 MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0 MAX_GEOMETRY_IMAGE_UNIFORMS 0 MAX_FRAGMENT_IMAGE_UNIFORMS 8 MAX_COMPUTE_IMAGE_UNIFORMS 8 MAX_COMBINED_IMAGE_UNIFORMS 8 MAX_SHADER_STORAGE_BUFFER_BINDINGS 4 MAX_SHADER_STORAGE_BLOCK_SIZE 2^27 MAX_COMBINED_SHADER_STORAGE_BLOCKS 8 SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 256 MAX_LABEL_LENGTH 256 MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 64 MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 4 MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 4 MAX_SAMPLES 4 MAX_SERVER_WAIT_TIMEOUT 0 MAX_VIEWS_OVR 6","title":"8.1.3. Physical Device Limits OpenGLES"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#82-extension","text":"OpenGL ES, EGL and Vulkan extension for HiVoyager V100 chip are listed in this chapter.","title":"8.2. Extension"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#821-opengl-es-extension","text":"OpenGL ES Extension GL_EXT_multi_draw_indirect GL_EXT_debug_marker GL_ARM_rgba8 GL_ARM_mali_shader_binary GL_OES_depth24 GL_OES_depth_texture GL_OES_depth_texture_cube_map GL_OES_packed_depth_stencil GL_OES_rgb8_rgba8 GL_EXT_read_format_bgra GL_OES_compressed_paletted_texture GL_OES_compressed_ETC1_RGB8_texture GL_OES_standard_derivatives GL_OES_EGL_image GL_OES_EGL_image_external GL_OES_EGL_image_external_essl3 GL_OES_EGL_sync GL_OES_texture_npot GL_OES_vertex_half_float GL_OES_required_internalformat GL_OES_vertex_array_object GL_OES_mapbuffer GL_EXT_texture_format_BGRA8888 GL_EXT_texture_rg GL_EXT_texture_type_2_10_10_10_REV GL_OES_fbo_render_mipmap GL_OES_element_index_uint GL_EXT_shadow_samplers GL_KHR_texture_compression_astc_ldr GL_KHR_debug GL_EXT_occlusion_query_boolean GL_EXT_disjoint_timer_query GL_EXT_blend_minmax GL_EXT_discard_framebuffer GL_OES_get_program_binary GL_OES_texture_3D GL_EXT_texture_storage GL_EXT_multisampled_render_to_texture GL_OES_surfaceless_context GL_OES_texture_stencil8 GL_EXT_shader_pixel_local_storage GL_ARM_shader_framebuffer_fetch GL_ARM_shader_framebuffer_fetch_depth_stencil GL_EXT_shader_framebuffer_fetch_non_coherent GL_ARM_mali_program_binary GL_EXT_sRGB GL_EXT_sRGB_write_control GL_EXT_texture_sRGB_decode GL_EXT_texture_sRGB_R8 GL_EXT_texture_sRGB_RG8 GL_KHR_blend_equation_advanced GL_KHR_blend_equation_advanced_coherent GL_OES_texture_storage_multisample_2d_array GL_OES_shader_image_atomic GL_EXT_robustness GL_EXT_draw_buffers_indexed GL_OES_draw_buffers_indexed GL_EXT_texture_border_clamp GL_OES_texture_border_clamp GL_EXT_texture_cube_map_array GL_OES_texture_cube_map_array GL_OES_sample_variables GL_OES_sample_shading GL_OES_shader_multisample_interpolation GL_EXT_shader_io_blocks GL_OES_shader_io_blocks GL_EXT_tessellation_shader GL_OES_tessellation_shader GL_EXT_primitive_bounding_box GL_OES_primitive_bounding_box GL_EXT_geometry_shader GL_OES_geometry_shader GL_ANDROID_extension_pack_es31a GL_EXT_gpu_shader5 GL_OES_gpu_shader5 GL_EXT_texture_buffer GL_OES_texture_buffer GL_EXT_copy_image GL_OES_copy_image GL_EXT_shader_non_constant_global_initializers GL_EXT_color_buffer_half_float GL_EXT_color_buffer_float GL_EXT_YUV_target GL_OVR_multiview GL_OVR_multiview2 GL_OVR_multiview_multisampled_render_to_texture GL_KHR_robustness GL_KHR_robust_buffer_access_behavior GL_EXT_draw_elements_base_vertex GL_OES_draw_elements_base_vertex GL_EXT_protected_textures GL_EXT_geometry_point_size GL_OES_geometry_point_size GL_EXT_tessellation_point_size GL_OES_tessellation_point_size GL_OES_draw_texture","title":"8.2.1. OpenGL ES Extension"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#822-egl-extension","text":"EGL extensions EGL_KHR_get_all_proc_addresses EGL_ANDROID_presentation_time EGL_KHR_swap_buffes_witn_damage EGL_ANDROID_get_native_client_buffer EGL_ANDROID_front_buffer_auto_refresh EGL_ANDROID_get_frame_timestamps EGL_KHR_image EGL_KHR_image_base EGL_KHR_gl_colorspace EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_gl_renderbuffer_image EGL_KHR_fence_sync EGL_KHR_create_context EGL_KHR_config_attribs EGL_KHR_surfaceless_context EGL_EXT_create_context_robustness EGL_ANDROID_image_native_buffer EGL_KHR_wait_sync EGL_ANDROID_recordable EGL_KHR_partial_update EGL_KHR_mutable_render_buffer EGL_EXT_protected_content EGL_IMG_context_priority","title":"8.2.2. EGL Extension"},{"location":"ANGLE/ANGLE_VK_Extensions%E5%88%86%E6%9E%90/#823-vulkan-extension","text":"Vulkan Extension storageBuffer8BitAccess[ 1 ] m[ 2 ] VK_KHR_create_renderpass2 [ 3 ] M VK_KHR_depth_stencil_resolve M supportedDepthResolveModes m supportedStencilResolveModes m VK_KHR_driver_properties M VK_KHR_image_format_list M VK_KHR_imageless_framebuffer M VK_KHR_separate_depth_stencil_layouts M VK_KHR_spirv_1_4 M VK_KHR_timeline_semaphore M VK_KHR_uniform_buffer_standard_layout M uniformBufferStandardLayout M VK_KHR_vulkan_memory_model M vulkanMemoryModel M VK_EXT_buffer_device_address M shaderUniformTexelBufferArrayDynamicIndexing m shaderStorageTexelBufferArrayDynamicIndexing m shaderSampledImageArrayNonUniformIndexing m shaderStorageBufferArrayNonUniformIndexing m shaderUniformTexelBufferArrayNonUniformIndexing m descriptorBindingSampledImageUpdateAfterBind m descriptorBindingStorageBufferUpdateAfterBind m descriptorBindingUniformTexelBufferUpdateAfterBind m descriptorBindingStorageTexelBufferUpdateAfterBind m descriptorBindingUpdateUnusedWhilePending m descriptorBindingPartiallyBound m descriptorBindingVariableDescriptorCount m VK_EXT_host_query_reset M VK_EXT_separate_stencil_usage M VK_KHR_16bit_storage M VK_KHR_bind_memory2 M VK_KHR_dedicated_allocation M VK_KHR_descriptor_update_template M VK_KHR_device_group M VK_KHR_device_group_creation M VK_KHR_external_fence M VK_KHR_external_fence_capabilities M VK_KHR_external_memory M VK_KHR_external_memory_capabilities M VK_KHR_external_semaphore M VK_KHR_external_semaphore_capabilities M VK_KHR_get_memory_requirements2 M VK_KHR_get_physical_device_properties2 M VK_KHR_maintenance1 M VK_KHR_maintenance2 M VK_KHR_maintenance3 M VK_KHR_multiview M multiview m VK_KHR_relaxed_block_layout M VK_KHR_sampler_ycbcr_conversion M VK_KHR_shader_draw_parameters M VK_KHR_storage_buffer_storage_class M VK_KHR_variable_pointers M subgroup M protected memory M instance version enumeration M VkPhysicalDeviceVulkan12Features M imagelessFramebuffer m uniformBufferStandardLayout m separateDepthStencilLayouts m hostQueryReset m timelineSemaphore m subgroupBroadcastDynamicId m VkPhysicalDeviceVulkan11Features M storageBuffer16BitAccess m multiview m VkPhysicalDeviceFeatures M robustBufferAccess M VkPhysicalDeviceSparseProperties O[ 4 ] VkPhysicalDeviceLimits M Linear Formats [ 5 ] M Optimal Formats [ 5 ] M Buffer Formats [ 5 ] M Lowercase character means this is subfunction of the above vulkan extension. M/m means current extension MUST support. Capital character means this is a main vulkan extension. O means current extension OPTIONALLY support. Details of Linear Formats, Optimal Formats and Buffer Formats are shown in Format_constraint_table_1 and Format_constraint_table_2 .","title":"8.2.3. Vulkan Extension"},{"location":"ANGLE/SRC_Extentions/","text":"// Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, VK_FORMAT_R8_UNORM = 9, VK_FORMAT_R8_SNORM = 10, VK_FORMAT_R8_USCALED = 11, VK_FORMAT_R8_SSCALED = 12, VK_FORMAT_R8_UINT = 13, VK_FORMAT_R8_SINT = 14, VK_FORMAT_R8_SRGB = 15, VK_FORMAT_R8G8_UNORM = 16, VK_FORMAT_R8G8_SNORM = 17, VK_FORMAT_R8G8_USCALED = 18, VK_FORMAT_R8G8_SSCALED = 19, VK_FORMAT_R8G8_UINT = 20, VK_FORMAT_R8G8_SINT = 21, VK_FORMAT_R8G8_SRGB = 22, VK_FORMAT_R8G8B8_UNORM = 23, VK_FORMAT_R8G8B8_SNORM = 24, VK_FORMAT_R8G8B8_USCALED = 25, VK_FORMAT_R8G8B8_SSCALED = 26, VK_FORMAT_R8G8B8_UINT = 27, VK_FORMAT_R8G8B8_SINT = 28, VK_FORMAT_R8G8B8_SRGB = 29, VK_FORMAT_B8G8R8_UNORM = 30, VK_FORMAT_B8G8R8_SNORM = 31, VK_FORMAT_B8G8R8_USCALED = 32, VK_FORMAT_B8G8R8_SSCALED = 33, VK_FORMAT_B8G8R8_UINT = 34, VK_FORMAT_B8G8R8_SINT = 35, VK_FORMAT_B8G8R8_SRGB = 36, VK_FORMAT_R8G8B8A8_UNORM = 37, VK_FORMAT_R8G8B8A8_SNORM = 38, VK_FORMAT_R8G8B8A8_USCALED = 39, VK_FORMAT_R8G8B8A8_SSCALED = 40, VK_FORMAT_R8G8B8A8_UINT = 41, VK_FORMAT_R8G8B8A8_SINT = 42, VK_FORMAT_R8G8B8A8_SRGB = 43, VK_FORMAT_B8G8R8A8_UNORM = 44, VK_FORMAT_B8G8R8A8_SNORM = 45, VK_FORMAT_B8G8R8A8_USCALED = 46, VK_FORMAT_B8G8R8A8_SSCALED = 47, VK_FORMAT_B8G8R8A8_UINT = 48, VK_FORMAT_B8G8R8A8_SINT = 49, VK_FORMAT_B8G8R8A8_SRGB = 50, VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51, VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52, VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53, VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54, VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55, VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56, VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57, VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58, VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59, VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60, VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61, VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62, VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63, VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64, VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65, VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66, VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67, VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68, VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69, VK_FORMAT_R16_UNORM = 70, VK_FORMAT_R16_SNORM = 71, VK_FORMAT_R16_USCALED = 72, VK_FORMAT_R16_SSCALED = 73, VK_FORMAT_R16_UINT = 74, VK_FORMAT_R16_SINT = 75, VK_FORMAT_R16_SFLOAT = 76, VK_FORMAT_R16G16_UNORM = 77, VK_FORMAT_R16G16_SNORM = 78, VK_FORMAT_R16G16_USCALED = 79, VK_FORMAT_R16G16_SSCALED = 80, VK_FORMAT_R16G16_UINT = 81, VK_FORMAT_R16G16_SINT = 82, VK_FORMAT_R16G16_SFLOAT = 83, VK_FORMAT_R16G16B16_UNORM = 84, VK_FORMAT_R16G16B16_SNORM = 85, VK_FORMAT_R16G16B16_USCALED = 86, VK_FORMAT_R16G16B16_SSCALED = 87, VK_FORMAT_R16G16B16_UINT = 88, VK_FORMAT_R16G16B16_SINT = 89, VK_FORMAT_R16G16B16_SFLOAT = 90, VK_FORMAT_R16G16B16A16_UNORM = 91, VK_FORMAT_R16G16B16A16_SNORM = 92, VK_FORMAT_R16G16B16A16_USCALED = 93, VK_FORMAT_R16G16B16A16_SSCALED = 94, VK_FORMAT_R16G16B16A16_UINT = 95, VK_FORMAT_R16G16B16A16_SINT = 96, VK_FORMAT_R16G16B16A16_SFLOAT = 97, VK_FORMAT_R32_UINT = 98, VK_FORMAT_R32_SINT = 99, VK_FORMAT_R32_SFLOAT = 100, VK_FORMAT_R32G32_UINT = 101, VK_FORMAT_R32G32_SINT = 102, VK_FORMAT_R32G32_SFLOAT = 103, VK_FORMAT_R32G32B32_UINT = 104, VK_FORMAT_R32G32B32_SINT = 105, VK_FORMAT_R32G32B32_SFLOAT = 106, VK_FORMAT_R32G32B32A32_UINT = 107, VK_FORMAT_R32G32B32A32_SINT = 108, VK_FORMAT_R32G32B32A32_SFLOAT = 109, VK_FORMAT_R64_UINT = 110, VK_FORMAT_R64_SINT = 111, VK_FORMAT_R64_SFLOAT = 112, VK_FORMAT_R64G64_UINT = 113, VK_FORMAT_R64G64_SINT = 114, VK_FORMAT_R64G64_SFLOAT = 115, VK_FORMAT_R64G64B64_UINT = 116, VK_FORMAT_R64G64B64_SINT = 117, VK_FORMAT_R64G64B64_SFLOAT = 118, VK_FORMAT_R64G64B64A64_UINT = 119, VK_FORMAT_R64G64B64A64_SINT = 120, VK_FORMAT_R64G64B64A64_SFLOAT = 121, VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122, VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123, VK_FORMAT_D16_UNORM = 124, VK_FORMAT_X8_D24_UNORM_PACK32 = 125, VK_FORMAT_D32_SFLOAT = 126, VK_FORMAT_S8_UINT = 127, VK_FORMAT_D16_UNORM_S8_UINT = 128, VK_FORMAT_D24_UNORM_S8_UINT = 129, VK_FORMAT_D32_SFLOAT_S8_UINT = 130, VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131, VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132, VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133, VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134, VK_FORMAT_BC2_UNORM_BLOCK = 135, VK_FORMAT_BC2_SRGB_BLOCK = 136, VK_FORMAT_BC3_UNORM_BLOCK = 137, VK_FORMAT_BC3_SRGB_BLOCK = 138, VK_FORMAT_BC4_UNORM_BLOCK = 139, VK_FORMAT_BC4_SNORM_BLOCK = 140, VK_FORMAT_BC5_UNORM_BLOCK = 141, VK_FORMAT_BC5_SNORM_BLOCK = 142, VK_FORMAT_BC6H_UFLOAT_BLOCK = 143, VK_FORMAT_BC6H_SFLOAT_BLOCK = 144, VK_FORMAT_BC7_UNORM_BLOCK = 145, VK_FORMAT_BC7_SRGB_BLOCK = 146, VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147, VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148, VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149, VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150, VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151, VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152, VK_FORMAT_EAC_R11_UNORM_BLOCK = 153, VK_FORMAT_EAC_R11_SNORM_BLOCK = 154, VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155, VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156, VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157, VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158, VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159, VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160, VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161, VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162, VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163, VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164, VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165, VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166, VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167, VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168, VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169, VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170, VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171, VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172, VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173, VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174, VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175, VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176, VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177, VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178, VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179, VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180, VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181, VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182, VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183, VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184, // Provided by VK_VERSION_1_1 VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000, // Provided by VK_VERSION_1_1 VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001, // Provided by VK_VERSION_1_1 VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002, // Provided by VK_VERSION_1_1 VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003, // Provided by VK_VERSION_1_1 VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004, // Provided by VK_VERSION_1_1 VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005, // Provided by VK_VERSION_1_1 VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006, // Provided by VK_VERSION_1_1 VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007, // Provided by VK_VERSION_1_1 VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008, // Provided by VK_VERSION_1_1 VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009, // Provided by VK_VERSION_1_1 VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010, // Provided by VK_VERSION_1_1 VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011, // Provided by VK_VERSION_1_1 VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012, // Provided by VK_VERSION_1_1 VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013, // Provided by VK_VERSION_1_1 VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014, // Provided by VK_VERSION_1_1 VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015, // Provided by VK_VERSION_1_1 VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016, // Provided by VK_VERSION_1_1 VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017, // Provided by VK_VERSION_1_1 VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018, // Provided by VK_VERSION_1_1 VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019, // Provided by VK_VERSION_1_1 VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020, // Provided by VK_VERSION_1_1 VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021, // Provided by VK_VERSION_1_1 VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022, // Provided by VK_VERSION_1_1 VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023, // Provided by VK_VERSION_1_1 VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024, // Provided by VK_VERSION_1_1 VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025, // Provided by VK_VERSION_1_1 VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026, // Provided by VK_VERSION_1_1 VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027, // Provided by VK_VERSION_1_1 VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028, // Provided by VK_VERSION_1_1 VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029, // Provided by VK_VERSION_1_1 VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030, // Provided by VK_VERSION_1_1 VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031, // Provided by VK_VERSION_1_1 VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032, // Provided by VK_VERSION_1_1 VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033, // Provided by VK_IMG_format_pvrtc VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000, // Provided by VK_IMG_format_pvrtc VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001, // Provided by VK_IMG_format_pvrtc VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002, // Provided by VK_IMG_format_pvrtc VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003, // Provided by VK_IMG_format_pvrtc VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004, // Provided by VK_IMG_format_pvrtc VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005, // Provided by VK_IMG_format_pvrtc VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006, // Provided by VK_IMG_format_pvrtc VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012, // Provided by VK_EXT_texture_compression_astc_hdr VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013, // Provided by VK_EXT_4444_formats VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 1000340000, // Provided by VK_EXT_4444_formats VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 1000340001, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G8B8G8R8_422_UNORM_KHR = VK_FORMAT_G8B8G8R8_422_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_B8G8R8G8_422_UNORM_KHR = VK_FORMAT_B8G8R8G8_422_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_R10X6_UNORM_PACK16_KHR = VK_FORMAT_R10X6_UNORM_PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_R12X4_UNORM_PACK16_KHR = VK_FORMAT_R12X4_UNORM_PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G16B16G16R16_422_UNORM_KHR = VK_FORMAT_G16B16G16R16_422_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_B16G16R16G16_422_UNORM_KHR = VK_FORMAT_B16G16R16G16_422_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM, // Provided by VK_KHR_sampler_ycbcr_conversion VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM, } VkFormat; // // Copyright 2018 The ANGLE Project Authors. All rights reserved. // Use of this source code is governed by a BSD-style license that can be // found in the LICENSE file. // // FeaturesVk.h: Optional features for the Vulkan renderer. // ifndef ANGLE_PLATFORM_FEATURESVK_H_ define ANGLE_PLATFORM_FEATURESVK_H_ include \"platform/FeatureFeatureFeature.h\" include namespace angle { struct FeaturesVk : FeatureSetBase { FeaturesVk(); ~FeaturesVk(); // Line segment rasterization must follow OpenGL rules. This means using an algorithm similar // to Bresenham's. Vulkan uses a different algorithm. This feature enables the use of pixel // shader patching to implement OpenGL basic line rasterization rules. This feature will // normally always be enabled. Exposing it as an option enables performance testing. FeatureFeatureFeature basicGLLineRasterization = { \"basicGLLineRasterization\", FeatureCategory::VulkanFeatures, \"Enable the use of pixel shader patching to implement OpenGL basic line \" \"rasterization rules\", &members}; // If the VK_EXT_line_rasterization extension is available we'll use it to get // Bresenham line rasterization. FeatureFeatureFeature bresenhamLineRasterization = { \"bresenhamLineRasterization\", FeatureCategory::VulkanFeatures, \"Enable Bresenham line rasterization via VK_EXT_line_rasterization extension\", &members}; // If the VK_EXT_provoking_vertex extension is available, we'll use it to set // the provoking vertex mode FeatureFeatureFeature provokingVertex = {\"provokingVertex\", FeatureCategory::VulkanFeatures, \"Enable provoking vertex mode via VK_EXT_provoking_vertex extension\", &members}; // Add an extra copy region when using vkCmdCopyBuffer as the Windows Intel driver seems // to have a bug where the last region is ignored. FeatureFeatureFeature extraCopyBufferRegion = { \"extraCopyBufferRegion\", FeatureCategory::VulkanWorkarounds, \"Some drivers seem to have a bug where the last copy region in vkCmdCopyBuffer is ignored\", &members}; // This flag is added for the sole purpose of end2end tests, to test the correctness // of various algorithms when a fallback format is used, such as using a packed format to // emulate a depth- or stencil-only format. FeatureFeatureFeature forceFallbackFormat = {\"forceFallbackFormat\", FeatureCategory::VulkanWorkarounds, \"Force a fallback format for angle_end2end_tests\", &members}; // On some NVIDIA drivers the point size range reported from the API is inconsistent with the // actual behavior. Clamp the point size to the value from the API to fix this. // Tracked in http://anglebug.com/2970. FeatureFeatureFeature clampPointSize = { \"clampPointSize\", FeatureCategory::VulkanWorkarounds, \"The point size range reported from the API is inconsistent with the actual behavior\", &members, \"http://anglebug.com/2970\"}; // On some NVIDIA drivers the depth value is not clamped to [0,1] for floating point depth // buffers. This is NVIDIA bug 3171019, see http://anglebug.com/3970 for details. FeatureFeatureFeature depthClamping = { \"depth_clamping\", FeatureCategory::VulkanWorkarounds, \"The depth value is not clamped to [0,1] for floating point depth buffers.\", &members, \"http://anglebug.com/3970\"}; // On some android devices, the memory barrier between the compute shader that converts vertex // attributes and the vertex shader that reads from it is ineffective. Only known workaround is // to perform a flush after the conversion. http://anglebug.com/3016 FeatureFeatureFeature flushAfterVertexConversion = { \"flushAfterVertexConversion\", FeatureCategory::VulkanWorkarounds, \"The memory barrier between the compute shader that converts vertex attributes and the \" \"vertex shader that reads from it is ineffective\", &members, \"http://anglebug.com/3016\"}; FeatureFeatureFeature supportsRenderpass2 = {\"supportsRenderpass2\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_create_renderpass2 extension\", &members}; // Whether the VkDevice supports the VK_KHR_incremental_present extension, on which the // EGL_KHR_swap_buffers_with_damage extension can be layered. FeatureFeatureFeature supportsIncrementalPresent = { \"supportsIncrementalPresent\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_incremental_present extension\", &members}; // Whether texture copies on cube map targets should be done on GPU. This is a workaround for // Intel drivers on windows that have an issue with creating single-layer views on cube map // textures. FeatureFeatureFeature forceCPUPathForCubeMapCopy = { \"forceCPUPathForCubeMapCopy\", FeatureCategory::VulkanWorkarounds, \"Some drivers have an issue with creating single-layer views on cube map textures\", &members}; // Whether the VkDevice supports the VK_ANDROID_external_memory_android_hardware_buffer // extension, on which the EGL_ANDROID_image_native_buffer extension can be layered. FeatureFeatureFeature supportsAndroidHardwareBuffer = { \"supportsAndroidHardwareBuffer\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_ANDROID_external_memory_android_hardware_buffer extension\", &members}; // Whether the VkDevice supports the VK_GGP_frame_token extension, on which // the EGL_ANGLE_swap_with_frame_token extension can be layered. FeatureFeatureFeature supportsGGPFrameToken = {\"supportsGGPFrameToken\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_GGP_frame_token extension\", &members}; // Whether the VkDevice supports the VK_KHR_external_memory_fd extension, on which the // GL_EXT_memory_object_fd extension can be layered. FeatureFeatureFeature supportsExternalMemoryFd = {\"supportsExternalMemoryFd\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_external_memory_fd extension\", &members}; // Whether the VkDevice supports the VK_FUCHSIA_external_memory // extension, on which the GL_ANGLE_memory_object_fuchsia extension can be layered. FeatureFeatureFeature supportsExternalMemoryFuchsia = { \"supportsExternalMemoryFuchsia\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_FUCHSIA_external_memory extension\", &members}; FeatureFeatureFeature supportsFilteringPrecision = { \"supportsFilteringPrecision\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_GOOGLE_sampler_filtering_precision extension\", &members}; // Whether the VkDevice supports the VK_KHR_external_fence_capabilities extension. FeatureFeatureFeature supportsExternalFenceCapabilities = { \"supportsExternalFenceCapabilities\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_external_fence_capabilities extension\", &members}; // Whether the VkDevice supports the VK_KHR_external_semaphore_capabilities extension. FeatureFeatureFeature supportsExternalSemaphoreCapabilities = { \"supportsExternalSemaphoreCapabilities\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_external_semaphore_capabilities extension\", &members}; // Whether the VkDevice supports the VK_KHR_external_semaphore_fd extension, on which the // GL_EXT_semaphore_fd extension can be layered. FeatureFeatureFeature supportsExternalSemaphoreFd = { \"supportsExternalSemaphoreFd\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_external_semaphore_fd extension\", &members}; // Whether the VkDevice supports the VK_FUCHSIA_external_semaphore // extension, on which the GL_ANGLE_semaphore_fuchsia extension can be layered. angle::Feature supportsExternalSemaphoreFuchsia = { \"supportsExternalSemaphoreFuchsia\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_FUCHSIA_external_semaphore extension\", &members}; // Whether the VkDevice supports the VK_KHR_external_fence_fd extension, on which the // EGL_ANDROID_native_fence extension can be layered. FeatureFeatureFeature supportsExternalFenceFd = {\"supportsExternalFenceFd\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_external_fence_fd extension\", &members, \"http://anglebug.com/2517\"}; // Whether the VkDevice can support EGL_ANDROID_native_fence_sync extension. FeatureFeatureFeature supportsAndroidNativeFenceSync = { \"supportsAndroidNativeFenceSync\", FeatureCategory::VulkanFeatures, \"VkDevice supports the EGL_ANDROID_native_fence_sync extension\", &members, \"http://anglebug.com/2517\"}; // Whether the VkDevice can support imageCubeArray feature properly. FeatureFeatureFeature supportsImageCubeArray = {\"supportsImageCubeArray\", FeatureCategory::VulkanFeatures, \"VkDevice supports the imageCubeArray feature properly\", &members, \"http://anglebug.com/3584\"}; // Whether the VkDevice supports the VK_EXT_shader_stencil_export extension, which is used to // perform multisampled resolve of stencil buffer. A multi-step workaround is used instead if // this extension is not available. FeatureFeatureFeature supportsShaderStencilExport = { \"supportsShaderStencilExport\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_EXT_shader_stencil_export extension\", &members}; // Whether the VkDevice supports the VK_KHR_sampler_ycbcr_conversion extension, which is needed // to support Ycbcr conversion with external images. FeatureFeatureFeature supportsYUVSamplerConversion = { \"supportsYUVSamplerConversion\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_sampler_ycbcr_conversion extension\", &members}; // Where VK_EXT_transform_feedback is not support, an emulation path is used. // http://anglebug.com/3205 FeatureFeatureFeature emulateTransformFeedback = { \"emulateTransformFeedback\", FeatureCategory::VulkanFeatures, \"Emulate transform feedback as the VK_EXT_transform_feedback is not present.\", &members, \"http://anglebug.com/3205\"}; // Where VK_EXT_transform_feedback is supported, it's preferred over an emulation path. // http://anglebug.com/3206 FeatureFeatureFeature supportsTransformFeedbackExtension = { \"supportsTransformFeedbackExtension\", FeatureCategory::VulkanFeatures, \"Transform feedback uses the VK_EXT_transform_feedback extension.\", &members, \"http://anglebug.com/3206\"}; // Whether the VkDevice supports the VK_EXT_index_type_uint8 extension // http://anglebug.com/4405 FeatureFeatureFeature supportsIndexTypeUint8 = {\"supportsIndexTypeUint8\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_EXT_index_type_uint8 extension\", &members, \"http://anglebug.com/4405\"}; // Whether the VkDevice supports the VK_KHR_depth_stencil_resolve extension with the // independentResolveNone feature. // http://anglebug.com/4836 FeatureFeatureFeature supportsDepthStencilResolve = {\"supportsDepthStencilResolve\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_depth_stencil_resolve \" \"extension with the independentResolveNone feature\", &members, \"http://anglebug.com/4836\"}; // VK_PRESENT_MODE_FIFO_KHR causes random timeouts on Linux Intel. http://anglebug.com/3153 FeatureFeatureFeature disableFifoPresentMode = {\"disableFifoPresentMode\", FeatureCategory::VulkanWorkarounds, \"VK_PRESENT_MODE_FIFO_KHR causes random timeouts\", &members, \"http://anglebug.com/3153\"}; // On Qualcomm, gaps in bound descriptor set indices causes the post-gap sets to misbehave. // For example, binding only descriptor set 3 results in zero being read from a uniform buffer // object within that set. This flag results in empty descriptor sets being bound for any // unused descriptor set to work around this issue. http://anglebug.com/2727 FeatureFeatureFeature bindEmptyForUnusedDescriptorSets = { \"bindEmptyForUnusedDescriptorSets\", FeatureCategory::VulkanWorkarounds, \"Gaps in bound descriptor set indices causes the post-gap sets to misbehave\", &members, \"http://anglebug.com/2727\"}; // OES_depth_texture is a commonly expected feature on Android. However it // requires that D16_UNORM support texture filtering // (e.g. VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT) and some devices // do not. Work-around this by setting saying D16_UNORM supports filtering // anyway. FeatureFeatureFeature forceD16TexFilter = { \"forceD16TexFilter\", FeatureCategory::VulkanWorkarounds, \"VK_FORMAT_D16_UNORM does not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT, \" \"which prevents OES_depth_texture from being supported.\", &members, \"http://anglebug.com/3452\"}; // On some android devices, vkCmdBlitImage with flipped coordinates blits incorrectly. This // workaround makes sure this path is avoided. http://anglebug.com/3498 FeatureFeatureFeature disableFlippingBlitWithCommand = { \"disableFlippingBlitWithCommand\", FeatureCategory::VulkanWorkarounds, \"vkCmdBlitImage with flipped coordinates blits incorrectly.\", &members, \"http://anglebug.com/3498\"}; // On platform with Intel or AMD GPU, a window resizing would not trigger the vulkan driver to // return VK_ERROR_OUT_OF_DATE on swapchain present. Work-around by query current window extent // every frame to detect a window resizing. // http://anglebug.com/3623, http://anglebug.com/3624, http://anglebug.com/3625 FeatureFeatureFeature perFrameWindowSizeQuery = { \"perFrameWindowSizeQuery\", FeatureCategory::VulkanWorkarounds, \"Vulkan swapchain is not returning VK_ERROR_OUT_OF_DATE when window resizing\", &members, \"http://anglebug.com/3623, http://anglebug.com/3624, http://anglebug.com/3625\"}; // Seamful cube map emulation misbehaves on the AMD windows driver, so it's disallowed. FeatureFeatureFeature disallowSeamfulCubeMapEmulation = { \"disallowSeamfulCubeMapEmulation\", FeatureCategory::VulkanWorkarounds, \"Seamful cube map emulation misbehaves on some drivers, so it's disallowed\", &members, \"http://anglebug.com/3243\"}; // Qualcomm and SwiftShader shader compiler doesn't support sampler arrays as parameters, so // revert to old RewriteStructSamplers behavior, which produces fewer. FeatureFeatureFeature forceOldRewriteStructSamplers = { \"forceOldRewriteStructSamplers\", FeatureCategory::VulkanWorkarounds, \"Some shader compilers don't support sampler arrays as parameters, so revert to old \" \"RewriteStructSamplers behavior, which produces fewer.\", &members, \"http://anglebug.com/2703\"}; // Vulkan considers vertex attribute accesses to count up to the last multiple of the stride. // This additional access supports AMD's robust buffer access implementation. // AMDVLK in particular will return incorrect values when the vertex access extends into the // range that would be the stride padding and the buffer is too small. // This workaround limits GL_MAX_VERTEX_ATTRIB_STRIDE to a reasonable value and pads out // every buffer allocation size to be large enough to support a maximum vertex stride. // http://anglebug.com/4428 FeatureFeatureFeature padBuffersToMaxVertexAttribStride = { \"padBuffersToMaxVertexAttribStride\", FeatureCategory::VulkanWorkarounds, \"Vulkan considers vertex attribute accesses to count up to the last multiple of the \" \"stride. This additional access supports AMD's robust buffer access implementation. \" \"AMDVLK in particular will return incorrect values when the vertex access extends into \" \"the range that would be the stride padding and the buffer is too small. \" \"This workaround limits GL_MAX_VERTEX_ATTRIB_STRIDE to a maximum value and \" \"pads up every buffer allocation size to be a multiple of the maximum stride.\", &members, \"http://anglebug.com/4428\"}; // Whether the VkDevice supports the VK_EXT_swapchain_colorspace extension // http://anglebug.com/2514 FeatureFeatureFeature supportsSwapchainColorspace = { \"supportsSwapchainColorspace\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_EXT_swapchain_colorspace extension\", &members, \"http://anglebug.com/2514\"}; // Whether the VkDevice supports the VK_EXT_external_memory_host extension, on which the // ANGLE_iosurface_client_buffer extension can be layered. FeatureFeatureFeature supportsExternalMemoryHost = { \"supportsExternalMemoryHost\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_EXT_external_memory_host extension\", &members}; // Whether to fill new buffers and textures with nonzero data to sanitize robust resource // initialization and flush out assumptions about zero init. FeatureFeatureFeature allocateNonZeroMemory = { \"allocateNonZeroMemory\", FeatureCategory::VulkanFeatures, \"Fill new allocations with non-zero values to flush out errors.\", &members, \"http://anglebug.com/4384\"}; // Allocate a \"shadow\" buffer for GL buffer objects. For GPU-read only buffers // glMap* latency can be reduced by maintaining a copy of the buffer which is // writeable only by the CPU. We then return this shadow buffer on glMap* calls. FeatureFeatureFeature shadowBuffers = { \"shadowBuffers\", FeatureCategory::VulkanFeatures, \"Allocate a shadow buffer for GL buffer objects to reduce glMap* latency.\", &members, \"http://anglebug.com/4339\"}; // Persistently map buffer memory until destroy, saves on map/unmap IOCTL overhead // for buffers that are updated frequently. FeatureFeatureFeature persistentlyMappedBuffers = { \"persistentlyMappedBuffers\", FeatureCategory::VulkanFeatures, \"Persistently map buffer memory to reduce map/unmap IOCTL overhead.\", &members, \"http://anglebug.com/2162\"}; // Android needs to pre-rotate surfaces that are not oriented per the native device's // orientation (e.g. a landscape application on a Pixel phone). This feature works for // full-screen applications. http://anglebug.com/3502 FeatureFeatureFeature enablePreRotateSurfaces = {\"enablePreRotateSurfaces\", FeatureCategory::VulkanFeatures, \"Enable Android pre-rotation for landscape applications\", &members, \"http://anglebug.com/3502\"}; // Cache FramebufferVk objects. Currently hitting a bug on Apple: http://anglebug.com/4442 FeatureFeatureFeature enableFramebufferVkCache = {\"enableFramebufferVkCache\", FeatureCategory::VulkanFeatures, \"Enable FramebufferVk objects to be cached\", &members, \"http://anglebug.com/4442\"}; // Enable precision qualifiers for shaders generated by Vulkan backend http://anglebug.com/3078 FeatureFeatureFeature enablePrecisionQualifiers = { \"enablePrecisionQualifiers\", FeatureCategory::VulkanFeatures, \"Enable precision qualifiers in shaders\", &members, \"http://anglebug.com/3078\"}; // Desktop (at least NVIDIA) drivers prefer combining barriers into one vkCmdPipelineBarrier // call over issuing multiple barrier calls with fine grained dependency information to have // better performance. http://anglebug.com/4633 FeatureFeatureFeature preferAggregateBarrierCalls = { \"preferAggregateBarrierCalls\", FeatureCategory::VulkanWorkarounds, \"Single barrier call is preferred over multiple calls with \" \"fine grained pipeline stage dependency information\", &members, \"http://anglebug.com/4633\"}; // Tell the Vulkan back-end to use the async command queue to dispatch work to the GPU. Command // buffer work will happened in a worker thread. Otherwise use Renderer::CommandQueue directly. FeatureFeatureFeature asyncCommandQueue = {\"asyncCommandQueue\", FeatureCategory::VulkanFeatures, \"Use CommandQueue worker thread to dispatch work to GPU.\", &members, \"http://anglebug.com/4324\"}; // Whether the VkDevice supports the VK_KHR_shader_float16_int8 extension and has the // shaderFloat16 feature. FeatureFeatureFeature supportsShaderFloat16 = {\"supportsShaderFloat16\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_shader_float16_int8 extension \" \"and has the shaderFloat16 feature\", &members, \"http://anglebug.com/4551\"}; // Some devices don't meet the limits required to perform mipmap generation using the built-in // compute shader. On some other devices, VK_IMAGE_USAGE_STORAGE_BIT is detrimental to // performance, making this solution impractical. FeatureFeatureFeature allowGenerateMipmapWithCompute = { \"allowGenerateMipmapWithCompute\", FeatureCategory::VulkanFeatures, \"Use the compute path to generate mipmaps on devices that meet the minimum requirements, \" \"and the performance is better.\", &members, \"http://anglebug.com/4551\"}; // Whether the VkDevice supports the VK_QCOM_render_pass_store_ops extension // http://anglebug.com/5505 FeatureFeatureFeature supportsRenderPassStoreOpNoneQCOM = { \"supportsRenderPassStoreOpNoneQCOM\", FeatureCategory::VulkanFeatures, \"VkDevice supports VK_QCOM_render_pass_store_ops extension.\", &members, \"http://anglebug.com/5055\"}; // Force maxUniformBufferSize to 16K on Qualcomm's Adreno 540. Pixel2's Adreno540 reports // maxUniformBufferSize 64k but various tests failed with that size. For that specific // device, we set to 16k for now which is known to pass all tests. // https://issuetracker.google.com/161903006 FeatureFeatureFeature forceMaxUniformBufferSize16KB = { \"forceMaxUniformBufferSize16KB\", FeatureCategory::VulkanWorkarounds, \"Force max uniform buffer size to 16K on some device due to bug\", &members, \"https://issuetracker.google.com/161903006\"}; // Enable mutable bit by default for ICD's that support VK_KHR_image_format_list. // http://anglebug.com/5281 FeatureFeatureFeature supportsImageFormatList = { \"supportsImageFormatList\", FeatureCategory::VulkanFeatures, \"Enable VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT by default for ICDs \" \"that support VK_KHR_image_format_list\", &members, \"http://anglebug.com/5281\"}; // Swiftshader on mac fails to initialize WebGL context when EXT_multisampled_render_to_texture // is used by Chromium. // http://anglebug.com/4937 FeatureFeatureFeature enableMultisampledRenderToTexture = { \"enableMultisampledRenderToTexture\", FeatureCategory::VulkanWorkarounds, \"Expose EXT_multisampled_render_to_texture\", &members, \"http://anglebug.com/4937\"}; // Qualcomm fails some tests when reducing the preferred block size to 4M. // http://anglebug.com/4995 FeatureFeatureFeature preferredLargeHeapBlockSize4MB = { \"preferredLargeHeapBlockSize4MB\", FeatureCategory::VulkanWorkarounds, \"Use 4 MB preferred large heap block size with AMD allocator\", &members, \"http://anglebug.com/4995\"}; // Manhattan is calling glFlush in the middle of renderpass which breaks renderpass and hurts // performance on tile based GPU. When this is enabled, we will defer the glFlush call made in // the middle of renderpass to the end of renderpass. // https://issuetracker.google.com/issues/166475273 FeatureFeatureFeature deferFlushUntilEndRenderPass = { \"deferFlushUntilEndRenderPass\", FeatureCategory::VulkanWorkarounds, \"Allow glFlush to be deferred until renderpass ends\", &members, \"https://issuetracker.google.com/issues/166475273\"}; // Android mistakenly destroys oldSwapchain passed to vkCreateSwapchainKHR, causing crashes on // certain drivers. http://anglebug.com/5061 FeatureFeatureFeature waitIdleBeforeSwapchainRecreation = { \"waitIdleBeforeSwapchainRecreation\", FeatureCategory::VulkanWorkarounds, \"Before passing an oldSwapchain to VkSwapchainCreateInfoKHR, wait for queue to be idle. \" \"Works around a bug on platforms which destroy oldSwapchain in vkCreateSwapchainKHR.\", &members, \"http://anglebug.com/5061\"}; // Translate non-nearest mip filtering modes to nearest mip for all samplers for performance // comparisons. ANGLE is non-conformant if this feature is enabled. FeatureFeatureFeature forceNearestMipFiltering = {\"forceNearestMipFiltering\", FeatureCategory::VulkanWorkarounds, \"Force nearest mip filtering when sampling.\", &members}; // Qualcomm missynchronizes vkCmdClearAttachments in the middle of render pass. // https://issuetracker.google.com/166809097 FeatureFeatureFeature preferDrawClearOverVkCmdClearAttachments = { \"preferDrawClearOverVkCmdClearAttachments\", FeatureCategory::VulkanWorkarounds, \"On some hardware, clear using a draw call instead of vkCmdClearAttachments in the middle \" \"of render pass due to bugs\", &members, \"https://issuetracker.google.com/166809097\"}; // Whether prerotation is being emulated for testing. 90 degree rotation. FeatureFeatureFeature emulatedPrerotation90 = {\"emulatedPrerotation90\", FeatureCategory::VulkanFeatures, \"Emulate 90-degree prerotation.\", &members, \"http://anglebug.com/4901\"}; // Whether prerotation is being emulated for testing. 180 degree rotation. FeatureFeatureFeature emulatedPrerotation180 = {\"emulatedPrerotation180\", FeatureCategory::VulkanFeatures, \"Emulate 180-degree prerotation.\", &members, \"http://anglebug.com/4901\"}; // Whether prerotation is being emulated for testing. 270 degree rotation. FeatureFeatureFeature emulatedPrerotation270 = {\"emulatedPrerotation270\", FeatureCategory::VulkanFeatures, \"Emulate 270-degree prerotation.\", &members, \"http://anglebug.com/4901\"}; // Whether we should use driver uniforms over specialization constants for some shader // modifications like yflip and rotation. FeatureFeatureFeature forceDriverUniformOverSpecConst = { \"forceDriverUniformOverSpecConst\", FeatureCategory::VulkanWorkarounds, \"Forces using driver uniforms instead of specialization constants.\", &members, \"http://issuetracker.google.com/173636783\"}; // Whether non-conformant configurations and extensions should be exposed. When an extension is // in development, or a GLES version is not supported on a device, we may still want to expose // them for partial testing. This feature is enabled by our test harness. FeatureFeatureFeature exposeNonConformantExtensionsAndVersions = { \"exposeNonConformantExtensionsAndVersions\", FeatureCategory::VulkanWorkarounds, \"Expose GLES versions and extensions that are not conformant.\", &members, \"http://anglebug.com/5375\"}; }; inline FeaturesVk::FeaturesVk() = default; inline FeaturesVk::~FeaturesVk() = default; } // namespace angle endif // ANGLE_PLATFORM_FEATURESVK_H_","title":"SRC Extentions"},{"location":"ANGLE/SRC_Extentions/#ifndef-angle_platform_featuresvk_h_","text":"","title":"ifndef ANGLE_PLATFORM_FEATURESVK_H_"},{"location":"ANGLE/SRC_Extentions/#define-angle_platform_featuresvk_h_","text":"","title":"define ANGLE_PLATFORM_FEATURESVK_H_"},{"location":"ANGLE/SRC_Extentions/#include-platformfeaturefeaturefeatureh","text":"","title":"include \"platform/FeatureFeatureFeature.h\""},{"location":"ANGLE/SRC_Extentions/#include","text":"namespace angle { struct FeaturesVk : FeatureSetBase { FeaturesVk(); ~FeaturesVk(); // Line segment rasterization must follow OpenGL rules. This means using an algorithm similar // to Bresenham's. Vulkan uses a different algorithm. This feature enables the use of pixel // shader patching to implement OpenGL basic line rasterization rules. This feature will // normally always be enabled. Exposing it as an option enables performance testing. FeatureFeatureFeature basicGLLineRasterization = { \"basicGLLineRasterization\", FeatureCategory::VulkanFeatures, \"Enable the use of pixel shader patching to implement OpenGL basic line \" \"rasterization rules\", &members}; // If the VK_EXT_line_rasterization extension is available we'll use it to get // Bresenham line rasterization. FeatureFeatureFeature bresenhamLineRasterization = { \"bresenhamLineRasterization\", FeatureCategory::VulkanFeatures, \"Enable Bresenham line rasterization via VK_EXT_line_rasterization extension\", &members}; // If the VK_EXT_provoking_vertex extension is available, we'll use it to set // the provoking vertex mode FeatureFeatureFeature provokingVertex = {\"provokingVertex\", FeatureCategory::VulkanFeatures, \"Enable provoking vertex mode via VK_EXT_provoking_vertex extension\", &members}; // Add an extra copy region when using vkCmdCopyBuffer as the Windows Intel driver seems // to have a bug where the last region is ignored. FeatureFeatureFeature extraCopyBufferRegion = { \"extraCopyBufferRegion\", FeatureCategory::VulkanWorkarounds, \"Some drivers seem to have a bug where the last copy region in vkCmdCopyBuffer is ignored\", &members}; // This flag is added for the sole purpose of end2end tests, to test the correctness // of various algorithms when a fallback format is used, such as using a packed format to // emulate a depth- or stencil-only format. FeatureFeatureFeature forceFallbackFormat = {\"forceFallbackFormat\", FeatureCategory::VulkanWorkarounds, \"Force a fallback format for angle_end2end_tests\", &members}; // On some NVIDIA drivers the point size range reported from the API is inconsistent with the // actual behavior. Clamp the point size to the value from the API to fix this. // Tracked in http://anglebug.com/2970. FeatureFeatureFeature clampPointSize = { \"clampPointSize\", FeatureCategory::VulkanWorkarounds, \"The point size range reported from the API is inconsistent with the actual behavior\", &members, \"http://anglebug.com/2970\"}; // On some NVIDIA drivers the depth value is not clamped to [0,1] for floating point depth // buffers. This is NVIDIA bug 3171019, see http://anglebug.com/3970 for details. FeatureFeatureFeature depthClamping = { \"depth_clamping\", FeatureCategory::VulkanWorkarounds, \"The depth value is not clamped to [0,1] for floating point depth buffers.\", &members, \"http://anglebug.com/3970\"}; // On some android devices, the memory barrier between the compute shader that converts vertex // attributes and the vertex shader that reads from it is ineffective. Only known workaround is // to perform a flush after the conversion. http://anglebug.com/3016 FeatureFeatureFeature flushAfterVertexConversion = { \"flushAfterVertexConversion\", FeatureCategory::VulkanWorkarounds, \"The memory barrier between the compute shader that converts vertex attributes and the \" \"vertex shader that reads from it is ineffective\", &members, \"http://anglebug.com/3016\"}; FeatureFeatureFeature supportsRenderpass2 = {\"supportsRenderpass2\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_create_renderpass2 extension\", &members}; // Whether the VkDevice supports the VK_KHR_incremental_present extension, on which the // EGL_KHR_swap_buffers_with_damage extension can be layered. FeatureFeatureFeature supportsIncrementalPresent = { \"supportsIncrementalPresent\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_incremental_present extension\", &members}; // Whether texture copies on cube map targets should be done on GPU. This is a workaround for // Intel drivers on windows that have an issue with creating single-layer views on cube map // textures. FeatureFeatureFeature forceCPUPathForCubeMapCopy = { \"forceCPUPathForCubeMapCopy\", FeatureCategory::VulkanWorkarounds, \"Some drivers have an issue with creating single-layer views on cube map textures\", &members}; // Whether the VkDevice supports the VK_ANDROID_external_memory_android_hardware_buffer // extension, on which the EGL_ANDROID_image_native_buffer extension can be layered. FeatureFeatureFeature supportsAndroidHardwareBuffer = { \"supportsAndroidHardwareBuffer\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_ANDROID_external_memory_android_hardware_buffer extension\", &members}; // Whether the VkDevice supports the VK_GGP_frame_token extension, on which // the EGL_ANGLE_swap_with_frame_token extension can be layered. FeatureFeatureFeature supportsGGPFrameToken = {\"supportsGGPFrameToken\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_GGP_frame_token extension\", &members}; // Whether the VkDevice supports the VK_KHR_external_memory_fd extension, on which the // GL_EXT_memory_object_fd extension can be layered. FeatureFeatureFeature supportsExternalMemoryFd = {\"supportsExternalMemoryFd\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_external_memory_fd extension\", &members}; // Whether the VkDevice supports the VK_FUCHSIA_external_memory // extension, on which the GL_ANGLE_memory_object_fuchsia extension can be layered. FeatureFeatureFeature supportsExternalMemoryFuchsia = { \"supportsExternalMemoryFuchsia\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_FUCHSIA_external_memory extension\", &members}; FeatureFeatureFeature supportsFilteringPrecision = { \"supportsFilteringPrecision\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_GOOGLE_sampler_filtering_precision extension\", &members}; // Whether the VkDevice supports the VK_KHR_external_fence_capabilities extension. FeatureFeatureFeature supportsExternalFenceCapabilities = { \"supportsExternalFenceCapabilities\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_external_fence_capabilities extension\", &members}; // Whether the VkDevice supports the VK_KHR_external_semaphore_capabilities extension. FeatureFeatureFeature supportsExternalSemaphoreCapabilities = { \"supportsExternalSemaphoreCapabilities\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_external_semaphore_capabilities extension\", &members}; // Whether the VkDevice supports the VK_KHR_external_semaphore_fd extension, on which the // GL_EXT_semaphore_fd extension can be layered. FeatureFeatureFeature supportsExternalSemaphoreFd = { \"supportsExternalSemaphoreFd\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_external_semaphore_fd extension\", &members}; // Whether the VkDevice supports the VK_FUCHSIA_external_semaphore // extension, on which the GL_ANGLE_semaphore_fuchsia extension can be layered. angle::Feature supportsExternalSemaphoreFuchsia = { \"supportsExternalSemaphoreFuchsia\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_FUCHSIA_external_semaphore extension\", &members}; // Whether the VkDevice supports the VK_KHR_external_fence_fd extension, on which the // EGL_ANDROID_native_fence extension can be layered. FeatureFeatureFeature supportsExternalFenceFd = {\"supportsExternalFenceFd\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_external_fence_fd extension\", &members, \"http://anglebug.com/2517\"}; // Whether the VkDevice can support EGL_ANDROID_native_fence_sync extension. FeatureFeatureFeature supportsAndroidNativeFenceSync = { \"supportsAndroidNativeFenceSync\", FeatureCategory::VulkanFeatures, \"VkDevice supports the EGL_ANDROID_native_fence_sync extension\", &members, \"http://anglebug.com/2517\"}; // Whether the VkDevice can support imageCubeArray feature properly. FeatureFeatureFeature supportsImageCubeArray = {\"supportsImageCubeArray\", FeatureCategory::VulkanFeatures, \"VkDevice supports the imageCubeArray feature properly\", &members, \"http://anglebug.com/3584\"}; // Whether the VkDevice supports the VK_EXT_shader_stencil_export extension, which is used to // perform multisampled resolve of stencil buffer. A multi-step workaround is used instead if // this extension is not available. FeatureFeatureFeature supportsShaderStencilExport = { \"supportsShaderStencilExport\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_EXT_shader_stencil_export extension\", &members}; // Whether the VkDevice supports the VK_KHR_sampler_ycbcr_conversion extension, which is needed // to support Ycbcr conversion with external images. FeatureFeatureFeature supportsYUVSamplerConversion = { \"supportsYUVSamplerConversion\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_sampler_ycbcr_conversion extension\", &members}; // Where VK_EXT_transform_feedback is not support, an emulation path is used. // http://anglebug.com/3205 FeatureFeatureFeature emulateTransformFeedback = { \"emulateTransformFeedback\", FeatureCategory::VulkanFeatures, \"Emulate transform feedback as the VK_EXT_transform_feedback is not present.\", &members, \"http://anglebug.com/3205\"}; // Where VK_EXT_transform_feedback is supported, it's preferred over an emulation path. // http://anglebug.com/3206 FeatureFeatureFeature supportsTransformFeedbackExtension = { \"supportsTransformFeedbackExtension\", FeatureCategory::VulkanFeatures, \"Transform feedback uses the VK_EXT_transform_feedback extension.\", &members, \"http://anglebug.com/3206\"}; // Whether the VkDevice supports the VK_EXT_index_type_uint8 extension // http://anglebug.com/4405 FeatureFeatureFeature supportsIndexTypeUint8 = {\"supportsIndexTypeUint8\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_EXT_index_type_uint8 extension\", &members, \"http://anglebug.com/4405\"}; // Whether the VkDevice supports the VK_KHR_depth_stencil_resolve extension with the // independentResolveNone feature. // http://anglebug.com/4836 FeatureFeatureFeature supportsDepthStencilResolve = {\"supportsDepthStencilResolve\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_depth_stencil_resolve \" \"extension with the independentResolveNone feature\", &members, \"http://anglebug.com/4836\"}; // VK_PRESENT_MODE_FIFO_KHR causes random timeouts on Linux Intel. http://anglebug.com/3153 FeatureFeatureFeature disableFifoPresentMode = {\"disableFifoPresentMode\", FeatureCategory::VulkanWorkarounds, \"VK_PRESENT_MODE_FIFO_KHR causes random timeouts\", &members, \"http://anglebug.com/3153\"}; // On Qualcomm, gaps in bound descriptor set indices causes the post-gap sets to misbehave. // For example, binding only descriptor set 3 results in zero being read from a uniform buffer // object within that set. This flag results in empty descriptor sets being bound for any // unused descriptor set to work around this issue. http://anglebug.com/2727 FeatureFeatureFeature bindEmptyForUnusedDescriptorSets = { \"bindEmptyForUnusedDescriptorSets\", FeatureCategory::VulkanWorkarounds, \"Gaps in bound descriptor set indices causes the post-gap sets to misbehave\", &members, \"http://anglebug.com/2727\"}; // OES_depth_texture is a commonly expected feature on Android. However it // requires that D16_UNORM support texture filtering // (e.g. VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT) and some devices // do not. Work-around this by setting saying D16_UNORM supports filtering // anyway. FeatureFeatureFeature forceD16TexFilter = { \"forceD16TexFilter\", FeatureCategory::VulkanWorkarounds, \"VK_FORMAT_D16_UNORM does not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT, \" \"which prevents OES_depth_texture from being supported.\", &members, \"http://anglebug.com/3452\"}; // On some android devices, vkCmdBlitImage with flipped coordinates blits incorrectly. This // workaround makes sure this path is avoided. http://anglebug.com/3498 FeatureFeatureFeature disableFlippingBlitWithCommand = { \"disableFlippingBlitWithCommand\", FeatureCategory::VulkanWorkarounds, \"vkCmdBlitImage with flipped coordinates blits incorrectly.\", &members, \"http://anglebug.com/3498\"}; // On platform with Intel or AMD GPU, a window resizing would not trigger the vulkan driver to // return VK_ERROR_OUT_OF_DATE on swapchain present. Work-around by query current window extent // every frame to detect a window resizing. // http://anglebug.com/3623, http://anglebug.com/3624, http://anglebug.com/3625 FeatureFeatureFeature perFrameWindowSizeQuery = { \"perFrameWindowSizeQuery\", FeatureCategory::VulkanWorkarounds, \"Vulkan swapchain is not returning VK_ERROR_OUT_OF_DATE when window resizing\", &members, \"http://anglebug.com/3623, http://anglebug.com/3624, http://anglebug.com/3625\"}; // Seamful cube map emulation misbehaves on the AMD windows driver, so it's disallowed. FeatureFeatureFeature disallowSeamfulCubeMapEmulation = { \"disallowSeamfulCubeMapEmulation\", FeatureCategory::VulkanWorkarounds, \"Seamful cube map emulation misbehaves on some drivers, so it's disallowed\", &members, \"http://anglebug.com/3243\"}; // Qualcomm and SwiftShader shader compiler doesn't support sampler arrays as parameters, so // revert to old RewriteStructSamplers behavior, which produces fewer. FeatureFeatureFeature forceOldRewriteStructSamplers = { \"forceOldRewriteStructSamplers\", FeatureCategory::VulkanWorkarounds, \"Some shader compilers don't support sampler arrays as parameters, so revert to old \" \"RewriteStructSamplers behavior, which produces fewer.\", &members, \"http://anglebug.com/2703\"}; // Vulkan considers vertex attribute accesses to count up to the last multiple of the stride. // This additional access supports AMD's robust buffer access implementation. // AMDVLK in particular will return incorrect values when the vertex access extends into the // range that would be the stride padding and the buffer is too small. // This workaround limits GL_MAX_VERTEX_ATTRIB_STRIDE to a reasonable value and pads out // every buffer allocation size to be large enough to support a maximum vertex stride. // http://anglebug.com/4428 FeatureFeatureFeature padBuffersToMaxVertexAttribStride = { \"padBuffersToMaxVertexAttribStride\", FeatureCategory::VulkanWorkarounds, \"Vulkan considers vertex attribute accesses to count up to the last multiple of the \" \"stride. This additional access supports AMD's robust buffer access implementation. \" \"AMDVLK in particular will return incorrect values when the vertex access extends into \" \"the range that would be the stride padding and the buffer is too small. \" \"This workaround limits GL_MAX_VERTEX_ATTRIB_STRIDE to a maximum value and \" \"pads up every buffer allocation size to be a multiple of the maximum stride.\", &members, \"http://anglebug.com/4428\"}; // Whether the VkDevice supports the VK_EXT_swapchain_colorspace extension // http://anglebug.com/2514 FeatureFeatureFeature supportsSwapchainColorspace = { \"supportsSwapchainColorspace\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_EXT_swapchain_colorspace extension\", &members, \"http://anglebug.com/2514\"}; // Whether the VkDevice supports the VK_EXT_external_memory_host extension, on which the // ANGLE_iosurface_client_buffer extension can be layered. FeatureFeatureFeature supportsExternalMemoryHost = { \"supportsExternalMemoryHost\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_EXT_external_memory_host extension\", &members}; // Whether to fill new buffers and textures with nonzero data to sanitize robust resource // initialization and flush out assumptions about zero init. FeatureFeatureFeature allocateNonZeroMemory = { \"allocateNonZeroMemory\", FeatureCategory::VulkanFeatures, \"Fill new allocations with non-zero values to flush out errors.\", &members, \"http://anglebug.com/4384\"}; // Allocate a \"shadow\" buffer for GL buffer objects. For GPU-read only buffers // glMap* latency can be reduced by maintaining a copy of the buffer which is // writeable only by the CPU. We then return this shadow buffer on glMap* calls. FeatureFeatureFeature shadowBuffers = { \"shadowBuffers\", FeatureCategory::VulkanFeatures, \"Allocate a shadow buffer for GL buffer objects to reduce glMap* latency.\", &members, \"http://anglebug.com/4339\"}; // Persistently map buffer memory until destroy, saves on map/unmap IOCTL overhead // for buffers that are updated frequently. FeatureFeatureFeature persistentlyMappedBuffers = { \"persistentlyMappedBuffers\", FeatureCategory::VulkanFeatures, \"Persistently map buffer memory to reduce map/unmap IOCTL overhead.\", &members, \"http://anglebug.com/2162\"}; // Android needs to pre-rotate surfaces that are not oriented per the native device's // orientation (e.g. a landscape application on a Pixel phone). This feature works for // full-screen applications. http://anglebug.com/3502 FeatureFeatureFeature enablePreRotateSurfaces = {\"enablePreRotateSurfaces\", FeatureCategory::VulkanFeatures, \"Enable Android pre-rotation for landscape applications\", &members, \"http://anglebug.com/3502\"}; // Cache FramebufferVk objects. Currently hitting a bug on Apple: http://anglebug.com/4442 FeatureFeatureFeature enableFramebufferVkCache = {\"enableFramebufferVkCache\", FeatureCategory::VulkanFeatures, \"Enable FramebufferVk objects to be cached\", &members, \"http://anglebug.com/4442\"}; // Enable precision qualifiers for shaders generated by Vulkan backend http://anglebug.com/3078 FeatureFeatureFeature enablePrecisionQualifiers = { \"enablePrecisionQualifiers\", FeatureCategory::VulkanFeatures, \"Enable precision qualifiers in shaders\", &members, \"http://anglebug.com/3078\"}; // Desktop (at least NVIDIA) drivers prefer combining barriers into one vkCmdPipelineBarrier // call over issuing multiple barrier calls with fine grained dependency information to have // better performance. http://anglebug.com/4633 FeatureFeatureFeature preferAggregateBarrierCalls = { \"preferAggregateBarrierCalls\", FeatureCategory::VulkanWorkarounds, \"Single barrier call is preferred over multiple calls with \" \"fine grained pipeline stage dependency information\", &members, \"http://anglebug.com/4633\"}; // Tell the Vulkan back-end to use the async command queue to dispatch work to the GPU. Command // buffer work will happened in a worker thread. Otherwise use Renderer::CommandQueue directly. FeatureFeatureFeature asyncCommandQueue = {\"asyncCommandQueue\", FeatureCategory::VulkanFeatures, \"Use CommandQueue worker thread to dispatch work to GPU.\", &members, \"http://anglebug.com/4324\"}; // Whether the VkDevice supports the VK_KHR_shader_float16_int8 extension and has the // shaderFloat16 feature. FeatureFeatureFeature supportsShaderFloat16 = {\"supportsShaderFloat16\", FeatureCategory::VulkanFeatures, \"VkDevice supports the VK_KHR_shader_float16_int8 extension \" \"and has the shaderFloat16 feature\", &members, \"http://anglebug.com/4551\"}; // Some devices don't meet the limits required to perform mipmap generation using the built-in // compute shader. On some other devices, VK_IMAGE_USAGE_STORAGE_BIT is detrimental to // performance, making this solution impractical. FeatureFeatureFeature allowGenerateMipmapWithCompute = { \"allowGenerateMipmapWithCompute\", FeatureCategory::VulkanFeatures, \"Use the compute path to generate mipmaps on devices that meet the minimum requirements, \" \"and the performance is better.\", &members, \"http://anglebug.com/4551\"}; // Whether the VkDevice supports the VK_QCOM_render_pass_store_ops extension // http://anglebug.com/5505 FeatureFeatureFeature supportsRenderPassStoreOpNoneQCOM = { \"supportsRenderPassStoreOpNoneQCOM\", FeatureCategory::VulkanFeatures, \"VkDevice supports VK_QCOM_render_pass_store_ops extension.\", &members, \"http://anglebug.com/5055\"}; // Force maxUniformBufferSize to 16K on Qualcomm's Adreno 540. Pixel2's Adreno540 reports // maxUniformBufferSize 64k but various tests failed with that size. For that specific // device, we set to 16k for now which is known to pass all tests. // https://issuetracker.google.com/161903006 FeatureFeatureFeature forceMaxUniformBufferSize16KB = { \"forceMaxUniformBufferSize16KB\", FeatureCategory::VulkanWorkarounds, \"Force max uniform buffer size to 16K on some device due to bug\", &members, \"https://issuetracker.google.com/161903006\"}; // Enable mutable bit by default for ICD's that support VK_KHR_image_format_list. // http://anglebug.com/5281 FeatureFeatureFeature supportsImageFormatList = { \"supportsImageFormatList\", FeatureCategory::VulkanFeatures, \"Enable VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT by default for ICDs \" \"that support VK_KHR_image_format_list\", &members, \"http://anglebug.com/5281\"}; // Swiftshader on mac fails to initialize WebGL context when EXT_multisampled_render_to_texture // is used by Chromium. // http://anglebug.com/4937 FeatureFeatureFeature enableMultisampledRenderToTexture = { \"enableMultisampledRenderToTexture\", FeatureCategory::VulkanWorkarounds, \"Expose EXT_multisampled_render_to_texture\", &members, \"http://anglebug.com/4937\"}; // Qualcomm fails some tests when reducing the preferred block size to 4M. // http://anglebug.com/4995 FeatureFeatureFeature preferredLargeHeapBlockSize4MB = { \"preferredLargeHeapBlockSize4MB\", FeatureCategory::VulkanWorkarounds, \"Use 4 MB preferred large heap block size with AMD allocator\", &members, \"http://anglebug.com/4995\"}; // Manhattan is calling glFlush in the middle of renderpass which breaks renderpass and hurts // performance on tile based GPU. When this is enabled, we will defer the glFlush call made in // the middle of renderpass to the end of renderpass. // https://issuetracker.google.com/issues/166475273 FeatureFeatureFeature deferFlushUntilEndRenderPass = { \"deferFlushUntilEndRenderPass\", FeatureCategory::VulkanWorkarounds, \"Allow glFlush to be deferred until renderpass ends\", &members, \"https://issuetracker.google.com/issues/166475273\"}; // Android mistakenly destroys oldSwapchain passed to vkCreateSwapchainKHR, causing crashes on // certain drivers. http://anglebug.com/5061 FeatureFeatureFeature waitIdleBeforeSwapchainRecreation = { \"waitIdleBeforeSwapchainRecreation\", FeatureCategory::VulkanWorkarounds, \"Before passing an oldSwapchain to VkSwapchainCreateInfoKHR, wait for queue to be idle. \" \"Works around a bug on platforms which destroy oldSwapchain in vkCreateSwapchainKHR.\", &members, \"http://anglebug.com/5061\"}; // Translate non-nearest mip filtering modes to nearest mip for all samplers for performance // comparisons. ANGLE is non-conformant if this feature is enabled. FeatureFeatureFeature forceNearestMipFiltering = {\"forceNearestMipFiltering\", FeatureCategory::VulkanWorkarounds, \"Force nearest mip filtering when sampling.\", &members}; // Qualcomm missynchronizes vkCmdClearAttachments in the middle of render pass. // https://issuetracker.google.com/166809097 FeatureFeatureFeature preferDrawClearOverVkCmdClearAttachments = { \"preferDrawClearOverVkCmdClearAttachments\", FeatureCategory::VulkanWorkarounds, \"On some hardware, clear using a draw call instead of vkCmdClearAttachments in the middle \" \"of render pass due to bugs\", &members, \"https://issuetracker.google.com/166809097\"}; // Whether prerotation is being emulated for testing. 90 degree rotation. FeatureFeatureFeature emulatedPrerotation90 = {\"emulatedPrerotation90\", FeatureCategory::VulkanFeatures, \"Emulate 90-degree prerotation.\", &members, \"http://anglebug.com/4901\"}; // Whether prerotation is being emulated for testing. 180 degree rotation. FeatureFeatureFeature emulatedPrerotation180 = {\"emulatedPrerotation180\", FeatureCategory::VulkanFeatures, \"Emulate 180-degree prerotation.\", &members, \"http://anglebug.com/4901\"}; // Whether prerotation is being emulated for testing. 270 degree rotation. FeatureFeatureFeature emulatedPrerotation270 = {\"emulatedPrerotation270\", FeatureCategory::VulkanFeatures, \"Emulate 270-degree prerotation.\", &members, \"http://anglebug.com/4901\"}; // Whether we should use driver uniforms over specialization constants for some shader // modifications like yflip and rotation. FeatureFeatureFeature forceDriverUniformOverSpecConst = { \"forceDriverUniformOverSpecConst\", FeatureCategory::VulkanWorkarounds, \"Forces using driver uniforms instead of specialization constants.\", &members, \"http://issuetracker.google.com/173636783\"}; // Whether non-conformant configurations and extensions should be exposed. When an extension is // in development, or a GLES version is not supported on a device, we may still want to expose // them for partial testing. This feature is enabled by our test harness. FeatureFeatureFeature exposeNonConformantExtensionsAndVersions = { \"exposeNonConformantExtensionsAndVersions\", FeatureCategory::VulkanWorkarounds, \"Expose GLES versions and extensions that are not conformant.\", &members, \"http://anglebug.com/5375\"}; }; inline FeaturesVk::FeaturesVk() = default; inline FeaturesVk::~FeaturesVk() = default; } // namespace angle","title":"include "},{"location":"ANGLE/SRC_Extentions/#endif-angle_platform_featuresvk_h_","text":"","title":"endif  // ANGLE_PLATFORM_FEATURESVK_H_"},{"location":"ANGLE/SRC_Framebuffers/","text":"\u524d\u7aef Framebuffer @startuml hide method class State { Framebuffer *mReadFramebuffer; Framebuffer *mDrawFramebuffer; BindingPointer<Renderbuffer> mRenderbuffer; } class Framebuffer { FramebufferImpl *mImpl; //FramebufferVk mutable Optional<GLenum> mCachedStatus; vector<ObserverBinding> mDirtyColorAttachmentBindings; ObserverBinding mDirtyDepthAttachmentBinding; ObserverBinding mDirtyStencilAttachmentBinding; } class FramebufferState { vector<FramebufferAttachment> mColorAttachments; FramebufferAttachment mDepthAttachment; FramebufferAttachment mStencilAttachment; DrawBufferMask mColorAttachmentsMask; } Context *-- State State --> Framebuffer FramebufferState --* Framebuffer FramebufferAttachment --* FramebufferState FramebufferAttachmentObject --* FramebufferAttachment @enduml \u540e\u7aef FramebufferVk @startuml skinparam classAttributeIconSize 0 class ContextVk { FramebufferVk *mDrawFramebuffer } class FramebufferVk { - WindowSurfaceVk *mBackbuffer syncState() startNewRenderPass() &getRenderPassDesc() getFramebuffer() } class RenderPassDesc { -DrawBufferMask mColorResolveAttachmentMask; -DrawBufferMask mColorUnresolveAttachmentMask; -FramebufferNonResolveAttachmentArray mAttachmentFormats; } class RenderTargetVk { ImageHelper *mImage; ImageViewHelper *mImageViews; } class FramebufferDesc { updateColor() updateDepthStencil() attachmentCount() } ContextVk --> RenderPassCache ContextVk ..> FramebufferVk FramebufferVk *-- RenderPassDesc FramebufferVk *-- RenderTargetCache RenderTargetVk ..> RenderTargetCache FramebufferVk *-- FramebufferDesc RenderPassCache ..> RenderPassDesc @enduml API \u5b9e\u73b0 \u521b\u5efa\u9636\u6bb5 \u521b\u5efa\u9ed8\u8ba4 Framebuffer @startuml APP -> EGLWindow : initializeContext() EGLWindow -> Display : makeCurrent() Display -> Context : makeCurrent() Context -> Context : setDefaultFramebuffer(\\ndrawSurface = readSurface) Context -> Surface : createDefaultFramebuffer() Surface -> Framebuffer : Framebuffer() Framebuffer -> SurfaceVk : createDefaultFramebuffer() SurfaceVk -> FramebufferVk : CreateDefaultFBO() @enduml CreateDefaultFBO vs. CreateUserFBO \u521b\u5efa\u65f6, \u4e8c\u8005\u533a\u522b\u4ec5\u4e3a\u9ed8\u8ba4FBO\u4f1a\u5305\u542b\u4e00\u4e2aWindowSurfaceVk // static FramebufferVk *FramebufferVk::CreateUserFBO(RendererVk *renderer, const gl::FramebufferState &state) // static FramebufferVk *FramebufferVk::CreateDefaultFBO(RendererVk *renderer, const gl::FramebufferState &state, WindowSurfaceVk *backbuffer) \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61 glGenFramebuffers(1, &fbo); @startuml APP -> Context :createFramebuffer() Context -> FramebufferManager : createFramebuffer() Context -> FramebufferManager : AllocateEmptyObject() @startuml ResourceManager ANGLE \u7684 gles \u524d\u7aef\u4e2d, \u4f7f\u7528\u4e00\u7cfb\u5217 ResourceManager \u6765\u5173\u8054\u6ce8\u518c\u7684 id \u4e0e\u7c7b\u7684\u5bf9\u5e94\u60c5\u51b5.\u5176\u6709\u4e24\u4e2a\u529f\u80fd: \u521b\u5efa\u65b0\u5bf9\u8c61, \u5e76\u7528\u4e00\u4e2ahash\u8868\u628a id\u4e0e\u5bf9\u8c61\u5b58\u50a8\u8d77\u6765\u4ee5\u4f9b\u67e5\u8be2. @startuml hide method class ResourceManagerBase { HandleAllocator mHandleAllocator; } class TypedResourceManager { ResourceMap<ResourceType, IDType> mObjectMap; } class ShaderProgramManager { ResourceMap<Shader, ShaderProgramID> mShaders; ResourceMap<Program, ShaderProgramID> mPrograms; } TypedResourceManager --|> ResourceManagerBase ShaderProgramManager --|> ResourceManagerBase @enduml TypedResourceManager \u7684\u5b50\u7c7b: BufferManager ShaderProgramManager TextureManager RenderbufferManager SamplerManager SyncManager FramebufferManager ProgramPipelineManager MemoryObjectManager SemaphoreManager \u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684(Active)\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, fbo); GL_READ_FRAMEBUFFER \u548c GL_DRAW_FRAMEBUFFER \u5206\u5f00\u5904\u7406, \u82e5\u4e3aGL_FRAMEBUFFER\u5219\u4e24\u4e2a\u5206\u652f\u90fd\u8d70\u4e00\u904d. \u5148\u53bbFramebufferManager\u7684Hash\u4e2d\u67e5\u627e, \u65e0\u5219\u521b\u5efa. GL_READ_FRAMEBUFFER @startuml EntryPoint -> Context : bindReadFramebuffer box \"if(query(fbID) == null)\" Context -> FramebufferManager : checkFramebufferAllocation (ShareGroup) FramebufferManager -> FramebufferManager : AllocateNewObject FramebufferManager -> Framebuffer : new Framebuffer Framebuffer -> FramebufferVk : CreateUserFBO end box Context -> State : setReadFramebufferBinding(framebuffer) Context -> ObserverBinding : bind(framebuffer) @enduml Context \u4e2d mDrawFramebufferObserverBinding: ObserverBinding.bind \u4e3a\u89c2\u5bdf\u8005\u7ed1\u5b9a\u5355\u4e00\u89c2\u5bdf\u5bf9\u8c61. GL_DRAW_FRAMEBUFFER @startuml EntryPoint -> Context: bindDrawFramebuffer Context -> FramebufferManager : checkFramebufferAllocation (ShareGroup) Context -> FramebufferManager : if(query(ID) == null) AllocateNewObject FramebufferManager -> Framebuffer : new Framebuffer Framebuffer -> FramebufferVk : CreateUserFBO Context -> State : setDrawFramebufferBinding Context -> ObserverBinding : bind(framebuffer) Context -> StateCache : onDrawFramebufferChange( context ) \\n \u9519\u8bef\u6821\u9a8c\u7528 @enduml \u89e3\u7ed1FBO / \u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u540c\u7ed1\u5b9aFBO \u7eb9\u7406\u9644\u7740 \u5c06\u7eb9\u7406\u9644\u52a0\u5728\u5e27\u7f13\u51b2\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); @startuml EntryPoint -> Context: framebufferTexture2D Context -> State : getTargetFramebuffer (ShareGroup) Context -> Framebuffer : setAttachment Framebuffer -> FramebufferAttachment : attachment(FBAObject) Context -> State : setObjectDirty() @enduml \u7ed1\u5b9a\u540e, \u4f1a\u8bbe\u7f6e\u5982\u4e0b dirty\u72b6\u6001 - State : setObjectDirty() - framebuffer.mDirtyBits.set(DIRTY_BIT_COLOR_ATTACHMENT_0) - state.mDirtyObjects.set(DIRTY_OBJECT_READ_FRAMEBUFFER); - state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_FRAMEBUFFER); - state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_ATTACHMENTS); Renderbuffer \u9644\u7740 \u521b\u5efa\u548c\u7ed1\u5b9a Renderbuffer \u5bf9\u8c61\u7684\u5b9e\u73b0\u4e0e Framebuffer \u7c7b\u4f3c glGenRenderbuffers(1, &rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); \u53c2\u8003 GenFramebuffer , BindFramebuffer \u521b\u5efa\u4e00\u4e2a\u6df1\u5ea6\u548c\u6a21\u677f\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); \u4e24\u4e2a\u65b9\u6cd5\u540c\u4e00\u4e2a\u5b9e\u73b0, \u524d\u8005 samples=0 \u5b8c\u6210\u5bf9 RenderBufferVk \u5bf9\u8c61\u5185\u5404\u53c2\u6570\u7684\u521d\u59cb\u5316, \u53ca\u8bbe\u7f6e RenderTargetVk @startuml Context -> Renderbuffer : setStorage() Renderbuffer -> RenderbufferVk : setStorageImpl() RenderbufferVk -> ImageHelper : init() RenderbufferVk -> ImageViewHelper : init() RenderbufferVk -> RenderTargetVk : init() @enduml \u9644\u52a0\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5230 FBO\uff1a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); @startuml Context -> RenderbufferManager : getRenderbuffer() Context -> Framebuffer : setAttachmentMultisample(renderbuffer) @enduml framebuffer.mDirtyBits.set(DIRTY_BIT_DEPTH_ATTACHMENT); state.mDirtyObjects.set(DIRTY_OBJECT_READ_FRAMEBUFFER); state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_FRAMEBUFFER); state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_ATTACHMENTS); Multisample glTexture2DMultisample glRenderbufferStorageMultisample \u7ed8\u5236 \u66f4\u65b0 Viewpoint DIRTY_BIT_VIEWPORT Vertex \u7ed8\u5236 Draw \u4f7f\u7528\u79bb\u5c4f\u7eb9\u7406 BindTexture \u8bfb\u53d6 \u62f7\u8d1d glBlitFramebuffer \u8bfb\u53d6 ReadPixel \u72b6\u6001\u540c\u6b65 ANGLE \u7684\u524d\u540e\u7aef\u5728\u6267\u884c\u53ef\u80fd\u4f1a\u89e6\u53d1Flush\u7684\u64cd\u4f5c\u65f6, \u4f1a\u8fdb\u884c\u72b6\u6001\u540c\u6b65. \u5e38\u89c1\u7684\u64cd\u4f5c\u4f8b\u5982 Clear, Draw, CopyImage \u7b49. \u4f8b\u5982\u5728\u7ed1\u5b9a\u4e00\u4e2aFBO\u5e76\u6267\u884c Clear\u7684\u65f6\u5019, \u4f1a\u8fdb\u884c\u5982\u4e0b\u540c\u6b65: @startuml Context -> Context : syncState() Context -> State : syncDirtyObjects() State -> FramebufferVk : syncState() Context -> ContextVk : syncDirtyBits() ContextVk -> ContextVk : syncState() \\n case: DIRTY_BIT_DRAW_FRAMEBUFFER_BINDING ContextVk -> GraphicsPipelineDesc : updatePipelineXXXX() @enduml \u5176\u4e2dState : syncDirtyObjects \u4f1a\u4f9d\u6b21\u8c03\u7528\u6ce8\u518c\u7684 dirty \u5bf9\u8c61\u7684 syncState\u65b9\u6cd5. ContextVk : syncState \u7684 DirtyBits \u4e2d, \u5305\u542b\u4e00\u4e2a DRAW_FRAMEBUFFER_BINDING \u8868\u793a\u53d1\u751f\u8fc7 Framebuffer \u7684\u91cd\u7ed1\u5b9a, \u9700\u8981\u66f4\u65b0 FramebufferVk.syncState() syncState updateDepthStencilAttachment RenderTargetCache.updateDepthStencilRenderTarget() FramebufferDesc.updateDepthStencil FramebufferDesc.updateColorResolve renderTarget->flushStagedUpdates RenderTargetCache.update updateColorAttachment TargetCache.updateColorRenderTarget() RenderTargetCache.getColors() updateActiveColorMasks() contextVk->updateColorMasks() renderTarget->flushStagedUpdates() FramebufferDesc.updateColor() index++ FramebufferDesc::updateColorResolve() index++ contextVk->updateColorMasks() // \u53c8 contextVk->flushCommandsAndEndRenderPass() // ??? \u4e3a\u4ec0\u4e48 sync \u8981 flush? updateRenderPassDesc(); contextVk->onFramebufferChange(this); Clear // Remove clear bits that are ineffective. An effective clear changes at least one fragment. If // color/depth/stencil masks make the clear ineffective we skip it altogether. // If all color channels in all draw buffers are masked, don't attempt to clear color. // If depth write is disabled, don't attempt to clear depth. // If all stencil bits are masked, don't attempt to clear stencil. // Sync the draw framebuffer manually after the clear attachments. \u6d41\u7a0b2 @startuml @enduml \u6d41\u7a0b3 @startuml @enduml \u6d41\u7a0b4 @startuml @enduml ANGLE \u4e2d API \u7edf\u8ba1 \u672c\u8282\u5217\u51fa ANGLE \u4e2d\u5404\u7248\u672cGLES \u4e2d\u4e0e Framebuffer \u548c Renderbuffer \u76f4\u63a5\u76f8\u5173\u7684\u5185\u5bb9. \u6b64\u5916 ANGLE \u4e2d\u8fd8\u6709\u5927\u91cf\u7684\u76f8\u5173 EXT API, \u6570\u91cf\u8f83\u591a, \u6682\u4e0d\u5728\u6b64\u5217\u51fa gl2 void glBindFramebuffer (GLenum target, GLuint framebuffer); GLenum glCheckFramebufferStatus (GLenum target); void glDeleteFramebuffers (GLsizei n, const GLuint *framebuffers); void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); void glFramebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); void glGenFramebuffers (GLsizei n, GLuint *framebuffers); void glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, GLint *params); GLboolean glIsFramebuffer (GLuint framebuffer); // renderbuffer void glBindRenderbuffer (GLenum target, GLuint renderbuffer); void glDeleteRenderbuffers (GLsizei n, const GLuint *renderbuffers); void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); void glGenRenderbuffers (GLsizei n, GLuint *renderbuffers); void glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint *params); GLboolean glIsRenderbuffer (GLuint renderbuffer); void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); gl3 void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); void glFramebufferTextureLayer (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); void glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments); void glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height); // renderbuffer void glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); gl31 void glFramebufferParameteri (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params); gl32 void glFramebufferTexture (GLenum target, GLenum attachment, GLuint texture, GLint level); syncState // FramebufferVk::syncState signals that we should start a new command buffer. // But changing the binding can skip FramebufferVk::syncState if the Framebuffer // has no dirty bits. Thus we need to explicitly clear the current command // buffer to ensure we start a new one. We don't actually close the render pass here // as some optimizations in non-draw commands require the render pass to remain // open, such as invalidate or blit. Note that we always start a new command buffer // because we currently can only support one open RenderPass at a time. onRenderPassFinished(); mRenderPassCommandBuffer = nullptr; mDrawFramebuffer->setReadOnlyDepthFeedbackLoopMode(false); Framebuffer -> mReadOnlyDepthFeedbackLoopMode = false updateFlipViewportDrawFramebuffer(glState); mFlipViewportForDrawFramebuffer = drawFramebuffer->isDefault(); updateSurfaceRotationDrawFramebuffer(glState); updateGraphicsPipelineDescWithSpecConstUsageBits() mGraphicsPipelineDesc -> updateSurfaceRotation (&mGraphicsPipelineTransition, rotationAndFlip); mGraphicsPipelineDesc -> updateDrawableSize (&mGraphicsPipelineTransition, dimensions.width, dimensions.height); updateViewport(mDrawFramebuffer, glState.getViewport(), glState.getNearPlane(), glState.getFarPlane(), isViewportFlipEnabledForDrawFBO()); mGraphicsPipelineDesc->updateViewport() updateColorMasks(glState.getBlendStateExt()); mGraphicsPipelineDesc->updateColorWriteMasks() updateRasterizationSamples(mDrawFramebuffer->getSamples()); mGraphicsPipelineDesc->updateRasterizationSamples (&mGraphicsPipelineTransition, rasterizationSamples); updateSampleShadingWithRasterizationSamples (rasterizationSamples); updateSampleMaskWithRasterizationSamples (rasterizationSamples); mGraphicsPipelineDesc->updateFrontFace (&mGraphicsPipelineTransition, glState.getRasterizerState(), isViewportFlipEnabledForDrawFBO()); updateScissor(glState); mGraphicsPipelineDesc->updateScissor () const gl::DepthStencilState depthStencilState = glState.getDepthStencilState(); mGraphicsPipelineDesc ->updateDepthTestEnabled(&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc ->updateDepthWriteEnabled(&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc ->updateStencilTestEnabled(&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc ->updateStencilFrontWriteMask(&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc ->updateStencilBackWriteMask(&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); onDrawFramebufferRenderPassDescChange(mDrawFramebuffer); invalidateCurrentGraphicsPipeline(); mGraphicsPipelineDesc. set Dirty mGraphicsPipelineDesc ->updateRenderPassDesc(&mGraphicsPipelineTransition, framebufferVk->getRenderPassDesc()); mGraphicsPipelineDesc ->updateDrawableSize(&mGraphicsPipelineTransition, framebufferVk->getState().getDimensions().width, framebufferVk->getState().getDimensions().height); mGraphicsPipelineDesc -> updateSurfaceRotation (&mGraphicsPipelineTransition, rotationAndFlip); mGraphicsPipelineDesc -> updateDrawableSize (&mGraphicsPipelineTransition, dimensions.width, dimensions.height); mGraphicsPipelineDesc->updateViewport() mGraphicsPipelineDesc->updateColorWriteMasks() mGraphicsPipelineDesc->updateRasterizationSamples (&mGraphicsPipelineTransition, rasterizationSamples); updateSampleShadingWithRasterizationSamples(rasterizationSamples); mGraphicsPipelineDesc-> updateSampleShading updateSampleMaskWithRasterizationSamples(rasterizationSamples); mGraphicsPipelineDesc-> updateSampleMask mGraphicsPipelineDesc->updateFrontFace (&mGraphicsPipelineTransition, glState.getRasterizerState(), isViewportFlipEnabledForDrawFBO()); mGraphicsPipelineDesc->updateScissor () mGraphicsPipelineDesc -> updateDepthTestEnabled (&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc -> updateDepthWriteEnabled (&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc -> updateStencilTestEnabled (&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc -> updateStencilFrontWriteMask (&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc -> updateStencilBackWriteMask (&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc -> updateRenderPassDesc (&mGraphicsPipelineTransition, framebufferVk->getRenderPassDesc()); cache property Field Pipeline State updateSurfaceRotation mDepthStencilStateInfo. depthCompareOpAndSurface-Rotation.surfaceRotation \u65e0? updateDrawableSize mDrawableSize. width height \u65e0? updateViewport mViewport ALL viewportState.pScissors updateColorMasks mInputAssemblyAndColorBlendStateInfo colorWriteMaskBits, blendState updateRasterizationSamples mRasterizationAndMultisampleStateInfo bits.rasterizationSamples updateSampleShading mRasterizationAndMultisampleStateInfo bits.sampleShadingEnable minSampleShading multisampleState updateSampleMask mRasterizationAndMultisampleStateInfo sampleMask multisampleState updateFrontFace mRasterizationAndMultisampleStateInfo bits.frontFace rasterState.frontFace updateScissor mScissor ALL viewportState.pScissors updateDepthTestEnabled mDepthStencilStateInfo. enable.depthTest updateDepthWriteEnabled -- enable.depthWrite updateStencilTestEnabled -- enable.stencilTest updateStencilFrontWriteMask -- front.writeMask updateStencilBackWriteMask -- back.writeMask updateRenderPassDesc mRenderPassDesc ALL (ContextVk::syncState) \u5207\u6362 Framebuffer\u65f6, \u4fee\u6539 Pipeline \u7531\u4e8e\u5728 gles \u5207\u6362 Framebuffer\u65f6, \u4e00\u4e9b\u4e0e\u4e4b\u7ed1\u5b9a\u7684\u8bbe\u7f6e\u4e5f\u76f8\u5e94\u88ab\u5207\u6362. \u4f8b\u5982 \u989c\u8272\u9644\u7740\u7684\u6570\u91cf\u7b49. \u800c\u5728 vk \u4e2d, \u9664\u4e86\u8981\u5207\u6362\u5bf9\u5e94 RenderPass \u548c Framebuffer, \u90e8\u5206\u8bbe\u7f6e\u8fd8\u4f1a\u53cd\u5e94\u5230 Pipeline \u4e0a, \u672c\u8282\u5217\u51fa\u5728 angle \u7684 vk::ContextVk \u8fdb\u884c\u72b6\u6001\u540c\u6b65( syncState ) \u7684\u8fc7\u7a0b\u4e2d, \u5bf9 Draw Framebuffer \u7ed1\u5b9a\u66f4\u65b0\u65f6\u6d89\u53ca\u5230\u7684 Pipeline \u5c5e\u6027\u7684\u66f4\u65b0: VkPipelineViewportStateCreateInfo pViewports pScissors \u6765\u6e90: \u7531\u7ed8\u5236\u8fc7\u7a0b\u4e2d, glViewpoint \u4fee\u6539 VkPipelineRasterizationStateCreateInfo \u5149\u6805, \u8bbe\u7f6e: \u6df1\u5ea6\u6d4b\u8bd5, \u80cc\u9762\u5254\u9664, \u88c1\u526a\u6d4b\u8bd5, \u4f8b\u5982: cullMode \u8868\u660e\u5254\u9664\u7c7b\u578b: \u80cc\u9762 / \u6b63\u9762 / \u53cc\u9762 frontFace =VK_FRONT_FACE_CLOCKWISE / VK_FRONT_FACE_COUNTER_CLOCKWISE \u6307\u5b9a\u987a\u65f6\u9488\u9876\u70b9\u5e8f\u662f\u6b63\u9762, \u8fd8\u662f\u9006\u65f6\u9488\u9876\u70b9\u5e8f\u662f\u6b63\u9762 \u6765\u6e90: ANGLE \u5728\u7ed8\u5236 \u9ed8\u8ba4FB\u548c\u81ea\u5b9a\u4e49FB\u65f6, \u4f1a\u5bf9\u753b\u9762\u8fdb\u884c\u65cb\u8f6c, \u6309\u4e0d\u540c\u7684\u987a\u5e8f\u8fdb\u884c\u7ed8\u5236. \u79bb\u5c4f: VK_FRONT_FACE_COUNTER_CLOCKWISE ANGLE \u8bf4\u660e: \u7531\u4e8eVulkan\u548cGLES\u5750\u6807\u7cfb\u7684\u4e0d\u540c\uff0c\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u533a\uff08\u6e90\u81ea\u4ea4\u6362\u94fe\uff09\u5448\u4e0a\u4e0b\u98a0\u5012\u663e\u793a\u3002\u98a0\u5012\u6e32\u67d3\u5177\u6709\u4e0eOpenGL\u76f8\u540c\u7684\u6e32\u67d3\u65b9\u5f0f\u3002\u968f\u540e\u542f\u7528KHR_MAINTENANCE_1 \u6269\u5c55\u7a0b\u5e8f\u4ee5\u5141\u8bb8\u5426\u5b9a\u89c6\u53e3\u3002\u6211\u4eec\u901a\u8fc7\u53cd\u8f6c\u89c6\u53e3\u7684\u9ad8\u5ea6\u5e76\u5c06Y\u589e\u52a0\u9ad8\u5ea6\u6765\u53cd\u8f6c\u6e32\u67d3\u5230\u540e\u7f13\u51b2\u533a\u3002\u56e0\u6b64\uff0c\u5982\u679c\u89c6\u53e3\u4e3a\uff080\uff0c0\uff0cwidth\uff0cheight\uff09\uff0c\u5219\u89c6\u53e3\u53d8\u4e3a\uff080\uff0cheight\uff0cwidth\uff0c-height\uff09\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u5f53\u6211\u4eec\u5f00\u59cb\u8fd9\u6837\u505a\u65f6\uff0c\u7531\u4e8e\u6e32\u67d3\u73b0\u5728\u662f\u4e0a\u4e0b\u98a0\u5012\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u8fd8\u9700\u8981\u8c03\u6574\u4e00\u4e9b\u4f4d\u7f6e\u3002\u5230\u76ee\u524d\u4e3a\u6b62\u53d7\u5f71\u54cd\u7684\u5730\u65b9\uff1a readPixels copyTexImage framebuffer blit generating mipmaps Point sprites tests texStorage VkPipelineMultisampleStateCreateInfo \u591a\u91cd\u91c7\u6837: \u7ec4\u5408\u591a\u4e2a\u4e0d\u540c\u591a\u8fb9\u5f62\u4ea7\u751f\u7684\u7247\u6bb5\u7684\u989c\u8272, \u6765\u51b3\u5b9a\u6700\u7ec8\u989c\u8272\u7684\u6280\u672f. (\u6297\u952f\u9f7f) rasterizationSamples : \u91c7\u6837\u6570, \u7b49\u4e8e VkImage.sample sampleShadingEnable : rasterizationSamples > 1 minSampleShading : sampleShadingEnable \u4e3a false \u65f6, \u503c\u4e3a1 pSampleMask : rasterizationSamples > 1 \u4e14 SamplerMaskEnable \u65f6\u624d\u4f1a\u542f\u7528 \u6765\u6e90: \u4e0e VkImage \u4e2d samples \u6570\u53d1\u751f\u53d8\u5316\u65f6, \u4e0a\u8ff0\u503c\u5bf9\u5e94\u6539\u53d8. VkPipelineDepthStencilStateCreateInfo \u6df1\u5ea6\u6d4b\u8bd5, \u6a21\u677f\u6d4b\u8bd5 depthTestEnable = static_cast (mDepthStencilStateInfo.enable. depthTest ); depthWriteEnable = static_cast (mDepthStencilStateInfo.enable. depthWrite ); stencilTestEnable = static_cast (mDepthStencilStateInfo.enable. stencilTest ); front.writeMask back.writeMask \u6765\u6e90: gLEnable \u542f\u7528 depth test\u7b49 VkPipelineColorBlendStateCreateInfo \u989c\u8272\u6df7\u5408: blendState. pAttachments [ \u200b VkPipelineColorBlendAttachmentState. colorWriteMask ] \u6765\u6e90: Color Attachment \u6570\u91cf\u53d8\u52a8\u65f6, \u9700\u5bf9\u5e94\u589e\u5220 \u5bf9\u5e94 API: void ContextVk::updateFlipViewportDrawFramebuffer(const gl::State &glState) { // The default framebuffer (originating from the swapchain) is rendered upside-down due to the // difference in the coordinate systems of Vulkan and GLES. Rendering upside-down has the // effect that rendering is done the same way as OpenGL. The KHR_MAINTENANCE_1 extension is // subsequently enabled to allow negative viewports. We inverse rendering to the backbuffer by // reversing the height of the viewport and increasing Y by the height. So if the viewport was // (0, 0, width, height), it becomes (0, height, width, -height). Unfortunately, when we start // doing this, we also need to adjust a number of places since the rendering now happens // upside-down. Affected places so far: // // - readPixels // - copyTexImage // - framebuffer blit // - generating mipmaps // - Point sprites tests // - texStorage gl::Framebuffer *drawFramebuffer = glState.getDrawFramebuffer(); mFlipViewportForDrawFramebuffer = drawFramebuffer->isDefault(); } Framebuffers void GenFramebuffers( sizei n, uint *framebuffers ); void BindFramebuffer( enum target, uint framebuffer ); void DeleteFramebuffers( sizei n, const uint *framebuffers ); boolean IsFramebuffer( uint framebuffer ); void FramebufferParameteri( enum target, enum pname, int param ); TexStorage2DMultisample void GetFramebufferParameteriv( enum target, enum pname, int *params ); void GetFramebufferAttachmentParameteriv( enum target, enum attachment, enum pname, int *params ); enum CheckFramebufferStatus( enum target ); Renderbuffers void GenRenderbuffers( sizei n, uint *renderbuffers ); void BindRenderbuffer( enum target, uint renderbuffer ); boolean IsRenderbuffer( uint renderbuffer ); void RenderbufferStorageMultisample( enum target, sizei samples, enum internalformat, sizei width, sizei height ); void GetRenderbufferParameteriv( enum target, enum pname, int *params ); void FramebufferRenderbuffer( enum target, enum attachment, enum renderbuffertarget, uint renderbuffer ); Texture void FramebufferTexture( enum target, enum attachment, uint texture, int level ); void FramebufferTexture2D( enum target, enum attachment, enum textarget, uint texture, int level ); void FramebufferTextureLayer( enum target, enum attachment, uint texture, int level, int layer ); DynamicBuffer // A dynamic buffer is conceptually an infinitely long buffer. Each time you write to the buffer, // you will always write to a previously unused portion. After a series of writes, you must flush // the buffer data to the device. Buffer lifetime currently assumes that each new allocation will // last as long or longer than each prior allocation. // // Dynamic buffers are used to implement a variety of data streaming operations in Vulkan, such // as for immediate vertex array and element array data, uniform updates, and other dynamic data. // // Internally dynamic buffers keep a collection of VkBuffers. When we write past the end of a // currently active VkBuffer we keep it until it is no longer in use. We then mark it available // for future allocations in a free list. class BufferHelper; using BufferHelperPointerVector = std::vector<std::unique_ptr<BufferHelper>>; class DynamicBuffer : angle::NonCopyable { public: DynamicBuffer(); DynamicBuffer(DynamicBuffer &&other); ~DynamicBuffer(); // Init is called after the buffer creation so that the alignment can be specified later. void init(RendererVk *renderer, VkBufferUsageFlags usage, size_t alignment, size_t initialSize, bool hostVisible); // Init that gives the ability to pass in specified memory property flags for the buffer. void initWithFlags(RendererVk *renderer, VkBufferUsageFlags usage, size_t alignment, size_t initialSize, VkMemoryPropertyFlags memoryProperty); // This call will allocate a new region at the end of the current buffer. If it can't find // enough space in the current buffer, it returns false. This gives caller a chance to deal with // buffer switch that may occur with allocate call. bool allocateFromCurrentBuffer(size_t sizeInBytes, uint8_t **ptrOut, VkDeviceSize *offsetOut); // This call will allocate a new region at the end of the buffer. It internally may trigger // a new buffer to be created (which is returned in the optional parameter // `newBufferAllocatedOut`). The new region will be in the returned buffer at given offset. If // a memory pointer is given, the buffer will be automatically map()ed. angle::Result allocateWithAlignment(ContextVk *contextVk, size_t sizeInBytes, size_t alignment, uint8_t **ptrOut, VkBuffer *bufferOut, VkDeviceSize *offsetOut, bool *newBufferAllocatedOut); // Allocate with default alignment angle::Result allocate(ContextVk *contextVk, size_t sizeInBytes, uint8_t **ptrOut, VkBuffer *bufferOut, VkDeviceSize *offsetOut, bool *newBufferAllocatedOut) { return allocateWithAlignment(contextVk, sizeInBytes, mAlignment, ptrOut, bufferOut, offsetOut, newBufferAllocatedOut); } // After a sequence of writes, call flush to ensure the data is visible to the device. angle::Result flush(ContextVk *contextVk); // After a sequence of writes, call invalidate to ensure the data is visible to the host. angle::Result invalidate(ContextVk *contextVk); // This releases resources when they might currently be in use. void release(RendererVk *renderer); // This releases all the buffers that have been allocated since this was last called. void releaseInFlightBuffers(ContextVk *contextVk); // This adds inflight buffers to the context's mResourceUseList and then releases them void releaseInFlightBuffersToResourceUseList(ContextVk *contextVk); // This frees resources immediately. void destroy(RendererVk *renderer); BufferHelper *getCurrentBuffer() const { return mBuffer.get(); } // **Accumulate** an alignment requirement. A dynamic buffer is used as the staging buffer for // image uploads, which can contain updates to unrelated mips, possibly with different formats. // The staging buffer should have an alignment that can satisfy all those formats, i.e. it's the // lcm of all alignments set in its lifetime. void requireAlignment(RendererVk *renderer, size_t alignment); size_t getAlignment() const { return mAlignment; } // For testing only! void setMinimumSizeForTesting(size_t minSize); bool isCoherent() const { return (mMemoryPropertyFlags & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) != 0; } private: void reset(); angle::Result allocateNewBuffer(ContextVk *contextVk); VkBufferUsageFlags mUsage; bool mHostVisible; size_t mInitialSize; std::unique_ptr<BufferHelper> mBuffer; uint32_t mNextAllocationOffset; uint32_t mLastFlushOrInvalidateOffset; size_t mSize; size_t mAlignment; VkMemoryPropertyFlags mMemoryPropertyFlags; BufferHelperPointerVector mInFlightBuffers; BufferHelperPointerVector mBufferFreeList; };","title":"SRC Framebuffers"},{"location":"ANGLE/SRC_Framebuffers/#framebuffer","text":"@startuml hide method class State { Framebuffer *mReadFramebuffer; Framebuffer *mDrawFramebuffer; BindingPointer<Renderbuffer> mRenderbuffer; } class Framebuffer { FramebufferImpl *mImpl; //FramebufferVk mutable Optional<GLenum> mCachedStatus; vector<ObserverBinding> mDirtyColorAttachmentBindings; ObserverBinding mDirtyDepthAttachmentBinding; ObserverBinding mDirtyStencilAttachmentBinding; } class FramebufferState { vector<FramebufferAttachment> mColorAttachments; FramebufferAttachment mDepthAttachment; FramebufferAttachment mStencilAttachment; DrawBufferMask mColorAttachmentsMask; } Context *-- State State --> Framebuffer FramebufferState --* Framebuffer FramebufferAttachment --* FramebufferState FramebufferAttachmentObject --* FramebufferAttachment @enduml","title":"\u524d\u7aef Framebuffer"},{"location":"ANGLE/SRC_Framebuffers/#framebuffervk","text":"@startuml skinparam classAttributeIconSize 0 class ContextVk { FramebufferVk *mDrawFramebuffer } class FramebufferVk { - WindowSurfaceVk *mBackbuffer syncState() startNewRenderPass() &getRenderPassDesc() getFramebuffer() } class RenderPassDesc { -DrawBufferMask mColorResolveAttachmentMask; -DrawBufferMask mColorUnresolveAttachmentMask; -FramebufferNonResolveAttachmentArray mAttachmentFormats; } class RenderTargetVk { ImageHelper *mImage; ImageViewHelper *mImageViews; } class FramebufferDesc { updateColor() updateDepthStencil() attachmentCount() } ContextVk --> RenderPassCache ContextVk ..> FramebufferVk FramebufferVk *-- RenderPassDesc FramebufferVk *-- RenderTargetCache RenderTargetVk ..> RenderTargetCache FramebufferVk *-- FramebufferDesc RenderPassCache ..> RenderPassDesc @enduml","title":"\u540e\u7aef FramebufferVk"},{"location":"ANGLE/SRC_Framebuffers/#api","text":"","title":"API \u5b9e\u73b0"},{"location":"ANGLE/SRC_Framebuffers/#_1","text":"\u521b\u5efa\u9ed8\u8ba4 Framebuffer @startuml APP -> EGLWindow : initializeContext() EGLWindow -> Display : makeCurrent() Display -> Context : makeCurrent() Context -> Context : setDefaultFramebuffer(\\ndrawSurface = readSurface) Context -> Surface : createDefaultFramebuffer() Surface -> Framebuffer : Framebuffer() Framebuffer -> SurfaceVk : createDefaultFramebuffer() SurfaceVk -> FramebufferVk : CreateDefaultFBO() @enduml CreateDefaultFBO vs. CreateUserFBO \u521b\u5efa\u65f6, \u4e8c\u8005\u533a\u522b\u4ec5\u4e3a\u9ed8\u8ba4FBO\u4f1a\u5305\u542b\u4e00\u4e2aWindowSurfaceVk // static FramebufferVk *FramebufferVk::CreateUserFBO(RendererVk *renderer, const gl::FramebufferState &state) // static FramebufferVk *FramebufferVk::CreateDefaultFBO(RendererVk *renderer, const gl::FramebufferState &state, WindowSurfaceVk *backbuffer) \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61 glGenFramebuffers(1, &fbo); @startuml APP -> Context :createFramebuffer() Context -> FramebufferManager : createFramebuffer() Context -> FramebufferManager : AllocateEmptyObject() @startuml","title":"\u521b\u5efa\u9636\u6bb5"},{"location":"ANGLE/SRC_Framebuffers/#resourcemanager","text":"ANGLE \u7684 gles \u524d\u7aef\u4e2d, \u4f7f\u7528\u4e00\u7cfb\u5217 ResourceManager \u6765\u5173\u8054\u6ce8\u518c\u7684 id \u4e0e\u7c7b\u7684\u5bf9\u5e94\u60c5\u51b5.\u5176\u6709\u4e24\u4e2a\u529f\u80fd: \u521b\u5efa\u65b0\u5bf9\u8c61, \u5e76\u7528\u4e00\u4e2ahash\u8868\u628a id\u4e0e\u5bf9\u8c61\u5b58\u50a8\u8d77\u6765\u4ee5\u4f9b\u67e5\u8be2. @startuml hide method class ResourceManagerBase { HandleAllocator mHandleAllocator; } class TypedResourceManager { ResourceMap<ResourceType, IDType> mObjectMap; } class ShaderProgramManager { ResourceMap<Shader, ShaderProgramID> mShaders; ResourceMap<Program, ShaderProgramID> mPrograms; } TypedResourceManager --|> ResourceManagerBase ShaderProgramManager --|> ResourceManagerBase @enduml TypedResourceManager \u7684\u5b50\u7c7b: BufferManager ShaderProgramManager TextureManager RenderbufferManager SamplerManager SyncManager FramebufferManager ProgramPipelineManager MemoryObjectManager SemaphoreManager \u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684(Active)\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, fbo); GL_READ_FRAMEBUFFER \u548c GL_DRAW_FRAMEBUFFER \u5206\u5f00\u5904\u7406, \u82e5\u4e3aGL_FRAMEBUFFER\u5219\u4e24\u4e2a\u5206\u652f\u90fd\u8d70\u4e00\u904d. \u5148\u53bbFramebufferManager\u7684Hash\u4e2d\u67e5\u627e, \u65e0\u5219\u521b\u5efa. GL_READ_FRAMEBUFFER @startuml EntryPoint -> Context : bindReadFramebuffer box \"if(query(fbID) == null)\" Context -> FramebufferManager : checkFramebufferAllocation (ShareGroup) FramebufferManager -> FramebufferManager : AllocateNewObject FramebufferManager -> Framebuffer : new Framebuffer Framebuffer -> FramebufferVk : CreateUserFBO end box Context -> State : setReadFramebufferBinding(framebuffer) Context -> ObserverBinding : bind(framebuffer) @enduml Context \u4e2d mDrawFramebufferObserverBinding: ObserverBinding.bind \u4e3a\u89c2\u5bdf\u8005\u7ed1\u5b9a\u5355\u4e00\u89c2\u5bdf\u5bf9\u8c61. GL_DRAW_FRAMEBUFFER @startuml EntryPoint -> Context: bindDrawFramebuffer Context -> FramebufferManager : checkFramebufferAllocation (ShareGroup) Context -> FramebufferManager : if(query(ID) == null) AllocateNewObject FramebufferManager -> Framebuffer : new Framebuffer Framebuffer -> FramebufferVk : CreateUserFBO Context -> State : setDrawFramebufferBinding Context -> ObserverBinding : bind(framebuffer) Context -> StateCache : onDrawFramebufferChange( context ) \\n \u9519\u8bef\u6821\u9a8c\u7528 @enduml \u89e3\u7ed1FBO / \u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u540c\u7ed1\u5b9aFBO","title":"ResourceManager"},{"location":"ANGLE/SRC_Framebuffers/#_2","text":"\u5c06\u7eb9\u7406\u9644\u52a0\u5728\u5e27\u7f13\u51b2\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); @startuml EntryPoint -> Context: framebufferTexture2D Context -> State : getTargetFramebuffer (ShareGroup) Context -> Framebuffer : setAttachment Framebuffer -> FramebufferAttachment : attachment(FBAObject) Context -> State : setObjectDirty() @enduml \u7ed1\u5b9a\u540e, \u4f1a\u8bbe\u7f6e\u5982\u4e0b dirty\u72b6\u6001 - State : setObjectDirty() - framebuffer.mDirtyBits.set(DIRTY_BIT_COLOR_ATTACHMENT_0) - state.mDirtyObjects.set(DIRTY_OBJECT_READ_FRAMEBUFFER); - state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_FRAMEBUFFER); - state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_ATTACHMENTS);","title":"\u7eb9\u7406\u9644\u7740"},{"location":"ANGLE/SRC_Framebuffers/#renderbuffer","text":"\u521b\u5efa\u548c\u7ed1\u5b9a Renderbuffer \u5bf9\u8c61\u7684\u5b9e\u73b0\u4e0e Framebuffer \u7c7b\u4f3c glGenRenderbuffers(1, &rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); \u53c2\u8003 GenFramebuffer , BindFramebuffer \u521b\u5efa\u4e00\u4e2a\u6df1\u5ea6\u548c\u6a21\u677f\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); \u4e24\u4e2a\u65b9\u6cd5\u540c\u4e00\u4e2a\u5b9e\u73b0, \u524d\u8005 samples=0 \u5b8c\u6210\u5bf9 RenderBufferVk \u5bf9\u8c61\u5185\u5404\u53c2\u6570\u7684\u521d\u59cb\u5316, \u53ca\u8bbe\u7f6e RenderTargetVk @startuml Context -> Renderbuffer : setStorage() Renderbuffer -> RenderbufferVk : setStorageImpl() RenderbufferVk -> ImageHelper : init() RenderbufferVk -> ImageViewHelper : init() RenderbufferVk -> RenderTargetVk : init() @enduml \u9644\u52a0\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5230 FBO\uff1a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); @startuml Context -> RenderbufferManager : getRenderbuffer() Context -> Framebuffer : setAttachmentMultisample(renderbuffer) @enduml framebuffer.mDirtyBits.set(DIRTY_BIT_DEPTH_ATTACHMENT); state.mDirtyObjects.set(DIRTY_OBJECT_READ_FRAMEBUFFER); state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_FRAMEBUFFER); state.mDirtyObjects.set(DIRTY_OBJECT_DRAW_ATTACHMENTS);","title":"Renderbuffer \u9644\u7740"},{"location":"ANGLE/SRC_Framebuffers/#multisample","text":"glTexture2DMultisample glRenderbufferStorageMultisample","title":"Multisample"},{"location":"ANGLE/SRC_Framebuffers/#_3","text":"\u66f4\u65b0 Viewpoint DIRTY_BIT_VIEWPORT Vertex \u7ed8\u5236 Draw \u4f7f\u7528\u79bb\u5c4f\u7eb9\u7406 BindTexture","title":"\u7ed8\u5236"},{"location":"ANGLE/SRC_Framebuffers/#_4","text":"\u62f7\u8d1d glBlitFramebuffer \u8bfb\u53d6 ReadPixel","title":"\u8bfb\u53d6"},{"location":"ANGLE/SRC_Framebuffers/#_5","text":"ANGLE \u7684\u524d\u540e\u7aef\u5728\u6267\u884c\u53ef\u80fd\u4f1a\u89e6\u53d1Flush\u7684\u64cd\u4f5c\u65f6, \u4f1a\u8fdb\u884c\u72b6\u6001\u540c\u6b65. \u5e38\u89c1\u7684\u64cd\u4f5c\u4f8b\u5982 Clear, Draw, CopyImage \u7b49. \u4f8b\u5982\u5728\u7ed1\u5b9a\u4e00\u4e2aFBO\u5e76\u6267\u884c Clear\u7684\u65f6\u5019, \u4f1a\u8fdb\u884c\u5982\u4e0b\u540c\u6b65: @startuml Context -> Context : syncState() Context -> State : syncDirtyObjects() State -> FramebufferVk : syncState() Context -> ContextVk : syncDirtyBits() ContextVk -> ContextVk : syncState() \\n case: DIRTY_BIT_DRAW_FRAMEBUFFER_BINDING ContextVk -> GraphicsPipelineDesc : updatePipelineXXXX() @enduml \u5176\u4e2dState : syncDirtyObjects \u4f1a\u4f9d\u6b21\u8c03\u7528\u6ce8\u518c\u7684 dirty \u5bf9\u8c61\u7684 syncState\u65b9\u6cd5. ContextVk : syncState \u7684 DirtyBits \u4e2d, \u5305\u542b\u4e00\u4e2a DRAW_FRAMEBUFFER_BINDING \u8868\u793a\u53d1\u751f\u8fc7 Framebuffer \u7684\u91cd\u7ed1\u5b9a, \u9700\u8981\u66f4\u65b0","title":"\u72b6\u6001\u540c\u6b65"},{"location":"ANGLE/SRC_Framebuffers/#framebuffervksyncstate","text":"syncState updateDepthStencilAttachment RenderTargetCache.updateDepthStencilRenderTarget() FramebufferDesc.updateDepthStencil FramebufferDesc.updateColorResolve renderTarget->flushStagedUpdates RenderTargetCache.update updateColorAttachment TargetCache.updateColorRenderTarget() RenderTargetCache.getColors() updateActiveColorMasks() contextVk->updateColorMasks() renderTarget->flushStagedUpdates() FramebufferDesc.updateColor() index++ FramebufferDesc::updateColorResolve() index++ contextVk->updateColorMasks() // \u53c8 contextVk->flushCommandsAndEndRenderPass() // ??? \u4e3a\u4ec0\u4e48 sync \u8981 flush? updateRenderPassDesc(); contextVk->onFramebufferChange(this);","title":"FramebufferVk.syncState()"},{"location":"ANGLE/SRC_Framebuffers/#clear","text":"// Remove clear bits that are ineffective. An effective clear changes at least one fragment. If // color/depth/stencil masks make the clear ineffective we skip it altogether. // If all color channels in all draw buffers are masked, don't attempt to clear color. // If depth write is disabled, don't attempt to clear depth. // If all stencil bits are masked, don't attempt to clear stencil. // Sync the draw framebuffer manually after the clear attachments. \u6d41\u7a0b2 @startuml @enduml \u6d41\u7a0b3 @startuml @enduml \u6d41\u7a0b4 @startuml @enduml","title":"Clear"},{"location":"ANGLE/SRC_Framebuffers/#angle-api","text":"\u672c\u8282\u5217\u51fa ANGLE \u4e2d\u5404\u7248\u672cGLES \u4e2d\u4e0e Framebuffer \u548c Renderbuffer \u76f4\u63a5\u76f8\u5173\u7684\u5185\u5bb9. \u6b64\u5916 ANGLE \u4e2d\u8fd8\u6709\u5927\u91cf\u7684\u76f8\u5173 EXT API, \u6570\u91cf\u8f83\u591a, \u6682\u4e0d\u5728\u6b64\u5217\u51fa","title":"ANGLE \u4e2d API \u7edf\u8ba1"},{"location":"ANGLE/SRC_Framebuffers/#gl2","text":"void glBindFramebuffer (GLenum target, GLuint framebuffer); GLenum glCheckFramebufferStatus (GLenum target); void glDeleteFramebuffers (GLsizei n, const GLuint *framebuffers); void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); void glFramebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); void glGenFramebuffers (GLsizei n, GLuint *framebuffers); void glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, GLint *params); GLboolean glIsFramebuffer (GLuint framebuffer); // renderbuffer void glBindRenderbuffer (GLenum target, GLuint renderbuffer); void glDeleteRenderbuffers (GLsizei n, const GLuint *renderbuffers); void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); void glGenRenderbuffers (GLsizei n, GLuint *renderbuffers); void glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint *params); GLboolean glIsRenderbuffer (GLuint renderbuffer); void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);","title":"gl2"},{"location":"ANGLE/SRC_Framebuffers/#gl3","text":"void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); void glFramebufferTextureLayer (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); void glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments); void glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height); // renderbuffer void glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);","title":"gl3"},{"location":"ANGLE/SRC_Framebuffers/#gl31","text":"void glFramebufferParameteri (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params);","title":"gl31"},{"location":"ANGLE/SRC_Framebuffers/#gl32","text":"void glFramebufferTexture (GLenum target, GLenum attachment, GLuint texture, GLint level);","title":"gl32"},{"location":"ANGLE/SRC_Framebuffers/#syncstate","text":"// FramebufferVk::syncState signals that we should start a new command buffer. // But changing the binding can skip FramebufferVk::syncState if the Framebuffer // has no dirty bits. Thus we need to explicitly clear the current command // buffer to ensure we start a new one. We don't actually close the render pass here // as some optimizations in non-draw commands require the render pass to remain // open, such as invalidate or blit. Note that we always start a new command buffer // because we currently can only support one open RenderPass at a time. onRenderPassFinished(); mRenderPassCommandBuffer = nullptr; mDrawFramebuffer->setReadOnlyDepthFeedbackLoopMode(false); Framebuffer -> mReadOnlyDepthFeedbackLoopMode = false updateFlipViewportDrawFramebuffer(glState); mFlipViewportForDrawFramebuffer = drawFramebuffer->isDefault(); updateSurfaceRotationDrawFramebuffer(glState); updateGraphicsPipelineDescWithSpecConstUsageBits() mGraphicsPipelineDesc -> updateSurfaceRotation (&mGraphicsPipelineTransition, rotationAndFlip); mGraphicsPipelineDesc -> updateDrawableSize (&mGraphicsPipelineTransition, dimensions.width, dimensions.height); updateViewport(mDrawFramebuffer, glState.getViewport(), glState.getNearPlane(), glState.getFarPlane(), isViewportFlipEnabledForDrawFBO()); mGraphicsPipelineDesc->updateViewport() updateColorMasks(glState.getBlendStateExt()); mGraphicsPipelineDesc->updateColorWriteMasks() updateRasterizationSamples(mDrawFramebuffer->getSamples()); mGraphicsPipelineDesc->updateRasterizationSamples (&mGraphicsPipelineTransition, rasterizationSamples); updateSampleShadingWithRasterizationSamples (rasterizationSamples); updateSampleMaskWithRasterizationSamples (rasterizationSamples); mGraphicsPipelineDesc->updateFrontFace (&mGraphicsPipelineTransition, glState.getRasterizerState(), isViewportFlipEnabledForDrawFBO()); updateScissor(glState); mGraphicsPipelineDesc->updateScissor () const gl::DepthStencilState depthStencilState = glState.getDepthStencilState(); mGraphicsPipelineDesc ->updateDepthTestEnabled(&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc ->updateDepthWriteEnabled(&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc ->updateStencilTestEnabled(&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc ->updateStencilFrontWriteMask(&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc ->updateStencilBackWriteMask(&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); onDrawFramebufferRenderPassDescChange(mDrawFramebuffer); invalidateCurrentGraphicsPipeline(); mGraphicsPipelineDesc. set Dirty mGraphicsPipelineDesc ->updateRenderPassDesc(&mGraphicsPipelineTransition, framebufferVk->getRenderPassDesc()); mGraphicsPipelineDesc ->updateDrawableSize(&mGraphicsPipelineTransition, framebufferVk->getState().getDimensions().width, framebufferVk->getState().getDimensions().height); mGraphicsPipelineDesc -> updateSurfaceRotation (&mGraphicsPipelineTransition, rotationAndFlip); mGraphicsPipelineDesc -> updateDrawableSize (&mGraphicsPipelineTransition, dimensions.width, dimensions.height); mGraphicsPipelineDesc->updateViewport() mGraphicsPipelineDesc->updateColorWriteMasks() mGraphicsPipelineDesc->updateRasterizationSamples (&mGraphicsPipelineTransition, rasterizationSamples); updateSampleShadingWithRasterizationSamples(rasterizationSamples); mGraphicsPipelineDesc-> updateSampleShading updateSampleMaskWithRasterizationSamples(rasterizationSamples); mGraphicsPipelineDesc-> updateSampleMask mGraphicsPipelineDesc->updateFrontFace (&mGraphicsPipelineTransition, glState.getRasterizerState(), isViewportFlipEnabledForDrawFBO()); mGraphicsPipelineDesc->updateScissor () mGraphicsPipelineDesc -> updateDepthTestEnabled (&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc -> updateDepthWriteEnabled (&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc -> updateStencilTestEnabled (&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc -> updateStencilFrontWriteMask (&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc -> updateStencilBackWriteMask (&mGraphicsPipelineTransition, depthStencilState, drawFramebuffer); mGraphicsPipelineDesc -> updateRenderPassDesc (&mGraphicsPipelineTransition, framebufferVk->getRenderPassDesc()); cache property Field Pipeline State updateSurfaceRotation mDepthStencilStateInfo. depthCompareOpAndSurface-Rotation.surfaceRotation \u65e0? updateDrawableSize mDrawableSize. width height \u65e0? updateViewport mViewport ALL viewportState.pScissors updateColorMasks mInputAssemblyAndColorBlendStateInfo colorWriteMaskBits, blendState updateRasterizationSamples mRasterizationAndMultisampleStateInfo bits.rasterizationSamples updateSampleShading mRasterizationAndMultisampleStateInfo bits.sampleShadingEnable minSampleShading multisampleState updateSampleMask mRasterizationAndMultisampleStateInfo sampleMask multisampleState updateFrontFace mRasterizationAndMultisampleStateInfo bits.frontFace rasterState.frontFace updateScissor mScissor ALL viewportState.pScissors updateDepthTestEnabled mDepthStencilStateInfo. enable.depthTest updateDepthWriteEnabled -- enable.depthWrite updateStencilTestEnabled -- enable.stencilTest updateStencilFrontWriteMask -- front.writeMask updateStencilBackWriteMask -- back.writeMask updateRenderPassDesc mRenderPassDesc ALL (ContextVk::syncState)","title":"syncState"},{"location":"ANGLE/SRC_Framebuffers/#framebuffer-pipeline","text":"\u7531\u4e8e\u5728 gles \u5207\u6362 Framebuffer\u65f6, \u4e00\u4e9b\u4e0e\u4e4b\u7ed1\u5b9a\u7684\u8bbe\u7f6e\u4e5f\u76f8\u5e94\u88ab\u5207\u6362. \u4f8b\u5982 \u989c\u8272\u9644\u7740\u7684\u6570\u91cf\u7b49. \u800c\u5728 vk \u4e2d, \u9664\u4e86\u8981\u5207\u6362\u5bf9\u5e94 RenderPass \u548c Framebuffer, \u90e8\u5206\u8bbe\u7f6e\u8fd8\u4f1a\u53cd\u5e94\u5230 Pipeline \u4e0a, \u672c\u8282\u5217\u51fa\u5728 angle \u7684 vk::ContextVk \u8fdb\u884c\u72b6\u6001\u540c\u6b65( syncState ) \u7684\u8fc7\u7a0b\u4e2d, \u5bf9 Draw Framebuffer \u7ed1\u5b9a\u66f4\u65b0\u65f6\u6d89\u53ca\u5230\u7684 Pipeline \u5c5e\u6027\u7684\u66f4\u65b0: VkPipelineViewportStateCreateInfo pViewports pScissors \u6765\u6e90: \u7531\u7ed8\u5236\u8fc7\u7a0b\u4e2d, glViewpoint \u4fee\u6539 VkPipelineRasterizationStateCreateInfo \u5149\u6805, \u8bbe\u7f6e: \u6df1\u5ea6\u6d4b\u8bd5, \u80cc\u9762\u5254\u9664, \u88c1\u526a\u6d4b\u8bd5, \u4f8b\u5982: cullMode \u8868\u660e\u5254\u9664\u7c7b\u578b: \u80cc\u9762 / \u6b63\u9762 / \u53cc\u9762 frontFace =VK_FRONT_FACE_CLOCKWISE / VK_FRONT_FACE_COUNTER_CLOCKWISE \u6307\u5b9a\u987a\u65f6\u9488\u9876\u70b9\u5e8f\u662f\u6b63\u9762, \u8fd8\u662f\u9006\u65f6\u9488\u9876\u70b9\u5e8f\u662f\u6b63\u9762 \u6765\u6e90: ANGLE \u5728\u7ed8\u5236 \u9ed8\u8ba4FB\u548c\u81ea\u5b9a\u4e49FB\u65f6, \u4f1a\u5bf9\u753b\u9762\u8fdb\u884c\u65cb\u8f6c, \u6309\u4e0d\u540c\u7684\u987a\u5e8f\u8fdb\u884c\u7ed8\u5236. \u79bb\u5c4f: VK_FRONT_FACE_COUNTER_CLOCKWISE ANGLE \u8bf4\u660e: \u7531\u4e8eVulkan\u548cGLES\u5750\u6807\u7cfb\u7684\u4e0d\u540c\uff0c\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u533a\uff08\u6e90\u81ea\u4ea4\u6362\u94fe\uff09\u5448\u4e0a\u4e0b\u98a0\u5012\u663e\u793a\u3002\u98a0\u5012\u6e32\u67d3\u5177\u6709\u4e0eOpenGL\u76f8\u540c\u7684\u6e32\u67d3\u65b9\u5f0f\u3002\u968f\u540e\u542f\u7528KHR_MAINTENANCE_1 \u6269\u5c55\u7a0b\u5e8f\u4ee5\u5141\u8bb8\u5426\u5b9a\u89c6\u53e3\u3002\u6211\u4eec\u901a\u8fc7\u53cd\u8f6c\u89c6\u53e3\u7684\u9ad8\u5ea6\u5e76\u5c06Y\u589e\u52a0\u9ad8\u5ea6\u6765\u53cd\u8f6c\u6e32\u67d3\u5230\u540e\u7f13\u51b2\u533a\u3002\u56e0\u6b64\uff0c\u5982\u679c\u89c6\u53e3\u4e3a\uff080\uff0c0\uff0cwidth\uff0cheight\uff09\uff0c\u5219\u89c6\u53e3\u53d8\u4e3a\uff080\uff0cheight\uff0cwidth\uff0c-height\uff09\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u5f53\u6211\u4eec\u5f00\u59cb\u8fd9\u6837\u505a\u65f6\uff0c\u7531\u4e8e\u6e32\u67d3\u73b0\u5728\u662f\u4e0a\u4e0b\u98a0\u5012\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u8fd8\u9700\u8981\u8c03\u6574\u4e00\u4e9b\u4f4d\u7f6e\u3002\u5230\u76ee\u524d\u4e3a\u6b62\u53d7\u5f71\u54cd\u7684\u5730\u65b9\uff1a readPixels copyTexImage framebuffer blit generating mipmaps Point sprites tests texStorage VkPipelineMultisampleStateCreateInfo \u591a\u91cd\u91c7\u6837: \u7ec4\u5408\u591a\u4e2a\u4e0d\u540c\u591a\u8fb9\u5f62\u4ea7\u751f\u7684\u7247\u6bb5\u7684\u989c\u8272, \u6765\u51b3\u5b9a\u6700\u7ec8\u989c\u8272\u7684\u6280\u672f. (\u6297\u952f\u9f7f) rasterizationSamples : \u91c7\u6837\u6570, \u7b49\u4e8e VkImage.sample sampleShadingEnable : rasterizationSamples > 1 minSampleShading : sampleShadingEnable \u4e3a false \u65f6, \u503c\u4e3a1 pSampleMask : rasterizationSamples > 1 \u4e14 SamplerMaskEnable \u65f6\u624d\u4f1a\u542f\u7528 \u6765\u6e90: \u4e0e VkImage \u4e2d samples \u6570\u53d1\u751f\u53d8\u5316\u65f6, \u4e0a\u8ff0\u503c\u5bf9\u5e94\u6539\u53d8. VkPipelineDepthStencilStateCreateInfo \u6df1\u5ea6\u6d4b\u8bd5, \u6a21\u677f\u6d4b\u8bd5 depthTestEnable = static_cast (mDepthStencilStateInfo.enable. depthTest ); depthWriteEnable = static_cast (mDepthStencilStateInfo.enable. depthWrite ); stencilTestEnable = static_cast (mDepthStencilStateInfo.enable. stencilTest ); front.writeMask back.writeMask \u6765\u6e90: gLEnable \u542f\u7528 depth test\u7b49 VkPipelineColorBlendStateCreateInfo \u989c\u8272\u6df7\u5408: blendState. pAttachments [ \u200b VkPipelineColorBlendAttachmentState. colorWriteMask ] \u6765\u6e90: Color Attachment \u6570\u91cf\u53d8\u52a8\u65f6, \u9700\u5bf9\u5e94\u589e\u5220 \u5bf9\u5e94 API: void ContextVk::updateFlipViewportDrawFramebuffer(const gl::State &glState) { // The default framebuffer (originating from the swapchain) is rendered upside-down due to the // difference in the coordinate systems of Vulkan and GLES. Rendering upside-down has the // effect that rendering is done the same way as OpenGL. The KHR_MAINTENANCE_1 extension is // subsequently enabled to allow negative viewports. We inverse rendering to the backbuffer by // reversing the height of the viewport and increasing Y by the height. So if the viewport was // (0, 0, width, height), it becomes (0, height, width, -height). Unfortunately, when we start // doing this, we also need to adjust a number of places since the rendering now happens // upside-down. Affected places so far: // // - readPixels // - copyTexImage // - framebuffer blit // - generating mipmaps // - Point sprites tests // - texStorage gl::Framebuffer *drawFramebuffer = glState.getDrawFramebuffer(); mFlipViewportForDrawFramebuffer = drawFramebuffer->isDefault(); }","title":"\u5207\u6362 Framebuffer\u65f6, \u4fee\u6539 Pipeline"},{"location":"ANGLE/SRC_Framebuffers/#framebuffers","text":"void GenFramebuffers( sizei n, uint *framebuffers ); void BindFramebuffer( enum target, uint framebuffer ); void DeleteFramebuffers( sizei n, const uint *framebuffers ); boolean IsFramebuffer( uint framebuffer ); void FramebufferParameteri( enum target, enum pname, int param ); TexStorage2DMultisample void GetFramebufferParameteriv( enum target, enum pname, int *params ); void GetFramebufferAttachmentParameteriv( enum target, enum attachment, enum pname, int *params ); enum CheckFramebufferStatus( enum target );","title":"Framebuffers"},{"location":"ANGLE/SRC_Framebuffers/#renderbuffers","text":"void GenRenderbuffers( sizei n, uint *renderbuffers ); void BindRenderbuffer( enum target, uint renderbuffer ); boolean IsRenderbuffer( uint renderbuffer ); void RenderbufferStorageMultisample( enum target, sizei samples, enum internalformat, sizei width, sizei height ); void GetRenderbufferParameteriv( enum target, enum pname, int *params ); void FramebufferRenderbuffer( enum target, enum attachment, enum renderbuffertarget, uint renderbuffer );","title":"Renderbuffers"},{"location":"ANGLE/SRC_Framebuffers/#texture","text":"void FramebufferTexture( enum target, enum attachment, uint texture, int level ); void FramebufferTexture2D( enum target, enum attachment, enum textarget, uint texture, int level ); void FramebufferTextureLayer( enum target, enum attachment, uint texture, int level, int layer );","title":"Texture"},{"location":"ANGLE/SRC_Framebuffers/#dynamicbuffer","text":"// A dynamic buffer is conceptually an infinitely long buffer. Each time you write to the buffer, // you will always write to a previously unused portion. After a series of writes, you must flush // the buffer data to the device. Buffer lifetime currently assumes that each new allocation will // last as long or longer than each prior allocation. // // Dynamic buffers are used to implement a variety of data streaming operations in Vulkan, such // as for immediate vertex array and element array data, uniform updates, and other dynamic data. // // Internally dynamic buffers keep a collection of VkBuffers. When we write past the end of a // currently active VkBuffer we keep it until it is no longer in use. We then mark it available // for future allocations in a free list. class BufferHelper; using BufferHelperPointerVector = std::vector<std::unique_ptr<BufferHelper>>; class DynamicBuffer : angle::NonCopyable { public: DynamicBuffer(); DynamicBuffer(DynamicBuffer &&other); ~DynamicBuffer(); // Init is called after the buffer creation so that the alignment can be specified later. void init(RendererVk *renderer, VkBufferUsageFlags usage, size_t alignment, size_t initialSize, bool hostVisible); // Init that gives the ability to pass in specified memory property flags for the buffer. void initWithFlags(RendererVk *renderer, VkBufferUsageFlags usage, size_t alignment, size_t initialSize, VkMemoryPropertyFlags memoryProperty); // This call will allocate a new region at the end of the current buffer. If it can't find // enough space in the current buffer, it returns false. This gives caller a chance to deal with // buffer switch that may occur with allocate call. bool allocateFromCurrentBuffer(size_t sizeInBytes, uint8_t **ptrOut, VkDeviceSize *offsetOut); // This call will allocate a new region at the end of the buffer. It internally may trigger // a new buffer to be created (which is returned in the optional parameter // `newBufferAllocatedOut`). The new region will be in the returned buffer at given offset. If // a memory pointer is given, the buffer will be automatically map()ed. angle::Result allocateWithAlignment(ContextVk *contextVk, size_t sizeInBytes, size_t alignment, uint8_t **ptrOut, VkBuffer *bufferOut, VkDeviceSize *offsetOut, bool *newBufferAllocatedOut); // Allocate with default alignment angle::Result allocate(ContextVk *contextVk, size_t sizeInBytes, uint8_t **ptrOut, VkBuffer *bufferOut, VkDeviceSize *offsetOut, bool *newBufferAllocatedOut) { return allocateWithAlignment(contextVk, sizeInBytes, mAlignment, ptrOut, bufferOut, offsetOut, newBufferAllocatedOut); } // After a sequence of writes, call flush to ensure the data is visible to the device. angle::Result flush(ContextVk *contextVk); // After a sequence of writes, call invalidate to ensure the data is visible to the host. angle::Result invalidate(ContextVk *contextVk); // This releases resources when they might currently be in use. void release(RendererVk *renderer); // This releases all the buffers that have been allocated since this was last called. void releaseInFlightBuffers(ContextVk *contextVk); // This adds inflight buffers to the context's mResourceUseList and then releases them void releaseInFlightBuffersToResourceUseList(ContextVk *contextVk); // This frees resources immediately. void destroy(RendererVk *renderer); BufferHelper *getCurrentBuffer() const { return mBuffer.get(); } // **Accumulate** an alignment requirement. A dynamic buffer is used as the staging buffer for // image uploads, which can contain updates to unrelated mips, possibly with different formats. // The staging buffer should have an alignment that can satisfy all those formats, i.e. it's the // lcm of all alignments set in its lifetime. void requireAlignment(RendererVk *renderer, size_t alignment); size_t getAlignment() const { return mAlignment; } // For testing only! void setMinimumSizeForTesting(size_t minSize); bool isCoherent() const { return (mMemoryPropertyFlags & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) != 0; } private: void reset(); angle::Result allocateNewBuffer(ContextVk *contextVk); VkBufferUsageFlags mUsage; bool mHostVisible; size_t mInitialSize; std::unique_ptr<BufferHelper> mBuffer; uint32_t mNextAllocationOffset; uint32_t mLastFlushOrInvalidateOffset; size_t mSize; size_t mAlignment; VkMemoryPropertyFlags mMemoryPropertyFlags; BufferHelperPointerVector mInFlightBuffers; BufferHelperPointerVector mBufferFreeList; };","title":"DynamicBuffer"},{"location":"ANGLE/SRC_Pipeline/","text":"ANGLE Pipeline @startuml APP -> Context : glDrawElements() Context -> ContextVk : drawElements() ContextVk -> ContextVk : handleDirtyGraphicsPipeline() \\nif pipeline null or dirty ContextVk -> ProgramExecutableVk : getGraphicsPipeline( renderPassCache ) ProgramExecutableVk -> GraphicsPipelineCache : getGraphicsPipeline( pipeLineLayout ) GraphicsPipelineCache -> ShaderProgramHelper : getPipeline( compatibleRenderPass ) ShaderProgramHelper -> GraphicsPipelineDesc:initializePipeline() @enduml pipelineDesc.setRenderPassDesc(framebuffer->getRenderPassDesc()); pipelineDesc.getRenderPassDesc(framebuffer->getRenderPassDesc()); 1 angle::FixedVector<VkPipelineShaderStageCreateInfo, 3> shaderStages; 2 VkPipelineVertexInputStateCreateInfo vertexInputState = {}; 3 VkPipelineInputAssemblyStateCreateInfo inputAssemblyState = {}; 5 VkPipelineViewportStateCreateInfo viewportState = {}; 6 VkPipelineRasterizationStateCreateInfo rasterState = {}; 7 VkPipelineMultisampleStateCreateInfo multisampleState = {}; 8 VkPipelineDepthStencilStateCreateInfo depthStencilState = {}; gl::DrawBuffersArray<VkPipelineColorBlendAttachmentState> blendAttachmentState; 9 VkPipelineColorBlendStateCreateInfo blendState = {}; 10 VkPipelineDynamicStateCreateInfo dynamicState = {}; VkGraphicsPipelineCreateInfo createInfo = {}; VkSpecializationInfo specializationInfo = {}; SpecializationConstantMap<VkSpecializationMapEntry> specializationEntries; InitializeSpecializationInfo(specConsts, &specializationEntries, &specializationInfo); // Vertex shader is always expected to be present. ASSERT(vertexModule != nullptr); VkPipelineShaderStageCreateInfo vertexStage = {}; SetPipelineShaderStageInfo(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, VK_SHADER_STAGE_VERTEX_BIT, vertexModule->getHandle(), specializationInfo, &vertexStage); shaderStages.push_back(vertexStage); if (geometryModule) { VkPipelineShaderStageCreateInfo geometryStage = {}; SetPipelineShaderStageInfo(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, VK_SHADER_STAGE_GEOMETRY_BIT, geometryModule->getHandle(), specializationInfo, &geometryStage); shaderStages.push_back(geometryStage); } // Fragment shader is optional. // anglebug.com/3509 - Don't compile the fragment shader if rasterizationDiscardEnable = true if (fragmentModule && !mRasterizationAndMultisampleStateInfo.bits.rasterizationDiscardEnable) { VkPipelineShaderStageCreateInfo fragmentStage = {}; SetPipelineShaderStageInfo(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, VK_SHADER_STAGE_FRAGMENT_BIT, fragmentModule->getHandle(), specializationInfo, &fragmentStage); shaderStages.push_back(fragmentStage); } // TODO(jmadill): Possibly use different path for ES 3.1 split bindings/attribs. gl::AttribArray<VkVertexInputBindingDescription> bindingDescs; gl::AttribArray<VkVertexInputAttributeDescription> attributeDescs; uint32_t vertexAttribCount = 0; size_t unpackedSize = sizeof(shaderStages) + sizeof(vertexInputState) + sizeof(inputAssemblyState) + sizeof(viewportState) + sizeof(rasterState) + sizeof(multisampleState) + sizeof(depthStencilState) + sizeof(blendAttachmentState) + sizeof(blendState) + sizeof(bindingDescs) + sizeof(attributeDescs); ANGLE_UNUSED_VARIABLE(unpackedSize); gl::AttribArray<VkVertexInputBindingDivisorDescriptionEXT> divisorDesc; VkPipelineVertexInputDivisorStateCreateInfoEXT divisorState = {}; divisorState.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT; divisorState.pVertexBindingDivisors = divisorDesc.data(); for (size_t attribIndexSizeT : activeAttribLocationsMask) { const uint32_t attribIndex = static_cast<uint32_t>(attribIndexSizeT); VkVertexInputBindingDescription &bindingDesc = bindingDescs[vertexAttribCount]; VkVertexInputAttributeDescription &attribDesc = attributeDescs[vertexAttribCount]; const PackedAttribDesc &packedAttrib = mVertexInputAttribs.attribs[attribIndex]; bindingDesc.binding = attribIndex; bindingDesc.stride = static_cast<uint32_t>(packedAttrib.stride); if (packedAttrib.divisor != 0) { bindingDesc.inputRate = static_cast<VkVertexInputRate>(VK_VERTEX_INPUT_RATE_INSTANCE); divisorDesc[divisorState.vertexBindingDivisorCount].binding = bindingDesc.binding; divisorDesc[divisorState.vertexBindingDivisorCount].divisor = packedAttrib.divisor; ++divisorState.vertexBindingDivisorCount; } else { bindingDesc.inputRate = static_cast<VkVertexInputRate>(VK_VERTEX_INPUT_RATE_VERTEX); } // Get the corresponding VkFormat for the attrib's format. angle::FormatID formatID = static_cast<angle::FormatID>(packedAttrib.format); const Format &format = contextVk->getRenderer()->getFormat(formatID); const angle::Format &angleFormat = format.intendedFormat(); VkFormat vkFormat = packedAttrib.compressed ? format.vkCompressedBufferFormat : format.vkBufferFormat; gl::ComponentType attribType = GetVertexAttributeComponentType(angleFormat.isPureInt(), angleFormat.vertexAttribType); gl::ComponentType programAttribType = gl::GetComponentTypeMask(programAttribsTypeMask, attribIndex); if (attribType != programAttribType) { // Override the format with a compatible one. vkFormat = kMismatchedComponentTypeMap[programAttribType]; bindingDesc.stride = 0; // Prevent out-of-bounds accesses. } // The binding index could become more dynamic in ES 3.1. attribDesc.binding = attribIndex; attribDesc.format = vkFormat; attribDesc.location = static_cast<uint32_t>(attribIndex); attribDesc.offset = packedAttrib.offset; vertexAttribCount++; } // The binding descriptions are filled in at draw time. vertexInputState.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputState.flags = 0; vertexInputState.vertexBindingDescriptionCount = vertexAttribCount; vertexInputState.pVertexBindingDescriptions = bindingDescs.data(); vertexInputState.vertexAttributeDescriptionCount = vertexAttribCount; vertexInputState.pVertexAttributeDescriptions = attributeDescs.data(); if (divisorState.vertexBindingDivisorCount) vertexInputState.pNext = &divisorState; // Primitive topology is filled in at draw time. inputAssemblyState.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssemblyState.flags = 0; inputAssemblyState.topology = static_cast<VkPrimitiveTopology>(mInputAssemblyAndColorBlendStateInfo.primitive.topology); // http://anglebug.com/3832 // We currently hit a VK Validation here where VUID // VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00428 is flagged because we allow // primitiveRestartEnable to be true for topologies VK_PRIMITIVE_TOPOLOGY_POINT_LIST, // VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST // VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, // VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY and VK_PRIMITIVE_TOPOLOGY_PATCH_LIST // However if we force primiteRestartEnable to FALSE we fail tests. // Need to identify alternate fix. inputAssemblyState.primitiveRestartEnable = static_cast<VkBool32>(mInputAssemblyAndColorBlendStateInfo.primitive.restartEnable); // Set initial viewport and scissor state. // 0-sized viewports are invalid in Vulkan. We always use a scissor that at least matches the // requested viewport, so it's safe to adjust the viewport size here. VkViewport viewport = mViewport; if (viewport.width == 0) { viewport.width = 1; } if (viewport.height == 0) { viewport.height = 1; } viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.flags = 0; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; VkRect2D scissor; if (IsScissorStateDynamic(mScissor)) { viewportState.pScissors = nullptr; } else { viewportState.pScissors = &scissor; scissor.offset.x = mScissor.x; scissor.offset.y = mScissor.y; scissor.extent.width = mScissor.width; scissor.extent.height = mScissor.height; } const PackedRasterizationAndMultisampleStateInfo &rasterAndMS = mRasterizationAndMultisampleStateInfo; // Rasterizer state. rasterState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterState.flags = 0; rasterState.depthClampEnable = static_cast<VkBool32>(rasterAndMS.bits.depthClampEnable); rasterState.rasterizerDiscardEnable = static_cast<VkBool32>(rasterAndMS.bits.rasterizationDiscardEnable); rasterState.polygonMode = static_cast<VkPolygonMode>(rasterAndMS.bits.polygonMode); rasterState.cullMode = static_cast<VkCullModeFlags>(rasterAndMS.bits.cullMode); rasterState.frontFace = static_cast<VkFrontFace>(rasterAndMS.bits.frontFace); rasterState.depthBiasEnable = static_cast<VkBool32>(rasterAndMS.bits.depthBiasEnable); rasterState.depthBiasConstantFactor = rasterAndMS.depthBiasConstantFactor; rasterState.depthBiasClamp = rasterAndMS.depthBiasClamp; rasterState.depthBiasSlopeFactor = rasterAndMS.depthBiasSlopeFactor; rasterState.lineWidth = rasterAndMS.lineWidth; const void **pNextPtr = &rasterState.pNext; VkPipelineRasterizationLineStateCreateInfoEXT rasterLineState = {}; rasterLineState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT; // Enable Bresenham line rasterization if available and not multisampling. if (rasterAndMS.bits.rasterizationSamples <= 1 && contextVk->getFeatures().bresenhamLineRasterization.enabled) { rasterLineState.lineRasterizationMode = VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT; *pNextPtr = &rasterLineState; pNextPtr = &rasterLineState.pNext; } VkPipelineRasterizationProvokingVertexStateCreateInfoEXT provokingVertexState = {}; provokingVertexState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT; // Always set provoking vertex mode to last if available. if (contextVk->getFeatures().provokingVertex.enabled) { provokingVertexState.provokingVertexMode = VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT; *pNextPtr = &provokingVertexState; pNextPtr = &provokingVertexState.pNext; } // When depth clamping is used, depth clipping is automatically disabled. // When the 'depthClamping' feature is enabled, we'll be using depth clamping // to work around a driver issue, not as an alternative to depth clipping. Therefore we need to // explicitly re-enable depth clipping. VkPipelineRasterizationDepthClipStateCreateInfoEXT depthClipState = {}; depthClipState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT; if (contextVk->getFeatures().depthClamping.enabled) { depthClipState.depthClipEnable = VK_TRUE; *pNextPtr = &depthClipState; pNextPtr = &depthClipState.pNext; } VkPipelineRasterizationStateStreamCreateInfoEXT rasterStreamState = {}; rasterStreamState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT; if (contextVk->getFeatures().supportsTransformFeedbackExtension.enabled) { rasterStreamState.rasterizationStream = 0; rasterState.pNext = &rasterLineState; } // Multisample state. multisampleState.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampleState.flags = 0; multisampleState.rasterizationSamples = gl_vk::GetSamples(rasterAndMS.bits.rasterizationSamples); multisampleState.sampleShadingEnable = static_cast<VkBool32>(rasterAndMS.bits.sampleShadingEnable); multisampleState.minSampleShading = rasterAndMS.minSampleShading; multisampleState.pSampleMask = rasterAndMS.sampleMask; multisampleState.alphaToCoverageEnable = static_cast<VkBool32>(rasterAndMS.bits.alphaToCoverageEnable); multisampleState.alphaToOneEnable = static_cast<VkBool32>(rasterAndMS.bits.alphaToOneEnable); // Depth/stencil state. depthStencilState.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO; depthStencilState.flags = 0; depthStencilState.depthTestEnable = static_cast<VkBool32>(mDepthStencilStateInfo.enable.depthTest); depthStencilState.depthWriteEnable = static_cast<VkBool32>(mDepthStencilStateInfo.enable.depthWrite); depthStencilState.depthCompareOp = static_cast<VkCompareOp>( mDepthStencilStateInfo.depthCompareOpAndSurfaceRotation.depthCompareOp); depthStencilState.depthBoundsTestEnable = static_cast<VkBool32>(mDepthStencilStateInfo.enable.depthBoundsTest); depthStencilState.stencilTestEnable = static_cast<VkBool32>(mDepthStencilStateInfo.enable.stencilTest); UnpackStencilState(mDepthStencilStateInfo.front, mDepthStencilStateInfo.frontStencilReference, &depthStencilState.front); UnpackStencilState(mDepthStencilStateInfo.back, mDepthStencilStateInfo.backStencilReference, &depthStencilState.back); depthStencilState.minDepthBounds = mDepthStencilStateInfo.minDepthBounds; depthStencilState.maxDepthBounds = mDepthStencilStateInfo.maxDepthBounds; const PackedInputAssemblyAndColorBlendStateInfo &inputAndBlend = mInputAssemblyAndColorBlendStateInfo; blendState.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; blendState.flags = 0; blendState.logicOpEnable = static_cast<VkBool32>(inputAndBlend.logic.opEnable); blendState.logicOp = static_cast<VkLogicOp>(inputAndBlend.logic.op); blendState.attachmentCount = static_cast<uint32_t>(mRenderPassDesc.colorAttachmentRange()); blendState.pAttachments = blendAttachmentState.data(); // If this graphics pipeline is for the unresolve operation, correct the color attachment count // for that subpass. if ((mRenderPassDesc.getColorUnresolveAttachmentMask().any() || mRenderPassDesc.hasDepthStencilUnresolveAttachment()) && mRasterizationAndMultisampleStateInfo.bits.subpass == 0) { blendState.attachmentCount = static_cast<uint32_t>(mRenderPassDesc.getColorUnresolveAttachmentMask().count()); } for (int i = 0; i < 4; i++) { blendState.blendConstants[i] = inputAndBlend.blendConstants[i]; } const gl::DrawBufferMask blendEnableMask(inputAndBlend.blendEnableMask); // Zero-init all states. blendAttachmentState = {}; for (uint32_t colorIndexGL = 0; colorIndexGL < blendState.attachmentCount; ++colorIndexGL) { VkPipelineColorBlendAttachmentState &state = blendAttachmentState[colorIndexGL]; if (blendEnableMask[colorIndexGL]) { // To avoid triggering valid usage error, blending must be disabled for formats that do // not have VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT feature bit set. // From OpenGL ES clients, this means disabling blending for integer formats. if (!angle::Format::Get(mRenderPassDesc[colorIndexGL]).isInt()) { ASSERT(!contextVk->getRenderer() ->getFormat(mRenderPassDesc[colorIndexGL]) .actualImageFormat() .isInt()); state.blendEnable = VK_TRUE; UnpackBlendAttachmentState(inputAndBlend.attachments[colorIndexGL], &state); } } state.colorWriteMask = Int4Array_Get<VkColorComponentFlags>(inputAndBlend.colorWriteMaskBits, colorIndexGL); } // Dynamic state angle::FixedVector<VkDynamicState, 1> dynamicStateList; if (IsScissorStateDynamic(mScissor)) { dynamicStateList.push_back(VK_DYNAMIC_STATE_SCISSOR); } dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO; dynamicState.dynamicStateCount = static_cast<uint32_t>(dynamicStateList.size()); dynamicState.pDynamicStates = dynamicStateList.data(); createInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; createInfo.flags = 0; createInfo.stageCount = static_cast<uint32_t>(shaderStages.size()); createInfo.pStages = shaderStages.data(); createInfo.pVertexInputState = &vertexInputState; createInfo.pInputAssemblyState = &inputAssemblyState; createInfo.pTessellationState = nullptr; createInfo.pViewportState = &viewportState; createInfo.pRasterizationState = &rasterState; createInfo.pMultisampleState = &multisampleState; createInfo.pDepthStencilState = &depthStencilState; createInfo.pColorBlendState = &blendState; createInfo.pDynamicState = dynamicStateList.empty() ? nullptr : &dynamicState; createInfo.layout = pipelineLayout.getHandle(); createInfo.renderPass = compatibleRenderPass.getHandle(); createInfo.subpass = mRasterizationAndMultisampleStateInfo.bits.subpass; createInfo.basePipelineHandle = VK_NULL_HANDLE; createInfo.basePipelineIndex = 0;","title":"ANGLE Pipeline"},{"location":"ANGLE/SRC_Pipeline/#angle-pipeline","text":"@startuml APP -> Context : glDrawElements() Context -> ContextVk : drawElements() ContextVk -> ContextVk : handleDirtyGraphicsPipeline() \\nif pipeline null or dirty ContextVk -> ProgramExecutableVk : getGraphicsPipeline( renderPassCache ) ProgramExecutableVk -> GraphicsPipelineCache : getGraphicsPipeline( pipeLineLayout ) GraphicsPipelineCache -> ShaderProgramHelper : getPipeline( compatibleRenderPass ) ShaderProgramHelper -> GraphicsPipelineDesc:initializePipeline() @enduml pipelineDesc.setRenderPassDesc(framebuffer->getRenderPassDesc()); pipelineDesc.getRenderPassDesc(framebuffer->getRenderPassDesc()); 1 angle::FixedVector<VkPipelineShaderStageCreateInfo, 3> shaderStages; 2 VkPipelineVertexInputStateCreateInfo vertexInputState = {}; 3 VkPipelineInputAssemblyStateCreateInfo inputAssemblyState = {}; 5 VkPipelineViewportStateCreateInfo viewportState = {}; 6 VkPipelineRasterizationStateCreateInfo rasterState = {}; 7 VkPipelineMultisampleStateCreateInfo multisampleState = {}; 8 VkPipelineDepthStencilStateCreateInfo depthStencilState = {}; gl::DrawBuffersArray<VkPipelineColorBlendAttachmentState> blendAttachmentState; 9 VkPipelineColorBlendStateCreateInfo blendState = {}; 10 VkPipelineDynamicStateCreateInfo dynamicState = {}; VkGraphicsPipelineCreateInfo createInfo = {}; VkSpecializationInfo specializationInfo = {}; SpecializationConstantMap<VkSpecializationMapEntry> specializationEntries; InitializeSpecializationInfo(specConsts, &specializationEntries, &specializationInfo); // Vertex shader is always expected to be present. ASSERT(vertexModule != nullptr); VkPipelineShaderStageCreateInfo vertexStage = {}; SetPipelineShaderStageInfo(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, VK_SHADER_STAGE_VERTEX_BIT, vertexModule->getHandle(), specializationInfo, &vertexStage); shaderStages.push_back(vertexStage); if (geometryModule) { VkPipelineShaderStageCreateInfo geometryStage = {}; SetPipelineShaderStageInfo(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, VK_SHADER_STAGE_GEOMETRY_BIT, geometryModule->getHandle(), specializationInfo, &geometryStage); shaderStages.push_back(geometryStage); } // Fragment shader is optional. // anglebug.com/3509 - Don't compile the fragment shader if rasterizationDiscardEnable = true if (fragmentModule && !mRasterizationAndMultisampleStateInfo.bits.rasterizationDiscardEnable) { VkPipelineShaderStageCreateInfo fragmentStage = {}; SetPipelineShaderStageInfo(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, VK_SHADER_STAGE_FRAGMENT_BIT, fragmentModule->getHandle(), specializationInfo, &fragmentStage); shaderStages.push_back(fragmentStage); } // TODO(jmadill): Possibly use different path for ES 3.1 split bindings/attribs. gl::AttribArray<VkVertexInputBindingDescription> bindingDescs; gl::AttribArray<VkVertexInputAttributeDescription> attributeDescs; uint32_t vertexAttribCount = 0; size_t unpackedSize = sizeof(shaderStages) + sizeof(vertexInputState) + sizeof(inputAssemblyState) + sizeof(viewportState) + sizeof(rasterState) + sizeof(multisampleState) + sizeof(depthStencilState) + sizeof(blendAttachmentState) + sizeof(blendState) + sizeof(bindingDescs) + sizeof(attributeDescs); ANGLE_UNUSED_VARIABLE(unpackedSize); gl::AttribArray<VkVertexInputBindingDivisorDescriptionEXT> divisorDesc; VkPipelineVertexInputDivisorStateCreateInfoEXT divisorState = {}; divisorState.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT; divisorState.pVertexBindingDivisors = divisorDesc.data(); for (size_t attribIndexSizeT : activeAttribLocationsMask) { const uint32_t attribIndex = static_cast<uint32_t>(attribIndexSizeT); VkVertexInputBindingDescription &bindingDesc = bindingDescs[vertexAttribCount]; VkVertexInputAttributeDescription &attribDesc = attributeDescs[vertexAttribCount]; const PackedAttribDesc &packedAttrib = mVertexInputAttribs.attribs[attribIndex]; bindingDesc.binding = attribIndex; bindingDesc.stride = static_cast<uint32_t>(packedAttrib.stride); if (packedAttrib.divisor != 0) { bindingDesc.inputRate = static_cast<VkVertexInputRate>(VK_VERTEX_INPUT_RATE_INSTANCE); divisorDesc[divisorState.vertexBindingDivisorCount].binding = bindingDesc.binding; divisorDesc[divisorState.vertexBindingDivisorCount].divisor = packedAttrib.divisor; ++divisorState.vertexBindingDivisorCount; } else { bindingDesc.inputRate = static_cast<VkVertexInputRate>(VK_VERTEX_INPUT_RATE_VERTEX); } // Get the corresponding VkFormat for the attrib's format. angle::FormatID formatID = static_cast<angle::FormatID>(packedAttrib.format); const Format &format = contextVk->getRenderer()->getFormat(formatID); const angle::Format &angleFormat = format.intendedFormat(); VkFormat vkFormat = packedAttrib.compressed ? format.vkCompressedBufferFormat : format.vkBufferFormat; gl::ComponentType attribType = GetVertexAttributeComponentType(angleFormat.isPureInt(), angleFormat.vertexAttribType); gl::ComponentType programAttribType = gl::GetComponentTypeMask(programAttribsTypeMask, attribIndex); if (attribType != programAttribType) { // Override the format with a compatible one. vkFormat = kMismatchedComponentTypeMap[programAttribType]; bindingDesc.stride = 0; // Prevent out-of-bounds accesses. } // The binding index could become more dynamic in ES 3.1. attribDesc.binding = attribIndex; attribDesc.format = vkFormat; attribDesc.location = static_cast<uint32_t>(attribIndex); attribDesc.offset = packedAttrib.offset; vertexAttribCount++; } // The binding descriptions are filled in at draw time. vertexInputState.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputState.flags = 0; vertexInputState.vertexBindingDescriptionCount = vertexAttribCount; vertexInputState.pVertexBindingDescriptions = bindingDescs.data(); vertexInputState.vertexAttributeDescriptionCount = vertexAttribCount; vertexInputState.pVertexAttributeDescriptions = attributeDescs.data(); if (divisorState.vertexBindingDivisorCount) vertexInputState.pNext = &divisorState; // Primitive topology is filled in at draw time. inputAssemblyState.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssemblyState.flags = 0; inputAssemblyState.topology = static_cast<VkPrimitiveTopology>(mInputAssemblyAndColorBlendStateInfo.primitive.topology); // http://anglebug.com/3832 // We currently hit a VK Validation here where VUID // VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00428 is flagged because we allow // primitiveRestartEnable to be true for topologies VK_PRIMITIVE_TOPOLOGY_POINT_LIST, // VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST // VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, // VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY and VK_PRIMITIVE_TOPOLOGY_PATCH_LIST // However if we force primiteRestartEnable to FALSE we fail tests. // Need to identify alternate fix. inputAssemblyState.primitiveRestartEnable = static_cast<VkBool32>(mInputAssemblyAndColorBlendStateInfo.primitive.restartEnable); // Set initial viewport and scissor state. // 0-sized viewports are invalid in Vulkan. We always use a scissor that at least matches the // requested viewport, so it's safe to adjust the viewport size here. VkViewport viewport = mViewport; if (viewport.width == 0) { viewport.width = 1; } if (viewport.height == 0) { viewport.height = 1; } viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.flags = 0; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; VkRect2D scissor; if (IsScissorStateDynamic(mScissor)) { viewportState.pScissors = nullptr; } else { viewportState.pScissors = &scissor; scissor.offset.x = mScissor.x; scissor.offset.y = mScissor.y; scissor.extent.width = mScissor.width; scissor.extent.height = mScissor.height; } const PackedRasterizationAndMultisampleStateInfo &rasterAndMS = mRasterizationAndMultisampleStateInfo; // Rasterizer state. rasterState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterState.flags = 0; rasterState.depthClampEnable = static_cast<VkBool32>(rasterAndMS.bits.depthClampEnable); rasterState.rasterizerDiscardEnable = static_cast<VkBool32>(rasterAndMS.bits.rasterizationDiscardEnable); rasterState.polygonMode = static_cast<VkPolygonMode>(rasterAndMS.bits.polygonMode); rasterState.cullMode = static_cast<VkCullModeFlags>(rasterAndMS.bits.cullMode); rasterState.frontFace = static_cast<VkFrontFace>(rasterAndMS.bits.frontFace); rasterState.depthBiasEnable = static_cast<VkBool32>(rasterAndMS.bits.depthBiasEnable); rasterState.depthBiasConstantFactor = rasterAndMS.depthBiasConstantFactor; rasterState.depthBiasClamp = rasterAndMS.depthBiasClamp; rasterState.depthBiasSlopeFactor = rasterAndMS.depthBiasSlopeFactor; rasterState.lineWidth = rasterAndMS.lineWidth; const void **pNextPtr = &rasterState.pNext; VkPipelineRasterizationLineStateCreateInfoEXT rasterLineState = {}; rasterLineState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT; // Enable Bresenham line rasterization if available and not multisampling. if (rasterAndMS.bits.rasterizationSamples <= 1 && contextVk->getFeatures().bresenhamLineRasterization.enabled) { rasterLineState.lineRasterizationMode = VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT; *pNextPtr = &rasterLineState; pNextPtr = &rasterLineState.pNext; } VkPipelineRasterizationProvokingVertexStateCreateInfoEXT provokingVertexState = {}; provokingVertexState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT; // Always set provoking vertex mode to last if available. if (contextVk->getFeatures().provokingVertex.enabled) { provokingVertexState.provokingVertexMode = VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT; *pNextPtr = &provokingVertexState; pNextPtr = &provokingVertexState.pNext; } // When depth clamping is used, depth clipping is automatically disabled. // When the 'depthClamping' feature is enabled, we'll be using depth clamping // to work around a driver issue, not as an alternative to depth clipping. Therefore we need to // explicitly re-enable depth clipping. VkPipelineRasterizationDepthClipStateCreateInfoEXT depthClipState = {}; depthClipState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT; if (contextVk->getFeatures().depthClamping.enabled) { depthClipState.depthClipEnable = VK_TRUE; *pNextPtr = &depthClipState; pNextPtr = &depthClipState.pNext; } VkPipelineRasterizationStateStreamCreateInfoEXT rasterStreamState = {}; rasterStreamState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT; if (contextVk->getFeatures().supportsTransformFeedbackExtension.enabled) { rasterStreamState.rasterizationStream = 0; rasterState.pNext = &rasterLineState; } // Multisample state. multisampleState.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampleState.flags = 0; multisampleState.rasterizationSamples = gl_vk::GetSamples(rasterAndMS.bits.rasterizationSamples); multisampleState.sampleShadingEnable = static_cast<VkBool32>(rasterAndMS.bits.sampleShadingEnable); multisampleState.minSampleShading = rasterAndMS.minSampleShading; multisampleState.pSampleMask = rasterAndMS.sampleMask; multisampleState.alphaToCoverageEnable = static_cast<VkBool32>(rasterAndMS.bits.alphaToCoverageEnable); multisampleState.alphaToOneEnable = static_cast<VkBool32>(rasterAndMS.bits.alphaToOneEnable); // Depth/stencil state. depthStencilState.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO; depthStencilState.flags = 0; depthStencilState.depthTestEnable = static_cast<VkBool32>(mDepthStencilStateInfo.enable.depthTest); depthStencilState.depthWriteEnable = static_cast<VkBool32>(mDepthStencilStateInfo.enable.depthWrite); depthStencilState.depthCompareOp = static_cast<VkCompareOp>( mDepthStencilStateInfo.depthCompareOpAndSurfaceRotation.depthCompareOp); depthStencilState.depthBoundsTestEnable = static_cast<VkBool32>(mDepthStencilStateInfo.enable.depthBoundsTest); depthStencilState.stencilTestEnable = static_cast<VkBool32>(mDepthStencilStateInfo.enable.stencilTest); UnpackStencilState(mDepthStencilStateInfo.front, mDepthStencilStateInfo.frontStencilReference, &depthStencilState.front); UnpackStencilState(mDepthStencilStateInfo.back, mDepthStencilStateInfo.backStencilReference, &depthStencilState.back); depthStencilState.minDepthBounds = mDepthStencilStateInfo.minDepthBounds; depthStencilState.maxDepthBounds = mDepthStencilStateInfo.maxDepthBounds; const PackedInputAssemblyAndColorBlendStateInfo &inputAndBlend = mInputAssemblyAndColorBlendStateInfo; blendState.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; blendState.flags = 0; blendState.logicOpEnable = static_cast<VkBool32>(inputAndBlend.logic.opEnable); blendState.logicOp = static_cast<VkLogicOp>(inputAndBlend.logic.op); blendState.attachmentCount = static_cast<uint32_t>(mRenderPassDesc.colorAttachmentRange()); blendState.pAttachments = blendAttachmentState.data(); // If this graphics pipeline is for the unresolve operation, correct the color attachment count // for that subpass. if ((mRenderPassDesc.getColorUnresolveAttachmentMask().any() || mRenderPassDesc.hasDepthStencilUnresolveAttachment()) && mRasterizationAndMultisampleStateInfo.bits.subpass == 0) { blendState.attachmentCount = static_cast<uint32_t>(mRenderPassDesc.getColorUnresolveAttachmentMask().count()); } for (int i = 0; i < 4; i++) { blendState.blendConstants[i] = inputAndBlend.blendConstants[i]; } const gl::DrawBufferMask blendEnableMask(inputAndBlend.blendEnableMask); // Zero-init all states. blendAttachmentState = {}; for (uint32_t colorIndexGL = 0; colorIndexGL < blendState.attachmentCount; ++colorIndexGL) { VkPipelineColorBlendAttachmentState &state = blendAttachmentState[colorIndexGL]; if (blendEnableMask[colorIndexGL]) { // To avoid triggering valid usage error, blending must be disabled for formats that do // not have VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT feature bit set. // From OpenGL ES clients, this means disabling blending for integer formats. if (!angle::Format::Get(mRenderPassDesc[colorIndexGL]).isInt()) { ASSERT(!contextVk->getRenderer() ->getFormat(mRenderPassDesc[colorIndexGL]) .actualImageFormat() .isInt()); state.blendEnable = VK_TRUE; UnpackBlendAttachmentState(inputAndBlend.attachments[colorIndexGL], &state); } } state.colorWriteMask = Int4Array_Get<VkColorComponentFlags>(inputAndBlend.colorWriteMaskBits, colorIndexGL); } // Dynamic state angle::FixedVector<VkDynamicState, 1> dynamicStateList; if (IsScissorStateDynamic(mScissor)) { dynamicStateList.push_back(VK_DYNAMIC_STATE_SCISSOR); } dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO; dynamicState.dynamicStateCount = static_cast<uint32_t>(dynamicStateList.size()); dynamicState.pDynamicStates = dynamicStateList.data(); createInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; createInfo.flags = 0; createInfo.stageCount = static_cast<uint32_t>(shaderStages.size()); createInfo.pStages = shaderStages.data(); createInfo.pVertexInputState = &vertexInputState; createInfo.pInputAssemblyState = &inputAssemblyState; createInfo.pTessellationState = nullptr; createInfo.pViewportState = &viewportState; createInfo.pRasterizationState = &rasterState; createInfo.pMultisampleState = &multisampleState; createInfo.pDepthStencilState = &depthStencilState; createInfo.pColorBlendState = &blendState; createInfo.pDynamicState = dynamicStateList.empty() ? nullptr : &dynamicState; createInfo.layout = pipelineLayout.getHandle(); createInfo.renderPass = compatibleRenderPass.getHandle(); createInfo.subpass = mRasterizationAndMultisampleStateInfo.bits.subpass; createInfo.basePipelineHandle = VK_NULL_HANDLE; createInfo.basePipelineIndex = 0;","title":"ANGLE Pipeline"},{"location":"ANGLE/SRC_RendererVK/","text":"RendererVK initialize initializeDevice queryDeviceExtensionFeatures(deviceExtensionNames); // Initialize features and workarounds. initFeatures(displayVk, deviceExtensionNames); \u200b getNativeExtensions ensureCapsInitialized Extensions & Features initialize mEnableDebugUtils = mEnableValidationLayers && ExtensionFound(VK_EXT_DEBUG_UTILS_EXTENSION_NAME, instanceExtensionNames); bool enableDebugReport = mEnableValidationLayers && !mEnableDebugUtils && ExtensionFound(VK_EXT_DEBUG_REPORT_EXTENSION_NAME, instanceExtensionNames); if (mEnableDebugUtils) { enabledInstanceExtensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME); } else if (enableDebugReport) { enabledInstanceExtensions.push_back(VK_EXT_DEBUG_REPORT_EXTENSION_NAME); } if (ExtensionFound(VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME, instanceExtensionNames)) { enabledInstanceExtensions.push_back(VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME); ANGLE_FEATURE_CONDITION(&mFeatures, supportsSwapchainColorspace, true); } initializeDevice queryDeviceExtensionFeatures initFeatures Features Extension Platform Note bresenhamLineRasterization mLineRasterizationFeatures basicGLLineRasterization -- !IsAndroid() && !isPowerVR Use OpenGL line rasterization rules if extension mLineRasterizationFeatures not available by default. provokingVertex mProvokingVertexFeatures extraCopyBufferRegion -- IsWindows() && isIntel forceCPUPathForCubeMapCopy -- IsWindows() && isIntel clampPointSize -- isNvidia nvidia Version < 421 depthClamping VK_EXT_depth_clip_enable isNvidia flushAfterVertexConversion IsAndroid() && IsNexus5X Work around ineffective compute-graphics barriers on Nexus 5X. Testing other vendors and driver versions are affected supportsRenderpass2 VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME supportsIncrementalPresent VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME supportsAndroidHardwareBuffer VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME ANDROID supportsExternalMemoryFd VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME supportsExternalMemoryFuchsia VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME supportsFilteringPrecision VK_GOOGLE_SAMPLER_FILTERING_PRECISION_EXTENSION_NAME supportsExternalFenceCapabilities VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME supportsExternalSemaphoreCapabilities VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME supportsExternalSemaphoreFd VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME supportsExternalSemaphoreFuchsia VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME supportsExternalFenceFd VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME supportsAndroidNativeFenceSync VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME ANDROID supportsShaderStencilExport VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME supportsRenderPassStoreOpNoneQCOM VK_QCOM_render_pass_store_ops_EXTENSION_NAME supportsTransformFeedbackExtension supportsIndexTypeUint8 mIndexTypeUint8Features supportsDepthStencilResolve VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME mDepthStencilResolveProperties emulateTransformFeedback mTransformFeedbackFeatures PhysicalDeviceFeatures.vertexPipelineStoresAndAtomics = true disableFifoPresentMode Linux() && isIntel bindEmptyForUnusedDescriptorSets IsAndroid() && isQualcomm forceOldRewriteStructSamplers mPhysicalDeviceFeatures.shaderSampledImageArrayDynamicIndexing = false isQualcomm perFrameWindowSizeQuery isIntel || (IsWindows() && isAMD) || IsFuchsia() disallowSeamfulCubeMapEmulation IsWindows() && isAMD padBuffersToMaxVertexAttribStride isAMD forceD16TexFilter IsAndroid() && isQualcomm disableFlippingBlitWithCommand IsAndroid() && isQualcomm shadowBuffers persistentlyMappedBuffers allocateNonZeroMemory Disable Allocation sanitization disabled by default because of a heaveyweight implementation that can cause OOM and timeouts. supportsExternalMemoryHost VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME enablePreRotateSurfaces IsAndroid enableFramebufferVkCache Disable on apple !IsApple() Currently disable FramebufferVk cache on Apple enablePrecisionQualifiers Disabled by default preferAggregateBarrierCalls isNvidia || isAMD || isIntel asyncCommandQueue Disabled supportsYUVSamplerConversion mSamplerYcbcrConversionFeatures supportsShaderFloat16 mShaderFloat16Int8Features forceMaxUniformBufferSize16KB isQualcomm && isAdreno540 supportsImageFormatList VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME isAMD enableMultisampledRenderToTexture Disabled IsWindows() && (isIntel || isAMD) supportsImageCubeArray mPhysicalDeviceFeatures.imageCubeArray == VK_TRUE !isSwiftShader && !isQualcomm preferredLargeHeapBlockSize4MB !isQualcomm deferFlushUntilEndRenderPass !isQualcomm Defer glFLush call causes manhattan 3.0 perf regression. Let Qualcomm driver opt out from // this optimization. waitIdleBeforeSwapchainRecreation IsAndroid() && isARM Android mistakenly destroys the old swapchain when creating a new one. preferDrawClearOverVkCmdClearAttachments IsPixel2 Format // These functions look at the mandatory format for support, and fallback to querying the device (if // necessary) to test the availability of the bits. bool RendererVk::hasLinearImageFormatFeatureBits(VkFormat format, const VkFormatFeatureFlags featureBits) const { return hasFormatFeatureBits<&VkFormatProperties::linearTilingFeatures>(format, featureBits); } VkFormatFeatureFlags RendererVk::getLinearImageFormatFeatureBits( VkFormat format, const VkFormatFeatureFlags featureBits) const { return getFormatFeatureBits<&VkFormatProperties::linearTilingFeatures>(format, featureBits); } VkFormatFeatureFlags RendererVk::getImageFormatFeatureBits( VkFormat format, const VkFormatFeatureFlags featureBits) const { return getFormatFeatureBits<&VkFormatProperties::optimalTilingFeatures>(format, featureBits); } bool RendererVk::hasImageFormatFeatureBits(VkFormat format, const VkFormatFeatureFlags featureBits) const { return hasFormatFeatureBits<&VkFormatProperties::optimalTilingFeatures>(format, featureBits); } bool RendererVk::hasBufferFormatFeatureBits(VkFormat format, const VkFormatFeatureFlags featureBits) const { return hasFormatFeatureBits<&VkFormatProperties::bufferFeatures>(format, featureBits); } API initialize vkEnumerateInstanceLayerProperties vkEnumerateInstanceExtensionProperties VkApplicationInfo VkInstanceCreateInfo VkValidationFeatureEnableEXT vkCreateInstance volkLoadInstance(mInstance); \u6ce8\u518c API. ANGLE_SHARED_LIBVULKAN ??? InitGetPhysicalDeviceProperties2KHRFunctions vkEnumeratePhysicalDevices vkGetPhysicalDeviceFeatures vkGetPhysicalDeviceQueueFamilyProperties initializeDevice vkEnumerateDeviceLayerProperties vkEnumerateDeviceExtensionProperties VkDeviceQueueCreateInfo call queryDeviceExtensionFeatures \u586b\u5145 deviceFeatures , deviceProperties vkGetPhysicalDeviceExternalFencePropertiesKHR vkGetPhysicalDeviceExternalSemaphorePropertiesKHR call initFeatures vkCreateDevice vkGetDeviceQueue call initPipelineCache","title":"SRC RendererVK"},{"location":"ANGLE/SRC_RendererVK/#extensions-features","text":"","title":"Extensions &amp; Features"},{"location":"ANGLE/SRC_RendererVK/#initialize","text":"mEnableDebugUtils = mEnableValidationLayers && ExtensionFound(VK_EXT_DEBUG_UTILS_EXTENSION_NAME, instanceExtensionNames); bool enableDebugReport = mEnableValidationLayers && !mEnableDebugUtils && ExtensionFound(VK_EXT_DEBUG_REPORT_EXTENSION_NAME, instanceExtensionNames); if (mEnableDebugUtils) { enabledInstanceExtensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME); } else if (enableDebugReport) { enabledInstanceExtensions.push_back(VK_EXT_DEBUG_REPORT_EXTENSION_NAME); } if (ExtensionFound(VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME, instanceExtensionNames)) { enabledInstanceExtensions.push_back(VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME); ANGLE_FEATURE_CONDITION(&mFeatures, supportsSwapchainColorspace, true); }","title":"initialize"},{"location":"ANGLE/SRC_RendererVK/#initializedevice","text":"","title":"initializeDevice"},{"location":"ANGLE/SRC_RendererVK/#querydeviceextensionfeatures","text":"","title":"queryDeviceExtensionFeatures"},{"location":"ANGLE/SRC_RendererVK/#initfeatures","text":"Features Extension Platform Note bresenhamLineRasterization mLineRasterizationFeatures basicGLLineRasterization -- !IsAndroid() && !isPowerVR Use OpenGL line rasterization rules if extension mLineRasterizationFeatures not available by default. provokingVertex mProvokingVertexFeatures extraCopyBufferRegion -- IsWindows() && isIntel forceCPUPathForCubeMapCopy -- IsWindows() && isIntel clampPointSize -- isNvidia nvidia Version < 421 depthClamping VK_EXT_depth_clip_enable isNvidia flushAfterVertexConversion IsAndroid() && IsNexus5X Work around ineffective compute-graphics barriers on Nexus 5X. Testing other vendors and driver versions are affected supportsRenderpass2 VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME supportsIncrementalPresent VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME supportsAndroidHardwareBuffer VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME ANDROID supportsExternalMemoryFd VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME supportsExternalMemoryFuchsia VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME supportsFilteringPrecision VK_GOOGLE_SAMPLER_FILTERING_PRECISION_EXTENSION_NAME supportsExternalFenceCapabilities VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME supportsExternalSemaphoreCapabilities VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME supportsExternalSemaphoreFd VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME supportsExternalSemaphoreFuchsia VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME supportsExternalFenceFd VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME supportsAndroidNativeFenceSync VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME ANDROID supportsShaderStencilExport VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME supportsRenderPassStoreOpNoneQCOM VK_QCOM_render_pass_store_ops_EXTENSION_NAME supportsTransformFeedbackExtension supportsIndexTypeUint8 mIndexTypeUint8Features supportsDepthStencilResolve VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME mDepthStencilResolveProperties emulateTransformFeedback mTransformFeedbackFeatures PhysicalDeviceFeatures.vertexPipelineStoresAndAtomics = true disableFifoPresentMode Linux() && isIntel bindEmptyForUnusedDescriptorSets IsAndroid() && isQualcomm forceOldRewriteStructSamplers mPhysicalDeviceFeatures.shaderSampledImageArrayDynamicIndexing = false isQualcomm perFrameWindowSizeQuery isIntel || (IsWindows() && isAMD) || IsFuchsia() disallowSeamfulCubeMapEmulation IsWindows() && isAMD padBuffersToMaxVertexAttribStride isAMD forceD16TexFilter IsAndroid() && isQualcomm disableFlippingBlitWithCommand IsAndroid() && isQualcomm shadowBuffers persistentlyMappedBuffers allocateNonZeroMemory Disable Allocation sanitization disabled by default because of a heaveyweight implementation that can cause OOM and timeouts. supportsExternalMemoryHost VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME enablePreRotateSurfaces IsAndroid enableFramebufferVkCache Disable on apple !IsApple() Currently disable FramebufferVk cache on Apple enablePrecisionQualifiers Disabled by default preferAggregateBarrierCalls isNvidia || isAMD || isIntel asyncCommandQueue Disabled supportsYUVSamplerConversion mSamplerYcbcrConversionFeatures supportsShaderFloat16 mShaderFloat16Int8Features forceMaxUniformBufferSize16KB isQualcomm && isAdreno540 supportsImageFormatList VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME isAMD enableMultisampledRenderToTexture Disabled IsWindows() && (isIntel || isAMD) supportsImageCubeArray mPhysicalDeviceFeatures.imageCubeArray == VK_TRUE !isSwiftShader && !isQualcomm preferredLargeHeapBlockSize4MB !isQualcomm deferFlushUntilEndRenderPass !isQualcomm Defer glFLush call causes manhattan 3.0 perf regression. Let Qualcomm driver opt out from // this optimization. waitIdleBeforeSwapchainRecreation IsAndroid() && isARM Android mistakenly destroys the old swapchain when creating a new one. preferDrawClearOverVkCmdClearAttachments IsPixel2","title":"initFeatures"},{"location":"ANGLE/SRC_RendererVK/#format","text":"// These functions look at the mandatory format for support, and fallback to querying the device (if // necessary) to test the availability of the bits. bool RendererVk::hasLinearImageFormatFeatureBits(VkFormat format, const VkFormatFeatureFlags featureBits) const { return hasFormatFeatureBits<&VkFormatProperties::linearTilingFeatures>(format, featureBits); } VkFormatFeatureFlags RendererVk::getLinearImageFormatFeatureBits( VkFormat format, const VkFormatFeatureFlags featureBits) const { return getFormatFeatureBits<&VkFormatProperties::linearTilingFeatures>(format, featureBits); } VkFormatFeatureFlags RendererVk::getImageFormatFeatureBits( VkFormat format, const VkFormatFeatureFlags featureBits) const { return getFormatFeatureBits<&VkFormatProperties::optimalTilingFeatures>(format, featureBits); } bool RendererVk::hasImageFormatFeatureBits(VkFormat format, const VkFormatFeatureFlags featureBits) const { return hasFormatFeatureBits<&VkFormatProperties::optimalTilingFeatures>(format, featureBits); } bool RendererVk::hasBufferFormatFeatureBits(VkFormat format, const VkFormatFeatureFlags featureBits) const { return hasFormatFeatureBits<&VkFormatProperties::bufferFeatures>(format, featureBits); }","title":"Format"},{"location":"ANGLE/SRC_RendererVK/#api","text":"","title":"API"},{"location":"ANGLE/SRC_RendererVK/#initialize_1","text":"vkEnumerateInstanceLayerProperties vkEnumerateInstanceExtensionProperties VkApplicationInfo VkInstanceCreateInfo VkValidationFeatureEnableEXT vkCreateInstance volkLoadInstance(mInstance); \u6ce8\u518c API. ANGLE_SHARED_LIBVULKAN ??? InitGetPhysicalDeviceProperties2KHRFunctions vkEnumeratePhysicalDevices vkGetPhysicalDeviceFeatures vkGetPhysicalDeviceQueueFamilyProperties","title":"initialize"},{"location":"ANGLE/SRC_RendererVK/#initializedevice_1","text":"vkEnumerateDeviceLayerProperties vkEnumerateDeviceExtensionProperties VkDeviceQueueCreateInfo call queryDeviceExtensionFeatures \u586b\u5145 deviceFeatures , deviceProperties vkGetPhysicalDeviceExternalFencePropertiesKHR vkGetPhysicalDeviceExternalSemaphorePropertiesKHR call initFeatures vkCreateDevice vkGetDeviceQueue call initPipelineCache","title":"initializeDevice"},{"location":"ANGLE/SRC_init/","text":"bool EGLWindow::initializeGL(OSWindow osWindow, angle::Library glWindowingLibrary, angle::GLESDriverType driverType, const EGLPlatformParameters &platformParams, const ConfigParameters &configParams) { if (!initializeDisplay(osWindow, glWindowingLibrary, driverType, platformParams)) return false; if (!initializeSurface(osWindow, glWindowingLibrary, configParams)) return false; if (!initializeContext()) return false; return true; }","title":"SRC init"},{"location":"ANGLE/SRC_%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/","text":"Context classDiagram class Context { State mState; bool mShared; bool mSkipValidation; bool mDisplayTextureShareGroup; bool mDisplaySemaphoreShareGroup; ErrorSet mErrors; // Recorded errors angle::PackedEnumBitSet<BufferBinding> mValidBufferBindings; std::unique_ptr<rx::ContextImpl> mImplementation; EGLLabelKHR mLabel; Extensions mSupportedExtensions; mutable BindingPointer<Compiler> mCompiler; // Shader compiler. Lazily initialized hence the mutable value. const egl::Config *mConfig; TextureMap mZeroTextures; ResourceMap<FenceNV, FenceNVID> mFenceNVMap; HandleAllocator mFenceNVHandleAllocator; QueryMap mQueryMap; HandleAllocator mQueryHandleAllocator; VertexArrayMap mVertexArrayMap; HandleAllocator mVertexArrayHandleAllocator; TransformFeedbackMap mTransformFeedbackMap; HandleAllocator mTransformFeedbackHandleAllocator; const char *mVersionString; const char *mShadingLanguageString; const char *mRendererString; const char *mExtensionString; std::vector<const char *> mExtensionStrings; const char *mRequestableExtensionString; std::vector<const char *> mRequestableExtensionStrings; std::unique_ptr<GLES1Renderer> mGLES1Renderer; // GLES1 renderer state bool mHasBeenCurrent; // Current/lost context flags bool mContextLost; // Set with setContextLost so that we also set mSkipValidation=false. GraphicsResetStatus mResetStatus; bool mContextLostForced; GLenum mResetStrategy; const bool mRobustAccess; const bool mSurfacelessSupported; const bool mExplicitContextAvailable; egl::Surface *mCurrentDrawSurface; egl::Surface *mCurrentReadSurface; egl::Display *mDisplay; const bool mWebGLContext; bool mBufferAccessValidationEnabled; const bool mExtensionsEnabled; MemoryProgramCache *mMemoryProgramCache; State::DirtyObjects mDrawDirtyObjects; StateCache mStateCache; State::DirtyBits mAllDirtyBits; State::DirtyBits mTexImageDirtyBits; State::DirtyObjects mTexImageDirtyObjects; State::DirtyBits mReadPixelsDirtyBits; State::DirtyObjects mReadPixelsDirtyObjects; State::DirtyBits mClearDirtyBits; State::DirtyObjects mClearDirtyObjects; State::DirtyBits mBlitDirtyBits; State::DirtyObjects mBlitDirtyObjects; State::DirtyBits mComputeDirtyBits; State::DirtyObjects mComputeDirtyObjects; State::DirtyBits mCopyImageDirtyBits; State::DirtyObjects mCopyImageDirtyObjects; angle::ObserverBinding mVertexArrayObserverBinding; angle::ObserverBinding mDrawFramebufferObserverBinding; angle::ObserverBinding mReadFramebufferObserverBinding; std::vector<angle::ObserverBinding> mUniformBufferObserverBindings; std::vector<angle::ObserverBinding> mSamplerObserverBindings; std::vector<angle::ObserverBinding> mImageObserverBindings; mutable Optional<angle::ScratchBuffer> mScratchBuffer; mutable Optional<angle::ScratchBuffer> mZeroFilledBuffer; std::shared_ptr<angle::WorkerThreadPool> mThreadPool; } Context Relationship classDiagram class State class ErrorSet class PackedEnumBitSet__BufferBinding class ContextImpl class EGLLabelKHR class Extensions class BindingPointer__Compiler class egl_Config class Context { State mState; TextureMap mZeroTextures; ResourceMap<FenceNV, FenceNVID> mFenceNVMap; HandleAllocator mFenceNVHandleAllocator; QueryMap mQueryMap; HandleAllocator mQueryHandleAllocator; VertexArrayMap mVertexArrayMap; HandleAllocator mVertexArrayHandleAllocator; TransformFeedbackMap mTransformFeedbackMap; HandleAllocator mTransformFeedbackHandleAllocator; const char *mVersionString; const char *mShadingLanguageString; const char *mRendererString; const char *mExtensionString; std::vector<const char *> mExtensionStrings; const char *mRequestableExtensionString; std::vector<const char *> mRequestableExtensionStrings; // GLES1 renderer state std::unique_ptr<GLES1Renderer> mGLES1Renderer; // Current/lost context flags bool mHasBeenCurrent; bool mContextLost; // Set with setContextLost so that we also set mSkipValidation=false. GraphicsResetStatus mResetStatus; bool mContextLostForced; GLenum mResetStrategy; const bool mRobustAccess; const bool mSurfacelessSupported; const bool mExplicitContextAvailable; egl::Surface *mCurrentDrawSurface; egl::Surface *mCurrentReadSurface; egl::Display *mDisplay; const bool mWebGLContext; bool mBufferAccessValidationEnabled; const bool mExtensionsEnabled; MemoryProgramCache *mMemoryProgramCache; State::DirtyObjects mDrawDirtyObjects; StateCache mStateCache; State::DirtyBits mAllDirtyBits; State::DirtyBits mTexImageDirtyBits; State::DirtyObjects mTexImageDirtyObjects; State::DirtyBits mReadPixelsDirtyBits; State::DirtyObjects mReadPixelsDirtyObjects; State::DirtyBits mClearDirtyBits; State::DirtyObjects mClearDirtyObjects; State::DirtyBits mBlitDirtyBits; State::DirtyObjects mBlitDirtyObjects; State::DirtyBits mComputeDirtyBits; State::DirtyObjects mComputeDirtyObjects; State::DirtyBits mCopyImageDirtyBits; State::DirtyObjects mCopyImageDirtyObjects; // Binding to container objects that use dependent state updates. angle::ObserverBinding mVertexArrayObserverBinding; angle::ObserverBinding mDrawFramebufferObserverBinding; angle::ObserverBinding mReadFramebufferObserverBinding; std::vector<angle::ObserverBinding> mUniformBufferObserverBindings; std::vector<angle::ObserverBinding> mSamplerObserverBindings; std::vector<angle::ObserverBinding> mImageObserverBindings; // Not really a property of context state. The size and contexts change per-api-call. mutable Optional<angle::ScratchBuffer> mScratchBuffer; mutable Optional<angle::ScratchBuffer> mZeroFilledBuffer; std::shared_ptr<angle::WorkerThreadPool> mThreadPool; } @startuml hide circle hide member class Buffer class Compiler class FenceNV class Framebuffer class GLES1Renderer class MemoryProgramCache class MemoryObject class Program class ProgramPipeline class Query class Renderbuffer class Sampler class Semaphore class Shader class Sync class Texture class TransformFeedback class VertexArray class VertexAttribute class Context @enduml class Buffer; class Compiler; class FenceNV; class Framebuffer; class GLES1Renderer; class MemoryProgramCache; class MemoryObject; class Program; class ProgramPipeline; class Query; class Renderbuffer; class Sampler; class Semaphore; class Shader; class Sync; class Texture; class TransformFeedback; class VertexArray; struct VertexAttribute; class Context Front-end AttributeMap BinaryStrea BlobCache Buffer Caps Compiler Config Constants Context Debug Device Display EGLSync Error Error.inc ErrorString Fence Framebuffer FramebufferAttachment FrameCapture GLES1Renderer GLES1Shaders.inc GLES1State HandleAllocator Image ImageIndex IndexRangeCache InfoLog LoggingAnnotator MemoryObject MemoryProgramCache Observer Overlay OverlayWidgets Platform.cpp Program ProgramExecutable ProgramLinkedResources ProgramPipeline Query RefCountObject Renderbuffer ResourceManager ResourceMap Sampler Semaphore Shader SizedMRUCache State Stream Surface Texture Thread TransformFeedback Uniform VaryingPacking Version VertexArray VertexAttribute WorkerThread Back-end Interface BufferImpl CompilerImpl ContextImpl DeviceImpl DisplayImpl EGLImplFactory EGLReusableSync EGLSyncImpl FenceNVImpl Format FramebufferAttachmentObjectImpl FramebufferImpl GLImplFactory ImageImpl MemoryObjectImpl OverlayImpl ProgramImpl ProgramPipelineImpl QueryImpl RenderbufferImpl RenderTargetCache SamplerImpl SemaphoreImpl ShaderImpl StreamProducerImpl SurfaceImpl SyncImpl TextureImpl TransformFeedbackImpl VertexArrayImpl Vulkan BufferVk CommandProcessor CompilerVk ContextVk DebugAnnotatorVk DeviceVk DisplayVk FenceNVVk FramebufferVk GlslangWrapperVk ImageVk MemoryObjectVk OverlayVk PersistentCommandPool ProgramExecutableVk ProgramPipelineVk ProgramVk QueryVk RenderbufferVk RendererVk RenderTargetVk ResourceVk SamplerVk SecondaryCommandBuffer SemaphoreVk ShaderVk SurfaceVk SyncVk TextureVk TransformFeedbackVk UtilsVk VertexArrayVk BufferVk CommandProcessor CompilerVk ContextVk DebugAnnotatorVk DeviceVk DisplayVk FenceNVVk FramebufferVk GlslangWrapperVk ImageVk MemoryObjectVk OverlayVk PersistentCommandPool ProgramExecutableVk ProgramPipelineVk ProgramVk QueryVk RenderbufferVk RendererVk RenderTargetVk ResourceVk SamplerVk SecondaryCommandBuffer SemaphoreVk ShaderVk SurfaceVk SyncVk TextureVk TransformFeedbackVk UtilsVk VertexArrayVk API \u5206\u6790 \u4ee5 Learn OpenGL \u7684\u4f7f\u7528\u987a\u5e8f \u4e09\u89d2\u5f62 Shader & Program glCreateShader(GL_VERTEX_SHADER | GL_FRAGMENT_SHADER) glShaderSource glCompileShader glGetShaderiv glCreateProgram glAttachShader glLinkProgram glGetProgramiv glDeleteShader // build and compile our shader program // ------------------------------------ // vertex shader unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &vertexShaderSource, NULL); glCompileShader(vertexShader); // check for shader compile errors int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success); if (!success) { glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" << infoLog << std::endl; } // fragment shader unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL); glCompileShader(fragmentShader); // check for shader compile errors glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success); if (!success) { glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout << \"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\" << infoLog << std::endl; } // link shaders unsigned int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); // check for linking errors glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success); if (!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\" << infoLog << std::endl; } glDeleteShader(vertexShader); glDeleteShader(fragmentShader); Vertex Array glGenVertexArrays glBindVertexArray glGenBuffers glBindBuffer(GL_ARRAY_BUFFER | GL_ELEMENT_ARRAY_BUFFER ) glBufferData(GL_ARRAY_BUFFER | GL_ELEMENT_ARRAY_BUFFER , size, data, GL_STATIC_DRAW) glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // unbind glBindBuffer(GL_ARRAY_BUFFER, 0); // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); glBindVertexArray(0); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = { 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left }; unsigned int indices[] = { // note that we start from 0! 0, 1, 3, // first Triangle 1, 2, 3 // second Triangle }; unsigned int VBO, VAO, EBO; glGenVertexArrays(1, &VAO); glGenBuffers(1, &VBO); glGenBuffers(1, &EBO); // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s). glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind glBindBuffer(GL_ARRAY_BUFFER, 0); // remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound. //glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); // You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other // VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary. glBindVertexArray(0); Draw glClearColor glClear glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); / glDrawArrays(GL_TRIANGLES, 0, 6); egl: glfwSwapBuffers(window); glfwPollEvents(); // uncomment this call to draw in wireframe polygons. //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); // render loop // ----------- while (!glfwWindowShouldClose(window)) { // input // ----- processInput(window); // render // ------ glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // draw our first triangle glUseProgram(shaderProgram); glBindVertexArray(VAO); // seeing as we only have a single VAO there's no need to bind it every time, but we'll do so to keep things a bit more organized //glDrawArrays(GL_TRIANGLES, 0, 6); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); // glBindVertexArray(0); // no need to unbind it every time // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); } // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &VAO); glDeleteBuffers(1, &VBO); glDeleteBuffers(1, &EBO); glDeleteProgram(shaderProgram);","title":"Context"},{"location":"ANGLE/SRC_%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#context","text":"classDiagram class Context { State mState; bool mShared; bool mSkipValidation; bool mDisplayTextureShareGroup; bool mDisplaySemaphoreShareGroup; ErrorSet mErrors; // Recorded errors angle::PackedEnumBitSet<BufferBinding> mValidBufferBindings; std::unique_ptr<rx::ContextImpl> mImplementation; EGLLabelKHR mLabel; Extensions mSupportedExtensions; mutable BindingPointer<Compiler> mCompiler; // Shader compiler. Lazily initialized hence the mutable value. const egl::Config *mConfig; TextureMap mZeroTextures; ResourceMap<FenceNV, FenceNVID> mFenceNVMap; HandleAllocator mFenceNVHandleAllocator; QueryMap mQueryMap; HandleAllocator mQueryHandleAllocator; VertexArrayMap mVertexArrayMap; HandleAllocator mVertexArrayHandleAllocator; TransformFeedbackMap mTransformFeedbackMap; HandleAllocator mTransformFeedbackHandleAllocator; const char *mVersionString; const char *mShadingLanguageString; const char *mRendererString; const char *mExtensionString; std::vector<const char *> mExtensionStrings; const char *mRequestableExtensionString; std::vector<const char *> mRequestableExtensionStrings; std::unique_ptr<GLES1Renderer> mGLES1Renderer; // GLES1 renderer state bool mHasBeenCurrent; // Current/lost context flags bool mContextLost; // Set with setContextLost so that we also set mSkipValidation=false. GraphicsResetStatus mResetStatus; bool mContextLostForced; GLenum mResetStrategy; const bool mRobustAccess; const bool mSurfacelessSupported; const bool mExplicitContextAvailable; egl::Surface *mCurrentDrawSurface; egl::Surface *mCurrentReadSurface; egl::Display *mDisplay; const bool mWebGLContext; bool mBufferAccessValidationEnabled; const bool mExtensionsEnabled; MemoryProgramCache *mMemoryProgramCache; State::DirtyObjects mDrawDirtyObjects; StateCache mStateCache; State::DirtyBits mAllDirtyBits; State::DirtyBits mTexImageDirtyBits; State::DirtyObjects mTexImageDirtyObjects; State::DirtyBits mReadPixelsDirtyBits; State::DirtyObjects mReadPixelsDirtyObjects; State::DirtyBits mClearDirtyBits; State::DirtyObjects mClearDirtyObjects; State::DirtyBits mBlitDirtyBits; State::DirtyObjects mBlitDirtyObjects; State::DirtyBits mComputeDirtyBits; State::DirtyObjects mComputeDirtyObjects; State::DirtyBits mCopyImageDirtyBits; State::DirtyObjects mCopyImageDirtyObjects; angle::ObserverBinding mVertexArrayObserverBinding; angle::ObserverBinding mDrawFramebufferObserverBinding; angle::ObserverBinding mReadFramebufferObserverBinding; std::vector<angle::ObserverBinding> mUniformBufferObserverBindings; std::vector<angle::ObserverBinding> mSamplerObserverBindings; std::vector<angle::ObserverBinding> mImageObserverBindings; mutable Optional<angle::ScratchBuffer> mScratchBuffer; mutable Optional<angle::ScratchBuffer> mZeroFilledBuffer; std::shared_ptr<angle::WorkerThreadPool> mThreadPool; }","title":"Context"},{"location":"ANGLE/SRC_%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#context-relationship","text":"classDiagram class State class ErrorSet class PackedEnumBitSet__BufferBinding class ContextImpl class EGLLabelKHR class Extensions class BindingPointer__Compiler class egl_Config class Context { State mState; TextureMap mZeroTextures; ResourceMap<FenceNV, FenceNVID> mFenceNVMap; HandleAllocator mFenceNVHandleAllocator; QueryMap mQueryMap; HandleAllocator mQueryHandleAllocator; VertexArrayMap mVertexArrayMap; HandleAllocator mVertexArrayHandleAllocator; TransformFeedbackMap mTransformFeedbackMap; HandleAllocator mTransformFeedbackHandleAllocator; const char *mVersionString; const char *mShadingLanguageString; const char *mRendererString; const char *mExtensionString; std::vector<const char *> mExtensionStrings; const char *mRequestableExtensionString; std::vector<const char *> mRequestableExtensionStrings; // GLES1 renderer state std::unique_ptr<GLES1Renderer> mGLES1Renderer; // Current/lost context flags bool mHasBeenCurrent; bool mContextLost; // Set with setContextLost so that we also set mSkipValidation=false. GraphicsResetStatus mResetStatus; bool mContextLostForced; GLenum mResetStrategy; const bool mRobustAccess; const bool mSurfacelessSupported; const bool mExplicitContextAvailable; egl::Surface *mCurrentDrawSurface; egl::Surface *mCurrentReadSurface; egl::Display *mDisplay; const bool mWebGLContext; bool mBufferAccessValidationEnabled; const bool mExtensionsEnabled; MemoryProgramCache *mMemoryProgramCache; State::DirtyObjects mDrawDirtyObjects; StateCache mStateCache; State::DirtyBits mAllDirtyBits; State::DirtyBits mTexImageDirtyBits; State::DirtyObjects mTexImageDirtyObjects; State::DirtyBits mReadPixelsDirtyBits; State::DirtyObjects mReadPixelsDirtyObjects; State::DirtyBits mClearDirtyBits; State::DirtyObjects mClearDirtyObjects; State::DirtyBits mBlitDirtyBits; State::DirtyObjects mBlitDirtyObjects; State::DirtyBits mComputeDirtyBits; State::DirtyObjects mComputeDirtyObjects; State::DirtyBits mCopyImageDirtyBits; State::DirtyObjects mCopyImageDirtyObjects; // Binding to container objects that use dependent state updates. angle::ObserverBinding mVertexArrayObserverBinding; angle::ObserverBinding mDrawFramebufferObserverBinding; angle::ObserverBinding mReadFramebufferObserverBinding; std::vector<angle::ObserverBinding> mUniformBufferObserverBindings; std::vector<angle::ObserverBinding> mSamplerObserverBindings; std::vector<angle::ObserverBinding> mImageObserverBindings; // Not really a property of context state. The size and contexts change per-api-call. mutable Optional<angle::ScratchBuffer> mScratchBuffer; mutable Optional<angle::ScratchBuffer> mZeroFilledBuffer; std::shared_ptr<angle::WorkerThreadPool> mThreadPool; } @startuml hide circle hide member class Buffer class Compiler class FenceNV class Framebuffer class GLES1Renderer class MemoryProgramCache class MemoryObject class Program class ProgramPipeline class Query class Renderbuffer class Sampler class Semaphore class Shader class Sync class Texture class TransformFeedback class VertexArray class VertexAttribute class Context @enduml class Buffer; class Compiler; class FenceNV; class Framebuffer; class GLES1Renderer; class MemoryProgramCache; class MemoryObject; class Program; class ProgramPipeline; class Query; class Renderbuffer; class Sampler; class Semaphore; class Shader; class Sync; class Texture; class TransformFeedback; class VertexArray; struct VertexAttribute; class Context","title":"Context Relationship"},{"location":"ANGLE/SRC_%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#front-end","text":"AttributeMap BinaryStrea BlobCache Buffer Caps Compiler Config Constants Context Debug Device Display EGLSync Error Error.inc ErrorString Fence Framebuffer FramebufferAttachment FrameCapture GLES1Renderer GLES1Shaders.inc GLES1State HandleAllocator Image ImageIndex IndexRangeCache InfoLog LoggingAnnotator MemoryObject MemoryProgramCache Observer Overlay OverlayWidgets Platform.cpp Program ProgramExecutable ProgramLinkedResources ProgramPipeline Query RefCountObject Renderbuffer ResourceManager ResourceMap Sampler Semaphore Shader SizedMRUCache State Stream Surface Texture Thread TransformFeedback Uniform VaryingPacking Version VertexArray VertexAttribute WorkerThread","title":"Front-end"},{"location":"ANGLE/SRC_%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#back-end-interface","text":"BufferImpl CompilerImpl ContextImpl DeviceImpl DisplayImpl EGLImplFactory EGLReusableSync EGLSyncImpl FenceNVImpl Format FramebufferAttachmentObjectImpl FramebufferImpl GLImplFactory ImageImpl MemoryObjectImpl OverlayImpl ProgramImpl ProgramPipelineImpl QueryImpl RenderbufferImpl RenderTargetCache SamplerImpl SemaphoreImpl ShaderImpl StreamProducerImpl SurfaceImpl SyncImpl TextureImpl TransformFeedbackImpl VertexArrayImpl","title":"Back-end Interface"},{"location":"ANGLE/SRC_%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#vulkan","text":"BufferVk CommandProcessor CompilerVk ContextVk DebugAnnotatorVk DeviceVk DisplayVk FenceNVVk FramebufferVk GlslangWrapperVk ImageVk MemoryObjectVk OverlayVk PersistentCommandPool ProgramExecutableVk ProgramPipelineVk ProgramVk QueryVk RenderbufferVk RendererVk RenderTargetVk ResourceVk SamplerVk SecondaryCommandBuffer SemaphoreVk ShaderVk SurfaceVk SyncVk TextureVk TransformFeedbackVk UtilsVk VertexArrayVk BufferVk CommandProcessor CompilerVk ContextVk DebugAnnotatorVk DeviceVk DisplayVk FenceNVVk FramebufferVk GlslangWrapperVk ImageVk MemoryObjectVk OverlayVk PersistentCommandPool ProgramExecutableVk ProgramPipelineVk ProgramVk QueryVk RenderbufferVk RendererVk RenderTargetVk ResourceVk SamplerVk SecondaryCommandBuffer SemaphoreVk ShaderVk SurfaceVk SyncVk TextureVk TransformFeedbackVk UtilsVk VertexArrayVk","title":"Vulkan"},{"location":"ANGLE/SRC_%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#api","text":"\u4ee5 Learn OpenGL \u7684\u4f7f\u7528\u987a\u5e8f","title":"API \u5206\u6790"},{"location":"ANGLE/SRC_%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#_1","text":"","title":"\u4e09\u89d2\u5f62"},{"location":"ANGLE/SRC_%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#shader-program","text":"glCreateShader(GL_VERTEX_SHADER | GL_FRAGMENT_SHADER) glShaderSource glCompileShader glGetShaderiv glCreateProgram glAttachShader glLinkProgram glGetProgramiv glDeleteShader // build and compile our shader program // ------------------------------------ // vertex shader unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &vertexShaderSource, NULL); glCompileShader(vertexShader); // check for shader compile errors int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success); if (!success) { glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" << infoLog << std::endl; } // fragment shader unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL); glCompileShader(fragmentShader); // check for shader compile errors glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success); if (!success) { glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout << \"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\" << infoLog << std::endl; } // link shaders unsigned int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); // check for linking errors glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success); if (!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\" << infoLog << std::endl; } glDeleteShader(vertexShader); glDeleteShader(fragmentShader);","title":"Shader &amp; Program"},{"location":"ANGLE/SRC_%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#vertex-array","text":"glGenVertexArrays glBindVertexArray glGenBuffers glBindBuffer(GL_ARRAY_BUFFER | GL_ELEMENT_ARRAY_BUFFER ) glBufferData(GL_ARRAY_BUFFER | GL_ELEMENT_ARRAY_BUFFER , size, data, GL_STATIC_DRAW) glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // unbind glBindBuffer(GL_ARRAY_BUFFER, 0); // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); glBindVertexArray(0); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = { 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left }; unsigned int indices[] = { // note that we start from 0! 0, 1, 3, // first Triangle 1, 2, 3 // second Triangle }; unsigned int VBO, VAO, EBO; glGenVertexArrays(1, &VAO); glGenBuffers(1, &VBO); glGenBuffers(1, &EBO); // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s). glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind glBindBuffer(GL_ARRAY_BUFFER, 0); // remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound. //glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); // You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other // VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary. glBindVertexArray(0);","title":"Vertex Array"},{"location":"ANGLE/SRC_%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#draw","text":"glClearColor glClear glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); / glDrawArrays(GL_TRIANGLES, 0, 6); egl: glfwSwapBuffers(window); glfwPollEvents(); // uncomment this call to draw in wireframe polygons. //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); // render loop // ----------- while (!glfwWindowShouldClose(window)) { // input // ----- processInput(window); // render // ------ glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // draw our first triangle glUseProgram(shaderProgram); glBindVertexArray(VAO); // seeing as we only have a single VAO there's no need to bind it every time, but we'll do so to keep things a bit more organized //glDrawArrays(GL_TRIANGLES, 0, 6); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); // glBindVertexArray(0); // no need to unbind it every time // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); } // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &VAO); glDeleteBuffers(1, &VBO); glDeleteBuffers(1, &EBO); glDeleteProgram(shaderProgram);","title":"Draw"},{"location":"ANGLE/UML%20Samples/","text":"1 tthis is @startuml Bob -> Alice : hello @enduml \u65f6\u5e8f\u56fe @startuml \u7528\u6237-> \u8ba4\u8bc1\u4e2d\u5fc3: \u767b\u5f55\u64cd\u4f5c \u8ba4\u8bc1\u4e2d\u5fc3-> \u7f13\u5b58: \u5b58\u653e(key=token+ip,value=token)token \u7528\u6237<- \u8ba4\u8bc1\u4e2d\u5fc3: \u8ba4\u8bc1\u6210\u529f\u8fd4\u56detoken \u7528\u6237-> \u8ba4\u8bc1\u4e2d\u5fc3: \u4e0b\u6b21\u8bbf\u95ee\u5934\u90e8\u643a\u5e26token\u8ba4\u8bc1 \u8ba4\u8bc1\u4e2d\u5fc3<- \u7f13\u5b58: key=token+ip\u83b7\u53d6token \u5176\u4ed6\u670d\u52a1<- \u8ba4\u8bc1\u4e2d\u5fc3: \u5b58\u5728\u4e14\u6821\u9a8c\u6210\u529f\u5219\u8df3\u8f6c\u5230\u7528\u6237\u8bf7\u6c42\u7684\u5176\u4ed6\u670d\u52a1 \u5176\u4ed6\u670d\u52a1-> \u7528\u6237: \u4fe1\u606f 'comment @enduml \u53c2\u4e0e\u8005 \u58f0\u660e \u56fe\u4f8b, \u989c\u8272, \u522b\u540das, @startuml actor Foo1 boundary Foo2 control Foo3 entity Foo4 #99FF99 database Foo5 as D collections Foo6 #red Foo1 -> Foo2 : To boundary Foo1 -> Foo3 : To control Foo1 -> Foo4 : To entity Foo1 -> D : To database Foo1 -> Foo6 : To collections @enduml \u7279\u6b8a\u7b26\u53f7\u540d\u79f0, \u5feb\u901f\u522b\u540das, \\n\u6362\u884c @startuml '\u547d\u4ee4: \u8fd4\u56de\u65f6,\u6587\u5b57\u5728\u7bad\u5934\u4e0b skinparam responseMessageBelowArrow true Alice -> \"Bob()\" : Hello \"Bob()\" -> \"This is \\nvery long\" as Long : Thinking '\u865a\u7ebf --> Long --> \"Bob()\" : ok \"Bob()\" -> \"Bob()\" : self @enduml \u7bad\u5934: \u7c7b\u578b, \u989c\u8272, \u7f16\u53f7 @startuml autonumber Bob ->x Alice Bob -> Alice Bob ->> Alice Bob -[#green]\\ Alice Bob \\\\[#0000FF]- Alice Bob //-- Alice Bob ->o Alice 'newpage A title for the\\nlast page Bob o\\\\-- Alice Bob <-> Alice Bob <->o Alice @enduml @startwbs + New Job ++ Decide on Job Requirements +++ Identity gaps +++ Review JDs ++++ Sign-Up for courses ++++ Volunteer ++++ Reading ++- Checklist +++- Responsibilities +++- Location ++ CV Upload Done +++ CV Updated ++++ Spelling & Grammar ++++ Check dates ---- Skills +++ Recruitment sites chosen @endwbs","title":"UML Samples"},{"location":"ANGLE/UML%20Samples/#1-tthis-is","text":"@startuml Bob -> Alice : hello @enduml","title":"1 tthis is"},{"location":"ANGLE/UML%20Samples/#_1","text":"@startuml \u7528\u6237-> \u8ba4\u8bc1\u4e2d\u5fc3: \u767b\u5f55\u64cd\u4f5c \u8ba4\u8bc1\u4e2d\u5fc3-> \u7f13\u5b58: \u5b58\u653e(key=token+ip,value=token)token \u7528\u6237<- \u8ba4\u8bc1\u4e2d\u5fc3: \u8ba4\u8bc1\u6210\u529f\u8fd4\u56detoken \u7528\u6237-> \u8ba4\u8bc1\u4e2d\u5fc3: \u4e0b\u6b21\u8bbf\u95ee\u5934\u90e8\u643a\u5e26token\u8ba4\u8bc1 \u8ba4\u8bc1\u4e2d\u5fc3<- \u7f13\u5b58: key=token+ip\u83b7\u53d6token \u5176\u4ed6\u670d\u52a1<- \u8ba4\u8bc1\u4e2d\u5fc3: \u5b58\u5728\u4e14\u6821\u9a8c\u6210\u529f\u5219\u8df3\u8f6c\u5230\u7528\u6237\u8bf7\u6c42\u7684\u5176\u4ed6\u670d\u52a1 \u5176\u4ed6\u670d\u52a1-> \u7528\u6237: \u4fe1\u606f 'comment @enduml","title":"\u65f6\u5e8f\u56fe"},{"location":"ANGLE/UML%20Samples/#_2","text":"","title":"\u53c2\u4e0e\u8005 \u58f0\u660e"},{"location":"ANGLE/UML%20Samples/#as","text":"@startuml actor Foo1 boundary Foo2 control Foo3 entity Foo4 #99FF99 database Foo5 as D collections Foo6 #red Foo1 -> Foo2 : To boundary Foo1 -> Foo3 : To control Foo1 -> Foo4 : To entity Foo1 -> D : To database Foo1 -> Foo6 : To collections @enduml","title":"\u56fe\u4f8b, \u989c\u8272, \u522b\u540das,"},{"location":"ANGLE/UML%20Samples/#as-n","text":"@startuml '\u547d\u4ee4: \u8fd4\u56de\u65f6,\u6587\u5b57\u5728\u7bad\u5934\u4e0b skinparam responseMessageBelowArrow true Alice -> \"Bob()\" : Hello \"Bob()\" -> \"This is \\nvery long\" as Long : Thinking '\u865a\u7ebf --> Long --> \"Bob()\" : ok \"Bob()\" -> \"Bob()\" : self @enduml","title":"\u7279\u6b8a\u7b26\u53f7\u540d\u79f0, \u5feb\u901f\u522b\u540das, \\n\u6362\u884c"},{"location":"ANGLE/UML%20Samples/#_3","text":"@startuml autonumber Bob ->x Alice Bob -> Alice Bob ->> Alice Bob -[#green]\\ Alice Bob \\\\[#0000FF]- Alice Bob //-- Alice Bob ->o Alice 'newpage A title for the\\nlast page Bob o\\\\-- Alice Bob <-> Alice Bob <->o Alice @enduml @startwbs + New Job ++ Decide on Job Requirements +++ Identity gaps +++ Review JDs ++++ Sign-Up for courses ++++ Volunteer ++++ Reading ++- Checklist +++- Responsibilities +++- Location ++ CV Upload Done +++ CV Updated ++++ Spelling & Grammar ++++ Check dates ---- Skills +++ Recruitment sites chosen @endwbs","title":"\u7bad\u5934: \u7c7b\u578b, \u989c\u8272, \u7f16\u53f7"},{"location":"GLES/Framebuffer%20Object/","text":"GLES Framebuffers learnopengl \u66f4\u591a\u7528\u4f8b: \u6cdb\u5149 \u591a\u6e32\u67d3\u76ee\u6807(Multiple Render Targets) \u4e0e \u5ef6\u8fdf\u7740\u8272\u6cd5 \u5b9a\u4e49 \u901a\u5e38\u6211\u4eec\u7684\u64cd\u4f5c\u90fd\u662f\u5728 \u9ed8\u8ba4 \u5e27\u7f13\u51b2 (Default Framebuffer ) \u7684\u6e32\u67d3\u7f13\u51b2\u4e0a\u8fdb\u884c\u7684\u3002\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u662f\u5728\u4f60\u521b\u5efa\u7a97\u53e3\u7684\u65f6\u5019\u751f\u6210\u548c\u914d\u7f6e\u7684\uff08EGL\uff09\u3002 \u5728GL\u4e2d\u4f1a\u4f7f\u7528\u51e0\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u5c4f\u5e55\u7f13\u51b2\uff1a\u7528\u4e8e\u5199\u5165\u989c\u8272\u503c\u7684 \u989c\u8272\u7f13\u51b2 \uff0c\u7528\u4e8e\u5199\u5165\u6df1\u5ea6\u4fe1\u606f\u7684 \u6df1\u5ea6\u7f13\u51b2 \uff0c\u4ee5\u53ca\u5141\u8bb8\u6211\u4eec\u57fa\u4e8e\u4e00\u4e9b\u6761\u4ef6\u4e22\u5f03\u6307\u5b9a\u7247\u6bb5\u7684 \u6a21\u677f\u7f13\u51b2 \u3002\u628a\u8fd9\u51e0\u79cd\u7f13\u51b2\u7ed3\u5408\u8d77\u6765\u53eb\u505a\u5e27\u7f13\u51b2(Framebuffer)\u3002 \u800c\u4f7f\u7528 \u5e27\u7f13\u51b2\u5bf9\u8c61 (Framebuffer Object) \u5141\u8bb8\u7528\u6237 \u81ea\u5b9a\u4e49\u5e27\u7f13\u51b2 \uff0cFramebuffer \u5b9e\u9645\u662f\u4e00\u4e2a\u53ef\u6dfb\u52a0 \u7f13\u51b2\u7684\u5bb9\u5668 . \u7528\u6237\u53ef\u4ee5\u4e3a\u5176\u6dfb\u52a0 \u7eb9\u7406 (Textures ) \u6216 \u6e32\u67d3\u7f13\u51b2\u533a \u5bf9\u8c61\uff08Renderbuffer), \u6765\u5b9a\u4e49\u81ea\u5df1\u7684\u989c\u8272\u7f13\u51b2\uff0c\u6df1\u5ea6\u7f13\u51b2, \u548c\u6a21\u677f\u7f13\u51b2\u3002 \u5e94\u7528 \u6e32\u67d3\u5230\u4e00\u4e2a\u975e\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u88ab\u53eb\u505a \u79bb\u5c4f\u6e32\u67d3 (Off-screen Rendering) \u6216 \u6e32\u67d3\u5230\u7eb9\u7406 (Render to Texture)\u3002 \u901a\u8fc7\u81ea\u5b9a\u4e49\u5e27\u7f13\u51b2\u53ef\u4ee5\u5c06\u4f60\u7684\u573a\u666f\u6e32\u67d3\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u4e2d, \u53ef\u4ee5\u4f7f\u6211\u4eec\u80fd\u591f\u5728\u5f53\u524d\u573a\u666f\u4e2d\u521b\u5efa \u955c\u5b50, \u5012\u5f71 \u8fd9\u6837\u7684\u6548\u679c. \u8fd8\u6709\u5f88\u591a\u5e38\u89c1\u7279\u6548\u9700\u8981\u7528\u5230\u5e27\u7f13\u51b2, \u4f8b\u5982: \u9634\u5f71\u8d34\u56fe, \u52a8\u6001\u53cd\u5c04\u548c\u73af\u5883\u8d34\u56fe, \u591a\u9053\u666f\u6df1\u6280\u672f, \u52a8\u6001\u6a21\u7cca, \u548c\u540e\u671f\u5904\u7406\u7279\u6548\u7b49. \u76f8\u5173\u5b9a\u4e49 \u9ed8\u8ba4\u5e27\u7f13\u51b2 Default Framebuffers \u5728\u8fdb\u884cGLES\u6307\u4ee4\u64cd\u4f5c\u524d, \u9700\u8981\u521b\u5efa\u4e00\u4e2a Context \u548c \u7ed8\u56fe\u8868\u9762 (\u9ed8\u8ba4 Framebuffer), \u8fd9\u901a\u5e38\u7531\u539f\u751f\u7a97\u53e3\u7cfb\u7edf\u901a\u8fc7 EGL \u7b49\u5b8c\u6210. \u521b\u5efa EGL \u7ed8\u5236\u8868\u9762\u7684\u8c03\u7528\u65f6, \u4ee5\u50cf\u7d20\u5f62\u5f0f\u6307\u5b9a \u5bbd\u5ea6,\u9ad8\u5ea6, \u662f\u5426\u4f7f\u7528 \u989c\u8272\u7f13\u51b2, \u6df1\u5ea6\u7f13\u51b2, \u6a21\u677f\u7f13\u51b2, \u53ca\u8fd9\u4e9b\u7f13\u51b2\u533a\u7684\u4f4d\u6df1. \u4e0d\u80fd\u5bf9\u5176\u8fdb\u884c\u4fee\u6539\u6216\u67e5\u8be2\u72b6\u6001\u64cd\u4f5c glViewport \u63a7\u5236\u5e27\u7f13\u51b2\u7684\u5927\u5c0f, \u4ee5\u53ca\u63a7\u5236\u9634\u5f71\u6df1\u5ea6\u8d34\u56fe\u5927\u5c0f\u7b49\u7b49 \u5e27\u7f13\u51b2\u5bf9\u8c61 Framebuffers Objects (FBOs) \u9644\u7740 Attachment FBO \u4ec5\u88ab\u89c6\u4e3a\u7f13\u5b58\u7684\u5bb9\u5668, \u56e0\u6b64\u4f7f\u7528 FBO \u4f5c\u4e3a\u6e32\u67d3\u76ee\u6807\u65f6\uff0c\u9996\u5148\u9700\u8981\u4e3a FBO \u7684\u9644\u7740\u8fde\u63a5\u5bf9\u8c61\uff0c \u9644\u7740\u662f\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\uff0c\u5b83\u80fd\u591f\u4f5c\u4e3a\u5e27\u7f13\u51b2\u7684\u4e00\u4e2a\u7f13\u51b2\uff0c\u53ef\u4ee5\u5c06\u5b83\u60f3\u8c61\u4e3a\u4e00\u4e2a\u56fe\u50cf\u3002 \u521b\u5efa\u4e00\u4e2a\u9644\u4ef6\u65b9\u5f0f\u6709\u4e24\u79cd\uff1a \u7eb9\u7406 \u6216 \u6e32\u67d3\u7f13\u51b2 \u5bf9\u8c61(Renderbuffer)\u3002 \u5e27\u7f13\u51b2\u76843\u4e2a\u9644\u7740 \u989c\u8272\u9644\u7740 Color Attachment \u6df1\u5ea6\u9644\u7740 Depth Attachment \u6a21\u677f\u9644\u7740 Stencil Attachment \u7eb9\u7406\u9644\u4ef6 Textures \u5373\u666e\u901a\u7684 Texture, \u6839\u636e Format\u7684\u4e0d\u540c, \u53ef\u4ee5\u5206\u522b\u7528\u4f5c FBO \u4e2d\u7684\u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u9644\u7740\u3002 \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 Renderbuffer Objects \u662f\u4e00\u4e2a\u7531\u5e94\u7528\u7a0b\u5e8f\u5206\u914d\u7684 2D \u56fe\u50cf\u7f13\u51b2\u533a\u3002 \u6e32\u67d3\u7f13\u51b2\u533a\u53ef\u4ee5\u7528\u4e8e\u5206\u914d\u548c\u5b58\u50a8 \u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u503c\uff0c\u53ef\u4ee5\u7528\u4f5c FBO \u4e2d\u7684\u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u9644\u7740\u3002 \u4f7f\u7528 \u7eb9\u7406 \u548c Renderbuffer \u5bf9\u8c61, \u90fd\u652f\u6301\u4e3a FBO \u5206\u522b\u6dfb\u52a0\u4e09\u79cd\u9644\u7740. \u4f46\u901a\u5e38\u4f7f\u7528 Texture \u6dfb\u52a0\u989c\u8272\u9644\u7740, \u7528 Renderbuffer \u6765\u6dfb\u52a0\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740. \u539f\u56e0\u5728\u540e\u9762\u8ba8\u8bba. (OpenGL ES 3.0 \u7f16\u7a0b\u6307\u5357) \u4f7f\u7528\u6d41\u7a0b APP --> GLES : glGenFramebuffers(1, &fbo); glBindFramebuffer(GL_FRAMEBUFFER, fbo); glBindFramebuffer(GL_FRAMEBUFFER, 0); \u521b\u5efa\u5e27\u7f13\u51b2 \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61 glGenFramebuffers(1, &fbo); \u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684(Active)\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, fbo); \u5728\u7ed1\u5b9a\u5230GL_FRAMEBUFFER\u76ee\u6807\u4e4b\u540e\uff0c\u6240\u6709\u7684 \u8bfb\u53d6 \u548c \u5199\u5165 \u5e27\u7f13\u51b2\u7684\u64cd\u4f5c\u5c06\u4f1a\u5f71\u54cd\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u3002 \u6211\u4eec\u4e5f\u53ef\u4ee5\u4f7f\u7528 GL_READ_FRAMEBUFFER \u6216 GL_DRAW_FRAMEBUFFER \uff0c\u5c06\u4e00\u4e2a\u5e27\u7f13\u51b2\u5206\u522b\u7ed1\u5b9a\u5230\u8bfb\u53d6\u76ee\u6807\u6216\u5199\u5165\u76ee\u6807\u3002 \u7ed1\u5b9a\u5230 GL_READ_FRAMEBUFFER \u7684\u5e27\u7f13\u51b2\u5c06\u4f1a\u4f7f\u7528\u5728\u6240\u6709\u50cf\u662f glReadPixels \u7684\u8bfb\u53d6\u64cd\u4f5c\u4e2d\uff0c \u7ed1\u5b9a\u5230 GL_DRAW_FRAMEBUFFER \u7684\u5e27\u7f13\u51b2\u5c06\u4f1a\u88ab\u7528\u4f5c\u6e32\u67d3\u3001\u6e05\u9664\u7b49\u5199\u5165\u64cd\u4f5c\u7684\u76ee\u6807\u3002 \u901a\u5e38\u90fd \u4e0d\u9700\u8981\u533a\u5206 \u5b83\u4eec\uff0c\u4f7f\u7528 GL_FRAMEBUFFER \uff0c\u7ed1\u5b9a\u5230\u4e24\u4e2a\u4e0a\u3002 \u6dfb\u52a0\u9644\u7740: \u5728\u8fd9\u4e00\u9636\u6bb5, \u4f7f\u7528Texture\u6216Renderbuffer\u5bf9FBO\u6dfb\u52a0\u9644\u7740, \u4ee3\u7801\u5728\u4e0b\u4e24\u8282\u79cd\u5c55\u793a. \u6dfb\u52a0\u9644\u7740\u540e, \u68c0\u67e5\u5e27\u7f13\u51b2\u7684\u5b8c\u6574\u6027 if( glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE) \u4e00\u4e2a\u5b8c\u6574\u7684\u5e27\u7f13\u51b2\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u7684\u6761\u4ef6\uff1a \u9644\u52a0\u81f3\u5c11\u4e00\u4e2a\u9644\u7740\uff08\u989c\u8272\u3001\u6df1\u5ea6\u6216\u6a21\u677f\u9644\u7740\uff09\u3002 \u81f3\u5c11\u6709\u4e00\u4e2a\u989c\u8272\u9644\u4ef6(Attachment)\u3002TODO: check angle \u6240\u6709\u7684\u9644\u4ef6\u90fd\u5fc5\u987b\u662f\u5b8c\u6574\u7684\uff08\u4fdd\u7559\u4e86\u5185\u5b58\uff09\u3002 \u6bcf\u4e2a\u7f13\u51b2\u90fd\u5e94\u8be5\u6709\u76f8\u540c\u7684\u9ad8\u5ea6\u548c\u5bbd\u5ea6\u3002 \u5982\u679c\u5b58\u5728\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740, \u5b83\u4eec\u5fc5\u987b\u662f\u76f8\u540c\u7684\u56fe\u50cf. \u6240\u6709\u9644\u7740\u7684 GL_RENDERBUFFER_SAMPLES \u6837\u672c\u503c\u76f8\u540c. \u82e5\u9644\u7740\u5bf9\u8c61\u662f\u7eb9\u7406, \u5219\u6b64\u503c\u4e3a0. \u89e3\u7ed1FBO / \u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u6e32\u67d3\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u88ab\u53eb\u505a \u79bb\u5c4f\u6e32\u67d3 (Off-screen Rendering)\u3002\u8981\u4fdd\u8bc1\u6240\u6709\u7684\u6e32\u67d3\u64cd\u4f5c\u5728\u4e3b\u7a97\u53e3\u4e2d\u6709\u89c6\u89c9\u6548\u679c\uff0c\u6211\u4eec\u9700\u8981\u518d\u6b21\u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2\uff0c\u5c06\u5b83\u7ed1\u5b9a\u5230 0 \u3002 \u7eb9\u7406\u9644\u7740 \u666e\u901a\u7684\u521b\u5efa\u7eb9\u7406\u7684\u65b9\u5f0f unsigned int texture; glGenTextures(1, &texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); \u5982\u679c\u4f60\u60f3\u5c06\u4f60\u7684\u5c4f\u5e55\u6e32\u67d3\u5230\u4e00\u4e2a\u66f4\u5c0f\u6216\u66f4\u5927\u7684\u7eb9\u7406\u4e0a\uff0c\u4f60\u9700\u8981\uff08\u5728\u6e32\u67d3\u5230\u4f60\u7684\u5e27\u7f13\u51b2\u4e4b\u524d\uff09\u518d\u6b21\u8c03\u7528glViewport\uff0c\u4f7f\u7528\u7eb9\u7406\u7684\u65b0\u7ef4\u5ea6\u4f5c\u4e3a\u53c2\u6570\uff0c\u5426\u5219\u53ea\u6709\u4e00\u5c0f\u90e8\u5206\u7684\u7eb9\u7406\u6216\u5c4f\u5e55\u4f1a\u88ab\u6e32\u67d3\u5230\u8fd9\u4e2a\u7eb9\u7406\u4e0a\u3002 TODO: \u4ec0\u4e48\u610f\u601d? \u5c06\u7eb9\u7406\u9644\u52a0\u5728\u5e27\u7f13\u51b2\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); target \uff1a\u5e27\u7f13\u51b2\u7684\u76ee\u6807\uff08\u7ed8\u5236\u3001\u8bfb\u53d6\u6216\u8005\u4e24\u8005\u7686\u6709\uff09 attachment \uff1a\u6211\u4eec\u60f3\u8981\u9644\u52a0\u7684\u9644\u4ef6\u7c7b\u578b\u3002\u5f53\u524d\u6211\u4eec\u6b63\u5728\u9644\u52a0\u4e00\u4e2a \u989c\u8272\u9644\u4ef6 \u3002\u6ce8\u610f\u6700\u540e\u7684 0 \u610f\u5473\u7740\u53ef\u4ee5\u9644\u52a0\u591a\u4e2a\u989c\u8272\u9644\u4ef6\u3002 GL_COLOR_ATTACHMENT i , GL_DEPTH_ATTACHMENT , GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMENT . textarget \uff1a\u4f60\u5e0c\u671b\u9644\u52a0\u7684\u7eb9\u7406\u7c7b\u578b texture \uff1a\u8981\u9644\u52a0\u7684\u7eb9\u7406\u672c\u8eab level \uff1a\u591a\u7ea7\u6e10\u8fdc\u7eb9\u7406\u7684\u7ea7\u522b\u3002\u6211\u4eec\u5c06\u5b83\u4fdd\u7559\u4e3a0 \u7eb9\u7406\u5bf9\u8c61\u5141\u8bb8\u9644\u52a0\u4e00\u4e2a\u6df1\u5ea6\u6216\u6a21\u677f\u7f13\u51b2\u7eb9\u7406\u5230\u5e27\u7f13\u51b2\u5bf9\u8c61\u4e2d\u3002 \u8981\u9644\u52a0\u6df1\u5ea6\u7f13\u51b2\u7684\u8bdd\uff0c\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e\u4e3a GL_DEPTH_ATTACHMENT \u3002\u5e76\u5c06\u7eb9\u7406\u7684\u683c\u5f0f(Format)\u548c\u5185\u90e8\u683c\u5f0f(Internalformat)\u7c7b\u578b\u53d8\u4e3a GL_DEPTH_COMPONENT \uff0c\u6765\u53cd\u6620\u6df1\u5ea6\u7f13\u51b2\u7684\u50a8\u5b58\u683c\u5f0f\u3002 \u8981\u9644\u52a0\u6a21\u677f\u7f13\u51b2\u7684\u8bdd\uff0c\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e\u4e3a GL_STENCIL_ATTACHMENT \uff0c\u5e76\u5c06\u7eb9\u7406\u7684\u683c\u5f0f\u8bbe\u5b9a\u4e3a GL_STENCIL_INDEX \u3002 \u4e5f\u53ef\u4ee5\u5c06\u6df1\u5ea6\u7f13\u51b2\u548c\u6a21\u677f\u7f13\u51b2\u5408\u5e76\u9644\u52a0\u4e3a\u4e00\u4e2a\u7eb9\u7406\u3002\u7eb9\u7406\u7684\u6bcf32\u4f4d\u6570\u503c\u5c06\u5305\u542b24\u4f4d\u7684\u6df1\u5ea6\u4fe1\u606f\u548c8\u4f4d\u7684\u6a21\u677f\u4fe1\u606f\u3002\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e GL_DEPTH_STENCIL_ATTACHMENT \u7c7b\u578b\uff0c\u5e76\u914d\u7f6e\u7eb9\u7406\u7684\u683c\u5f0f\uff0c\u8ba9\u5b83\u5305\u542b\u5408\u5e76\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u503c\u3002 ``` glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL ); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0); ``` Renderbuffer \u9644\u7740 \u521b\u5efa\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u7684\u4ee3\u7801 glGenRenderbuffers(1, &rbo); \u7ed1\u5b9a\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\uff0c\u8ba9\u4e4b\u540e\u6240\u6709\u7684\u6e32\u67d3\u7f13\u51b2\u64cd\u4f5c\u5f71\u54cd\u5f53\u524d\u7684 RBO\uff1a glBindRenderbuffer(GL_RENDERBUFFER, rbo); \u521b\u5efa\u4e00\u4e2a\u6df1\u5ea6\u548c\u6a21\u677f\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); \u521b\u5efa\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u548c\u7eb9\u7406\u5bf9\u8c61\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u662f\u8fd9\u4e2a\u5bf9\u8c61\u662f\u4e13\u95e8\u88ab\u8bbe\u8ba1\u4f5c\u4e3a\u56fe\u50cf\u4f7f\u7528\u7684\uff0c\u800c\u4e0d\u662f\u7eb9\u7406\u90a3\u6837\u7684\u901a\u7528\u6570\u636e\u7f13\u51b2(General Purpose Data Buffer)\u3002 \u8fd9\u91cc\u6211\u4eec\u9009\u62e9 GL_DEPTH24_STENCIL8 \u4f5c\u4e3a\u5185\u90e8\u683c\u5f0f\uff0c\u5b83\u5c01\u88c5\u4e8624\u4f4d\u7684\u6df1\u5ea6\u548c8\u4f4d\u7684\u6a21\u677f\u7f13\u51b2\u3002 \u9644\u52a0\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5230 FBO\uff1a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); \u4f7f\u7528 GL_DEPTH_STENCIL_ATTACHMENT \u8868\u793a\u540c\u65f6\u5305\u542b\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740 Texture VS. Renderbuffer \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61(Renderbuffer Object) \u662f\u5728\u7eb9\u7406\u4e4b\u540e\u5f15\u5165\u5230OpenGL\u4e2d\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u53ef\u7528\u7684\u5e27\u7f13\u51b2\u9644\u4ef6\u7c7b\u578b\u7684\uff0c\u6240\u4ee5\u5728\u8fc7\u53bb\u7eb9\u7406\u662f\u552f\u4e00\u53ef\u7528\u7684\u9644\u4ef6\u3002 Renderbuffer : \u548c\u7eb9\u7406\u56fe\u50cf\u4e00\u6837\uff0c\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u662f\u4e00\u4e2a\u771f\u6b63\u7684\u7f13\u51b2\uff0c\u5373\u4e00\u7cfb\u5217\u7684\u5b57\u8282\u3001\u6574\u6570\u3001\u50cf\u7d20\u7b49\u3002 \u4f18\u70b9: Renderbuffer \u4f1a\u5c06\u6570\u636e\u50a8\u5b58\u4e3aOpenGL\u539f\u751f\u7684\u6e32\u67d3\u683c\u5f0f\uff0c\u5b83\u662f\u4e3a\u79bb\u5c4f\u6e32\u67d3\u5230\u5e27\u7f13\u51b2\u4f18\u5316\u8fc7\u7684\u3002 Renderbuffer \u76f4\u63a5\u5c06\u6240\u6709\u7684\u6e32\u67d3\u6570\u636e\u50a8\u5b58\u5230\u5b83\u7684\u7f13\u51b2\u4e2d\uff0c\u4e0d\u4f1a\u505a\u4efb\u4f55\u9488\u5bf9\u7eb9\u7406\u683c\u5f0f\u7684\u8f6c\u6362\uff0c\u8ba9\u5b83\u53d8\u4e3a\u4e00\u4e2a\u66f4\u5feb\u7684\u53ef\u5199\u50a8\u5b58\u4ecb\u8d28\u3002 \u7f3a\u70b9: Renderbuffer \u4e0d\u80fd\u505a\u7eb9\u7406: \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u901a\u5e38\u90fd\u662f \u53ea\u5199 \u7684\uff0c\u6240\u4ee5\u4f60\u4e0d\u80fd\u8bfb\u53d6\u5b83\u4eec, \u6bd4\u5982\u4f7f\u7528\u7eb9\u7406\u8bbf\u95ee\u3002 \u5f53\u7136\u4f60\u4ecd\u7136\u8fd8\u662f\u80fd\u591f\u4f7f\u7528 glReadPixels \u6765\u8bfb\u53d6\u5b83\uff0c\u8fd9\u4f1a\u4ece\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2(\u800c\u4e0d\u662f\u9644\u4ef6\u672c\u8eab)\u4e2d\u8fd4\u56de\u7279\u5b9a\u533a\u57df\u7684\u50cf\u7d20\u3002 \u56e0\u6b64\u901a\u5e38\u7684\u89c4\u5219\u662f: \u5982\u679c\u4f60 \u4e0d\u9700\u8981\u4ece\u4e00\u4e2a\u7f13\u51b2\u4e2d\u91c7\u6837 \u6570\u636e\uff0c\u90a3\u4e48\u5bf9\u8fd9\u4e2a\u7f13\u51b2\u4f7f\u7528 \u6e32\u67d3\u7f13\u51b2 \u5bf9\u8c61\u4f1a\u662f\u660e\u667a\u7684\u9009\u62e9\u3002 \u800c\u5982\u679c\u4f60 \u9700\u8981\u4ece\u7f13\u51b2\u4e2d\u91c7\u6837\u989c\u8272\u6216\u6df1\u5ea6 \u503c\u7b49\u6570\u636e\uff0c\u90a3\u4e48\u4f60\u5e94\u8be5\u9009\u62e9 \u7eb9\u7406 \u9644\u4ef6\u3002\u6027\u80fd\u65b9\u9762\u5b83\u4e0d\u4f1a\u4ea7\u751f\u975e\u5e38\u5927\u7684\u5f71\u54cd\u7684\u3002 \u56e0\u6b64 Renderbuffer \u5bf9\u8c61\u901a\u5e38\u7528\u4e8e \u6df1\u5ea6\u548c\u6a21\u677f \u9644\u4ef6\uff0c\u56e0\u4e3a\u5927\u90e8\u5206\u65f6\u95f4\u6211\u4eec\u90fd\u4e0d\u9700\u8981\u4ece\u6df1\u5ea6\u548c\u6a21\u677f\u7f13\u51b2\u4e2d\u8bfb\u53d6\u503c\uff0c\u53ea\u5173\u5fc3\u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5, \u4f46\u4e0d\u9700\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u91c7\u6837. \u5bf9\u5e94\u5230\u573a\u666f\u4e2d: \u9009\u62e9 Texture \u6e32\u67d3\u5230\u4e00\u4e2a\u7528\u4f5c\u989c\u8272\u7eb9\u7406\u7684\u989c\u8272\u7f13\u51b2\u533a \u6e32\u67d3\u5230\u4e00\u4e2a\u7528\u4f5c\u9634\u5f71\u7684\u6df1\u5ea6\u7eb9\u7406\u7684\u6df1\u5ea6\u7f13\u51b2\u533a \u9009\u62e9 Renderbuffer \u591a\u91cd\u91c7\u6837 \u5982\u679c\u56fe\u50cf\u4e0d\u88ab\u4f5c\u4e3a\u7eb9\u7406, \u5219 Renderbuffer \u53ef\u80fd\u5e26\u6765\u6027\u80fd\u4f18\u52bf: GLES \u53ef\u80fd\u4ee5\u66f4\u9ad8\u6548\u7684\u683c\u5f0f\u5b58\u50a8 Renderbuffer, \u6bd4\u7eb9\u7406\u66f4\u9002\u5408\u6e32\u67d3 \u4f8b\u5982: \u5229\u7528\u5176\u5199\u5165\u6216\u8005\u590d\u5236\u5230\u5176\u5b83\u7f13\u51b2\u5feb\u7684\u7279\u70b9\u3002 \u4ea4\u6362\u7f13\u51b2 \u8fd9\u6837\u7684\u64cd\u4f5c\u5728\u4f7f\u7528\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u65f6\u4f1a\u975e\u5e38\u5feb\u3002 \u5728\u6bcf\u4e2a\u6e32\u67d3\u8fed\u4ee3\u6700\u540e\u4f7f\u7528\u7684 glfwSwapBuffers \uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5b9e\u73b0\uff1a\u53ea\u9700\u8981\u5199\u5165\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u56fe\u50cf\uff0c\u5e76\u5728\u6700\u540e\u4ea4\u6362\u5230\u53e6\u5916\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5c31\u53ef\u4ee5\u4e86\u3002 \u793a\u4f8b: \u573a\u666f\u6ee4\u955c \u521b\u5efa\u9636\u6bb5 // \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61\uff0c\u5e76\u7ed1\u5b9a unsigned int framebuffer; glGenFramebuffers(1, &framebuffer); glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); // \u4f7f\u7528 Texture \u6dfb\u52a0\u989c\u8272\u9644\u7740 // \u751f\u6210\u7eb9\u7406 unsigned int texColorBuffer; glGenTextures(1, &texColorBuffer); glBindTexture(GL_TEXTURE_2D, texColorBuffer); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glBindTexture(GL_TEXTURE_2D, 0); // \u5c06\u7eb9\u7406\u5bf9\u8c61, \u9644\u52a0\u5230\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u5bf9\u8c61\u989c\u8272(color)\u9644\u4ef6\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, 0); // \u4f7f\u7528 Renderbuffer \u6dfb\u52a0\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740 // \u6df1\u5ea6\uff08\u548c\u6a21\u677f\uff09\u6d4b\u8bd5 // \u6dfb\u52a0\u4e00\u4e2a\u6df1\u5ea6\uff08\u548c\u6a21\u677f\uff09\u9644\u4ef6\u5230\u5e27\u7f13\u51b2\u4e2d unsigned int rbo; glGenRenderbuffers(1, &rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); // GL_DEPTH24_STENCIL8 glBindRenderbuffer(GL_RENDERBUFFER, 0); // \u5c06\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61, \u9644\u52a0\u5230\u5230\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u7684 depth \u548c stencil \u9644\u4ef6\u4e0a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); // \u68c0\u67e5\u5e27\u7f13\u51b2\u662f\u5426\u662f\u5b8c\u6574\u7684 if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) std::cout << \"ERROR::FRAMEBUFFER:: Framebuffer is not complete!\" << std::endl; // \u89e3\u7ed1\u5e27\u7f13\u51b2/\u7ed1\u5b9a\u56de\u9ed8\u8ba4 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u7ed8\u5236\u9636\u6bb5 \u8981\u60f3\u7ed8\u5236\u573a\u666f\u5230\u4e00\u4e2a\u7eb9\u7406\u4e0a\uff0c\u6211\u4eec\u9700\u8981\u91c7\u53d6\u4ee5\u4e0b\u7684\u6b65\u9aa4\uff1a \u5c06\u65b0\u7684\u5e27\u7f13\u51b2\u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684\u5e27\u7f13\u51b2 \u548c\u5f80\u5e38\u4e00\u6837\u6e32\u67d3\u573a\u666f \u6b64\u65f6\u573a\u666f\u4f1a\u6e32\u67d3\u5230\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2, \u800c\u4e0d\u662f\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u3002 \u6240\u6709\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u64cd\u4f5c\u90fd\u4f1a\u4ece\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u4ef6\u4e2d\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u8bfb\u53d6\u3002 \u7ed1\u5b9a\u56de\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2 \u7ed8\u5236\u4e00\u4e2a\u6574\u5c4f\u5e55\u7684\u56db\u8fb9\u5f62\uff0c\u7136\u540e\u5c06\u5e27\u7f13\u51b2\u7684\u989c\u8272\u7f13\u51b2\u4f5c\u4e3a\u56db\u8fb9\u5f62\u7684\u7eb9\u7406\u3002 // \u7b2c\u4e00\u5904\u7406\u9636\u6bb5: \u7ed8\u5236\u5230FBO glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // \u6211\u4eec\u73b0\u5728\u4e0d\u4f7f\u7528\u6a21\u677f\u7f13\u51b2 glEnable(GL_DEPTH_TEST); DrawScene(); // \u7ed8\u5236\u539f\u59cb 3D \u573a\u666f // Load VAO, bind Textures, uniform data, call glDrawArrays or glDrawElements // \u7b2c\u4e8c\u5904\u7406\u9636\u6bb5: \u7ed8\u5236\u5230\u5c4f\u5e55 glBindFramebuffer(GL_FRAMEBUFFER, 0); // \u8fd4\u56de\u9ed8\u8ba4 glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); screenShader.use(); // \u4f7f\u7528\u53e6\u4e00\u5957 shader glBindVertexArray(quadVAO); // \u7ed8\u5236\u4e00\u4e2a\u56db\u8fb9\u5f62 glDisable(GL_DEPTH_TEST); glBindTexture(GL_TEXTURE_2D, textureColorbuffer); // \u5c06 Color Buffer \u4f5c\u4e3a\u7eb9\u7406\u7ed8\u5236\u5230\u56db\u8fb9\u5f62\u4e0a glDrawArrays(GL_TRIANGLES, 0, 6); \u5982\u679c screenShader \u4e0d\u505a\u7279\u6b8a\u5904\u7406, \u6b64\u65f6\u753b\u9762\u4f1a\u548c DrawScene \u7ed8\u5236\u7684\u539f\u59cb3D\u573a\u666f\u4e00\u81f4. \u6b64\u65f6\u7ed8\u5236\u7684\u56db\u8fb9\u5f62\u7c7b\u4f3c\u4e00\u4e2a\u663e\u793a\u5c4f\u5e55, \u5229\u7528\u8d34\u56fe\u663e\u793a\u539f\u59cb\u573a\u666f. \u4f46\u5982\u679c\u5bf9 screenShader \u4e2d\u7eb9\u7406\u7684color\u8fdb\u884c\u4fee\u6539, \u5c31\u53ef\u7528\u5b9e\u73b0\u6ee4\u955c\u6548\u679c. void main() { // \u53cd\u767d\u7279\u6548 FragColor = vec4(vec3(1.0 - texture(screenTexture, TexCoords)), 1.0); } \u753b\u9762\u6548\u679c\u548c\u66f4\u591a\u7279\u6548\u5904\u7406, \u53c2\u89c1 LearnOpenGL (English version: LearnOpenGL ) \u79bb\u5c4fMSAA \u79bb\u5c4fMSAA \u5728\u9ed8\u8ba4\u5e27\u7f13\u51b2\u4e2d\u542f\u7528MASS, \u53ea\u9700\u8981 glEnable(GL_MULTISAMPLE); \u542f\u7528\u5373\u53ef. \u4f46\u5bf9\u4e8e\u79bb\u5c4f\u6e32\u67d3, \u9700\u8981\u624b\u52a8\u521b\u5efa\u591a\u91cd\u91c7\u6837\u7684\u9644\u7740. Texture: \u521b\u5efaMS Texture: \u4f7f\u7528 glTexImage2DMultisample \u6765\u66ff\u4ee3 glTexImage2D glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex); glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE); glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0); \u9644\u52a0\u5230\u5e27\u7f13\u51b2: \u4f7f\u7528 glFramebufferTexture2D \u5c06\u591a\u91cd\u91c7\u6837\u7eb9\u7406\u4e0a\uff0c\u4f46\u8fd9\u91cc\u7eb9\u7406\u7c7b\u578b\u4f7f\u7528\u7684\u662f GL_TEXTURE_2D_MULTISAMPLE \u3002 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0); Renderbuffer : \u521b\u5efa\u8fc7\u7a0b\u4e0d\u53d8 \u9644\u52a0\u5230\u5e27\u7f13\u51b2: \u5c06 glRenderbufferStorage \u7684\u8c03\u7528\u6539\u4e3a glRenderbufferStorageMultisample \u5c31\u53ef\u4ee5\u4e86 glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, width, height); \u7b2c\u4e8c\u53c2\u6570 4 \u4e3a\u91c7\u6837\u6b21\u6570 \u7ed8\u5236: void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); \u5c06\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u7684\u50cf\u7d20\u503c, \u4ece\u4e00\u4e2a\u5e27\u7f13\u51b2\u590d\u5236\u5230\u53e6\u4e00\u4e2a\u5e27\u7f13\u51b2. \u901a\u8fc7 glBlitFramebuffer \u5c06\u591a\u91cd\u91c7\u6837\u7684\u5e27\u7f13\u51b2, \u590d\u5236\u5230\u4e00\u4e2a\u4e2d\u4ecb\u5e27\u7f13\u51b2\u7684\u989c\u8272\u9644\u7740\u7684\u7eb9\u7406, \u5b9e\u73b0\u591a\u91cd\u91c7\u6837. glBindFramebuffer(multisampledFBO); ClearFrameBuffer(); DrawScene(); // \u5c06\u591a\u91cd\u91c7\u6837\u7f13\u51b2\u8fd8\u539f\u5230\u4e2d\u4ecbFBO\u4e0a glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO); glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO); glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST); // \u73b0\u5728\u573a\u666f\u662f\u4e00\u4e2a2D\u7eb9\u7406\u7f13\u51b2\uff0c\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u56fe\u50cf\u7528\u6765\u540e\u671f\u5904\u7406 glBindFramebuffer(GL_FRAMEBUFFER, 0); ClearFramebuffer(); glBindTexture(GL_TEXTURE_2D, screenTexture); DrawPostProcessingQuad(); Framebuffer \u76f8\u5173 API \u6c47\u603b API ES Ver. Notes void glGenFramebuffers ( sizei n, uint *framebuffers ); 2 void glBindFramebuffer ( enum target, uint framebuffer ); 2 void glGenRenderbuffers ( sizei n, uint *renderbuffers ); 2 void glBindRenderbuffer ( enum target, uint renderbuffer ); 2 void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); 2 \u521b\u5efa\u4e00\u4e2a Renderbuffer internalformat : \u6307\u5b9a\u7f13\u51b2\u683c\u5f0f: depth \u548c stencil GL_DEPTH24_STENCIL8; GL_DEPTH32F_STENCIL8 GL_DEPTH_COMPONENT16 GL_DEPTH_COMPONENT24 GL_DEPTH_COMPONENT32F GL_STENCIL_INDEX8 void glRenderbufferStorageMultisample ( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); 3.0 \u521b\u5efa\u4e00\u4e2a\u591a\u91cd\u91c7\u6837 Renderbuffer, \u4e0eglRenderbufferStorage\u7684\u533a\u522b\u4ec5\u4e3a\u540e\u8005samples=0 GLenum glCheckFramebufferStatus (GLenum target); \u68c0\u67e5fbo\u5b8c\u6574\u6027 void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); \u5c06\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u7684\u50cf\u7d20\u503c, \u4ece\u4e00\u4e2afb\u590d\u5236\u5230\u53e6\u4e00\u4e2afb. \u5e94\u7528\u4e3e\u4f8b: 1. \u590d\u5236\u591a\u4e2a\u7eb9\u7406\u5230\u5c4f\u5e55 2. \u5c06\u591a\u91cd\u91c7\u6837\u6e32\u67d3\u89e3\u6790\u4e3a\u4e00\u4e2a\u7eb9\u7406 \u7ed1\u5b9a void glFramebufferRenderbuffer ( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); 2 void glFramebufferTexture ( GLenum target, GLenum attachment, GLuint texture, GLint level); 3.2 void glFramebufferTexture2D ( enum target, enum attachment, enum textarget, uint texture, int level ); 2.0 void glFramebufferTextureLayer ( enum target, enum attachment, uint texture, int level, int layer ); 3.0 \u7ed1\u5b9a 3D Texture \u65e0\u6548\u5316/\u5220\u9664 void glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments); 3.0 \u901a\u77e5\u9a71\u52a8\u4e0d\u518d\u9700\u8981fb\u5185\u5bb9. \u4f7f\u9a71\u52a8\u53ef\u7528\u8fdb\u884c\u4f18\u5316: \u5982\u8df3\u8fc7TBR\u67b6\u6784\u4e2d\u4e0d\u5fc5\u8981\u7684\u56fe\u5757\u5185\u5bb9\u6062\u590d \u8df3\u8fc7\u5b9e\u73b0\u4e2d\u4e3a\u6539\u8fdb\u6027\u80fd\u800c\u505a\u7684\u7f13\u5b58\u5237\u65b0 void glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height); 3.0 void glDeleteRenderbuffers (GLsizei n, const GLuint *renderbuffers); 2 void glDeleteFramebuffers (GLsizei n, const GLuint *framebuffers); 2 \u5176\u4ed6 void glFramebufferParameteri (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params); boolean IsRenderbuffer ( uint renderbuffer ); boolean IsFramebuffer ( uint framebuffer ); \u5176\u4ed6\u9488\u5bf9\u8bfb\u5e27\u7f13\u51b2\u7684\u547d\u4ee4: ReadPixels, CopyTexImage , and CopyTexSubImage , gl2 void glBindFramebuffer (GLenum target, GLuint framebuffer); GLenum glCheckFramebufferStatus (GLenum target); void glDeleteFramebuffers (GLsizei n, const GLuint framebuffers); void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); void glFramebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); void glGenFramebuffers (GLsizei n, GLuint framebuffers); void glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, GLint *params); GLboolean glIsFramebuffer (GLuint framebuffer); void glBindRenderbuffer (GLenum target, GLuint renderbuffer); void glDeleteRenderbuffers (GLsizei n, const GLuint renderbuffers); void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); void glGenRenderbuffers (GLsizei n, GLuint renderbuffers); void glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint *params); GLboolean glIsRenderbuffer (GLuint renderbuffer); void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); gl3 void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); void glFramebufferTextureLayer (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); void glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum attachments); void glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum attachments, GLint x, GLint y, GLsizei width, GLsizei height); void glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); gl31 void glFramebufferParameteri (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params); gl32 void glFramebufferTexture (GLenum target, GLenum attachment, GLuint texture, GLint level); EXT glext.h void glResolveMultisampleFramebufferAPPLE (void); void glDiscardFramebufferEXT (GLenum target, GLsizei numAttachments, const GLenum attachments); void glFramebufferTexture2DMultisampleEXT (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glFramebufferTexture2DMultisampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glExtGetFramebuffersQCOM (GLuint framebuffers, GLint maxFramebuffers, GLint *numFramebuffers); Renderbuffer void glEGLImageTargetRenderbufferStorageOES (GLenum target, GLeglImageOES image); void glRenderbufferStorageMultisampleAPPLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleEXT (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleIMG (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glExtGetRenderbuffersQCOM (GLuint renderbuffers, GLint maxRenderbuffers, GLint numRenderbuffers); gl2Ext void glFramebufferTextureOES (GLenum target, GLenum attachment, GLuint texture, GLint level); void glFramebufferTexture3DOES (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); void glResolveMultisampleFramebufferAPPLE (void); void glDiscardFramebufferEXT (GLenum target, GLsizei numAttachments, const GLenum attachments); void glFramebufferTextureEXT (GLenum target, GLenum attachment, GLuint texture, GLint level); void glFramebufferTexture2DMultisampleEXT (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glFramebufferFetchBarrierEXT (void); void glFramebufferPixelLocalStorageSizeEXT (GLuint target, GLsizei size); GLsizei glGetFramebufferPixelLocalStorageSizeEXT (GLuint target); void glFramebufferTexture2DDownsampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint xscale, GLint yscale); void glFramebufferTextureLayerDownsampleIMG (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale); void glFramebufferTexture2DMultisampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glApplyFramebufferAttachmentCMAAINTEL (void); void glFramebufferParameteriMESA (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameterivMESA (GLenum target, GLenum pname, GLint params); void glBlitFramebufferNV (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); void glFramebufferSampleLocationsfvNV (GLenum target, GLuint start, GLsizei count, const GLfloat v); void glNamedFramebufferSampleLocationsfvNV (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat v); void glFramebufferTextureMultiviewOVR (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews); void glFramebufferTextureMultisampleMultiviewOVR (GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews); void glFramebufferFoveationConfigQCOM (GLuint framebuffer, GLuint numLayers, GLuint focalPointsPerLayer, GLuint requestedFeatures, GLuint *providedFeatures); void glFramebufferFoveationParametersQCOM (GLuint framebuffer, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea); void glFramebufferFetchBarrierQCOM (void); Renderbuffer void glEGLImageTargetRenderbufferStorageOES (GLenum target, GLeglImageOES image); void glRenderbufferStorageMultisampleAdvancedAMD (GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height); void glNamedRenderbufferStorageMultisampleAdvancedAMD (GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleANGLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleAPPLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleEXT (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleIMG (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleNV (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glExtGetRenderbuffersQCOM (GLuint renderbuffers, GLint maxRenderbuffers, GLint numRenderbuffers); gl2ext_angle.h void glGetRenderbufferParameterivRobustANGLE (GLenum target, GLenum pname, GLsizei bufSize, GLsizei length, GLint params); void glGetRenderbufferImageANGLE (GLenum target, GLenum format, GLenum type, void *pixels); gl2Ext_ANGLE void glGetFramebufferAttachmentParameterivRobustANGLE (GLenum target, GLenum attachment, GLenum pname, GLsizei bufSize, GLsizei length, GLint params); void glGetFramebufferParameterivRobustANGLE (GLenum target, GLenum pname, GLsizei bufSize, GLsizei length, GLint params); Summary Framebuffer \u5206\u9ed8\u8ba4 fb \u548c \u7528\u6237\u5b9a\u4e49 fb, \u540e\u8005\u88ab\u79f0\u4e3a Framebuffer Objects (FBOs) OpenGL \u4f1a\u5728 Context\u4e2d\u521b\u5efa Default Framebuffer \u7528\u6765\u8868\u793a\u4e00\u4e2a \u7a97\u53e3 \u6216 \u663e\u793a\u8bbe\u5907. \u4e0d\u80fd\u4fee\u6539\u5176 attachments FBOs \u5173\u8054 Textures \u6216 Renderbuffers, \u4e0d\u4f1a\u76f4\u63a5\u53ef\u89c1 FBOs\u4e2d\u7f13\u5b58(Buffers)\u53c8\u79f0\u4f5c \"attachment points\" Bind points void glBindFramebuffer(GL_FRAMEBUFFER, mFramebuffer) bind framebuffers to the context \u4e24\u79cd\u7c7b\u578b: GL_DRAW_FRAMEBUFFER \u548c GL_READ_FRAMEBUFFER , \u800c GL_FRAMEBUFFER \u8868\u793a\u4e8c\u8005\u90fd\u6709. Colorspace: \u4e24\u79cd: linear RGB \u548c sRGB \u542f\u7528 / \u7981\u7528 GL_FRAMEBUFFER_SRGB \u6765\u63a7\u5236\u662f\u5426\u8fdb\u884c\u8f6c\u6362 ### Blending blending \u4f5c\u7528\u4e8e\u76ee\u6807\u56fe\u50cf\u7684 sRGB colorspace, \u56e0\u6b64\u82e5 GL_FRAMEBUFFER_SRGB \u672a\u542f\u7528, \u65e0\u6cd5\u6b63\u5e38\u5de5\u4f5c. Read void glReadBuffer (GLenum mode ); Draw void glDrawBuffersEXT(attachmentCount, drawBuffers[GL_COLOR_ATTACHMENT0_EXT, ...]); attachmentCount can only be as large as GL_MAX_DRAW_BUFFERS ( Windows ANGLE\u4e0a\u7ea6\u4e3a 34852) Draw \u64cd\u4f5c\u4f1a\u5bf9 fb \u8bbe\u7f6e\u4e00\u79cd state, \u56e0\u6b64\u53ef\u7528\u53ea draw \u4e00\u6b21. Framebuffer Jump to navigation Jump to search A Framebuffer is a collection of buffers that can be used as the destination for rendering. OpenGL has two kinds of framebuffers: the Default Framebuffer , which is provided by the OpenGL Context ; and user-created framebuffers called Framebuffer Objects (FBOs). The buffers for default framebuffers are part of the context and usually represent a window or display device. The buffers for FBOs reference images from either Textures or Renderbuffers ; they are never directly visible. Note that the term \"buffer\" here refers to a specific location in the framebuffer. An image may or may not be associated with a particular buffer in a framebuffer. Buffers in FBOs are also called \"attachment points\"; they're the locations where images can be attached. Default framebuffers cannot change their buffer attachments, but a particular default framebuffer may not have images associated with certain buffers. For example the GL_BACK_RIGHT buffer will only have an image if the default framebuffer is double-buffered and uses stereoscopic 3D. The default framebuffer's buffer names are separate from framebuffer object buffer names . Bind points glBindFramebuffer is used to bind framebuffers to the context. They can be bound to one of two targets: GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER. The draw framebuffer is used as the destination for rendering, clearing , and other writing operations. The read framebuffer is used as the source for reading operations. Binding to the GL_FRAMEBUFFER target is equivalent to binding that framebuffer to both GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER. Note that most other uses of GL_FRAMEBUFFER mean the draw framebuffer; this is the case when it means both. Colorspace Color Image Formats can be in a linear or sRGB colorspace . Normally, sRGB images perform color correction, such that texture reads from them will always convert them to linear RGB. However, when writing values from a Fragment Shader to the image, a question arises: in what colorspace are the values written by the shader? When the output buffer is linear RGB, the answer is assumed to be linear. But if we are writing to an sRGB image, it is entirely reasonable for a shader to want to write linear values which will be automatically converted to sRGB for storage. However, at other times, it is entirely reasonable for a shader to want to write sRGB values directly, and therefore want to store the written provided without any conversion. The fragment shader is not given the power to control this, as the controls for it depend partially on state external to the fragment shader (namely, the colorspace of the image buffer being written to). Instead, this is made a global state value. When GL_FRAMEBUFFER_SRGB is disabled , the system assumes that the color written by the fragment shader is in whatever colorspace the image it is being written to is. Therefore, no colorspace correction is performed. If GL_FRAMEBUFFER_SRGB is enabled however, then if the destination image is in the sRGB colorspace (as queried through glGetFramebufferAttachmentParameter(GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING) ), then it will assume the shader's output is in the linear RGB colorspace. It will therefore convert the output from linear RGB to sRGB. Note that Logical Operations are disabled for any sRGB buffer when GL_FRAMEBUFFER_SRGB is enabled. Blending Blending interacts with sRGB colorspace in destination images. The sRGB colorspace is non-linear, and thus linearly interpolating between non-linear colorspaces generally leads to colors that are not accurate. The correct operation is to linearize the destination color, do the blending in linear RGB space, and then convert back to sRGB. If GL_FRAMEBUFFER_SRGB is enabled , then the appropriate correction will be done for sRGB destination images. That is, if a particular destination image is sRGB, the destination value will be converted to linear RGB, blended with the linear source value via the current blend functions, and the result will be converted back to sRGB for writing to the destination image. If GL_FRAMEBUFFER_SRGB is not enabled, then it is assumed that the user knows what they are doing. Therefore, blending against an sRGB image when GL_FRAMEBUFFER_SRGB is not enabled will not perform any of the above correction. This is generally not a good idea, even if you are writing sRGB color values from the Fragment Shader . Read color buffer Certain OpenGL operations can read pixel data from the color buffer. These operations are: Direct pixel reads . Framebuffer blits . Copies from the framebuffer to textures , which could also be during mutable storage specification . All of these operations read from the framebuffer bound to GL_READ_FRAMEBUFFER. However, because framebuffers often have multiple color images that could be read from, there is a selector in the framebuffer object that defines which color buffer these operations read from. The framebuffer's read buffer is specified by: void glReadBuffer (GLenum mode ); Warning: This sets the read buffer for the framebuffer currently bound to GL_READ_FRAMEBUFFER. So make sure that the framebuffer you want is bound to that buffer. The read buffer is part of the framebuffer's state, so each framebuffer will remember its previously set read buffer. If the GL_READ_FRAMEBUFFER is the default framebuffer, then mode must be the name of a color buffer name . It may be one of the multiple buffer aliases , which degrades as specified. If the read framebuffer is an FBO, then mode must be GL_COLOR_ATTACHMENT i , for one of the legal values of i . mode may also be GL_NONE, which indicates that no reading can be performed from color buffers on this framebuffer. Any attempt to perform read operations will fail with an error (GL_INVALID_OPERATION). Draw color buffers Much as with the read buffer, framebuffers have a set of draw buffers where writing operations write to. Unlike the read buffer, there are multiple draw buffers, which allow writing operations to write values to different buffers in the framebuffer at the same time. Fragment shader color outputs allow a fragment shader to define fragment color outputs, for example. The framebuffer therefore has a table of draw buffers, which are indexed on the half-open range [0, GL_MAX_DRAW_BUFFERS). The framebuffer's table maps from these indices to named color buffers in the framebuffer. To set this mapping table (on the framebuffer bound to GL_DRAW_FRAMEBUFFER), use this function: void glDrawBuffers( GLsizei n, const GLenum *bufs ); This function sets the first n entries of the mapping table. The indices of the enumerators correspond to the output fragment colors from the fragment shader. Thus, n can only be as large as GL_MAX_DRAW_BUFFERS. The entries in the bufs array are enumerators referring to buffer names in the framebuffer. All entries after n are set to GL_NONE. The values in bufs must name specific color buffers in the framebuffer. For the default framebuffer, buffer names cannot be the one of the multiple buffer aliases ; you must use GL_BACK_LEFT rather than GL_BACK. Framebuffer Objects use GL_COLOR_ATTACHMENT i buffer names. An entry in the list can be GL_NONE, which means that the output (if the shader outputs a value for it at all) is discarded. If you are only setting up one draw buffer, you may use glDrawBuffer . It takes one enumeration value and sets the fragment color 0 to draw to that buffer. All other draw buffer indices are set to GL_NONE. For the default framebuffer, the multiple buffer aliases can be used (though it is not advised to do so). They will cause drawing operations to write to all of the specified buffers. The state set by glDrawBuffers is part of the state of the framebuffer. So you can generally set this up once and leave it set. Buffer clearing Images in a framebuffer may be cleared to a particular value. Clearing is affected by the following state: The Write Mask . Only unmasked components will be changed by a clear call. The Pixel Ownership Test , which matters only for the Default Framebuffer . Pixels that are not owned will have undefined values. The Scissor Test . If the scissor test is enabled, then the clear region is bounded by the scissor rectangle. The Rasterizer Discard state. If discarding is enabled, all clearing commands are ignored. Framebuffer image clearing commands are Rendering Commands . Therefore, they are affected by Conditional Rendering . Clearing can be done in one of two ways. The old way can clear multiple buffers in a single call: void glClear (GLbitfield mask ); This will clear the current GL_DRAW_FRAMEBUFFER. The mask field is a bitmask that defines which kinds of buffers to clear. It can be a combination of GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT. When GL_COLOR_BUFFER_BIT is cleared, all of the active draw buffers are cleared. The values that the given buffers are cleared to are set beforehand via OpenGL state functions: void glClearColor (GLfloat red , GLfloat green , GLfloat blue , GLfloat alpha ); void glClearDepth (GLdouble depth ); void glClearStencil (GLint s ); These functions set the values that will be used to clear the appropriate buffers. Note that you must call these before calling glClear . depth will be clamped to the range [0, 1]. s , the stencil index, will be clamped to the valid integer range for the stencil buffer's image format. Note that glClearColor takes floating-point values. Yet it is perfectly legal to use integer Image Formats for images in framebuffers. Attempting to clear integer buffers with floating-point data will not work. Instead, you must clear each buffer individually with this suite of functions: void glClearBufferiv (GLenum buffer , GLint drawBuffer , const GLint * value ); void glClearBufferuiv (GLenum buffer , GLint drawBuffer , const GLuint * value ); void glClearBufferfv (GLenum buffer , GLint drawBuffer , const GLfloat * value ); void glClearBufferfi (GLenum buffer , GLint drawBuffer , GLfloat depth , GLint stencil ); This will clear a buffer in the current GL_DRAW_FRAMEBUFFER. buffer is either GL_COLOR, GL_DEPTH, GL_DEPTH_STENCIL, or GL_STENCIL. When clearing the GL_DEPTH buffer, you must use glClearBufferfv , and the depth value (a single float) will be clamped to [0, 1]. When using GL_STENCIL, you must use glClearBufferiv , and the stencil value (a single integer) will be clamped to the range of the stencil image format's precision. When using GL_DEPTH_STENCIL, you must use glClearBufferfi , and depth and stencil will each be clamped as appropriate for their value. The drawbuffer specifies the draw buffer index for the buffer to clear. This is only relevant if the buffer is GL_COLOR; in all other cases it must be 0. Note that this is the draw buffer index , not one of the GL_COLOR_ATTACHMENT i values. So 0 represents whatever the first buffer named by glDrawBuffers is. Note: Confusingly, buffer may also be one of the default framebuffer's multiple buffer aliases . In this case, drawbuffer specifies an additional draw buffer to clear, and all of the buffers will be cleared. You should probably avoid using them. Warning: Buffer clearing, of all forms , will respect the current state of the Scissor Test . If you wish to clear the entire buffer, you must make sure the scissor test is disabled. Buffer reading Pixel data can be read from a framebuffer and stored into CPU memory (or a buffer object ). The framebuffer being read from is the framebuffer bound to GL_READ_FRAMEBUFFER; remember that binding to GL_FRAMEBUFFER binds to both the read and the draw. To begin reading pixels, use this command: void glReadPixels (GLint x , GLint y , GLsizei width , GLsizei height , GLenum format , GLenum type , GLvoid * data ) This performs a Pixel Transfer read operation; as such, the destination data can be an offset into a Pixel Buffer Object if you so desire. Framebuffers have many buffers to read from. Which buffer is read from depends in part on the format parameter. If format is GL_DEPTH_COMPONENT, then the depth buffer is read from. If it is GL_STENCIL_INDEX, then the stencil buffer is read from. If it is GL_DEPTH_STENCIL then both the depth and stencil buffers are read from. If format is a color format, then the current read color buffer is used. If the current read buffer is GL_NONE, then a GL_INVALID_OPERATION error will occur. Read color clamping The color values read via glReadPixels may be clamped to the [0, 1] range. This is controlled via this function: void glClampColor (GLenum target , GLenum clamp ); The target must be GL_CLAMP_READ_COLOR. The clamp can be set to one of the following: GL_TRUE: Clamping is always on, no matter what the format or type parameters of the read pixels call. GL_FALSE: Clamping is always off, no matter what the format or type parameters of the read pixels call. GL_FIXED_ONLY: Clamping is only on if the type of the image being read is a normalized signed or unsigned value. Note that the clamping behavior is not framebuffer object state. It will not be stored with the current framebuffer. Invalidation The contents of a framebuffer can be invalidated. This means that the application is no longer interested in whatever pixel data happens to be stored in any images in that part of the framebuffer. Invalidation is useful, as it allows the implementation to allocate new memory if asynchronous commands are working with the previously invalidated framebuffer images. In particular, invalidation after asynchronous pixel reads are quite useful. To invalidate the framebuffer as a whole, the following function is used: glInvalidateFramebuffer (GLenum target , GLsizei numAttachments , const GLenum * attachments ) The framebuffer bound to target will be invalidated. The specific images in the framebuffer to be invalidated are specified by the array attachments , which must have numAttachments entries in it. The entries in the array must be names of specific images in the framebuffer. For user-created Framebuffer Objects, these must be the names of one of the available attachment points. For the default framebuffer, the names can be one of the images in the default framebuffer ; none of the color buffer's aliases work here. The default framebuffer can also use the names GL_COLOR (which means GL_BACK_LEFT if double-buffered and GL_FRONT_LEFT if single-bufferred. Instead of invalidating whole sets of images in the framebuffer, a portion of the framebuffer can be invalidated instead: glInvalidateSubFramebuffer (GLenum target , GLsizei numAttachments , const GLenum * attachments , GLint x , GLint y , GLint width , GLint height ) The x , y , width , and height parameters specify a rectangular region of the specified images to invalidate. After invalidation, the contents of pixels stored in those areas are undefined. You can clear them to a set value after invalidation. Blitting Framebuffers can be bound to two separate targets with glBindFramebuffer : GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER. Binding to GL_FRAMEBUFFER is equivalent to binding the framebuffer to both. The reason for the separation of these targets is to allow data in one framebuffer to be blitted to another framebuffer. A blit operation is a special form of copy operation; it copies a rectangular area of pixels from one framebuffer to another. This function also has some very specific properties with regard to multisampling . Framebuffer blitting commands are considered Rendering Commands . Therefore, they are affected by Conditional Rendering . However, they do not invoke most parts of the Rendering Pipeline . Blits are affected by the Scissor Test (they always use viewport index 0) as well as the Pixel Ownership Test , but are not affected by the Write Mask , Depth Test or any other parts of the rendering pipeline. You bind the source framebuffer to GL_READ_FRAMEBUFFER, then bind the destination framebuffer to GL_DRAW_FRAMEBUFFER. The read framebuffer is the source of the blit, and the draw framebuffer is the destination. The read and draw framebuffers can be the same. After binding the framebuffers, you call this function: void glBlitFramebuffer( GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); The pixels in the rectangular area specified by the src values are copied to the rectangular area specified by the dst values. The mask parameter is a bitfield that specifies which kinds of buffers you want copied: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT, or some combination. The filter parameter specifies how you want filtering performed if the two rectangles are not the same size. One thing to keep in mind is this: when using GL_COLOR_BUFFER_BIT, the only colors read will come from the read color buffer in the read FBO, specified by glReadBuffer . The colors written will only go to the draw color buffers in the write FBO, specified by glDrawBuffers . If multiple draw buffers are specified, then multiple color buffers are updated with the same data. The depth and stencil buffers of the source framebuffers are blitted to the depth and stencil buffers of the destination if the mask specifies them. Note that it is perfectly valid to blit from or to the Default Framebuffer . If one (or both) of the framebuffers is a layered framebuffer (blitting fails if the framebuffers are incomplete. So they will be either all layered or all not layered), then blitting happens rather oddly. Only layer 0 will be read and only layer 0 will be written . This is true even if both the read and draw FBOs are layered and have the same number of layers. If you want to blit other layers, you will have to bind those layers to some other FBO and blit from/to that new FBO. Format Considerations Blitting is not the same as performing a pixel transfer or a texture copy . The conversion between source and destination format is more limited. Blitting depth and stencil buffers works as expected: values are converted from one bitdepth to the other as needed. Conversion between color formats is different. A blit operation can only convert between formats within 3 groups. Signed integral and unsigned integral formats make up two groups, with all normalized and floating-point formats making up the third. Thus, it is legal to blit from an GL_RGB8 buffer to a GL_RGB32F and vice versa. But it is not legal to blit a GL_RGB8 from or to a GL_RGBI8 format image. The data during blitting is converted according to simple rules. Blitting from a floating-point format to a normalized integer format will cause clamping, either to [0, 1] for unsigned normalized or [-1, 1] for signed normalized. Multisampling Considerations Multisampling is supported with the Default Framebuffer (through WGL/GLX_multisample) and/or Framebuffer Objects (through multisampled renderbuffers or textures , where supported). As explained in the article on Multisampling , a multisampled buffer must be resolved into a single sample before it can be displayed. When the default framebuffer uses multisampling, this resolving operation is automatic, occurring during framebuffer swapping (though reading from the framebuffer can cause it to happen anyway). Each framebuffer has a specific number of samples; for Framebuffer Objects , they cannot be framebuffer-complete if all of the attached images do not have the same number of samples. A sample count of zero represents a framebuffer that is not multisampled. If you perform a blit operation and and at least one of the framebuffers is multisampled, then the source and destination sizes must be the same. That is, you cannot do multisampled blits and rescaling at the same time. If you blit between two framebuffers with the same number of samples, the copy is done directly; the destination buffer gets the same information the source had. It is an error to blit between framebuffers with different numbers of samples, unless one of the framebuffers has zero samples. Blitting from a non-multisampled framebuffer to a multisampled framebuffer causes all of samples in a pixel of the draw framebuffer to get the same value from the corresponding pixel in the read framebuffer. Blitting from a multisampled framebuffer to a non-multisampled framebuffer performs a multisample resolve operation, computing the value of a draw framebuffer's pixel from all of the samples in the corresponding pixel of the read framebuffer. This explicit resolve operation is very useful when wanting to display multisampled buffers. As with all multisample behavior, none of this works at all unless glEnable(GL_MULTISAMPLE) is in effect (which is the default).","title":"OpenGL(ES)"},{"location":"GLES/Framebuffer%20Object/#gles-framebuffers","text":"learnopengl \u66f4\u591a\u7528\u4f8b: \u6cdb\u5149 \u591a\u6e32\u67d3\u76ee\u6807(Multiple Render Targets) \u4e0e \u5ef6\u8fdf\u7740\u8272\u6cd5","title":"GLES Framebuffers"},{"location":"GLES/Framebuffer%20Object/#_1","text":"\u901a\u5e38\u6211\u4eec\u7684\u64cd\u4f5c\u90fd\u662f\u5728 \u9ed8\u8ba4 \u5e27\u7f13\u51b2 (Default Framebuffer ) \u7684\u6e32\u67d3\u7f13\u51b2\u4e0a\u8fdb\u884c\u7684\u3002\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u662f\u5728\u4f60\u521b\u5efa\u7a97\u53e3\u7684\u65f6\u5019\u751f\u6210\u548c\u914d\u7f6e\u7684\uff08EGL\uff09\u3002 \u5728GL\u4e2d\u4f1a\u4f7f\u7528\u51e0\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u5c4f\u5e55\u7f13\u51b2\uff1a\u7528\u4e8e\u5199\u5165\u989c\u8272\u503c\u7684 \u989c\u8272\u7f13\u51b2 \uff0c\u7528\u4e8e\u5199\u5165\u6df1\u5ea6\u4fe1\u606f\u7684 \u6df1\u5ea6\u7f13\u51b2 \uff0c\u4ee5\u53ca\u5141\u8bb8\u6211\u4eec\u57fa\u4e8e\u4e00\u4e9b\u6761\u4ef6\u4e22\u5f03\u6307\u5b9a\u7247\u6bb5\u7684 \u6a21\u677f\u7f13\u51b2 \u3002\u628a\u8fd9\u51e0\u79cd\u7f13\u51b2\u7ed3\u5408\u8d77\u6765\u53eb\u505a\u5e27\u7f13\u51b2(Framebuffer)\u3002 \u800c\u4f7f\u7528 \u5e27\u7f13\u51b2\u5bf9\u8c61 (Framebuffer Object) \u5141\u8bb8\u7528\u6237 \u81ea\u5b9a\u4e49\u5e27\u7f13\u51b2 \uff0cFramebuffer \u5b9e\u9645\u662f\u4e00\u4e2a\u53ef\u6dfb\u52a0 \u7f13\u51b2\u7684\u5bb9\u5668 . \u7528\u6237\u53ef\u4ee5\u4e3a\u5176\u6dfb\u52a0 \u7eb9\u7406 (Textures ) \u6216 \u6e32\u67d3\u7f13\u51b2\u533a \u5bf9\u8c61\uff08Renderbuffer), \u6765\u5b9a\u4e49\u81ea\u5df1\u7684\u989c\u8272\u7f13\u51b2\uff0c\u6df1\u5ea6\u7f13\u51b2, \u548c\u6a21\u677f\u7f13\u51b2\u3002","title":"\u5b9a\u4e49"},{"location":"GLES/Framebuffer%20Object/#_2","text":"\u6e32\u67d3\u5230\u4e00\u4e2a\u975e\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u88ab\u53eb\u505a \u79bb\u5c4f\u6e32\u67d3 (Off-screen Rendering) \u6216 \u6e32\u67d3\u5230\u7eb9\u7406 (Render to Texture)\u3002 \u901a\u8fc7\u81ea\u5b9a\u4e49\u5e27\u7f13\u51b2\u53ef\u4ee5\u5c06\u4f60\u7684\u573a\u666f\u6e32\u67d3\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u4e2d, \u53ef\u4ee5\u4f7f\u6211\u4eec\u80fd\u591f\u5728\u5f53\u524d\u573a\u666f\u4e2d\u521b\u5efa \u955c\u5b50, \u5012\u5f71 \u8fd9\u6837\u7684\u6548\u679c. \u8fd8\u6709\u5f88\u591a\u5e38\u89c1\u7279\u6548\u9700\u8981\u7528\u5230\u5e27\u7f13\u51b2, \u4f8b\u5982: \u9634\u5f71\u8d34\u56fe, \u52a8\u6001\u53cd\u5c04\u548c\u73af\u5883\u8d34\u56fe, \u591a\u9053\u666f\u6df1\u6280\u672f, \u52a8\u6001\u6a21\u7cca, \u548c\u540e\u671f\u5904\u7406\u7279\u6548\u7b49.","title":"\u5e94\u7528"},{"location":"GLES/Framebuffer%20Object/#_3","text":"\u9ed8\u8ba4\u5e27\u7f13\u51b2 Default Framebuffers \u5728\u8fdb\u884cGLES\u6307\u4ee4\u64cd\u4f5c\u524d, \u9700\u8981\u521b\u5efa\u4e00\u4e2a Context \u548c \u7ed8\u56fe\u8868\u9762 (\u9ed8\u8ba4 Framebuffer), \u8fd9\u901a\u5e38\u7531\u539f\u751f\u7a97\u53e3\u7cfb\u7edf\u901a\u8fc7 EGL \u7b49\u5b8c\u6210. \u521b\u5efa EGL \u7ed8\u5236\u8868\u9762\u7684\u8c03\u7528\u65f6, \u4ee5\u50cf\u7d20\u5f62\u5f0f\u6307\u5b9a \u5bbd\u5ea6,\u9ad8\u5ea6, \u662f\u5426\u4f7f\u7528 \u989c\u8272\u7f13\u51b2, \u6df1\u5ea6\u7f13\u51b2, \u6a21\u677f\u7f13\u51b2, \u53ca\u8fd9\u4e9b\u7f13\u51b2\u533a\u7684\u4f4d\u6df1. \u4e0d\u80fd\u5bf9\u5176\u8fdb\u884c\u4fee\u6539\u6216\u67e5\u8be2\u72b6\u6001\u64cd\u4f5c glViewport \u63a7\u5236\u5e27\u7f13\u51b2\u7684\u5927\u5c0f, \u4ee5\u53ca\u63a7\u5236\u9634\u5f71\u6df1\u5ea6\u8d34\u56fe\u5927\u5c0f\u7b49\u7b49 \u5e27\u7f13\u51b2\u5bf9\u8c61 Framebuffers Objects (FBOs) \u9644\u7740 Attachment FBO \u4ec5\u88ab\u89c6\u4e3a\u7f13\u5b58\u7684\u5bb9\u5668, \u56e0\u6b64\u4f7f\u7528 FBO \u4f5c\u4e3a\u6e32\u67d3\u76ee\u6807\u65f6\uff0c\u9996\u5148\u9700\u8981\u4e3a FBO \u7684\u9644\u7740\u8fde\u63a5\u5bf9\u8c61\uff0c \u9644\u7740\u662f\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\uff0c\u5b83\u80fd\u591f\u4f5c\u4e3a\u5e27\u7f13\u51b2\u7684\u4e00\u4e2a\u7f13\u51b2\uff0c\u53ef\u4ee5\u5c06\u5b83\u60f3\u8c61\u4e3a\u4e00\u4e2a\u56fe\u50cf\u3002 \u521b\u5efa\u4e00\u4e2a\u9644\u4ef6\u65b9\u5f0f\u6709\u4e24\u79cd\uff1a \u7eb9\u7406 \u6216 \u6e32\u67d3\u7f13\u51b2 \u5bf9\u8c61(Renderbuffer)\u3002 \u5e27\u7f13\u51b2\u76843\u4e2a\u9644\u7740 \u989c\u8272\u9644\u7740 Color Attachment \u6df1\u5ea6\u9644\u7740 Depth Attachment \u6a21\u677f\u9644\u7740 Stencil Attachment \u7eb9\u7406\u9644\u4ef6 Textures \u5373\u666e\u901a\u7684 Texture, \u6839\u636e Format\u7684\u4e0d\u540c, \u53ef\u4ee5\u5206\u522b\u7528\u4f5c FBO \u4e2d\u7684\u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u9644\u7740\u3002 \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 Renderbuffer Objects \u662f\u4e00\u4e2a\u7531\u5e94\u7528\u7a0b\u5e8f\u5206\u914d\u7684 2D \u56fe\u50cf\u7f13\u51b2\u533a\u3002 \u6e32\u67d3\u7f13\u51b2\u533a\u53ef\u4ee5\u7528\u4e8e\u5206\u914d\u548c\u5b58\u50a8 \u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u503c\uff0c\u53ef\u4ee5\u7528\u4f5c FBO \u4e2d\u7684\u989c\u8272\u3001\u6df1\u5ea6\u6216\u8005\u6a21\u677f\u9644\u7740\u3002 \u4f7f\u7528 \u7eb9\u7406 \u548c Renderbuffer \u5bf9\u8c61, \u90fd\u652f\u6301\u4e3a FBO \u5206\u522b\u6dfb\u52a0\u4e09\u79cd\u9644\u7740. \u4f46\u901a\u5e38\u4f7f\u7528 Texture \u6dfb\u52a0\u989c\u8272\u9644\u7740, \u7528 Renderbuffer \u6765\u6dfb\u52a0\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740. \u539f\u56e0\u5728\u540e\u9762\u8ba8\u8bba. (OpenGL ES 3.0 \u7f16\u7a0b\u6307\u5357)","title":"\u76f8\u5173\u5b9a\u4e49"},{"location":"GLES/Framebuffer%20Object/#_4","text":"APP --> GLES : glGenFramebuffers(1, &fbo); glBindFramebuffer(GL_FRAMEBUFFER, fbo); glBindFramebuffer(GL_FRAMEBUFFER, 0);","title":"\u4f7f\u7528\u6d41\u7a0b"},{"location":"GLES/Framebuffer%20Object/#_5","text":"\u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61 glGenFramebuffers(1, &fbo); \u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684(Active)\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, fbo); \u5728\u7ed1\u5b9a\u5230GL_FRAMEBUFFER\u76ee\u6807\u4e4b\u540e\uff0c\u6240\u6709\u7684 \u8bfb\u53d6 \u548c \u5199\u5165 \u5e27\u7f13\u51b2\u7684\u64cd\u4f5c\u5c06\u4f1a\u5f71\u54cd\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u3002 \u6211\u4eec\u4e5f\u53ef\u4ee5\u4f7f\u7528 GL_READ_FRAMEBUFFER \u6216 GL_DRAW_FRAMEBUFFER \uff0c\u5c06\u4e00\u4e2a\u5e27\u7f13\u51b2\u5206\u522b\u7ed1\u5b9a\u5230\u8bfb\u53d6\u76ee\u6807\u6216\u5199\u5165\u76ee\u6807\u3002 \u7ed1\u5b9a\u5230 GL_READ_FRAMEBUFFER \u7684\u5e27\u7f13\u51b2\u5c06\u4f1a\u4f7f\u7528\u5728\u6240\u6709\u50cf\u662f glReadPixels \u7684\u8bfb\u53d6\u64cd\u4f5c\u4e2d\uff0c \u7ed1\u5b9a\u5230 GL_DRAW_FRAMEBUFFER \u7684\u5e27\u7f13\u51b2\u5c06\u4f1a\u88ab\u7528\u4f5c\u6e32\u67d3\u3001\u6e05\u9664\u7b49\u5199\u5165\u64cd\u4f5c\u7684\u76ee\u6807\u3002 \u901a\u5e38\u90fd \u4e0d\u9700\u8981\u533a\u5206 \u5b83\u4eec\uff0c\u4f7f\u7528 GL_FRAMEBUFFER \uff0c\u7ed1\u5b9a\u5230\u4e24\u4e2a\u4e0a\u3002 \u6dfb\u52a0\u9644\u7740: \u5728\u8fd9\u4e00\u9636\u6bb5, \u4f7f\u7528Texture\u6216Renderbuffer\u5bf9FBO\u6dfb\u52a0\u9644\u7740, \u4ee3\u7801\u5728\u4e0b\u4e24\u8282\u79cd\u5c55\u793a. \u6dfb\u52a0\u9644\u7740\u540e, \u68c0\u67e5\u5e27\u7f13\u51b2\u7684\u5b8c\u6574\u6027 if( glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE) \u4e00\u4e2a\u5b8c\u6574\u7684\u5e27\u7f13\u51b2\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u7684\u6761\u4ef6\uff1a \u9644\u52a0\u81f3\u5c11\u4e00\u4e2a\u9644\u7740\uff08\u989c\u8272\u3001\u6df1\u5ea6\u6216\u6a21\u677f\u9644\u7740\uff09\u3002 \u81f3\u5c11\u6709\u4e00\u4e2a\u989c\u8272\u9644\u4ef6(Attachment)\u3002TODO: check angle \u6240\u6709\u7684\u9644\u4ef6\u90fd\u5fc5\u987b\u662f\u5b8c\u6574\u7684\uff08\u4fdd\u7559\u4e86\u5185\u5b58\uff09\u3002 \u6bcf\u4e2a\u7f13\u51b2\u90fd\u5e94\u8be5\u6709\u76f8\u540c\u7684\u9ad8\u5ea6\u548c\u5bbd\u5ea6\u3002 \u5982\u679c\u5b58\u5728\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740, \u5b83\u4eec\u5fc5\u987b\u662f\u76f8\u540c\u7684\u56fe\u50cf. \u6240\u6709\u9644\u7740\u7684 GL_RENDERBUFFER_SAMPLES \u6837\u672c\u503c\u76f8\u540c. \u82e5\u9644\u7740\u5bf9\u8c61\u662f\u7eb9\u7406, \u5219\u6b64\u503c\u4e3a0. \u89e3\u7ed1FBO / \u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2 glBindFramebuffer(GL_FRAMEBUFFER, 0); \u6e32\u67d3\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u88ab\u53eb\u505a \u79bb\u5c4f\u6e32\u67d3 (Off-screen Rendering)\u3002\u8981\u4fdd\u8bc1\u6240\u6709\u7684\u6e32\u67d3\u64cd\u4f5c\u5728\u4e3b\u7a97\u53e3\u4e2d\u6709\u89c6\u89c9\u6548\u679c\uff0c\u6211\u4eec\u9700\u8981\u518d\u6b21\u6fc0\u6d3b\u9ed8\u8ba4\u5e27\u7f13\u51b2\uff0c\u5c06\u5b83\u7ed1\u5b9a\u5230 0 \u3002","title":"\u521b\u5efa\u5e27\u7f13\u51b2"},{"location":"GLES/Framebuffer%20Object/#_6","text":"\u666e\u901a\u7684\u521b\u5efa\u7eb9\u7406\u7684\u65b9\u5f0f unsigned int texture; glGenTextures(1, &texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); \u5982\u679c\u4f60\u60f3\u5c06\u4f60\u7684\u5c4f\u5e55\u6e32\u67d3\u5230\u4e00\u4e2a\u66f4\u5c0f\u6216\u66f4\u5927\u7684\u7eb9\u7406\u4e0a\uff0c\u4f60\u9700\u8981\uff08\u5728\u6e32\u67d3\u5230\u4f60\u7684\u5e27\u7f13\u51b2\u4e4b\u524d\uff09\u518d\u6b21\u8c03\u7528glViewport\uff0c\u4f7f\u7528\u7eb9\u7406\u7684\u65b0\u7ef4\u5ea6\u4f5c\u4e3a\u53c2\u6570\uff0c\u5426\u5219\u53ea\u6709\u4e00\u5c0f\u90e8\u5206\u7684\u7eb9\u7406\u6216\u5c4f\u5e55\u4f1a\u88ab\u6e32\u67d3\u5230\u8fd9\u4e2a\u7eb9\u7406\u4e0a\u3002 TODO: \u4ec0\u4e48\u610f\u601d? \u5c06\u7eb9\u7406\u9644\u52a0\u5728\u5e27\u7f13\u51b2\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); target \uff1a\u5e27\u7f13\u51b2\u7684\u76ee\u6807\uff08\u7ed8\u5236\u3001\u8bfb\u53d6\u6216\u8005\u4e24\u8005\u7686\u6709\uff09 attachment \uff1a\u6211\u4eec\u60f3\u8981\u9644\u52a0\u7684\u9644\u4ef6\u7c7b\u578b\u3002\u5f53\u524d\u6211\u4eec\u6b63\u5728\u9644\u52a0\u4e00\u4e2a \u989c\u8272\u9644\u4ef6 \u3002\u6ce8\u610f\u6700\u540e\u7684 0 \u610f\u5473\u7740\u53ef\u4ee5\u9644\u52a0\u591a\u4e2a\u989c\u8272\u9644\u4ef6\u3002 GL_COLOR_ATTACHMENT i , GL_DEPTH_ATTACHMENT , GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMENT . textarget \uff1a\u4f60\u5e0c\u671b\u9644\u52a0\u7684\u7eb9\u7406\u7c7b\u578b texture \uff1a\u8981\u9644\u52a0\u7684\u7eb9\u7406\u672c\u8eab level \uff1a\u591a\u7ea7\u6e10\u8fdc\u7eb9\u7406\u7684\u7ea7\u522b\u3002\u6211\u4eec\u5c06\u5b83\u4fdd\u7559\u4e3a0 \u7eb9\u7406\u5bf9\u8c61\u5141\u8bb8\u9644\u52a0\u4e00\u4e2a\u6df1\u5ea6\u6216\u6a21\u677f\u7f13\u51b2\u7eb9\u7406\u5230\u5e27\u7f13\u51b2\u5bf9\u8c61\u4e2d\u3002 \u8981\u9644\u52a0\u6df1\u5ea6\u7f13\u51b2\u7684\u8bdd\uff0c\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e\u4e3a GL_DEPTH_ATTACHMENT \u3002\u5e76\u5c06\u7eb9\u7406\u7684\u683c\u5f0f(Format)\u548c\u5185\u90e8\u683c\u5f0f(Internalformat)\u7c7b\u578b\u53d8\u4e3a GL_DEPTH_COMPONENT \uff0c\u6765\u53cd\u6620\u6df1\u5ea6\u7f13\u51b2\u7684\u50a8\u5b58\u683c\u5f0f\u3002 \u8981\u9644\u52a0\u6a21\u677f\u7f13\u51b2\u7684\u8bdd\uff0c\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e\u4e3a GL_STENCIL_ATTACHMENT \uff0c\u5e76\u5c06\u7eb9\u7406\u7684\u683c\u5f0f\u8bbe\u5b9a\u4e3a GL_STENCIL_INDEX \u3002 \u4e5f\u53ef\u4ee5\u5c06\u6df1\u5ea6\u7f13\u51b2\u548c\u6a21\u677f\u7f13\u51b2\u5408\u5e76\u9644\u52a0\u4e3a\u4e00\u4e2a\u7eb9\u7406\u3002\u7eb9\u7406\u7684\u6bcf32\u4f4d\u6570\u503c\u5c06\u5305\u542b24\u4f4d\u7684\u6df1\u5ea6\u4fe1\u606f\u548c8\u4f4d\u7684\u6a21\u677f\u4fe1\u606f\u3002\u5c06\u9644\u4ef6\u7c7b\u578b attachment \u8bbe\u7f6e GL_DEPTH_STENCIL_ATTACHMENT \u7c7b\u578b\uff0c\u5e76\u914d\u7f6e\u7eb9\u7406\u7684\u683c\u5f0f\uff0c\u8ba9\u5b83\u5305\u542b\u5408\u5e76\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u503c\u3002 ``` glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL ); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0); ```","title":"\u7eb9\u7406\u9644\u7740"},{"location":"GLES/Framebuffer%20Object/#renderbuffer","text":"\u521b\u5efa\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u7684\u4ee3\u7801 glGenRenderbuffers(1, &rbo); \u7ed1\u5b9a\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\uff0c\u8ba9\u4e4b\u540e\u6240\u6709\u7684\u6e32\u67d3\u7f13\u51b2\u64cd\u4f5c\u5f71\u54cd\u5f53\u524d\u7684 RBO\uff1a glBindRenderbuffer(GL_RENDERBUFFER, rbo); \u521b\u5efa\u4e00\u4e2a\u6df1\u5ea6\u548c\u6a21\u677f\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61 glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); \u521b\u5efa\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u548c\u7eb9\u7406\u5bf9\u8c61\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u662f\u8fd9\u4e2a\u5bf9\u8c61\u662f\u4e13\u95e8\u88ab\u8bbe\u8ba1\u4f5c\u4e3a\u56fe\u50cf\u4f7f\u7528\u7684\uff0c\u800c\u4e0d\u662f\u7eb9\u7406\u90a3\u6837\u7684\u901a\u7528\u6570\u636e\u7f13\u51b2(General Purpose Data Buffer)\u3002 \u8fd9\u91cc\u6211\u4eec\u9009\u62e9 GL_DEPTH24_STENCIL8 \u4f5c\u4e3a\u5185\u90e8\u683c\u5f0f\uff0c\u5b83\u5c01\u88c5\u4e8624\u4f4d\u7684\u6df1\u5ea6\u548c8\u4f4d\u7684\u6a21\u677f\u7f13\u51b2\u3002 \u9644\u52a0\u8fd9\u4e2a\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5230 FBO\uff1a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); \u4f7f\u7528 GL_DEPTH_STENCIL_ATTACHMENT \u8868\u793a\u540c\u65f6\u5305\u542b\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740","title":"Renderbuffer \u9644\u7740"},{"location":"GLES/Framebuffer%20Object/#texture-vs-renderbuffer","text":"\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61(Renderbuffer Object) \u662f\u5728\u7eb9\u7406\u4e4b\u540e\u5f15\u5165\u5230OpenGL\u4e2d\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u53ef\u7528\u7684\u5e27\u7f13\u51b2\u9644\u4ef6\u7c7b\u578b\u7684\uff0c\u6240\u4ee5\u5728\u8fc7\u53bb\u7eb9\u7406\u662f\u552f\u4e00\u53ef\u7528\u7684\u9644\u4ef6\u3002 Renderbuffer : \u548c\u7eb9\u7406\u56fe\u50cf\u4e00\u6837\uff0c\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u662f\u4e00\u4e2a\u771f\u6b63\u7684\u7f13\u51b2\uff0c\u5373\u4e00\u7cfb\u5217\u7684\u5b57\u8282\u3001\u6574\u6570\u3001\u50cf\u7d20\u7b49\u3002 \u4f18\u70b9: Renderbuffer \u4f1a\u5c06\u6570\u636e\u50a8\u5b58\u4e3aOpenGL\u539f\u751f\u7684\u6e32\u67d3\u683c\u5f0f\uff0c\u5b83\u662f\u4e3a\u79bb\u5c4f\u6e32\u67d3\u5230\u5e27\u7f13\u51b2\u4f18\u5316\u8fc7\u7684\u3002 Renderbuffer \u76f4\u63a5\u5c06\u6240\u6709\u7684\u6e32\u67d3\u6570\u636e\u50a8\u5b58\u5230\u5b83\u7684\u7f13\u51b2\u4e2d\uff0c\u4e0d\u4f1a\u505a\u4efb\u4f55\u9488\u5bf9\u7eb9\u7406\u683c\u5f0f\u7684\u8f6c\u6362\uff0c\u8ba9\u5b83\u53d8\u4e3a\u4e00\u4e2a\u66f4\u5feb\u7684\u53ef\u5199\u50a8\u5b58\u4ecb\u8d28\u3002 \u7f3a\u70b9: Renderbuffer \u4e0d\u80fd\u505a\u7eb9\u7406: \u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u901a\u5e38\u90fd\u662f \u53ea\u5199 \u7684\uff0c\u6240\u4ee5\u4f60\u4e0d\u80fd\u8bfb\u53d6\u5b83\u4eec, \u6bd4\u5982\u4f7f\u7528\u7eb9\u7406\u8bbf\u95ee\u3002 \u5f53\u7136\u4f60\u4ecd\u7136\u8fd8\u662f\u80fd\u591f\u4f7f\u7528 glReadPixels \u6765\u8bfb\u53d6\u5b83\uff0c\u8fd9\u4f1a\u4ece\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2(\u800c\u4e0d\u662f\u9644\u4ef6\u672c\u8eab)\u4e2d\u8fd4\u56de\u7279\u5b9a\u533a\u57df\u7684\u50cf\u7d20\u3002 \u56e0\u6b64\u901a\u5e38\u7684\u89c4\u5219\u662f: \u5982\u679c\u4f60 \u4e0d\u9700\u8981\u4ece\u4e00\u4e2a\u7f13\u51b2\u4e2d\u91c7\u6837 \u6570\u636e\uff0c\u90a3\u4e48\u5bf9\u8fd9\u4e2a\u7f13\u51b2\u4f7f\u7528 \u6e32\u67d3\u7f13\u51b2 \u5bf9\u8c61\u4f1a\u662f\u660e\u667a\u7684\u9009\u62e9\u3002 \u800c\u5982\u679c\u4f60 \u9700\u8981\u4ece\u7f13\u51b2\u4e2d\u91c7\u6837\u989c\u8272\u6216\u6df1\u5ea6 \u503c\u7b49\u6570\u636e\uff0c\u90a3\u4e48\u4f60\u5e94\u8be5\u9009\u62e9 \u7eb9\u7406 \u9644\u4ef6\u3002\u6027\u80fd\u65b9\u9762\u5b83\u4e0d\u4f1a\u4ea7\u751f\u975e\u5e38\u5927\u7684\u5f71\u54cd\u7684\u3002 \u56e0\u6b64 Renderbuffer \u5bf9\u8c61\u901a\u5e38\u7528\u4e8e \u6df1\u5ea6\u548c\u6a21\u677f \u9644\u4ef6\uff0c\u56e0\u4e3a\u5927\u90e8\u5206\u65f6\u95f4\u6211\u4eec\u90fd\u4e0d\u9700\u8981\u4ece\u6df1\u5ea6\u548c\u6a21\u677f\u7f13\u51b2\u4e2d\u8bfb\u53d6\u503c\uff0c\u53ea\u5173\u5fc3\u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5, \u4f46\u4e0d\u9700\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u91c7\u6837. \u5bf9\u5e94\u5230\u573a\u666f\u4e2d: \u9009\u62e9 Texture \u6e32\u67d3\u5230\u4e00\u4e2a\u7528\u4f5c\u989c\u8272\u7eb9\u7406\u7684\u989c\u8272\u7f13\u51b2\u533a \u6e32\u67d3\u5230\u4e00\u4e2a\u7528\u4f5c\u9634\u5f71\u7684\u6df1\u5ea6\u7eb9\u7406\u7684\u6df1\u5ea6\u7f13\u51b2\u533a \u9009\u62e9 Renderbuffer \u591a\u91cd\u91c7\u6837 \u5982\u679c\u56fe\u50cf\u4e0d\u88ab\u4f5c\u4e3a\u7eb9\u7406, \u5219 Renderbuffer \u53ef\u80fd\u5e26\u6765\u6027\u80fd\u4f18\u52bf: GLES \u53ef\u80fd\u4ee5\u66f4\u9ad8\u6548\u7684\u683c\u5f0f\u5b58\u50a8 Renderbuffer, \u6bd4\u7eb9\u7406\u66f4\u9002\u5408\u6e32\u67d3 \u4f8b\u5982: \u5229\u7528\u5176\u5199\u5165\u6216\u8005\u590d\u5236\u5230\u5176\u5b83\u7f13\u51b2\u5feb\u7684\u7279\u70b9\u3002 \u4ea4\u6362\u7f13\u51b2 \u8fd9\u6837\u7684\u64cd\u4f5c\u5728\u4f7f\u7528\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u65f6\u4f1a\u975e\u5e38\u5feb\u3002 \u5728\u6bcf\u4e2a\u6e32\u67d3\u8fed\u4ee3\u6700\u540e\u4f7f\u7528\u7684 glfwSwapBuffers \uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61\u5b9e\u73b0\uff1a\u53ea\u9700\u8981\u5199\u5165\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u56fe\u50cf\uff0c\u5e76\u5728\u6700\u540e\u4ea4\u6362\u5230\u53e6\u5916\u4e00\u4e2a\u6e32\u67d3\u7f13\u51b2\u5c31\u53ef\u4ee5\u4e86\u3002","title":"Texture VS. Renderbuffer"},{"location":"GLES/Framebuffer%20Object/#_7","text":"","title":"\u793a\u4f8b: \u573a\u666f\u6ee4\u955c"},{"location":"GLES/Framebuffer%20Object/#_8","text":"// \u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u5bf9\u8c61\uff0c\u5e76\u7ed1\u5b9a unsigned int framebuffer; glGenFramebuffers(1, &framebuffer); glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); // \u4f7f\u7528 Texture \u6dfb\u52a0\u989c\u8272\u9644\u7740 // \u751f\u6210\u7eb9\u7406 unsigned int texColorBuffer; glGenTextures(1, &texColorBuffer); glBindTexture(GL_TEXTURE_2D, texColorBuffer); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glBindTexture(GL_TEXTURE_2D, 0); // \u5c06\u7eb9\u7406\u5bf9\u8c61, \u9644\u52a0\u5230\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u5bf9\u8c61\u989c\u8272(color)\u9644\u4ef6\u4e0a glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, 0); // \u4f7f\u7528 Renderbuffer \u6dfb\u52a0\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u7740 // \u6df1\u5ea6\uff08\u548c\u6a21\u677f\uff09\u6d4b\u8bd5 // \u6dfb\u52a0\u4e00\u4e2a\u6df1\u5ea6\uff08\u548c\u6a21\u677f\uff09\u9644\u4ef6\u5230\u5e27\u7f13\u51b2\u4e2d unsigned int rbo; glGenRenderbuffers(1, &rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); // GL_DEPTH24_STENCIL8 glBindRenderbuffer(GL_RENDERBUFFER, 0); // \u5c06\u6e32\u67d3\u7f13\u51b2\u5bf9\u8c61, \u9644\u52a0\u5230\u5230\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u7684 depth \u548c stencil \u9644\u4ef6\u4e0a glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); // \u68c0\u67e5\u5e27\u7f13\u51b2\u662f\u5426\u662f\u5b8c\u6574\u7684 if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) std::cout << \"ERROR::FRAMEBUFFER:: Framebuffer is not complete!\" << std::endl; // \u89e3\u7ed1\u5e27\u7f13\u51b2/\u7ed1\u5b9a\u56de\u9ed8\u8ba4 glBindFramebuffer(GL_FRAMEBUFFER, 0);","title":"\u521b\u5efa\u9636\u6bb5"},{"location":"GLES/Framebuffer%20Object/#_9","text":"\u8981\u60f3\u7ed8\u5236\u573a\u666f\u5230\u4e00\u4e2a\u7eb9\u7406\u4e0a\uff0c\u6211\u4eec\u9700\u8981\u91c7\u53d6\u4ee5\u4e0b\u7684\u6b65\u9aa4\uff1a \u5c06\u65b0\u7684\u5e27\u7f13\u51b2\u7ed1\u5b9a\u4e3a\u6fc0\u6d3b\u7684\u5e27\u7f13\u51b2 \u548c\u5f80\u5e38\u4e00\u6837\u6e32\u67d3\u573a\u666f \u6b64\u65f6\u573a\u666f\u4f1a\u6e32\u67d3\u5230\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2, \u800c\u4e0d\u662f\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2\u3002 \u6240\u6709\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u64cd\u4f5c\u90fd\u4f1a\u4ece\u5f53\u524d\u7ed1\u5b9a\u7684\u5e27\u7f13\u51b2\u7684\u6df1\u5ea6\u548c\u6a21\u677f\u9644\u4ef6\u4e2d\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u8bfb\u53d6\u3002 \u7ed1\u5b9a\u56de\u9ed8\u8ba4\u7684\u5e27\u7f13\u51b2 \u7ed8\u5236\u4e00\u4e2a\u6574\u5c4f\u5e55\u7684\u56db\u8fb9\u5f62\uff0c\u7136\u540e\u5c06\u5e27\u7f13\u51b2\u7684\u989c\u8272\u7f13\u51b2\u4f5c\u4e3a\u56db\u8fb9\u5f62\u7684\u7eb9\u7406\u3002 // \u7b2c\u4e00\u5904\u7406\u9636\u6bb5: \u7ed8\u5236\u5230FBO glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // \u6211\u4eec\u73b0\u5728\u4e0d\u4f7f\u7528\u6a21\u677f\u7f13\u51b2 glEnable(GL_DEPTH_TEST); DrawScene(); // \u7ed8\u5236\u539f\u59cb 3D \u573a\u666f // Load VAO, bind Textures, uniform data, call glDrawArrays or glDrawElements // \u7b2c\u4e8c\u5904\u7406\u9636\u6bb5: \u7ed8\u5236\u5230\u5c4f\u5e55 glBindFramebuffer(GL_FRAMEBUFFER, 0); // \u8fd4\u56de\u9ed8\u8ba4 glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); screenShader.use(); // \u4f7f\u7528\u53e6\u4e00\u5957 shader glBindVertexArray(quadVAO); // \u7ed8\u5236\u4e00\u4e2a\u56db\u8fb9\u5f62 glDisable(GL_DEPTH_TEST); glBindTexture(GL_TEXTURE_2D, textureColorbuffer); // \u5c06 Color Buffer \u4f5c\u4e3a\u7eb9\u7406\u7ed8\u5236\u5230\u56db\u8fb9\u5f62\u4e0a glDrawArrays(GL_TRIANGLES, 0, 6); \u5982\u679c screenShader \u4e0d\u505a\u7279\u6b8a\u5904\u7406, \u6b64\u65f6\u753b\u9762\u4f1a\u548c DrawScene \u7ed8\u5236\u7684\u539f\u59cb3D\u573a\u666f\u4e00\u81f4. \u6b64\u65f6\u7ed8\u5236\u7684\u56db\u8fb9\u5f62\u7c7b\u4f3c\u4e00\u4e2a\u663e\u793a\u5c4f\u5e55, \u5229\u7528\u8d34\u56fe\u663e\u793a\u539f\u59cb\u573a\u666f. \u4f46\u5982\u679c\u5bf9 screenShader \u4e2d\u7eb9\u7406\u7684color\u8fdb\u884c\u4fee\u6539, \u5c31\u53ef\u7528\u5b9e\u73b0\u6ee4\u955c\u6548\u679c. void main() { // \u53cd\u767d\u7279\u6548 FragColor = vec4(vec3(1.0 - texture(screenTexture, TexCoords)), 1.0); } \u753b\u9762\u6548\u679c\u548c\u66f4\u591a\u7279\u6548\u5904\u7406, \u53c2\u89c1 LearnOpenGL (English version: LearnOpenGL )","title":"\u7ed8\u5236\u9636\u6bb5"},{"location":"GLES/Framebuffer%20Object/#msaa","text":"\u79bb\u5c4fMSAA \u5728\u9ed8\u8ba4\u5e27\u7f13\u51b2\u4e2d\u542f\u7528MASS, \u53ea\u9700\u8981 glEnable(GL_MULTISAMPLE); \u542f\u7528\u5373\u53ef. \u4f46\u5bf9\u4e8e\u79bb\u5c4f\u6e32\u67d3, \u9700\u8981\u624b\u52a8\u521b\u5efa\u591a\u91cd\u91c7\u6837\u7684\u9644\u7740. Texture: \u521b\u5efaMS Texture: \u4f7f\u7528 glTexImage2DMultisample \u6765\u66ff\u4ee3 glTexImage2D glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex); glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE); glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0); \u9644\u52a0\u5230\u5e27\u7f13\u51b2: \u4f7f\u7528 glFramebufferTexture2D \u5c06\u591a\u91cd\u91c7\u6837\u7eb9\u7406\u4e0a\uff0c\u4f46\u8fd9\u91cc\u7eb9\u7406\u7c7b\u578b\u4f7f\u7528\u7684\u662f GL_TEXTURE_2D_MULTISAMPLE \u3002 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0); Renderbuffer : \u521b\u5efa\u8fc7\u7a0b\u4e0d\u53d8 \u9644\u52a0\u5230\u5e27\u7f13\u51b2: \u5c06 glRenderbufferStorage \u7684\u8c03\u7528\u6539\u4e3a glRenderbufferStorageMultisample \u5c31\u53ef\u4ee5\u4e86 glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, width, height); \u7b2c\u4e8c\u53c2\u6570 4 \u4e3a\u91c7\u6837\u6b21\u6570 \u7ed8\u5236: void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); \u5c06\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u7684\u50cf\u7d20\u503c, \u4ece\u4e00\u4e2a\u5e27\u7f13\u51b2\u590d\u5236\u5230\u53e6\u4e00\u4e2a\u5e27\u7f13\u51b2. \u901a\u8fc7 glBlitFramebuffer \u5c06\u591a\u91cd\u91c7\u6837\u7684\u5e27\u7f13\u51b2, \u590d\u5236\u5230\u4e00\u4e2a\u4e2d\u4ecb\u5e27\u7f13\u51b2\u7684\u989c\u8272\u9644\u7740\u7684\u7eb9\u7406, \u5b9e\u73b0\u591a\u91cd\u91c7\u6837. glBindFramebuffer(multisampledFBO); ClearFrameBuffer(); DrawScene(); // \u5c06\u591a\u91cd\u91c7\u6837\u7f13\u51b2\u8fd8\u539f\u5230\u4e2d\u4ecbFBO\u4e0a glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO); glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO); glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST); // \u73b0\u5728\u573a\u666f\u662f\u4e00\u4e2a2D\u7eb9\u7406\u7f13\u51b2\uff0c\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u56fe\u50cf\u7528\u6765\u540e\u671f\u5904\u7406 glBindFramebuffer(GL_FRAMEBUFFER, 0); ClearFramebuffer(); glBindTexture(GL_TEXTURE_2D, screenTexture); DrawPostProcessingQuad();","title":"\u79bb\u5c4fMSAA"},{"location":"GLES/Framebuffer%20Object/#framebuffer-api","text":"API ES Ver. Notes void glGenFramebuffers ( sizei n, uint *framebuffers ); 2 void glBindFramebuffer ( enum target, uint framebuffer ); 2 void glGenRenderbuffers ( sizei n, uint *renderbuffers ); 2 void glBindRenderbuffer ( enum target, uint renderbuffer ); 2 void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height); 2 \u521b\u5efa\u4e00\u4e2a Renderbuffer internalformat : \u6307\u5b9a\u7f13\u51b2\u683c\u5f0f: depth \u548c stencil GL_DEPTH24_STENCIL8; GL_DEPTH32F_STENCIL8 GL_DEPTH_COMPONENT16 GL_DEPTH_COMPONENT24 GL_DEPTH_COMPONENT32F GL_STENCIL_INDEX8 void glRenderbufferStorageMultisample ( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); 3.0 \u521b\u5efa\u4e00\u4e2a\u591a\u91cd\u91c7\u6837 Renderbuffer, \u4e0eglRenderbufferStorage\u7684\u533a\u522b\u4ec5\u4e3a\u540e\u8005samples=0 GLenum glCheckFramebufferStatus (GLenum target); \u68c0\u67e5fbo\u5b8c\u6574\u6027 void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); \u5c06\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u7684\u50cf\u7d20\u503c, \u4ece\u4e00\u4e2afb\u590d\u5236\u5230\u53e6\u4e00\u4e2afb. \u5e94\u7528\u4e3e\u4f8b: 1. \u590d\u5236\u591a\u4e2a\u7eb9\u7406\u5230\u5c4f\u5e55 2. \u5c06\u591a\u91cd\u91c7\u6837\u6e32\u67d3\u89e3\u6790\u4e3a\u4e00\u4e2a\u7eb9\u7406 \u7ed1\u5b9a void glFramebufferRenderbuffer ( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); 2 void glFramebufferTexture ( GLenum target, GLenum attachment, GLuint texture, GLint level); 3.2 void glFramebufferTexture2D ( enum target, enum attachment, enum textarget, uint texture, int level ); 2.0 void glFramebufferTextureLayer ( enum target, enum attachment, uint texture, int level, int layer ); 3.0 \u7ed1\u5b9a 3D Texture \u65e0\u6548\u5316/\u5220\u9664 void glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments); 3.0 \u901a\u77e5\u9a71\u52a8\u4e0d\u518d\u9700\u8981fb\u5185\u5bb9. \u4f7f\u9a71\u52a8\u53ef\u7528\u8fdb\u884c\u4f18\u5316: \u5982\u8df3\u8fc7TBR\u67b6\u6784\u4e2d\u4e0d\u5fc5\u8981\u7684\u56fe\u5757\u5185\u5bb9\u6062\u590d \u8df3\u8fc7\u5b9e\u73b0\u4e2d\u4e3a\u6539\u8fdb\u6027\u80fd\u800c\u505a\u7684\u7f13\u5b58\u5237\u65b0 void glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height); 3.0 void glDeleteRenderbuffers (GLsizei n, const GLuint *renderbuffers); 2 void glDeleteFramebuffers (GLsizei n, const GLuint *framebuffers); 2 \u5176\u4ed6 void glFramebufferParameteri (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params); boolean IsRenderbuffer ( uint renderbuffer ); boolean IsFramebuffer ( uint framebuffer ); \u5176\u4ed6\u9488\u5bf9\u8bfb\u5e27\u7f13\u51b2\u7684\u547d\u4ee4: ReadPixels, CopyTexImage , and CopyTexSubImage ,","title":"Framebuffer \u76f8\u5173 API \u6c47\u603b"},{"location":"GLES/Framebuffer%20Object/#gl2","text":"void glBindFramebuffer (GLenum target, GLuint framebuffer); GLenum glCheckFramebufferStatus (GLenum target); void glDeleteFramebuffers (GLsizei n, const GLuint framebuffers); void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); void glFramebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); void glGenFramebuffers (GLsizei n, GLuint framebuffers); void glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, GLint *params); GLboolean glIsFramebuffer (GLuint framebuffer); void glBindRenderbuffer (GLenum target, GLuint renderbuffer); void glDeleteRenderbuffers (GLsizei n, const GLuint renderbuffers); void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); void glGenRenderbuffers (GLsizei n, GLuint renderbuffers); void glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint *params); GLboolean glIsRenderbuffer (GLuint renderbuffer); void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);","title":"gl2"},{"location":"GLES/Framebuffer%20Object/#gl3","text":"void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); void glFramebufferTextureLayer (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); void glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum attachments); void glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum attachments, GLint x, GLint y, GLsizei width, GLsizei height); void glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);","title":"gl3"},{"location":"GLES/Framebuffer%20Object/#gl31","text":"void glFramebufferParameteri (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params);","title":"gl31"},{"location":"GLES/Framebuffer%20Object/#gl32","text":"void glFramebufferTexture (GLenum target, GLenum attachment, GLuint texture, GLint level);","title":"gl32"},{"location":"GLES/Framebuffer%20Object/#ext","text":"","title":"EXT"},{"location":"GLES/Framebuffer%20Object/#glexth","text":"void glResolveMultisampleFramebufferAPPLE (void); void glDiscardFramebufferEXT (GLenum target, GLsizei numAttachments, const GLenum attachments); void glFramebufferTexture2DMultisampleEXT (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glFramebufferTexture2DMultisampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glExtGetFramebuffersQCOM (GLuint framebuffers, GLint maxFramebuffers, GLint *numFramebuffers);","title":"glext.h"},{"location":"GLES/Framebuffer%20Object/#renderbuffer_1","text":"void glEGLImageTargetRenderbufferStorageOES (GLenum target, GLeglImageOES image); void glRenderbufferStorageMultisampleAPPLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleEXT (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleIMG (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glExtGetRenderbuffersQCOM (GLuint renderbuffers, GLint maxRenderbuffers, GLint numRenderbuffers);","title":"Renderbuffer"},{"location":"GLES/Framebuffer%20Object/#gl2ext","text":"void glFramebufferTextureOES (GLenum target, GLenum attachment, GLuint texture, GLint level); void glFramebufferTexture3DOES (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); void glResolveMultisampleFramebufferAPPLE (void); void glDiscardFramebufferEXT (GLenum target, GLsizei numAttachments, const GLenum attachments); void glFramebufferTextureEXT (GLenum target, GLenum attachment, GLuint texture, GLint level); void glFramebufferTexture2DMultisampleEXT (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glFramebufferFetchBarrierEXT (void); void glFramebufferPixelLocalStorageSizeEXT (GLuint target, GLsizei size); GLsizei glGetFramebufferPixelLocalStorageSizeEXT (GLuint target); void glFramebufferTexture2DDownsampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint xscale, GLint yscale); void glFramebufferTextureLayerDownsampleIMG (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale); void glFramebufferTexture2DMultisampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); void glApplyFramebufferAttachmentCMAAINTEL (void); void glFramebufferParameteriMESA (GLenum target, GLenum pname, GLint param); void glGetFramebufferParameterivMESA (GLenum target, GLenum pname, GLint params); void glBlitFramebufferNV (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); void glFramebufferSampleLocationsfvNV (GLenum target, GLuint start, GLsizei count, const GLfloat v); void glNamedFramebufferSampleLocationsfvNV (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat v); void glFramebufferTextureMultiviewOVR (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews); void glFramebufferTextureMultisampleMultiviewOVR (GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews); void glFramebufferFoveationConfigQCOM (GLuint framebuffer, GLuint numLayers, GLuint focalPointsPerLayer, GLuint requestedFeatures, GLuint *providedFeatures); void glFramebufferFoveationParametersQCOM (GLuint framebuffer, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea); void glFramebufferFetchBarrierQCOM (void);","title":"gl2Ext"},{"location":"GLES/Framebuffer%20Object/#renderbuffer_2","text":"void glEGLImageTargetRenderbufferStorageOES (GLenum target, GLeglImageOES image); void glRenderbufferStorageMultisampleAdvancedAMD (GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height); void glNamedRenderbufferStorageMultisampleAdvancedAMD (GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleANGLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleAPPLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleEXT (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleIMG (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glRenderbufferStorageMultisampleNV (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); void glExtGetRenderbuffersQCOM (GLuint renderbuffers, GLint maxRenderbuffers, GLint numRenderbuffers); gl2ext_angle.h void glGetRenderbufferParameterivRobustANGLE (GLenum target, GLenum pname, GLsizei bufSize, GLsizei length, GLint params); void glGetRenderbufferImageANGLE (GLenum target, GLenum format, GLenum type, void *pixels);","title":"Renderbuffer"},{"location":"GLES/Framebuffer%20Object/#gl2ext_angle","text":"void glGetFramebufferAttachmentParameterivRobustANGLE (GLenum target, GLenum attachment, GLenum pname, GLsizei bufSize, GLsizei length, GLint params); void glGetFramebufferParameterivRobustANGLE (GLenum target, GLenum pname, GLsizei bufSize, GLsizei length, GLint params);","title":"gl2Ext_ANGLE"},{"location":"GLES/Framebuffer%20Object/#summary","text":"Framebuffer \u5206\u9ed8\u8ba4 fb \u548c \u7528\u6237\u5b9a\u4e49 fb, \u540e\u8005\u88ab\u79f0\u4e3a Framebuffer Objects (FBOs) OpenGL \u4f1a\u5728 Context\u4e2d\u521b\u5efa Default Framebuffer \u7528\u6765\u8868\u793a\u4e00\u4e2a \u7a97\u53e3 \u6216 \u663e\u793a\u8bbe\u5907. \u4e0d\u80fd\u4fee\u6539\u5176 attachments FBOs \u5173\u8054 Textures \u6216 Renderbuffers, \u4e0d\u4f1a\u76f4\u63a5\u53ef\u89c1 FBOs\u4e2d\u7f13\u5b58(Buffers)\u53c8\u79f0\u4f5c \"attachment points\"","title":"Summary"},{"location":"GLES/Framebuffer%20Object/#bind-points","text":"void glBindFramebuffer(GL_FRAMEBUFFER, mFramebuffer) bind framebuffers to the context \u4e24\u79cd\u7c7b\u578b: GL_DRAW_FRAMEBUFFER \u548c GL_READ_FRAMEBUFFER , \u800c GL_FRAMEBUFFER \u8868\u793a\u4e8c\u8005\u90fd\u6709.","title":"Bind points"},{"location":"GLES/Framebuffer%20Object/#colorspace","text":"\u4e24\u79cd: linear RGB \u548c sRGB \u542f\u7528 / \u7981\u7528 GL_FRAMEBUFFER_SRGB \u6765\u63a7\u5236\u662f\u5426\u8fdb\u884c\u8f6c\u6362 ### Blending blending \u4f5c\u7528\u4e8e\u76ee\u6807\u56fe\u50cf\u7684 sRGB colorspace, \u56e0\u6b64\u82e5 GL_FRAMEBUFFER_SRGB \u672a\u542f\u7528, \u65e0\u6cd5\u6b63\u5e38\u5de5\u4f5c.","title":"Colorspace:"},{"location":"GLES/Framebuffer%20Object/#read","text":"void glReadBuffer (GLenum mode );","title":"Read"},{"location":"GLES/Framebuffer%20Object/#draw","text":"void glDrawBuffersEXT(attachmentCount, drawBuffers[GL_COLOR_ATTACHMENT0_EXT, ...]); attachmentCount can only be as large as GL_MAX_DRAW_BUFFERS ( Windows ANGLE\u4e0a\u7ea6\u4e3a 34852) Draw \u64cd\u4f5c\u4f1a\u5bf9 fb \u8bbe\u7f6e\u4e00\u79cd state, \u56e0\u6b64\u53ef\u7528\u53ea draw \u4e00\u6b21.","title":"Draw"},{"location":"GLES/Framebuffer%20Object/#framebuffer","text":"Jump to navigation Jump to search A Framebuffer is a collection of buffers that can be used as the destination for rendering. OpenGL has two kinds of framebuffers: the Default Framebuffer , which is provided by the OpenGL Context ; and user-created framebuffers called Framebuffer Objects (FBOs). The buffers for default framebuffers are part of the context and usually represent a window or display device. The buffers for FBOs reference images from either Textures or Renderbuffers ; they are never directly visible. Note that the term \"buffer\" here refers to a specific location in the framebuffer. An image may or may not be associated with a particular buffer in a framebuffer. Buffers in FBOs are also called \"attachment points\"; they're the locations where images can be attached. Default framebuffers cannot change their buffer attachments, but a particular default framebuffer may not have images associated with certain buffers. For example the GL_BACK_RIGHT buffer will only have an image if the default framebuffer is double-buffered and uses stereoscopic 3D. The default framebuffer's buffer names are separate from framebuffer object buffer names .","title":"Framebuffer"},{"location":"GLES/Framebuffer%20Object/#bind-points_1","text":"glBindFramebuffer is used to bind framebuffers to the context. They can be bound to one of two targets: GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER. The draw framebuffer is used as the destination for rendering, clearing , and other writing operations. The read framebuffer is used as the source for reading operations. Binding to the GL_FRAMEBUFFER target is equivalent to binding that framebuffer to both GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER. Note that most other uses of GL_FRAMEBUFFER mean the draw framebuffer; this is the case when it means both.","title":"Bind points"},{"location":"GLES/Framebuffer%20Object/#colorspace_1","text":"Color Image Formats can be in a linear or sRGB colorspace . Normally, sRGB images perform color correction, such that texture reads from them will always convert them to linear RGB. However, when writing values from a Fragment Shader to the image, a question arises: in what colorspace are the values written by the shader? When the output buffer is linear RGB, the answer is assumed to be linear. But if we are writing to an sRGB image, it is entirely reasonable for a shader to want to write linear values which will be automatically converted to sRGB for storage. However, at other times, it is entirely reasonable for a shader to want to write sRGB values directly, and therefore want to store the written provided without any conversion. The fragment shader is not given the power to control this, as the controls for it depend partially on state external to the fragment shader (namely, the colorspace of the image buffer being written to). Instead, this is made a global state value. When GL_FRAMEBUFFER_SRGB is disabled , the system assumes that the color written by the fragment shader is in whatever colorspace the image it is being written to is. Therefore, no colorspace correction is performed. If GL_FRAMEBUFFER_SRGB is enabled however, then if the destination image is in the sRGB colorspace (as queried through glGetFramebufferAttachmentParameter(GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING) ), then it will assume the shader's output is in the linear RGB colorspace. It will therefore convert the output from linear RGB to sRGB. Note that Logical Operations are disabled for any sRGB buffer when GL_FRAMEBUFFER_SRGB is enabled.","title":"Colorspace"},{"location":"GLES/Framebuffer%20Object/#blending","text":"Blending interacts with sRGB colorspace in destination images. The sRGB colorspace is non-linear, and thus linearly interpolating between non-linear colorspaces generally leads to colors that are not accurate. The correct operation is to linearize the destination color, do the blending in linear RGB space, and then convert back to sRGB. If GL_FRAMEBUFFER_SRGB is enabled , then the appropriate correction will be done for sRGB destination images. That is, if a particular destination image is sRGB, the destination value will be converted to linear RGB, blended with the linear source value via the current blend functions, and the result will be converted back to sRGB for writing to the destination image. If GL_FRAMEBUFFER_SRGB is not enabled, then it is assumed that the user knows what they are doing. Therefore, blending against an sRGB image when GL_FRAMEBUFFER_SRGB is not enabled will not perform any of the above correction. This is generally not a good idea, even if you are writing sRGB color values from the Fragment Shader .","title":"Blending"},{"location":"GLES/Framebuffer%20Object/#read-color-buffer","text":"Certain OpenGL operations can read pixel data from the color buffer. These operations are: Direct pixel reads . Framebuffer blits . Copies from the framebuffer to textures , which could also be during mutable storage specification . All of these operations read from the framebuffer bound to GL_READ_FRAMEBUFFER. However, because framebuffers often have multiple color images that could be read from, there is a selector in the framebuffer object that defines which color buffer these operations read from. The framebuffer's read buffer is specified by: void glReadBuffer (GLenum mode ); Warning: This sets the read buffer for the framebuffer currently bound to GL_READ_FRAMEBUFFER. So make sure that the framebuffer you want is bound to that buffer. The read buffer is part of the framebuffer's state, so each framebuffer will remember its previously set read buffer. If the GL_READ_FRAMEBUFFER is the default framebuffer, then mode must be the name of a color buffer name . It may be one of the multiple buffer aliases , which degrades as specified. If the read framebuffer is an FBO, then mode must be GL_COLOR_ATTACHMENT i , for one of the legal values of i . mode may also be GL_NONE, which indicates that no reading can be performed from color buffers on this framebuffer. Any attempt to perform read operations will fail with an error (GL_INVALID_OPERATION).","title":"Read color buffer"},{"location":"GLES/Framebuffer%20Object/#draw-color-buffers","text":"Much as with the read buffer, framebuffers have a set of draw buffers where writing operations write to. Unlike the read buffer, there are multiple draw buffers, which allow writing operations to write values to different buffers in the framebuffer at the same time. Fragment shader color outputs allow a fragment shader to define fragment color outputs, for example. The framebuffer therefore has a table of draw buffers, which are indexed on the half-open range [0, GL_MAX_DRAW_BUFFERS). The framebuffer's table maps from these indices to named color buffers in the framebuffer. To set this mapping table (on the framebuffer bound to GL_DRAW_FRAMEBUFFER), use this function: void glDrawBuffers( GLsizei n, const GLenum *bufs ); This function sets the first n entries of the mapping table. The indices of the enumerators correspond to the output fragment colors from the fragment shader. Thus, n can only be as large as GL_MAX_DRAW_BUFFERS. The entries in the bufs array are enumerators referring to buffer names in the framebuffer. All entries after n are set to GL_NONE. The values in bufs must name specific color buffers in the framebuffer. For the default framebuffer, buffer names cannot be the one of the multiple buffer aliases ; you must use GL_BACK_LEFT rather than GL_BACK. Framebuffer Objects use GL_COLOR_ATTACHMENT i buffer names. An entry in the list can be GL_NONE, which means that the output (if the shader outputs a value for it at all) is discarded. If you are only setting up one draw buffer, you may use glDrawBuffer . It takes one enumeration value and sets the fragment color 0 to draw to that buffer. All other draw buffer indices are set to GL_NONE. For the default framebuffer, the multiple buffer aliases can be used (though it is not advised to do so). They will cause drawing operations to write to all of the specified buffers. The state set by glDrawBuffers is part of the state of the framebuffer. So you can generally set this up once and leave it set.","title":"Draw color buffers"},{"location":"GLES/Framebuffer%20Object/#buffer-clearing","text":"Images in a framebuffer may be cleared to a particular value. Clearing is affected by the following state: The Write Mask . Only unmasked components will be changed by a clear call. The Pixel Ownership Test , which matters only for the Default Framebuffer . Pixels that are not owned will have undefined values. The Scissor Test . If the scissor test is enabled, then the clear region is bounded by the scissor rectangle. The Rasterizer Discard state. If discarding is enabled, all clearing commands are ignored. Framebuffer image clearing commands are Rendering Commands . Therefore, they are affected by Conditional Rendering . Clearing can be done in one of two ways. The old way can clear multiple buffers in a single call: void glClear (GLbitfield mask ); This will clear the current GL_DRAW_FRAMEBUFFER. The mask field is a bitmask that defines which kinds of buffers to clear. It can be a combination of GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT. When GL_COLOR_BUFFER_BIT is cleared, all of the active draw buffers are cleared. The values that the given buffers are cleared to are set beforehand via OpenGL state functions: void glClearColor (GLfloat red , GLfloat green , GLfloat blue , GLfloat alpha ); void glClearDepth (GLdouble depth ); void glClearStencil (GLint s ); These functions set the values that will be used to clear the appropriate buffers. Note that you must call these before calling glClear . depth will be clamped to the range [0, 1]. s , the stencil index, will be clamped to the valid integer range for the stencil buffer's image format. Note that glClearColor takes floating-point values. Yet it is perfectly legal to use integer Image Formats for images in framebuffers. Attempting to clear integer buffers with floating-point data will not work. Instead, you must clear each buffer individually with this suite of functions: void glClearBufferiv (GLenum buffer , GLint drawBuffer , const GLint * value ); void glClearBufferuiv (GLenum buffer , GLint drawBuffer , const GLuint * value ); void glClearBufferfv (GLenum buffer , GLint drawBuffer , const GLfloat * value ); void glClearBufferfi (GLenum buffer , GLint drawBuffer , GLfloat depth , GLint stencil ); This will clear a buffer in the current GL_DRAW_FRAMEBUFFER. buffer is either GL_COLOR, GL_DEPTH, GL_DEPTH_STENCIL, or GL_STENCIL. When clearing the GL_DEPTH buffer, you must use glClearBufferfv , and the depth value (a single float) will be clamped to [0, 1]. When using GL_STENCIL, you must use glClearBufferiv , and the stencil value (a single integer) will be clamped to the range of the stencil image format's precision. When using GL_DEPTH_STENCIL, you must use glClearBufferfi , and depth and stencil will each be clamped as appropriate for their value. The drawbuffer specifies the draw buffer index for the buffer to clear. This is only relevant if the buffer is GL_COLOR; in all other cases it must be 0. Note that this is the draw buffer index , not one of the GL_COLOR_ATTACHMENT i values. So 0 represents whatever the first buffer named by glDrawBuffers is. Note: Confusingly, buffer may also be one of the default framebuffer's multiple buffer aliases . In this case, drawbuffer specifies an additional draw buffer to clear, and all of the buffers will be cleared. You should probably avoid using them. Warning: Buffer clearing, of all forms , will respect the current state of the Scissor Test . If you wish to clear the entire buffer, you must make sure the scissor test is disabled.","title":"Buffer clearing"},{"location":"GLES/Framebuffer%20Object/#buffer-reading","text":"Pixel data can be read from a framebuffer and stored into CPU memory (or a buffer object ). The framebuffer being read from is the framebuffer bound to GL_READ_FRAMEBUFFER; remember that binding to GL_FRAMEBUFFER binds to both the read and the draw. To begin reading pixels, use this command: void glReadPixels (GLint x , GLint y , GLsizei width , GLsizei height , GLenum format , GLenum type , GLvoid * data ) This performs a Pixel Transfer read operation; as such, the destination data can be an offset into a Pixel Buffer Object if you so desire. Framebuffers have many buffers to read from. Which buffer is read from depends in part on the format parameter. If format is GL_DEPTH_COMPONENT, then the depth buffer is read from. If it is GL_STENCIL_INDEX, then the stencil buffer is read from. If it is GL_DEPTH_STENCIL then both the depth and stencil buffers are read from. If format is a color format, then the current read color buffer is used. If the current read buffer is GL_NONE, then a GL_INVALID_OPERATION error will occur.","title":"Buffer reading"},{"location":"GLES/Framebuffer%20Object/#read-color-clamping","text":"The color values read via glReadPixels may be clamped to the [0, 1] range. This is controlled via this function: void glClampColor (GLenum target , GLenum clamp ); The target must be GL_CLAMP_READ_COLOR. The clamp can be set to one of the following: GL_TRUE: Clamping is always on, no matter what the format or type parameters of the read pixels call. GL_FALSE: Clamping is always off, no matter what the format or type parameters of the read pixels call. GL_FIXED_ONLY: Clamping is only on if the type of the image being read is a normalized signed or unsigned value. Note that the clamping behavior is not framebuffer object state. It will not be stored with the current framebuffer.","title":"Read color clamping"},{"location":"GLES/Framebuffer%20Object/#invalidation","text":"The contents of a framebuffer can be invalidated. This means that the application is no longer interested in whatever pixel data happens to be stored in any images in that part of the framebuffer. Invalidation is useful, as it allows the implementation to allocate new memory if asynchronous commands are working with the previously invalidated framebuffer images. In particular, invalidation after asynchronous pixel reads are quite useful. To invalidate the framebuffer as a whole, the following function is used: glInvalidateFramebuffer (GLenum target , GLsizei numAttachments , const GLenum * attachments ) The framebuffer bound to target will be invalidated. The specific images in the framebuffer to be invalidated are specified by the array attachments , which must have numAttachments entries in it. The entries in the array must be names of specific images in the framebuffer. For user-created Framebuffer Objects, these must be the names of one of the available attachment points. For the default framebuffer, the names can be one of the images in the default framebuffer ; none of the color buffer's aliases work here. The default framebuffer can also use the names GL_COLOR (which means GL_BACK_LEFT if double-buffered and GL_FRONT_LEFT if single-bufferred. Instead of invalidating whole sets of images in the framebuffer, a portion of the framebuffer can be invalidated instead: glInvalidateSubFramebuffer (GLenum target , GLsizei numAttachments , const GLenum * attachments , GLint x , GLint y , GLint width , GLint height ) The x , y , width , and height parameters specify a rectangular region of the specified images to invalidate. After invalidation, the contents of pixels stored in those areas are undefined. You can clear them to a set value after invalidation.","title":"Invalidation"},{"location":"GLES/Framebuffer%20Object/#blitting","text":"Framebuffers can be bound to two separate targets with glBindFramebuffer : GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER. Binding to GL_FRAMEBUFFER is equivalent to binding the framebuffer to both. The reason for the separation of these targets is to allow data in one framebuffer to be blitted to another framebuffer. A blit operation is a special form of copy operation; it copies a rectangular area of pixels from one framebuffer to another. This function also has some very specific properties with regard to multisampling . Framebuffer blitting commands are considered Rendering Commands . Therefore, they are affected by Conditional Rendering . However, they do not invoke most parts of the Rendering Pipeline . Blits are affected by the Scissor Test (they always use viewport index 0) as well as the Pixel Ownership Test , but are not affected by the Write Mask , Depth Test or any other parts of the rendering pipeline. You bind the source framebuffer to GL_READ_FRAMEBUFFER, then bind the destination framebuffer to GL_DRAW_FRAMEBUFFER. The read framebuffer is the source of the blit, and the draw framebuffer is the destination. The read and draw framebuffers can be the same. After binding the framebuffers, you call this function: void glBlitFramebuffer( GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); The pixels in the rectangular area specified by the src values are copied to the rectangular area specified by the dst values. The mask parameter is a bitfield that specifies which kinds of buffers you want copied: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT, or some combination. The filter parameter specifies how you want filtering performed if the two rectangles are not the same size. One thing to keep in mind is this: when using GL_COLOR_BUFFER_BIT, the only colors read will come from the read color buffer in the read FBO, specified by glReadBuffer . The colors written will only go to the draw color buffers in the write FBO, specified by glDrawBuffers . If multiple draw buffers are specified, then multiple color buffers are updated with the same data. The depth and stencil buffers of the source framebuffers are blitted to the depth and stencil buffers of the destination if the mask specifies them. Note that it is perfectly valid to blit from or to the Default Framebuffer . If one (or both) of the framebuffers is a layered framebuffer (blitting fails if the framebuffers are incomplete. So they will be either all layered or all not layered), then blitting happens rather oddly. Only layer 0 will be read and only layer 0 will be written . This is true even if both the read and draw FBOs are layered and have the same number of layers. If you want to blit other layers, you will have to bind those layers to some other FBO and blit from/to that new FBO.","title":"Blitting"},{"location":"GLES/Framebuffer%20Object/#format-considerations","text":"Blitting is not the same as performing a pixel transfer or a texture copy . The conversion between source and destination format is more limited. Blitting depth and stencil buffers works as expected: values are converted from one bitdepth to the other as needed. Conversion between color formats is different. A blit operation can only convert between formats within 3 groups. Signed integral and unsigned integral formats make up two groups, with all normalized and floating-point formats making up the third. Thus, it is legal to blit from an GL_RGB8 buffer to a GL_RGB32F and vice versa. But it is not legal to blit a GL_RGB8 from or to a GL_RGBI8 format image. The data during blitting is converted according to simple rules. Blitting from a floating-point format to a normalized integer format will cause clamping, either to [0, 1] for unsigned normalized or [-1, 1] for signed normalized.","title":"Format Considerations"},{"location":"GLES/Framebuffer%20Object/#multisampling-considerations","text":"Multisampling is supported with the Default Framebuffer (through WGL/GLX_multisample) and/or Framebuffer Objects (through multisampled renderbuffers or textures , where supported). As explained in the article on Multisampling , a multisampled buffer must be resolved into a single sample before it can be displayed. When the default framebuffer uses multisampling, this resolving operation is automatic, occurring during framebuffer swapping (though reading from the framebuffer can cause it to happen anyway). Each framebuffer has a specific number of samples; for Framebuffer Objects , they cannot be framebuffer-complete if all of the attached images do not have the same number of samples. A sample count of zero represents a framebuffer that is not multisampled. If you perform a blit operation and and at least one of the framebuffers is multisampled, then the source and destination sizes must be the same. That is, you cannot do multisampled blits and rescaling at the same time. If you blit between two framebuffers with the same number of samples, the copy is done directly; the destination buffer gets the same information the source had. It is an error to blit between framebuffers with different numbers of samples, unless one of the framebuffers has zero samples. Blitting from a non-multisampled framebuffer to a multisampled framebuffer causes all of samples in a pixel of the draw framebuffer to get the same value from the corresponding pixel in the read framebuffer. Blitting from a multisampled framebuffer to a non-multisampled framebuffer performs a multisample resolve operation, computing the value of a draw framebuffer's pixel from all of the samples in the corresponding pixel of the read framebuffer. This explicit resolve operation is very useful when wanting to display multisampled buffers. As with all multisample behavior, none of this works at all unless glEnable(GL_MULTISAMPLE) is in effect (which is the default).","title":"Multisampling Considerations"},{"location":"GLES/GLES%20Draw%20APIs/","text":"Drawing Commands For all the functions in this section: mode: GL_POINTS GL_LINE_STRIP GL_LINE_LOOP GL_LINES GL_TRIANGLE_STRIP GL_TRIANGLE_FAN GL_TRIANGLES 3.2 \u65b0\u589e\u56db\u4e2a\u90bb\u63a5\u6a21\u5f0f (Adjacency mode) GL_LINE_STRIP_ADJACENCY GL_LINES_ADJACENCY GL_TRIANGLE_STRIP_ADJACENCY GL_TRIANGLES_ADJACENCY type: UNSIGNED_{BYTE, SHORT, INT} void DrawArrays (enum mode, int first, sizei count); void DrawElements (enum mode, sizei count, enum type, const void *indices); void DrawRangeElements (enum mode, uint start, uint end, sizei count, enum type, const void *indices); void DrawArraysInstanced (enum mode, int first, sizei count, sizei instancecount); void DrawElementsInstanced (enum mode, sizei count, enum type, const void *indices, sizei instancecount); void DrawArraysIndirect (enum mode, const void *indirect); void DrawElementsIndirect (enum mode, enum type, const void *indirect); void DrawElementsBaseVertex (enum mode, sizei count, enum type, const void *indices, int basevertex); void DrawRangeElementsBaseVertex (enum mode, uint start, uint end, sizei count, enum type, const void *indices, int basevertex); void DrawElementsInstancedBaseVertex (enum mode, sizei count,enum type, const void *indices, sizei instancecount, int basevertex); Drawing Commands 2.0 3.0 3.1 3.2 Note glDrawArrays \u221a glDrawElements \u221a glDrawRangeElements \u221a glDrawArraysInstanced \u221a glDrawElementsInstanced \u221a glDrawArraysIndirect \u221a glDrawElementsIndirect \u221a glDrawElementsBaseVertex \u221a glDrawRangeElementsBaseVertex \u221a glDrawElementsInstancedBaseVertex \u221a Mode \u7ed8\u5236mode\u5373\u901a\u8fc7\u7ed8\u5236\u6a21\u5f0f\u6765\u6307\u5b9a \u56fe\u5143 \u7684\u7ed8\u5236\u6a21\u5f0f. \u6e32\u67d3\u7684\u65f6\u5019\u9700\u8981\u6307\u5b9a\u4e00\u4e2a\u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\u3002 TODO \u4f7f\u7528\u573a\u666f\u53ca\u5bf9\u6bd4. 1. \u70b9 \u5bf9\u5e94\u7684\u6a21\u5f0f\u4e3a GL_POINTS \uff0c\u5373\u5728\u6bcf\u4e2a\u9876\u70b9\u4f4d\u7f6e\u7ed8\u5236\u4e00\u4e2a\u70b9\u3002OpenGL ES \u4e2d\u7ed8\u5236\u7684\u70b9\u5b9e\u5219\u662f\u4e00\u4e2a\u65b9\u5757\uff0c\u9876\u70b9\u4f4d\u7f6e\u662f\u65b9\u5757\u7684\u4e2d\u5fc3\u70b9\uff0c\u8fb9\u957f\u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7531\u5185\u5efa\u53d8\u91cf gl_PointSize \u6307\u5b9a\u3002 \u70b9\u7684\u5c3a\u5bf8\u5927\u5c0f\u8303\u56f4\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u65b9\u5f0f\u83b7\u53d6\uff1a GLfloat pointSizeRange[2]; glGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, pointSizeRange); 12 \u5982\u679c\u6211\u4eec\u60f3\u81ea\u5b9a\u4e49\u70b9\u7684\u5916\u5f62\uff0c\u901a\u5e38\u53ef\u4ee5\u4f7f\u7528\u7eb9\u7406\u3002\u4e00\u4e2a\u4f7f\u7528\u7eb9\u7406\u7684\u7247\u6bb5\u7740\u8272\u5668\u793a\u4f8b\u5982\u4e0b\uff1a #version 300 es precision mediump float; uniform sampler2D u_TextureUnit; layout(location = 0) out vec4 outColor; void main() { outColor = texture2D(u_TextureUnit, gl_PointCoord); } 123456789 \u8fd9\u6837\u6211\u4eec\u5728\u5916\u9762\u7ed9 u_TextureUnit \u6307\u5b9a\u7eb9\u7406\u7684 id \u5373\u53ef\uff0c\u5173\u4e8e\u7eb9\u7406\u7684\u76f8\u5173\u4f7f\u7528\u540e\u7eed\u6587\u7ae0\u518d\u4ecb\u7ecd\u3002 \u8fd8\u6709\u4e0a\u4f8b\u4e2d\u6211\u4eec\u4f7f\u7528\u5230\u4e86\u4e00\u4e2a\u5185\u5efa\u53d8\u91cf gl_PointCoord \uff0c\u5b83\u53ea\u5728\u7ed8\u5236\u70b9\u7cbe\u7075\u65f6\u53ef\u4ee5\u4f7f\u7528\uff0c\u63cf\u8ff0\u4e86\u8fd9\u4e2a\u70b9\u5185\u90e8\u7684\u5750\u6807\u7a7a\u95f4\uff0c\u5176\u5de6\u4e0a\u89d2\u4e3a (0, 0)\uff0c\u53f3\u4e0b\u89d2\u4e3a (1, 1)\u3002 2. \u76f4\u7ebf \u5bf9\u5e94\u7684\u6a21\u5f0f\u4e3a GL_LINES \u3001 GL_LINE_LOOP \u3001 GL_LINE_STRIP \uff0c\u7528\u6307\u5b9a\u7684\u9876\u70b9\u7ed8\u5236\u76f8\u5e94\u7684\u7ebf\u6bb5\u3002 \u5982\u56fe\uff0c\u5047\u8bbe\u6307\u5b9a\u7684\u9876\u70b9\u5750\u6807\u4e3a (v0, v1, v2, v3)\uff0c\u90a3\u4e48 GL_LINES \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1) \u548c (v2, v3) \u8fd9\u4e24\u6761\u7ebf\u6bb5 GL_LINE_STRIP \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1)\u3001(v1, v2) \u548c (v2, v3) \u4e09\u6761\u7ebf\u6bb5 GL_LINE_LOOP \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1)\u3001(v1, v2)\u3001(v2, v3) \u548c (v3, v0) \u56db\u6761\u7ebf\u6bb5 \u7ebf\u6bb5\u7684\u5bbd\u5ea6\u4f7f\u7528\u5982\u4e0b API \u6307\u5b9a\uff1a /** * @param width \u7ebf\u5bbd\uff0c\u4ee5\u50cf\u7d20\u6570\u8868\u793a\uff0c\u9ed8\u8ba4\u7684\u5bbd\u5ea6\u4e3a 1.0 */ void glLineWidth(GLFloat width); 1234 \u6307\u5b9a\u7684\u7ebf\u5bbd\u5c06\u88ab OpenGL \u8bb0\u4f4f\uff0c\u76f4\u5230\u7531\u5e94\u7528\u7a0b\u5e8f\u66f4\u65b0\u3002 \u652f\u6301\u7684\u7ebf\u5bbd\u8303\u56f4\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u65b9\u5f0f\u83b7\u53d6\uff1a GLfloat lineWidthRange[2]; glGetFloatv(GL_ALIASED_LINE_WIDTH_RANGE, lineWidthRange); 12 3. \u4e09\u89d2\u5f62 \u5bf9\u5e94\u7684\u6a21\u5f0f\u4e3a GL_TRIANGLES \u3001 GL_TRIANGLE_STRIP \u3001 GL_TRIANGLE_FAN \u3002\u4e09\u89d2\u5f62\u56fe\u5143\u53ef\u8c13\u662f\u6700\u5e38\u4f7f\u7528\u7684\u4e86\u3002 \u5982\u56fe\uff0c\u5047\u8bbe\u6307\u5b9a\u7684\u9876\u70b9\u5750\u6807\u4e3a\u4e0a\u56fe\u6240\u793a\uff0c\u90a3\u4e48 GL_TRIANGLES \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1, v2) \u548c (v3, v4, v5) \u8fd9\u4e24\u4e2a\u4e09\u89d2\u5f62\u3002 GL_TRIANGLE_STRIP \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1, v2)\u3001(v2, v1, v3) \uff08\u6ce8\u610f\u987a\u5e8f\uff09\u548c (v2, v3, v4) \u4e09\u4e2a\u4e09\u89d2\u5f62\u3002 GL_TRIANGLE_FAN \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1, v2)\u3001(v0, v2, v3) \u548c (v0, v3, v4) \u4e09\u4e2a\u4e09\u89d2\u5f62\u3002 4. 3.2 \u65b0\u589e Adjacent Mode IndexType type: UNSIGNED_BYTE, UNSIGNED_SHORT, UNSIGNED_INT 2.0 \u57fa\u7840\u7ed8\u5236 /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param first \u8d77\u59cb\u4f4d\u7f6e * @param count \u9876\u70b9\u6570\u91cf */ void glDrawArrays(GLenum mode, GLint first, GLsizei count); /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param count \u9876\u70b9\u6570\u91cf * @param type \u5143\u7d20\u7c7b\u578b\uff0c\u6709\uff1aGL_UNSIGNED_BYTE\u3001GL_UNSIGNED_SHORT\u3001GL_UNSIGNED_INT * @param indices \u5143\u7d20\u7d22\u5f15\u6570\u7ec4 */ void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void *indices); \u533a\u522b \u9996\u5148\uff0c\u8fd9\u4e24\u4e2a\u51fd\u6570\u7684\u4f5c\u7528\u90fd\u662f\u4ece\u4e00\u4e2a\u6570\u636e\u6570\u7ec4\u4e2d\u63d0\u53d6\u6570\u636e\uff0c\u7136\u540e\u6e32\u67d3\u56fe\u5143\u3002 \u533a\u522b\u5728\u4e8e\uff1a glDrawArrays \u662f\u76f4\u63a5\u7ed8\u5236\u771f\u5b9e\u7684\u9876\u70b9\u6570\u636e\uff0c\u800c glDrawElements \u662f\u6309\u7167\u6307\u5b9a\u7684\u7d22\u5f15\u987a\u5e8f\u53d6\u51fa\u771f\u5b9e\u6570\u636e\u518d\u7ed8\u5236\u3002 \u4e8e\u662f\u5bf9\u4e8e\u9876\u70b9\u5b58\u5728\u5171\u4eab\u7684\u573a\u666f\u65f6\uff0c\u4f7f\u7528 glDrawElements \u5bf9\u4e8e\u91cd\u590d\u7684\u9876\u70b9\u6570\u636e\u53ea\u9700\u8981\u4f20\u8f93\u4e00\u4efd\u6570\u636e\uff0c\u7ed8\u5236\u65f6\u901a\u8fc7\u7d22\u5f15\u53cd\u590d\u7684\u83b7\u53d6\u5176\u503c\uff0c\u6700\u7ec8\u964d\u4f4e\u5185\u5b58\u5360\u7528\u548c\u5185\u5b58\u5e26\u5bbd\u9700\u6c42\u3002 3.0 \u65b0\u589e\u7684\u7ed8\u5236\u63a5\u53e3: Instanced \u591a\u5b9e\u4f8b\u6e32\u67d3 \u5728 OpenGL ES 3.0 \u4e2d\u65b0\u589e\u4e86\u51e0\u4e2a\u7ed8\u5236\u56fe\u5143\u7684\u63a5\u53e3\u3002 1. glDrawRangeElements /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param start \u8d77\u59cb\u7d22\u5f15\u4f4d\u7f6e * @param end \u7ed3\u675f\u7d22\u5f15\u4f4d\u7f6e * @param count \u9876\u70b9\u6570\u91cf * @param type \u5143\u7d20\u7c7b\u578b\uff0c\u6709\uff1aGL_UNSIGNED_BYTE\u3001GL_UNSIGNED_SHORT\u3001GL_UNSIGNED_INT * @param indices \u5143\u7d20\u7d22\u5f15\u6570\u7ec4 */ void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices); \u76f8\u6bd4\u4e8e glDrawElements \u63a5\u53e3\uff0c\u5b83\u65b0\u589e\u4e86 start \uff0c end \u4e24\u4e2a\u53c2\u6570\uff0c\u7528\u6765\u6307\u5b9a\u4f7f\u7528\u7684\u6570\u636e\u6570\u7ec4\u7684\u8d77\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e\u3002\u5176\u4f59\u533a\u522b\u4e0d\u5927\u3002 glDrawElementsInstanced \u548c glDrawArraysInstanced \u591a\u5b9e\u4f8b\u6e32\u67d3 Learn GL: \u591a\u5b9e\u4f8b\u6e32\u67d3 \u573a\u666f \u5047\u8bbe\u4f60\u6709\u4e00\u4e2a\u7ed8\u5236\u4e86\u5f88\u591a\u6a21\u578b\u7684\u573a\u666f\uff0c\u800c\u5927\u90e8\u5206\u7684\u6a21\u578b\u5305\u542b\u7684\u662f\u540c\u4e00\u7ec4\u9876\u70b9\u6570\u636e\uff0c\u53ea\u4e0d\u8fc7\u8fdb\u884c\u7684\u662f\u4e0d\u540c\u7684\u4e16\u754c\u7a7a\u95f4\u53d8\u6362\u3002\u60f3\u8c61\u4e00\u4e2a\u5145\u6ee1\u8349\u7684\u573a\u666f\uff1a\u6bcf\u6839\u8349\u90fd\u662f\u4e00\u4e2a\u5305\u542b\u51e0\u4e2a\u4e09\u89d2\u5f62\u7684\u5c0f\u6a21\u578b\u3002\u4f60\u53ef\u80fd\u4f1a\u9700\u8981\u7ed8\u5236\u5f88\u591a\u6839\u8349\uff0c\u6700\u7ec8\u5728\u6bcf\u5e27\u4e2d\u4f60\u53ef\u80fd\u4f1a\u9700\u8981\u6e32\u67d3\u4e0a\u5343\u6216\u8005\u4e0a\u4e07\u6839\u8349\u3002\u56e0\u4e3a\u6bcf\u4e00\u6839\u8349\u4ec5\u4ec5\u662f\u7531\u51e0\u4e2a\u4e09\u89d2\u5f62\u6784\u6210\uff0c\u6e32\u67d3\u51e0\u4e4e\u662f\u77ac\u95f4\u5b8c\u6210\u7684\uff0c\u4f46\u4e0a\u5343\u4e2a\u6e32\u67d3\u51fd\u6570\u8c03\u7528\u5374\u4f1a\u6781\u5927\u5730\u5f71\u54cd\u6027\u80fd\u3002 \u5982\u679c\u6211\u4eec\u80fd\u591f\u5c06\u6570\u636e\u4e00\u6b21\u6027\u53d1\u9001\u7ed9GPU\uff0c\u7136\u540e\u4f7f\u7528\u4e00\u4e2a\u7ed8\u5236\u51fd\u6570\u8ba9OpenGL\u5229\u7528\u8fd9\u4e9b\u6570\u636e\u7ed8\u5236\u591a\u4e2a\u7269\u4f53\uff0c\u5c31\u4f1a\u66f4\u65b9\u4fbf\u4e86\u3002\u8fd9\u5c31\u662f\u5b9e\u4f8b\u5316(Instancing)\u3002 \u5b9e\u4f8b\u5316\uff08instancing) \u5b9e\u4f8b\u5316\u8fd9\u9879\u6280\u672f\u80fd\u591f\u8ba9\u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u6e32\u67d3\u8c03\u7528\u6765\u7ed8\u5236\u591a\u4e2a\u7269\u4f53\uff0c\u6765\u8282\u7701\u6bcf\u6b21\u7ed8\u5236\u7269\u4f53\u65f6CPU -> GPU\u7684\u901a\u4fe1\uff0c\u5b83\u53ea\u9700\u8981\u4e00\u6b21\u5373\u53ef\u3002 \u5982\u679c\u60f3\u4f7f\u7528\u5b9e\u4f8b\u5316\u6e32\u67d3\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5c06glDrawArrays\u548cglDrawElements\u7684\u6e32\u67d3\u8c03\u7528\u5206\u522b\u6539\u4e3aglDrawArraysInstanced\u548cglDrawElementsInstanced\u5c31\u53ef\u4ee5\u4e86\u3002\u8fd9\u4e9b\u6e32\u67d3\u51fd\u6570\u7684 \u5b9e\u4f8b\u5316 \u7248\u672c\u9700\u8981\u4e00\u4e2a\u989d\u5916\u7684\u53c2\u6570\uff0c\u53eb\u505a\u5b9e\u4f8b\u6570\u91cf(Instance Count)\uff0c\u5b83\u80fd\u591f\u8bbe\u7f6e\u6211\u4eec\u9700\u8981\u6e32\u67d3\u7684\u5b9e\u4f8b\u4e2a\u6570\u3002\u8fd9\u6837\u6211\u4eec\u53ea\u9700\u8981\u5c06\u5fc5\u987b\u7684\u6570\u636e\u53d1\u9001\u5230GPU\u4e00\u6b21\uff0c\u7136\u540e\u4f7f\u7528\u4e00\u6b21\u51fd\u6570\u8c03\u7528\u544a\u8bc9GPU\u5b83\u5e94\u8be5\u5982\u4f55\u7ed8\u5236\u8fd9\u4e9b\u5b9e\u4f8b\u3002GPU\u5c06\u4f1a\u76f4\u63a5\u6e32\u67d3\u8fd9\u4e9b\u5b9e\u4f8b\uff0c\u800c\u4e0d\u7528\u4e0d\u65ad\u5730\u4e0eCPU\u8fdb\u884c\u901a\u4fe1\u3002 glDrawElementsInstanced \u548c glDrawArraysInstanced glDrawArraysInstanced \u51fd\u6570\u662f glDrawArrays \u7684\u591a\u5b9e\u4f8b\u7248\u672c\uff0c\u53c2\u6570\u5b8c\u5168\u7b49\u4ef7\uff0c\u53ea\u662f\u591a\u4e86\u4e2ainstance count\uff0c\u8be5\u53c2\u6570\u7528\u4e8e\u8bbe\u7f6e\u6e32\u67d3\u5b9e\u4f8b\u4e2a\u6570\u3002\u4f8b\u5982\u6211\u4eec\u60f3\u8981\u4e00\u6b21\u6279\u91cf\u7ed8\u5236 100 \u4e2a\u76f8\u4f3c\u7684\u56fe\u5143\uff0c\u8fd9\u4e2a\u503c\u5bf9\u5e94\u5c31\u4f20 100\u3002 /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param first \u8d77\u59cb\u4f4d\u7f6e: \u4ece\u6570\u7ec4\u7f13\u5b58\u4e2d\u7684\u54ea\u4e00\u4f4d\u5f00\u59cb\u7ed8\u5236\uff0c\u4e00\u822c\u4e3a0\u3002 * @param count \u9876\u70b9\u6570\u91cf * @param instancecount \u7ed8\u5236\u7684\u5b9e\u4f8b\u6570\u91cf */ void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount); glDrawElementsInstanced \u662f glDrawElements \u7684\u591a\u5b9e\u4f8b\u7248\u672c\uff0c\u540c\u6837\u53ea\u662f\u591a\u4e86\u4e2ainstance count\u53c2\u6570\u800c\u5df2\uff0c\u540c\u6837\u662f\u7528\u4e8e\u8bbe\u7f6e\u6e32\u67d3\u5b9e\u4f8b\u4e2a\u6570\u3002 /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param count \u9876\u70b9\u6570\u91cf * @param type \u5143\u7d20\u7c7b\u578b\uff0c\u6709\uff1aGL_UNSIGNED_BYTE\u3001GL_UNSIGNED_SHORT\u3001GL_UNSIGNED_INT * @param indices \u5143\u7d20\u7d22\u5f15\u7684\u6307\u9488 * @param instancecount \u7ed8\u5236\u7684\u56fe\u5143\u5b9e\u4f8b\u6570\u91cf */ void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount); \u53d8\u91cf\u63a7\u5236 gl_InstanceID \u8fd9\u4e2a\u51fd\u6570\u672c\u8eab\u5e76\u6ca1\u6709\u4ec0\u4e48\u7528\u3002\u6e32\u67d3\u540c\u4e00\u4e2a\u7269\u4f53\u4e00\u5343\u6b21\u5bf9\u6211\u4eec\u5e76\u6ca1\u6709\u4ec0\u4e48\u7528\u5904\uff0c\u6bcf\u4e2a\u7269\u4f53\u90fd\u662f\u5b8c\u5168\u76f8\u540c\u7684\uff0c\u800c\u4e14\u8fd8\u5728\u540c\u4e00\u4e2a\u4f4d\u7f6e\u3002\u6211\u4eec\u53ea\u80fd\u770b\u89c1\u4e00\u4e2a\u7269\u4f53\uff01\u5904\u4e8e\u8fd9\u4e2a\u539f\u56e0\uff0cGLSL\u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u5d4c\u5165\u4e86\u53e6\u4e00\u4e2a\u5185\u5efa\u53d8\u91cf\uff0cgl_InstanceID\u3002 \u53d8\u91cf\u6570\u7ec4\u9700\u8981\u4f7f\u7528 uniform \u6570\u7ec4\u8f6c\u5165GLSL. \u4f8b\u5982\u4e0b\u4f8b\u4e2d \u4f7f\u7528\u4e86\u5927\u5c0f100\u7684 uniform\u6570\u7ec4\u8f6c\u5165 offset: gl_InstanceID \u5f88\u65b9\u4fbf, \u4f46\u4f1a\u5f88\u5feb\u8fbe\u5230uniform\u6570\u636e\u5927\u5c0f \u4e0a\u9650 , \u9700\u8981\u6ce8\u610f\u6570\u91cf. #version 330 core layout (location = 0) in vec2 aPos; layout (location = 1) in vec3 aColor; out vec3 fColor; uniform vec2 offsets[100]; void main() { vec2 offset = offsets[gl_InstanceID]; gl_Position = vec4(aPos + offset, 0.0, 1.0); fColor = aColor; } Instanced Array \u7531\u4e8e\u5b9e\u4f8b\u592a\u591a\u65f6, \u4f7f\u7528 gl_InstanceID \u5bb9\u6613\u4f7funiform \u8d85\u9650, \u5b83\u7684\u4e00\u4e2a\u4ee3\u66ff\u65b9\u6848\u662f\u5b9e\u4f8b\u5316\u6570\u7ec4(Instanced Array)\uff0c\u5b83\u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u9876\u70b9\u5c5e\u6027\uff08\u80fd\u591f\u8ba9\u6211\u4eec\u50a8\u5b58\u66f4\u591a\u7684\u6570\u636e\uff09\uff0c\u4ec5\u5728\u9876\u70b9\u7740\u8272\u5668\u6e32\u67d3\u4e00\u4e2a\u65b0\u7684\u5b9e\u4f8b\u65f6\u624d\u4f1a\u66f4\u65b0\u3002 #version 330 core layout (location = 0) in vec2 aPos; layout (location = 1) in vec3 aColor; layout (location = 2) in vec2 aOffset; out vec3 fColor; void main() { gl_Position = vec4(aPos + aOffset, 0.0, 1.0); fColor = aColor; } 3. \u591a\u5b9e\u4f8b\u6e32\u67d3\u9876\u70b9\u5c5e\u6027\u63a7\u5236 \u591a\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027, \u591a\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027\uff0c\u4e0e\u5176\u4ed6\u7684\u9876\u70b9\u5c5e\u6027\u662f\u7c7b\u4f3c\u7684\u3002\u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684\u58f0\u660e\u548c\u6570\u636e\u914d\u7f6e\u65b9\u6cd5\u5b8c\u5168\u4e00\u81f4. \u5b83\u4eec\u53ef\u4ee5\u4f7f\u7528 APIs: glGetAttribLocation \u67e5\u8be2 glVertexAttribPointer \u8bbe\u7f6e glEnableVertexAttribArray \u542f\u7528 glDisableVertexAttribArray \u7981\u7528 \u591a\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027\u7684\u552f\u4e00\u7684\u533a\u522b\u5c31\u662f \u6b63\u5e38\u7684\u9876\u70b9\u5c5e\u6027: \u9488\u5bf9\u7684\u662f\u5355\u4e00\u9876\u70b9 \u591a\u5b9e\u4f8b\u9876\u70b9\u5c5e\u6027: \u9488\u5bf9\u7684\u662f\u4e00\u4e2a\u56fe\u5143\u5b9e\u4f8b\u3002 \u7b80\u5355\u7684\u7406\u89e3\u5c31\u662f\u9876\u70b9\u7740\u8272\u5668\u7684\u8f93\u5165\u6b63\u5e38\u60c5\u51b5\u662f\u4e00\u4e2a\u9876\u70b9\u5c5e\u6027\u5bf9\u5e94\u4e00\u4e2a\u9876\u70b9\uff0c\u800c\u6240\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027\u662f\u4e00\u4e2a\u5c5e\u6027\u5bf9\u4ee5\u4e00\u4e2a\u56fe\u5143\uff08\u56fe\u5143\u4e2d\u6240\u6709\u7684\u9876\u70b9\u7684\u8fd9\u4e00\u6761\u5c5e\u6027\u5171\u7528\u540c\u4e00\u4e2a\u6570\u636e\uff09\uff0c\u5373\u6bcf\u4e2a\u5b9e\u4f8b\u66f4\u65b0\u4e00\u6b21\u8fd9\u4e2a\u5c5e\u6027\u7684\u6570\u636e\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e2a\u529f\u80fd\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u51fd\u6570\uff1a /** * @param index \u5bf9\u5e94\u7740\u8272\u5668\u4e2d\u7684\u5b9e\u4f8b\u53d8\u91cf\u7684\u7d22\u5f15, \u4f8b\u5982 offset \u3002 * @param divisor \u8868\u793a\u9876\u70b9\u5c5e\u6027\u7684\u66f4\u65b0\u9891\u7387\uff0c\u6bcf\u9694\u591a\u5c11\u4e2a\u5b9e\u4f8b\u5c06\u91cd\u65b0\u8bbe\u7f6e\u5b9e\u4f8b\u7684\u8be5\u5c5e\u6027\uff0c * \u4f8b\u5982\u8bbe\u7f6e\u4e3a 1 \u90a3\u4e48\u6bcf\u4e2a\u5b9e\u4f8b\u7684\u5c5e\u6027\u90fd\u4e0d\u4e00\u6837\uff0c \u8bbe\u7f6e\u4e3a2\u5219\u6bcf\u4e24\u4e2a\u5b9e\u4f8b\u76f8\u540c\u3002 * \u5982\u679cdivisor\u7684\u503c\u662f0\uff0c\u8868\u793a\u591a\u5b9e\u4f8b\u7279\u6027\u88ab\u7981\u7528 */ void glVertexAttribDivisor (GLuint index, GLuint divisor) 4. \u4ee3\u7801\u5b9e\u4f8b \u521b\u5efa\u7740\u8272\u5668: \u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u6211\u4eec\u589e\u52a0\u4e00\u4e2a\u504f\u79fb\u91cf\u7684\u5c5e\u6027\uff08attribute vec3 offset\uff09 \u5728\u6bcf\u6b21\u7ed8\u5236\u4e4b\u540e\u5b83\u7684\u503c\u4f1a\u53d1\u751f\u504f\u79fb\u3002\u901a\u8fc7 glVertexAttribDivisor \u6765\u8bbe\u7f6e\u5982\u4f55\u504f\u79fb\u3002 fragment shader precision mediump float; uniform sampler2D image; varying vec2 vTexcoord; void main() { gl_FragColor = texture2D(image, vTexcoord); } vertex shader attribute vec3 position; attribute vec3 offset; //\u504f\u79fb\u91cf attribute vec2 texcoord; varying vec2 vTexcoord; void main() { gl_Position = vec4(position + offset, 1.0); vTexcoord = texcoord; } \u8bbe\u7f6e\u9876\u70b9\u5c5e\u6027\u3002\u8bbe\u7f6e\u9876\u70b9\u5c5e\u6027\u65b9\u4fbf\u6211\u4eec\u8fdb\u884c\u7eb9\u7406\u8d34\u56fe\u3002 - (void)setupVBO { _vertCount = 6; GLfloat vertices[] = { -0.5f, 1.0f, 0.0f, 1.0f, 0.0f, // \u53f3\u4e0a -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, // \u53f3\u4e0b -1.0f, 0.5f, 0.0f, 0.0f, 1.0f, // \u5de6\u4e0b -1.0f, 0.5f, 0.0f, 0.0f, 1.0f, // \u5de6\u4e0b -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, // \u5de6\u4e0a -0.5f, 1.0f, 0.0f, 1.0f, 0.0f, // \u53f3\u4e0a }; // \u521b\u5efaVBO _vbo = createVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW, sizeof(vertices), vertices); // Vertex Attrib: position glEnableVertexAttribArray(glGetAttribLocation(_program, \"position\")); glVertexAttribPointer(glGetAttribLocation(_program, \"position\"), 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, NULL); // Vertex Attrib: texcoord glEnableVertexAttribArray(glGetAttribLocation(_program, \"texcoord\")); glVertexAttribPointer(glGetAttribLocation(_program, \"texcoord\"), 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, NULL+sizeof(GL_FLOAT)*3); } \u8bbe\u7f6e\u7eb9\u7406 \u901a\u8fc7\u8bfb\u53d6\u7eb9\u7406\u56fe\u7247\uff0c\u751f\u6210\u7eb9\u7406\u7f13\u5b58\u5bf9\u8c61\u3002 \u8bbe\u7f6e\u504f\u79fb\u91cf \u504f\u79fb\u91cf\u548c\u666e\u901a\u7684\u9876\u70b9\u6570\u636e\u4e00\u6837\u53ef\u4ee5\u4f7f\u7528VBO\u6765\u5b58\u50a8\u3002 \u6211\u4eec\u5e0c\u671b\u6bcf\u6b21\u7ed8\u5236\u9876\u70b9\u6570\u7ec4\u90fd\u53d1\u751f\u4e00\u5b9a\u7684\u504f\u79fb\uff0c\u603b\u5171\u53d1\u751f\u4e09\u6b21\u504f\u79fb\uff08gl_Position = vec4(position+offset, 1.0)\uff09\u3002\u8fd9\u6837\u6211\u4eec\u603b\u5171\u9700\u89819\u4e2aGLfloat\u7684\u7a7a\u95f4\u6765\u5b58\u50a8\u504f\u79fb\u6570\u636e\u3002 - (void)setupOffset { GLfloat vertices[] = { 0.1f, -0.1f, 0.0f, 0.7f, -0.7f, 0.0f, 1.3f, -1.3f, 0.0f, }; // \u521b\u5efaVBO _offsetVBO = createVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW, sizeof(vertices), vertices); glEnableVertexAttribArray(glGetAttribLocation(_program, \"offset\")); glVertexAttribPointer(glGetAttribLocation(_program, \"offset\"), 3, GL_FLOAT, GL_FALSE, 0, NULL); } \u7ed8\u5236 - (void)render { glClearColor(1.0, 1.0, 1.0, 1.0); glClear(GL_COLOR_BUFFER_BIT); glLineWidth(2.0); glViewport(0, 0, self.frame.size.width, self.frame.size.height); // \u6fc0\u6d3b\u7eb9\u7406 glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, _texture); glUniform1i(glGetUniformLocation(_program, \"image\"), 0); // \u6bcf\u6b21\u7ed8\u5236\u4e4b\u540e\uff0c\u5bf9offset\u8fdb\u884c1\u4e2a\u504f\u79fb glVertexAttribDivisor(glGetAttribLocation(_program, \"offset\"), 1); // \u7ed8\u5236 3 \u4e2a\u5b9e\u4f8b, \u6bcf\u4e2a\u5b9e\u4f8b\u5bf9\u5e94\u4e00\u4e2a offset vector glDrawArraysInstanced(GL_TRIANGLES, 0, _vertCount, 3); //\u5c06\u6307\u5b9a renderbuffer \u5448\u73b0\u5728\u5c4f\u5e55\u4e0a\uff0c\u5728\u8fd9\u91cc\u6211\u4eec\u6307\u5b9a\u7684\u662f\u524d\u9762\u5df2\u7ecf\u7ed1\u5b9a\u4e3a\u5f53\u524d renderbuffer \u7684\u90a3\u4e2a\uff0c\u5728 renderbuffer \u53ef\u4ee5\u88ab\u5448\u73b0\u4e4b\u524d\uff0c\u5fc5\u987b\u8c03\u7528renderbufferStorage:fromDrawable: \u4e3a\u4e4b\u5206\u914d\u5b58\u50a8\u7a7a\u95f4\u3002 [_context presentRenderbuffer:GL_RENDERBUFFER]; } \u590d\u6742\u70b9\u7684\u4f8b\u5b50 #version 330 core layout (location = 0) in vec3 aPos; layout (location = 2) in vec2 aTexCoords; layout (location = 3) in mat4 instanceMatrix; out vec2 TexCoords; uniform mat4 projection; uniform mat4 view; void main() { gl_Position = projection * view * instanceMatrix * vec4(aPos, 1.0); TexCoords = aTexCoords; } \u6211\u4eec\u4e0d\u518d\u4f7f\u7528\u6a21\u578buniform\u53d8\u91cf\uff0c\u6539\u4e3a\u4e00\u4e2amat4\u7684\u9876\u70b9\u5c5e\u6027\uff0c\u8ba9\u6211\u4eec\u80fd\u591f\u5b58\u50a8\u4e00\u4e2a\u5b9e\u4f8b\u5316\u6570\u7ec4\u7684\u53d8\u6362\u77e9\u9635\u3002\u7136\u800c\uff0c\u5f53\u6211\u4eec\u9876\u70b9\u5c5e\u6027\u7684\u7c7b\u578b\u5927\u4e8evec4\u65f6\uff0c\u5c31\u8981\u591a\u8fdb\u884c\u4e00\u6b65\u5904\u7406\u4e86\u3002\u9876\u70b9\u5c5e\u6027\u6700\u5927\u5141\u8bb8\u7684\u6570\u636e\u5927\u5c0f\u7b49\u4e8e\u4e00\u4e2avec4\u3002\u56e0\u4e3a\u4e00\u4e2amat4\u672c\u8d28\u4e0a\u662f4\u4e2avec4\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u8fd9\u4e2a\u77e9\u9635\u9884\u75594\u4e2a\u9876\u70b9\u5c5e\u6027\u3002\u56e0\u4e3a\u6211\u4eec\u5c06\u5b83\u7684\u4f4d\u7f6e\u503c\u8bbe\u7f6e\u4e3a3\uff0c\u77e9\u9635\u6bcf\u4e00\u5217\u7684\u9876\u70b9\u5c5e\u6027\u4f4d\u7f6e\u503c\u5c31\u662f3\u30014\u30015\u548c6\u3002 \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u8fd94\u4e2a\u9876\u70b9\u5c5e\u6027\u8bbe\u7f6e\u5c5e\u6027\u6307\u9488\uff0c\u5e76\u5c06\u5b83\u4eec\u8bbe\u7f6e\u4e3a\u5b9e\u4f8b\u5316\u6570\u7ec4\uff1a // \u9876\u70b9\u7f13\u51b2\u5bf9\u8c61 unsigned int buffer; glGenBuffers(1, &buffer); glBindBuffer(GL_ARRAY_BUFFER, buffer); glBufferData(GL_ARRAY_BUFFER, amount * sizeof(glm::mat4), &modelMatrices[0], GL_STATIC_DRAW); for(unsigned int i = 0; i < rock.meshes.size(); i++) { unsigned int VAO = rock.meshes[i].VAO; glBindVertexArray(VAO); // \u9876\u70b9\u5c5e\u6027 GLsizei vec4Size = sizeof(glm::vec4); glEnableVertexAttribArray(3); glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)0); glEnableVertexAttribArray(4); glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(vec4Size)); glEnableVertexAttribArray(5); glVertexAttribPointer(5, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(2 * vec4Size)); glEnableVertexAttribArray(6); glVertexAttribPointer(6, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(3 * vec4Size)); glVertexAttribDivisor(3, 1); glVertexAttribDivisor(4, 1); glVertexAttribDivisor(5, 1); glVertexAttribDivisor(6, 1); glBindVertexArray(0); } \u6ce8\u610f\u8fd9\u91cc\u6211\u4eec\u5c06Mesh\u7684VAO\u4ece\u79c1\u6709\u53d8\u91cf\u6539\u4e3a\u4e86\u516c\u6709\u53d8\u91cf\uff0c\u8ba9\u6211\u4eec\u80fd\u591f\u8bbf\u95ee\u5b83\u7684\u9876\u70b9\u6570\u7ec4\u5bf9\u8c61\u3002\u8fd9\u5e76\u4e0d\u662f\u6700\u597d\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u53ea\u662f\u4e3a\u4e86\u914d\u5408\u672c\u5c0f\u8282\u7684\u4e00\u4e2a\u7b80\u5355\u7684\u6539\u52a8\u3002\u9664\u6b64\u4e4b\u5916\u4ee3\u7801\u5c31\u5e94\u8be5\u5f88\u6e05\u695a\u4e86\u3002\u6211\u4eec\u544a\u8bc9\u4e86OpenGL\u5e94\u8be5\u5982\u4f55\u89e3\u91ca\u6bcf\u4e2a\u7f13\u51b2\u9876\u70b9\u5c5e\u6027\u7684\u7f13\u51b2\uff0c\u5e76\u4e14\u544a\u8bc9\u5b83\u8fd9\u4e9b\u9876\u70b9\u5c5e\u6027\u662f\u5b9e\u4f8b\u5316\u6570\u7ec4\u3002 \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u518d\u6b21\u4f7f\u7528\u7f51\u683c\u7684VAO\uff0c\u8fd9\u4e00\u6b21\u4f7f\u7528glDrawElementsInstanced\u8fdb\u884c\u7ed8\u5236\uff1a // \u7ed8\u5236\u5c0f\u884c\u661f instanceShader.use(); for(unsigned int i = 0; i < rock.meshes.size(); i++) { glBindVertexArray(rock.meshes[i].VAO); glDrawElementsInstanced( GL_TRIANGLES, rock.meshes[i].indices.size(), GL_UNSIGNED_INT, 0, amount ); } 3.1 \u65b0\u589e\u7684\u7ed8\u5236\u63a5\u53e3: Indirect DrawArraysIndirect \u548c DrawElementsIndirect void DrawArraysIndirect (enum mode, const void *indirect); void DrawElementsIndirect (enum mode, enum type, const void *indirect); 3.2 \u65b0\u589e\u7684\u7ed8\u5236\u63a5\u53e3: BaseVertex void DrawElementsBaseVertex (enum mode, sizei count, enum type, const void *indices, int basevertex); void DrawRangeElementsBaseVertex (enum mode, uint start, uint end, sizei count, enum type, const void *indices, int basevertex); void DrawElementsInstancedBaseVertex (enum mode, sizei count,enum type, const void *indices, sizei instancecount, int basevertex);","title":"Drawing Commands"},{"location":"GLES/GLES%20Draw%20APIs/#drawing-commands","text":"For all the functions in this section: mode: GL_POINTS GL_LINE_STRIP GL_LINE_LOOP GL_LINES GL_TRIANGLE_STRIP GL_TRIANGLE_FAN GL_TRIANGLES 3.2 \u65b0\u589e\u56db\u4e2a\u90bb\u63a5\u6a21\u5f0f (Adjacency mode) GL_LINE_STRIP_ADJACENCY GL_LINES_ADJACENCY GL_TRIANGLE_STRIP_ADJACENCY GL_TRIANGLES_ADJACENCY type: UNSIGNED_{BYTE, SHORT, INT} void DrawArrays (enum mode, int first, sizei count); void DrawElements (enum mode, sizei count, enum type, const void *indices); void DrawRangeElements (enum mode, uint start, uint end, sizei count, enum type, const void *indices); void DrawArraysInstanced (enum mode, int first, sizei count, sizei instancecount); void DrawElementsInstanced (enum mode, sizei count, enum type, const void *indices, sizei instancecount); void DrawArraysIndirect (enum mode, const void *indirect); void DrawElementsIndirect (enum mode, enum type, const void *indirect); void DrawElementsBaseVertex (enum mode, sizei count, enum type, const void *indices, int basevertex); void DrawRangeElementsBaseVertex (enum mode, uint start, uint end, sizei count, enum type, const void *indices, int basevertex); void DrawElementsInstancedBaseVertex (enum mode, sizei count,enum type, const void *indices, sizei instancecount, int basevertex); Drawing Commands 2.0 3.0 3.1 3.2 Note glDrawArrays \u221a glDrawElements \u221a glDrawRangeElements \u221a glDrawArraysInstanced \u221a glDrawElementsInstanced \u221a glDrawArraysIndirect \u221a glDrawElementsIndirect \u221a glDrawElementsBaseVertex \u221a glDrawRangeElementsBaseVertex \u221a glDrawElementsInstancedBaseVertex \u221a","title":"Drawing Commands"},{"location":"GLES/GLES%20Draw%20APIs/#mode","text":"\u7ed8\u5236mode\u5373\u901a\u8fc7\u7ed8\u5236\u6a21\u5f0f\u6765\u6307\u5b9a \u56fe\u5143 \u7684\u7ed8\u5236\u6a21\u5f0f. \u6e32\u67d3\u7684\u65f6\u5019\u9700\u8981\u6307\u5b9a\u4e00\u4e2a\u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\u3002 TODO \u4f7f\u7528\u573a\u666f\u53ca\u5bf9\u6bd4.","title":"Mode"},{"location":"GLES/GLES%20Draw%20APIs/#1","text":"\u5bf9\u5e94\u7684\u6a21\u5f0f\u4e3a GL_POINTS \uff0c\u5373\u5728\u6bcf\u4e2a\u9876\u70b9\u4f4d\u7f6e\u7ed8\u5236\u4e00\u4e2a\u70b9\u3002OpenGL ES \u4e2d\u7ed8\u5236\u7684\u70b9\u5b9e\u5219\u662f\u4e00\u4e2a\u65b9\u5757\uff0c\u9876\u70b9\u4f4d\u7f6e\u662f\u65b9\u5757\u7684\u4e2d\u5fc3\u70b9\uff0c\u8fb9\u957f\u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7531\u5185\u5efa\u53d8\u91cf gl_PointSize \u6307\u5b9a\u3002 \u70b9\u7684\u5c3a\u5bf8\u5927\u5c0f\u8303\u56f4\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u65b9\u5f0f\u83b7\u53d6\uff1a GLfloat pointSizeRange[2]; glGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, pointSizeRange); 12 \u5982\u679c\u6211\u4eec\u60f3\u81ea\u5b9a\u4e49\u70b9\u7684\u5916\u5f62\uff0c\u901a\u5e38\u53ef\u4ee5\u4f7f\u7528\u7eb9\u7406\u3002\u4e00\u4e2a\u4f7f\u7528\u7eb9\u7406\u7684\u7247\u6bb5\u7740\u8272\u5668\u793a\u4f8b\u5982\u4e0b\uff1a #version 300 es precision mediump float; uniform sampler2D u_TextureUnit; layout(location = 0) out vec4 outColor; void main() { outColor = texture2D(u_TextureUnit, gl_PointCoord); } 123456789 \u8fd9\u6837\u6211\u4eec\u5728\u5916\u9762\u7ed9 u_TextureUnit \u6307\u5b9a\u7eb9\u7406\u7684 id \u5373\u53ef\uff0c\u5173\u4e8e\u7eb9\u7406\u7684\u76f8\u5173\u4f7f\u7528\u540e\u7eed\u6587\u7ae0\u518d\u4ecb\u7ecd\u3002 \u8fd8\u6709\u4e0a\u4f8b\u4e2d\u6211\u4eec\u4f7f\u7528\u5230\u4e86\u4e00\u4e2a\u5185\u5efa\u53d8\u91cf gl_PointCoord \uff0c\u5b83\u53ea\u5728\u7ed8\u5236\u70b9\u7cbe\u7075\u65f6\u53ef\u4ee5\u4f7f\u7528\uff0c\u63cf\u8ff0\u4e86\u8fd9\u4e2a\u70b9\u5185\u90e8\u7684\u5750\u6807\u7a7a\u95f4\uff0c\u5176\u5de6\u4e0a\u89d2\u4e3a (0, 0)\uff0c\u53f3\u4e0b\u89d2\u4e3a (1, 1)\u3002","title":"1. \u70b9"},{"location":"GLES/GLES%20Draw%20APIs/#2","text":"\u5bf9\u5e94\u7684\u6a21\u5f0f\u4e3a GL_LINES \u3001 GL_LINE_LOOP \u3001 GL_LINE_STRIP \uff0c\u7528\u6307\u5b9a\u7684\u9876\u70b9\u7ed8\u5236\u76f8\u5e94\u7684\u7ebf\u6bb5\u3002 \u5982\u56fe\uff0c\u5047\u8bbe\u6307\u5b9a\u7684\u9876\u70b9\u5750\u6807\u4e3a (v0, v1, v2, v3)\uff0c\u90a3\u4e48 GL_LINES \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1) \u548c (v2, v3) \u8fd9\u4e24\u6761\u7ebf\u6bb5 GL_LINE_STRIP \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1)\u3001(v1, v2) \u548c (v2, v3) \u4e09\u6761\u7ebf\u6bb5 GL_LINE_LOOP \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1)\u3001(v1, v2)\u3001(v2, v3) \u548c (v3, v0) \u56db\u6761\u7ebf\u6bb5 \u7ebf\u6bb5\u7684\u5bbd\u5ea6\u4f7f\u7528\u5982\u4e0b API \u6307\u5b9a\uff1a /** * @param width \u7ebf\u5bbd\uff0c\u4ee5\u50cf\u7d20\u6570\u8868\u793a\uff0c\u9ed8\u8ba4\u7684\u5bbd\u5ea6\u4e3a 1.0 */ void glLineWidth(GLFloat width); 1234 \u6307\u5b9a\u7684\u7ebf\u5bbd\u5c06\u88ab OpenGL \u8bb0\u4f4f\uff0c\u76f4\u5230\u7531\u5e94\u7528\u7a0b\u5e8f\u66f4\u65b0\u3002 \u652f\u6301\u7684\u7ebf\u5bbd\u8303\u56f4\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u65b9\u5f0f\u83b7\u53d6\uff1a GLfloat lineWidthRange[2]; glGetFloatv(GL_ALIASED_LINE_WIDTH_RANGE, lineWidthRange); 12","title":"2. \u76f4\u7ebf"},{"location":"GLES/GLES%20Draw%20APIs/#3","text":"\u5bf9\u5e94\u7684\u6a21\u5f0f\u4e3a GL_TRIANGLES \u3001 GL_TRIANGLE_STRIP \u3001 GL_TRIANGLE_FAN \u3002\u4e09\u89d2\u5f62\u56fe\u5143\u53ef\u8c13\u662f\u6700\u5e38\u4f7f\u7528\u7684\u4e86\u3002 \u5982\u56fe\uff0c\u5047\u8bbe\u6307\u5b9a\u7684\u9876\u70b9\u5750\u6807\u4e3a\u4e0a\u56fe\u6240\u793a\uff0c\u90a3\u4e48 GL_TRIANGLES \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1, v2) \u548c (v3, v4, v5) \u8fd9\u4e24\u4e2a\u4e09\u89d2\u5f62\u3002 GL_TRIANGLE_STRIP \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1, v2)\u3001(v2, v1, v3) \uff08\u6ce8\u610f\u987a\u5e8f\uff09\u548c (v2, v3, v4) \u4e09\u4e2a\u4e09\u89d2\u5f62\u3002 GL_TRIANGLE_FAN \u6a21\u5f0f\u4e0b\uff0c\u5c06\u7ed8\u5236 (v0, v1, v2)\u3001(v0, v2, v3) \u548c (v0, v3, v4) \u4e09\u4e2a\u4e09\u89d2\u5f62\u3002","title":"3. \u4e09\u89d2\u5f62"},{"location":"GLES/GLES%20Draw%20APIs/#4-32-adjacent-mode","text":"","title":"4. 3.2 \u65b0\u589e Adjacent Mode"},{"location":"GLES/GLES%20Draw%20APIs/#indextype","text":"type: UNSIGNED_BYTE, UNSIGNED_SHORT, UNSIGNED_INT","title":"IndexType"},{"location":"GLES/GLES%20Draw%20APIs/#20","text":"/** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param first \u8d77\u59cb\u4f4d\u7f6e * @param count \u9876\u70b9\u6570\u91cf */ void glDrawArrays(GLenum mode, GLint first, GLsizei count); /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param count \u9876\u70b9\u6570\u91cf * @param type \u5143\u7d20\u7c7b\u578b\uff0c\u6709\uff1aGL_UNSIGNED_BYTE\u3001GL_UNSIGNED_SHORT\u3001GL_UNSIGNED_INT * @param indices \u5143\u7d20\u7d22\u5f15\u6570\u7ec4 */ void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void *indices); \u533a\u522b \u9996\u5148\uff0c\u8fd9\u4e24\u4e2a\u51fd\u6570\u7684\u4f5c\u7528\u90fd\u662f\u4ece\u4e00\u4e2a\u6570\u636e\u6570\u7ec4\u4e2d\u63d0\u53d6\u6570\u636e\uff0c\u7136\u540e\u6e32\u67d3\u56fe\u5143\u3002 \u533a\u522b\u5728\u4e8e\uff1a glDrawArrays \u662f\u76f4\u63a5\u7ed8\u5236\u771f\u5b9e\u7684\u9876\u70b9\u6570\u636e\uff0c\u800c glDrawElements \u662f\u6309\u7167\u6307\u5b9a\u7684\u7d22\u5f15\u987a\u5e8f\u53d6\u51fa\u771f\u5b9e\u6570\u636e\u518d\u7ed8\u5236\u3002 \u4e8e\u662f\u5bf9\u4e8e\u9876\u70b9\u5b58\u5728\u5171\u4eab\u7684\u573a\u666f\u65f6\uff0c\u4f7f\u7528 glDrawElements \u5bf9\u4e8e\u91cd\u590d\u7684\u9876\u70b9\u6570\u636e\u53ea\u9700\u8981\u4f20\u8f93\u4e00\u4efd\u6570\u636e\uff0c\u7ed8\u5236\u65f6\u901a\u8fc7\u7d22\u5f15\u53cd\u590d\u7684\u83b7\u53d6\u5176\u503c\uff0c\u6700\u7ec8\u964d\u4f4e\u5185\u5b58\u5360\u7528\u548c\u5185\u5b58\u5e26\u5bbd\u9700\u6c42\u3002","title":"2.0 \u57fa\u7840\u7ed8\u5236"},{"location":"GLES/GLES%20Draw%20APIs/#30-instanced","text":"\u5728 OpenGL ES 3.0 \u4e2d\u65b0\u589e\u4e86\u51e0\u4e2a\u7ed8\u5236\u56fe\u5143\u7684\u63a5\u53e3\u3002","title":"3.0 \u65b0\u589e\u7684\u7ed8\u5236\u63a5\u53e3: Instanced \u591a\u5b9e\u4f8b\u6e32\u67d3"},{"location":"GLES/GLES%20Draw%20APIs/#1-gldrawrangeelements","text":"/** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param start \u8d77\u59cb\u7d22\u5f15\u4f4d\u7f6e * @param end \u7ed3\u675f\u7d22\u5f15\u4f4d\u7f6e * @param count \u9876\u70b9\u6570\u91cf * @param type \u5143\u7d20\u7c7b\u578b\uff0c\u6709\uff1aGL_UNSIGNED_BYTE\u3001GL_UNSIGNED_SHORT\u3001GL_UNSIGNED_INT * @param indices \u5143\u7d20\u7d22\u5f15\u6570\u7ec4 */ void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices); \u76f8\u6bd4\u4e8e glDrawElements \u63a5\u53e3\uff0c\u5b83\u65b0\u589e\u4e86 start \uff0c end \u4e24\u4e2a\u53c2\u6570\uff0c\u7528\u6765\u6307\u5b9a\u4f7f\u7528\u7684\u6570\u636e\u6570\u7ec4\u7684\u8d77\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e\u3002\u5176\u4f59\u533a\u522b\u4e0d\u5927\u3002","title":"1. glDrawRangeElements"},{"location":"GLES/GLES%20Draw%20APIs/#gldrawelementsinstanced-gldrawarraysinstanced","text":"","title":"glDrawElementsInstanced \u548c glDrawArraysInstanced"},{"location":"GLES/GLES%20Draw%20APIs/#_1","text":"Learn GL: \u591a\u5b9e\u4f8b\u6e32\u67d3","title":"\u591a\u5b9e\u4f8b\u6e32\u67d3"},{"location":"GLES/GLES%20Draw%20APIs/#_2","text":"\u5047\u8bbe\u4f60\u6709\u4e00\u4e2a\u7ed8\u5236\u4e86\u5f88\u591a\u6a21\u578b\u7684\u573a\u666f\uff0c\u800c\u5927\u90e8\u5206\u7684\u6a21\u578b\u5305\u542b\u7684\u662f\u540c\u4e00\u7ec4\u9876\u70b9\u6570\u636e\uff0c\u53ea\u4e0d\u8fc7\u8fdb\u884c\u7684\u662f\u4e0d\u540c\u7684\u4e16\u754c\u7a7a\u95f4\u53d8\u6362\u3002\u60f3\u8c61\u4e00\u4e2a\u5145\u6ee1\u8349\u7684\u573a\u666f\uff1a\u6bcf\u6839\u8349\u90fd\u662f\u4e00\u4e2a\u5305\u542b\u51e0\u4e2a\u4e09\u89d2\u5f62\u7684\u5c0f\u6a21\u578b\u3002\u4f60\u53ef\u80fd\u4f1a\u9700\u8981\u7ed8\u5236\u5f88\u591a\u6839\u8349\uff0c\u6700\u7ec8\u5728\u6bcf\u5e27\u4e2d\u4f60\u53ef\u80fd\u4f1a\u9700\u8981\u6e32\u67d3\u4e0a\u5343\u6216\u8005\u4e0a\u4e07\u6839\u8349\u3002\u56e0\u4e3a\u6bcf\u4e00\u6839\u8349\u4ec5\u4ec5\u662f\u7531\u51e0\u4e2a\u4e09\u89d2\u5f62\u6784\u6210\uff0c\u6e32\u67d3\u51e0\u4e4e\u662f\u77ac\u95f4\u5b8c\u6210\u7684\uff0c\u4f46\u4e0a\u5343\u4e2a\u6e32\u67d3\u51fd\u6570\u8c03\u7528\u5374\u4f1a\u6781\u5927\u5730\u5f71\u54cd\u6027\u80fd\u3002 \u5982\u679c\u6211\u4eec\u80fd\u591f\u5c06\u6570\u636e\u4e00\u6b21\u6027\u53d1\u9001\u7ed9GPU\uff0c\u7136\u540e\u4f7f\u7528\u4e00\u4e2a\u7ed8\u5236\u51fd\u6570\u8ba9OpenGL\u5229\u7528\u8fd9\u4e9b\u6570\u636e\u7ed8\u5236\u591a\u4e2a\u7269\u4f53\uff0c\u5c31\u4f1a\u66f4\u65b9\u4fbf\u4e86\u3002\u8fd9\u5c31\u662f\u5b9e\u4f8b\u5316(Instancing)\u3002","title":"\u573a\u666f"},{"location":"GLES/GLES%20Draw%20APIs/#instancing","text":"\u5b9e\u4f8b\u5316\u8fd9\u9879\u6280\u672f\u80fd\u591f\u8ba9\u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u6e32\u67d3\u8c03\u7528\u6765\u7ed8\u5236\u591a\u4e2a\u7269\u4f53\uff0c\u6765\u8282\u7701\u6bcf\u6b21\u7ed8\u5236\u7269\u4f53\u65f6CPU -> GPU\u7684\u901a\u4fe1\uff0c\u5b83\u53ea\u9700\u8981\u4e00\u6b21\u5373\u53ef\u3002 \u5982\u679c\u60f3\u4f7f\u7528\u5b9e\u4f8b\u5316\u6e32\u67d3\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5c06glDrawArrays\u548cglDrawElements\u7684\u6e32\u67d3\u8c03\u7528\u5206\u522b\u6539\u4e3aglDrawArraysInstanced\u548cglDrawElementsInstanced\u5c31\u53ef\u4ee5\u4e86\u3002\u8fd9\u4e9b\u6e32\u67d3\u51fd\u6570\u7684 \u5b9e\u4f8b\u5316 \u7248\u672c\u9700\u8981\u4e00\u4e2a\u989d\u5916\u7684\u53c2\u6570\uff0c\u53eb\u505a\u5b9e\u4f8b\u6570\u91cf(Instance Count)\uff0c\u5b83\u80fd\u591f\u8bbe\u7f6e\u6211\u4eec\u9700\u8981\u6e32\u67d3\u7684\u5b9e\u4f8b\u4e2a\u6570\u3002\u8fd9\u6837\u6211\u4eec\u53ea\u9700\u8981\u5c06\u5fc5\u987b\u7684\u6570\u636e\u53d1\u9001\u5230GPU\u4e00\u6b21\uff0c\u7136\u540e\u4f7f\u7528\u4e00\u6b21\u51fd\u6570\u8c03\u7528\u544a\u8bc9GPU\u5b83\u5e94\u8be5\u5982\u4f55\u7ed8\u5236\u8fd9\u4e9b\u5b9e\u4f8b\u3002GPU\u5c06\u4f1a\u76f4\u63a5\u6e32\u67d3\u8fd9\u4e9b\u5b9e\u4f8b\uff0c\u800c\u4e0d\u7528\u4e0d\u65ad\u5730\u4e0eCPU\u8fdb\u884c\u901a\u4fe1\u3002 glDrawElementsInstanced \u548c glDrawArraysInstanced glDrawArraysInstanced \u51fd\u6570\u662f glDrawArrays \u7684\u591a\u5b9e\u4f8b\u7248\u672c\uff0c\u53c2\u6570\u5b8c\u5168\u7b49\u4ef7\uff0c\u53ea\u662f\u591a\u4e86\u4e2ainstance count\uff0c\u8be5\u53c2\u6570\u7528\u4e8e\u8bbe\u7f6e\u6e32\u67d3\u5b9e\u4f8b\u4e2a\u6570\u3002\u4f8b\u5982\u6211\u4eec\u60f3\u8981\u4e00\u6b21\u6279\u91cf\u7ed8\u5236 100 \u4e2a\u76f8\u4f3c\u7684\u56fe\u5143\uff0c\u8fd9\u4e2a\u503c\u5bf9\u5e94\u5c31\u4f20 100\u3002 /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param first \u8d77\u59cb\u4f4d\u7f6e: \u4ece\u6570\u7ec4\u7f13\u5b58\u4e2d\u7684\u54ea\u4e00\u4f4d\u5f00\u59cb\u7ed8\u5236\uff0c\u4e00\u822c\u4e3a0\u3002 * @param count \u9876\u70b9\u6570\u91cf * @param instancecount \u7ed8\u5236\u7684\u5b9e\u4f8b\u6570\u91cf */ void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount); glDrawElementsInstanced \u662f glDrawElements \u7684\u591a\u5b9e\u4f8b\u7248\u672c\uff0c\u540c\u6837\u53ea\u662f\u591a\u4e86\u4e2ainstance count\u53c2\u6570\u800c\u5df2\uff0c\u540c\u6837\u662f\u7528\u4e8e\u8bbe\u7f6e\u6e32\u67d3\u5b9e\u4f8b\u4e2a\u6570\u3002 /** * @param mode \u6e32\u67d3\u7684\u56fe\u5143\u6a21\u5f0f\uff0c\u6709\uff1aGL_POINTS\u3001GL_LINES\u3001GL_LINE_LOOP\u3001GL_LINE_STRIP\u3001GL_TRIANGLES\u3001GL_TRIANGLE_STRIP\u3001GL_TRIANGLE_FAN * @param count \u9876\u70b9\u6570\u91cf * @param type \u5143\u7d20\u7c7b\u578b\uff0c\u6709\uff1aGL_UNSIGNED_BYTE\u3001GL_UNSIGNED_SHORT\u3001GL_UNSIGNED_INT * @param indices \u5143\u7d20\u7d22\u5f15\u7684\u6307\u9488 * @param instancecount \u7ed8\u5236\u7684\u56fe\u5143\u5b9e\u4f8b\u6570\u91cf */ void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);","title":"\u5b9e\u4f8b\u5316\uff08instancing)"},{"location":"GLES/GLES%20Draw%20APIs/#_3","text":"","title":"\u53d8\u91cf\u63a7\u5236"},{"location":"GLES/GLES%20Draw%20APIs/#gl_instanceid","text":"\u8fd9\u4e2a\u51fd\u6570\u672c\u8eab\u5e76\u6ca1\u6709\u4ec0\u4e48\u7528\u3002\u6e32\u67d3\u540c\u4e00\u4e2a\u7269\u4f53\u4e00\u5343\u6b21\u5bf9\u6211\u4eec\u5e76\u6ca1\u6709\u4ec0\u4e48\u7528\u5904\uff0c\u6bcf\u4e2a\u7269\u4f53\u90fd\u662f\u5b8c\u5168\u76f8\u540c\u7684\uff0c\u800c\u4e14\u8fd8\u5728\u540c\u4e00\u4e2a\u4f4d\u7f6e\u3002\u6211\u4eec\u53ea\u80fd\u770b\u89c1\u4e00\u4e2a\u7269\u4f53\uff01\u5904\u4e8e\u8fd9\u4e2a\u539f\u56e0\uff0cGLSL\u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u5d4c\u5165\u4e86\u53e6\u4e00\u4e2a\u5185\u5efa\u53d8\u91cf\uff0cgl_InstanceID\u3002 \u53d8\u91cf\u6570\u7ec4\u9700\u8981\u4f7f\u7528 uniform \u6570\u7ec4\u8f6c\u5165GLSL. \u4f8b\u5982\u4e0b\u4f8b\u4e2d \u4f7f\u7528\u4e86\u5927\u5c0f100\u7684 uniform\u6570\u7ec4\u8f6c\u5165 offset: gl_InstanceID \u5f88\u65b9\u4fbf, \u4f46\u4f1a\u5f88\u5feb\u8fbe\u5230uniform\u6570\u636e\u5927\u5c0f \u4e0a\u9650 , \u9700\u8981\u6ce8\u610f\u6570\u91cf. #version 330 core layout (location = 0) in vec2 aPos; layout (location = 1) in vec3 aColor; out vec3 fColor; uniform vec2 offsets[100]; void main() { vec2 offset = offsets[gl_InstanceID]; gl_Position = vec4(aPos + offset, 0.0, 1.0); fColor = aColor; }","title":"gl_InstanceID"},{"location":"GLES/GLES%20Draw%20APIs/#instanced-array","text":"\u7531\u4e8e\u5b9e\u4f8b\u592a\u591a\u65f6, \u4f7f\u7528 gl_InstanceID \u5bb9\u6613\u4f7funiform \u8d85\u9650, \u5b83\u7684\u4e00\u4e2a\u4ee3\u66ff\u65b9\u6848\u662f\u5b9e\u4f8b\u5316\u6570\u7ec4(Instanced Array)\uff0c\u5b83\u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u9876\u70b9\u5c5e\u6027\uff08\u80fd\u591f\u8ba9\u6211\u4eec\u50a8\u5b58\u66f4\u591a\u7684\u6570\u636e\uff09\uff0c\u4ec5\u5728\u9876\u70b9\u7740\u8272\u5668\u6e32\u67d3\u4e00\u4e2a\u65b0\u7684\u5b9e\u4f8b\u65f6\u624d\u4f1a\u66f4\u65b0\u3002 #version 330 core layout (location = 0) in vec2 aPos; layout (location = 1) in vec3 aColor; layout (location = 2) in vec2 aOffset; out vec3 fColor; void main() { gl_Position = vec4(aPos + aOffset, 0.0, 1.0); fColor = aColor; }","title":"Instanced Array"},{"location":"GLES/GLES%20Draw%20APIs/#3_1","text":"\u591a\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027, \u591a\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027\uff0c\u4e0e\u5176\u4ed6\u7684\u9876\u70b9\u5c5e\u6027\u662f\u7c7b\u4f3c\u7684\u3002\u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684\u58f0\u660e\u548c\u6570\u636e\u914d\u7f6e\u65b9\u6cd5\u5b8c\u5168\u4e00\u81f4. \u5b83\u4eec\u53ef\u4ee5\u4f7f\u7528 APIs: glGetAttribLocation \u67e5\u8be2 glVertexAttribPointer \u8bbe\u7f6e glEnableVertexAttribArray \u542f\u7528 glDisableVertexAttribArray \u7981\u7528 \u591a\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027\u7684\u552f\u4e00\u7684\u533a\u522b\u5c31\u662f \u6b63\u5e38\u7684\u9876\u70b9\u5c5e\u6027: \u9488\u5bf9\u7684\u662f\u5355\u4e00\u9876\u70b9 \u591a\u5b9e\u4f8b\u9876\u70b9\u5c5e\u6027: \u9488\u5bf9\u7684\u662f\u4e00\u4e2a\u56fe\u5143\u5b9e\u4f8b\u3002 \u7b80\u5355\u7684\u7406\u89e3\u5c31\u662f\u9876\u70b9\u7740\u8272\u5668\u7684\u8f93\u5165\u6b63\u5e38\u60c5\u51b5\u662f\u4e00\u4e2a\u9876\u70b9\u5c5e\u6027\u5bf9\u5e94\u4e00\u4e2a\u9876\u70b9\uff0c\u800c\u6240\u5b9e\u4f8b\u7684\u9876\u70b9\u5c5e\u6027\u662f\u4e00\u4e2a\u5c5e\u6027\u5bf9\u4ee5\u4e00\u4e2a\u56fe\u5143\uff08\u56fe\u5143\u4e2d\u6240\u6709\u7684\u9876\u70b9\u7684\u8fd9\u4e00\u6761\u5c5e\u6027\u5171\u7528\u540c\u4e00\u4e2a\u6570\u636e\uff09\uff0c\u5373\u6bcf\u4e2a\u5b9e\u4f8b\u66f4\u65b0\u4e00\u6b21\u8fd9\u4e2a\u5c5e\u6027\u7684\u6570\u636e\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e2a\u529f\u80fd\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u51fd\u6570\uff1a /** * @param index \u5bf9\u5e94\u7740\u8272\u5668\u4e2d\u7684\u5b9e\u4f8b\u53d8\u91cf\u7684\u7d22\u5f15, \u4f8b\u5982 offset \u3002 * @param divisor \u8868\u793a\u9876\u70b9\u5c5e\u6027\u7684\u66f4\u65b0\u9891\u7387\uff0c\u6bcf\u9694\u591a\u5c11\u4e2a\u5b9e\u4f8b\u5c06\u91cd\u65b0\u8bbe\u7f6e\u5b9e\u4f8b\u7684\u8be5\u5c5e\u6027\uff0c * \u4f8b\u5982\u8bbe\u7f6e\u4e3a 1 \u90a3\u4e48\u6bcf\u4e2a\u5b9e\u4f8b\u7684\u5c5e\u6027\u90fd\u4e0d\u4e00\u6837\uff0c \u8bbe\u7f6e\u4e3a2\u5219\u6bcf\u4e24\u4e2a\u5b9e\u4f8b\u76f8\u540c\u3002 * \u5982\u679cdivisor\u7684\u503c\u662f0\uff0c\u8868\u793a\u591a\u5b9e\u4f8b\u7279\u6027\u88ab\u7981\u7528 */ void glVertexAttribDivisor (GLuint index, GLuint divisor)","title":"3. \u591a\u5b9e\u4f8b\u6e32\u67d3\u9876\u70b9\u5c5e\u6027\u63a7\u5236"},{"location":"GLES/GLES%20Draw%20APIs/#4","text":"\u521b\u5efa\u7740\u8272\u5668: \u5728\u9876\u70b9\u7740\u8272\u5668\u4e2d\u6211\u4eec\u589e\u52a0\u4e00\u4e2a\u504f\u79fb\u91cf\u7684\u5c5e\u6027\uff08attribute vec3 offset\uff09 \u5728\u6bcf\u6b21\u7ed8\u5236\u4e4b\u540e\u5b83\u7684\u503c\u4f1a\u53d1\u751f\u504f\u79fb\u3002\u901a\u8fc7 glVertexAttribDivisor \u6765\u8bbe\u7f6e\u5982\u4f55\u504f\u79fb\u3002 fragment shader precision mediump float; uniform sampler2D image; varying vec2 vTexcoord; void main() { gl_FragColor = texture2D(image, vTexcoord); } vertex shader attribute vec3 position; attribute vec3 offset; //\u504f\u79fb\u91cf attribute vec2 texcoord; varying vec2 vTexcoord; void main() { gl_Position = vec4(position + offset, 1.0); vTexcoord = texcoord; } \u8bbe\u7f6e\u9876\u70b9\u5c5e\u6027\u3002\u8bbe\u7f6e\u9876\u70b9\u5c5e\u6027\u65b9\u4fbf\u6211\u4eec\u8fdb\u884c\u7eb9\u7406\u8d34\u56fe\u3002 - (void)setupVBO { _vertCount = 6; GLfloat vertices[] = { -0.5f, 1.0f, 0.0f, 1.0f, 0.0f, // \u53f3\u4e0a -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, // \u53f3\u4e0b -1.0f, 0.5f, 0.0f, 0.0f, 1.0f, // \u5de6\u4e0b -1.0f, 0.5f, 0.0f, 0.0f, 1.0f, // \u5de6\u4e0b -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, // \u5de6\u4e0a -0.5f, 1.0f, 0.0f, 1.0f, 0.0f, // \u53f3\u4e0a }; // \u521b\u5efaVBO _vbo = createVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW, sizeof(vertices), vertices); // Vertex Attrib: position glEnableVertexAttribArray(glGetAttribLocation(_program, \"position\")); glVertexAttribPointer(glGetAttribLocation(_program, \"position\"), 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, NULL); // Vertex Attrib: texcoord glEnableVertexAttribArray(glGetAttribLocation(_program, \"texcoord\")); glVertexAttribPointer(glGetAttribLocation(_program, \"texcoord\"), 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, NULL+sizeof(GL_FLOAT)*3); } \u8bbe\u7f6e\u7eb9\u7406 \u901a\u8fc7\u8bfb\u53d6\u7eb9\u7406\u56fe\u7247\uff0c\u751f\u6210\u7eb9\u7406\u7f13\u5b58\u5bf9\u8c61\u3002 \u8bbe\u7f6e\u504f\u79fb\u91cf \u504f\u79fb\u91cf\u548c\u666e\u901a\u7684\u9876\u70b9\u6570\u636e\u4e00\u6837\u53ef\u4ee5\u4f7f\u7528VBO\u6765\u5b58\u50a8\u3002 \u6211\u4eec\u5e0c\u671b\u6bcf\u6b21\u7ed8\u5236\u9876\u70b9\u6570\u7ec4\u90fd\u53d1\u751f\u4e00\u5b9a\u7684\u504f\u79fb\uff0c\u603b\u5171\u53d1\u751f\u4e09\u6b21\u504f\u79fb\uff08gl_Position = vec4(position+offset, 1.0)\uff09\u3002\u8fd9\u6837\u6211\u4eec\u603b\u5171\u9700\u89819\u4e2aGLfloat\u7684\u7a7a\u95f4\u6765\u5b58\u50a8\u504f\u79fb\u6570\u636e\u3002 - (void)setupOffset { GLfloat vertices[] = { 0.1f, -0.1f, 0.0f, 0.7f, -0.7f, 0.0f, 1.3f, -1.3f, 0.0f, }; // \u521b\u5efaVBO _offsetVBO = createVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW, sizeof(vertices), vertices); glEnableVertexAttribArray(glGetAttribLocation(_program, \"offset\")); glVertexAttribPointer(glGetAttribLocation(_program, \"offset\"), 3, GL_FLOAT, GL_FALSE, 0, NULL); } \u7ed8\u5236 - (void)render { glClearColor(1.0, 1.0, 1.0, 1.0); glClear(GL_COLOR_BUFFER_BIT); glLineWidth(2.0); glViewport(0, 0, self.frame.size.width, self.frame.size.height); // \u6fc0\u6d3b\u7eb9\u7406 glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, _texture); glUniform1i(glGetUniformLocation(_program, \"image\"), 0); // \u6bcf\u6b21\u7ed8\u5236\u4e4b\u540e\uff0c\u5bf9offset\u8fdb\u884c1\u4e2a\u504f\u79fb glVertexAttribDivisor(glGetAttribLocation(_program, \"offset\"), 1); // \u7ed8\u5236 3 \u4e2a\u5b9e\u4f8b, \u6bcf\u4e2a\u5b9e\u4f8b\u5bf9\u5e94\u4e00\u4e2a offset vector glDrawArraysInstanced(GL_TRIANGLES, 0, _vertCount, 3); //\u5c06\u6307\u5b9a renderbuffer \u5448\u73b0\u5728\u5c4f\u5e55\u4e0a\uff0c\u5728\u8fd9\u91cc\u6211\u4eec\u6307\u5b9a\u7684\u662f\u524d\u9762\u5df2\u7ecf\u7ed1\u5b9a\u4e3a\u5f53\u524d renderbuffer \u7684\u90a3\u4e2a\uff0c\u5728 renderbuffer \u53ef\u4ee5\u88ab\u5448\u73b0\u4e4b\u524d\uff0c\u5fc5\u987b\u8c03\u7528renderbufferStorage:fromDrawable: \u4e3a\u4e4b\u5206\u914d\u5b58\u50a8\u7a7a\u95f4\u3002 [_context presentRenderbuffer:GL_RENDERBUFFER]; }","title":"4. \u4ee3\u7801\u5b9e\u4f8b"},{"location":"GLES/GLES%20Draw%20APIs/#_4","text":"#version 330 core layout (location = 0) in vec3 aPos; layout (location = 2) in vec2 aTexCoords; layout (location = 3) in mat4 instanceMatrix; out vec2 TexCoords; uniform mat4 projection; uniform mat4 view; void main() { gl_Position = projection * view * instanceMatrix * vec4(aPos, 1.0); TexCoords = aTexCoords; } \u6211\u4eec\u4e0d\u518d\u4f7f\u7528\u6a21\u578buniform\u53d8\u91cf\uff0c\u6539\u4e3a\u4e00\u4e2amat4\u7684\u9876\u70b9\u5c5e\u6027\uff0c\u8ba9\u6211\u4eec\u80fd\u591f\u5b58\u50a8\u4e00\u4e2a\u5b9e\u4f8b\u5316\u6570\u7ec4\u7684\u53d8\u6362\u77e9\u9635\u3002\u7136\u800c\uff0c\u5f53\u6211\u4eec\u9876\u70b9\u5c5e\u6027\u7684\u7c7b\u578b\u5927\u4e8evec4\u65f6\uff0c\u5c31\u8981\u591a\u8fdb\u884c\u4e00\u6b65\u5904\u7406\u4e86\u3002\u9876\u70b9\u5c5e\u6027\u6700\u5927\u5141\u8bb8\u7684\u6570\u636e\u5927\u5c0f\u7b49\u4e8e\u4e00\u4e2avec4\u3002\u56e0\u4e3a\u4e00\u4e2amat4\u672c\u8d28\u4e0a\u662f4\u4e2avec4\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u8fd9\u4e2a\u77e9\u9635\u9884\u75594\u4e2a\u9876\u70b9\u5c5e\u6027\u3002\u56e0\u4e3a\u6211\u4eec\u5c06\u5b83\u7684\u4f4d\u7f6e\u503c\u8bbe\u7f6e\u4e3a3\uff0c\u77e9\u9635\u6bcf\u4e00\u5217\u7684\u9876\u70b9\u5c5e\u6027\u4f4d\u7f6e\u503c\u5c31\u662f3\u30014\u30015\u548c6\u3002 \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u8fd94\u4e2a\u9876\u70b9\u5c5e\u6027\u8bbe\u7f6e\u5c5e\u6027\u6307\u9488\uff0c\u5e76\u5c06\u5b83\u4eec\u8bbe\u7f6e\u4e3a\u5b9e\u4f8b\u5316\u6570\u7ec4\uff1a // \u9876\u70b9\u7f13\u51b2\u5bf9\u8c61 unsigned int buffer; glGenBuffers(1, &buffer); glBindBuffer(GL_ARRAY_BUFFER, buffer); glBufferData(GL_ARRAY_BUFFER, amount * sizeof(glm::mat4), &modelMatrices[0], GL_STATIC_DRAW); for(unsigned int i = 0; i < rock.meshes.size(); i++) { unsigned int VAO = rock.meshes[i].VAO; glBindVertexArray(VAO); // \u9876\u70b9\u5c5e\u6027 GLsizei vec4Size = sizeof(glm::vec4); glEnableVertexAttribArray(3); glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)0); glEnableVertexAttribArray(4); glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(vec4Size)); glEnableVertexAttribArray(5); glVertexAttribPointer(5, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(2 * vec4Size)); glEnableVertexAttribArray(6); glVertexAttribPointer(6, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(3 * vec4Size)); glVertexAttribDivisor(3, 1); glVertexAttribDivisor(4, 1); glVertexAttribDivisor(5, 1); glVertexAttribDivisor(6, 1); glBindVertexArray(0); } \u6ce8\u610f\u8fd9\u91cc\u6211\u4eec\u5c06Mesh\u7684VAO\u4ece\u79c1\u6709\u53d8\u91cf\u6539\u4e3a\u4e86\u516c\u6709\u53d8\u91cf\uff0c\u8ba9\u6211\u4eec\u80fd\u591f\u8bbf\u95ee\u5b83\u7684\u9876\u70b9\u6570\u7ec4\u5bf9\u8c61\u3002\u8fd9\u5e76\u4e0d\u662f\u6700\u597d\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u53ea\u662f\u4e3a\u4e86\u914d\u5408\u672c\u5c0f\u8282\u7684\u4e00\u4e2a\u7b80\u5355\u7684\u6539\u52a8\u3002\u9664\u6b64\u4e4b\u5916\u4ee3\u7801\u5c31\u5e94\u8be5\u5f88\u6e05\u695a\u4e86\u3002\u6211\u4eec\u544a\u8bc9\u4e86OpenGL\u5e94\u8be5\u5982\u4f55\u89e3\u91ca\u6bcf\u4e2a\u7f13\u51b2\u9876\u70b9\u5c5e\u6027\u7684\u7f13\u51b2\uff0c\u5e76\u4e14\u544a\u8bc9\u5b83\u8fd9\u4e9b\u9876\u70b9\u5c5e\u6027\u662f\u5b9e\u4f8b\u5316\u6570\u7ec4\u3002 \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u518d\u6b21\u4f7f\u7528\u7f51\u683c\u7684VAO\uff0c\u8fd9\u4e00\u6b21\u4f7f\u7528glDrawElementsInstanced\u8fdb\u884c\u7ed8\u5236\uff1a // \u7ed8\u5236\u5c0f\u884c\u661f instanceShader.use(); for(unsigned int i = 0; i < rock.meshes.size(); i++) { glBindVertexArray(rock.meshes[i].VAO); glDrawElementsInstanced( GL_TRIANGLES, rock.meshes[i].indices.size(), GL_UNSIGNED_INT, 0, amount ); }","title":"\u590d\u6742\u70b9\u7684\u4f8b\u5b50"},{"location":"GLES/GLES%20Draw%20APIs/#31-indirect","text":"","title":"3.1 \u65b0\u589e\u7684\u7ed8\u5236\u63a5\u53e3: Indirect"},{"location":"GLES/GLES%20Draw%20APIs/#drawarraysindirect-drawelementsindirect","text":"","title":"DrawArraysIndirect   \u548c DrawElementsIndirect"},{"location":"GLES/GLES%20Draw%20APIs/#_5","text":"void DrawArraysIndirect (enum mode, const void *indirect); void DrawElementsIndirect (enum mode, enum type, const void *indirect);","title":""},{"location":"GLES/GLES%20Draw%20APIs/#32-basevertex","text":"void DrawElementsBaseVertex (enum mode, sizei count, enum type, const void *indices, int basevertex); void DrawRangeElementsBaseVertex (enum mode, uint start, uint end, sizei count, enum type, const void *indices, int basevertex); void DrawElementsInstancedBaseVertex (enum mode, sizei count,enum type, const void *indices, sizei instancecount, int basevertex);","title":"3.2 \u65b0\u589e\u7684\u7ed8\u5236\u63a5\u53e3: BaseVertex"},{"location":"GLES/GLES%20Object%20Model.mm/","text":"\u540d\u8bcd\u89e3\u91ca FBOs Fence Semephere Sampler Vertex Attribute Divisors 1. Objects \u5bf9\u8c61 1.1. Buffer void GenBuffers (sizei n, uint buffers); void DeleteBuffers (sizei n,const uint buffers); boolean IsBuffer (uint buffer); 1.1.1. Create and Bind Buffer Objects [6.1] void BindBuffer void BindBufferRange void BindBufferBase 1.1.2. Buffer Object Data Stores [6.2] void BufferData void BufferSubData 1.1.3. Map/Unmap Buffer Data [6.3] void *MapBufferRange void FlushMappedBufferRange 1.1.4. Copy Between Buffers [6.5] void CopyBufferSubData 1.1.5. Buffer Object Queries [6.6] void GetBufferParameteri void GetBufferPointerv 1.2. Shader uint CreateShader void ShaderSource void CompileShader void ReleaseShaderCompiler void DeleteShader boolean IsShader void ShaderBinary 1.2.1. Shader Memory Access 1.3. Program 1.3.1. Program Interfaces 1.3.2. Program Binaries 1.4. Program Pipeline 1.5. Uniform Variables 1.6. Texture & Sampler 1.6.1. Texture 1.6.2. Sampler 1.6.3. Pixel Storage Modes and Pixel Buffer Objects 1.6.4. Texture Image TexImage3D TexImage2D 1.6.5. Alternate Texture Image CopyTexImage2D TexSubImage3D TexSubImage2D CopyTexSubImage3D CopyTexSubImage2D 1.6.6. Compressed Texture Images 1.6.7. Multisample Textures TexStorage2DMultisample TexStorage3DMultisample 1.6.8. Buffer Textures void TexBufferRange void TexBuffer 1.6.9. Manual Mipmap Generation void GenerateMipmap 1.6.10. Immutable-Format Tex. Images void TexStorage2D void TexStorage3D 1.6.11. Texture Image Loads/Stores void BindImageTexture 1.7. Renderbuffer 1.8. Framebuffer 1.9. Vertex Array 1.9.1. Generic Vertex Attributes 1.9.2. Vertex Attribute Divisors 1.9.3. Drawing Commands For all the functions in this section: mode: LINE_LOOP, LINE_[STRIP_]ADJACENCY, LINES, LINES_ADJACENCY, PATCHES TRIANGLE_FAN, POINTS[ TRIANGLES_ADJACENCY], TRIANGLES, TRIANGLE_STRIP[ ADJACENCY] type: UNSIGNED_{BYTE, SHORT, INT} void DrawArrays (enum mode, int first, sizei count); void DrawArraysInstanced (enum mode, int first, sizei count, sizei instancecount); void DrawArraysIndirect (enum mode, const void *indirect); void DrawElements (enum mode, sizei count, enum type, const void *indices); void DrawElementsInstanced (enum mode, sizei count, enum type, const void *indices, sizei instancecount); void DrawRangeElements (enum mode, uint start, uint end, sizei count, enum type, const void *indices); void DrawElementsBaseVertex (enum mode, sizei count, enum type, const void *indices, int basevertex); void DrawRangeElementsBaseVertex (enum mode, uint start, uint end, sizei count, enum type, const void *indices, int basevertex); void DrawElementsInstancedBaseVertex(enum mode, sizei count,enum type, const void *indices, sizei instancecount, int basevertex); void DrawElementsIndirect (enum mode,enum type, const void *indirect); 1.9.4. Vertex Attributes 1.10. Transform Feedback 1.11. Query 1.12. Sync 2. Operation \u64cd\u4f5c 2.1. Vertex Post-Processing 2.1.1. Transform Feedback [12.1] void GenTransformFeedbacks void DeleteTransformFeedbacks boolean IsTransformFeedback void BindTransformFeedback void BeginTransformFeedback void EndTransformFeedback void PauseTransformFeedback void ResumeTransformFeedback 2.1.2. Controlling Viewport [12.5.1] void DepthRangef(float n, float f); void Viewport(int x, int y, sizei w, sizei h); 2.2. Rasterization 2.2.1. Primitive Bounding Box [13.2] void PrimitiveBoundingBox(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW); 2.2.2. Multisampling [13.4] Use to antialias points and lines. void GetMultisamplefv(enum pname, uint index, float *val); pname: SAMPLE_POSITION 2.2.3. Sample Shading [13.4.1] void MinSampleShading(float value); 2.2.4. Points [13.5] Point size is taken from the shader built-in gl_PointSize and clamped to the implementation-dependent point size range. 2.2.5. Line Segments [13.6] void LineWidth(float width); 2.2.6. Polygons [13.7] void FrontFace(enum dir); Enable(CULL_FACE) Disable(CULL_FACE) IsEnabled(CULL_FACE) void CullFace(enum mode); Enable(POLYGON_OFFSET_FILL) Disable(POLYGON_OFFSET_FILL) IsEnabled(POLYGON_OFFSET_FILL) void PolygonOffset(float factor, float units); 2.3. Whole Framebuffer Operations Whole Framebuffer Operations Selecting Buffers for Writing [15.2.1] void DrawBuffers(sizei n, const enum *bufs); Fine Control of Buffer Updates [15.2.2] void ColorMask(boolean r, boolean g, boolean b, boolean a); void ColorMaski(uint buf, boolean r, boolean g, boolean b, boolean a); void DepthMask(boolean mask); void StencilMask(uint mask); void StencilMaskSeparate(enum face, uint mask); face: FRONT, BACK, FRONT_AND_BACK Clearing the Buffers [15.2.3] void Clear(bitfield buf); buf: Zero or Bitwise OR of {COLOR, DEPTH, STENCIL}_BUFFER_BIT void ClearColor(float r, float g, float b, float a); void ClearDepthf(float d); void ClearStencil(int s); void ClearBuffer{i f ui}v(enum buffer, int drawbuffer, const T *value); buffer: COLOR, DEPTH, STENCIL void ClearBufferfi(enum buffer, int drawbuffer, float depth, int stencil); buffer: DEPTH_STENCIL drawbuffer: 0 Invalidating Framebuffer Contents [15.2.4] void InvalidateSubFramebuffer(enum target, sizei numAttachments, const enum *attachments, int x, int y, sizei width, sizei height); target: [DRAW_, READ_]FRAMEBUFFER attachments: points to an array of COLOR, STENCIL, {COLOR, DEPTH, STENCIL}_ATTACHMENT void InvalidateFramebuffer( 2.4. Per-Fragment Operations Scissor Test [13.8.2] Enable/Disable(SCISSOR_TEST); void Scissor(int left, int bottom, sizei width, sizei height); Multisample Fragment Ops. [13.8.3] Enable/Disable(cap); cap: SAMPLE_ALPHA_TO_COVERAGE, SAMPLE_COVERAGE void SampleCoverage(float value, boolean invert); void SampleMaski(uint maskNumber, bitfield mask); Stencil Test [15.1.2] Enable/Disable(STENCIL_TEST); void StencilFunc (enum func, int ref, uint mask); func: ALWAYS, EQUAL, GEQUAL, GREATER, LEQUAL, LESS, NEVER, NOTEQUAL void StencilFuncSeparate (enum face, enum func, int ref, uint mask); func: See StencilFunc face: BACK, FRONT, FRONT_AND_BACK void StencilOp (enum sfail, enum dpfail, enum dppass); void StencilOpSeparate (enum face, enum sfail, enum dpfail, enum dppass); face: BACK, FRONT, FRONT_AND_BACK sfail, dpfail, dppass: DECR, DECR_WRAP, INCR, INCR_WRAP, INVERT, KEEP, REPLACE, ZERO Depth Buffer Test [15.1.3] Enable/Disable(DEPTH_TEST); void DepthFunc (enum func); func: See StencilFunc Blending [15.1.5] void Enablei (enum target, uint index); void Disablei (enum target, uint index); target: must be BLEND Enable/Disable/IsEnabled(BLEND); void BlendColor (float red, float green, float blue, float alpha); void BlendEquation (enum mode); void BlendEquationSeparate (enum modeRGB, enum modeAlpha); mode, modeRGB, modeAlpha: FUNC_{ADD, SUBTRACT, REVERSE_SUBTRACT}, MAX, MIN void BlendEquationi (uint buf, enum mode); void BlendEquationSeparatei (uint buf, enum modeRGB, enum modeAlpha ); modeRGB, modeAlpha: See BlendEquationSeparate void BlendFunc(enum src, enum dst); src, dst: See BlendFuncSeparate void BlendFuncSeparate (enum srcRGB, enum dstRGB, enum srcAlpha, enum dstAlpha); src, dst, srcRGB, dstRGB, srcAlpha, dstAlpha: {CONSTANT, DST, SRC} COLOR, {CONSTANT, DST, SRC}_ALPHA, ONE, ONE_MINUS_SRC {ALPHA, COLOR}, ONE_MINUS_{CONSTANT, DST} ALPHA , ONE_MINUS {CONSTANT, DST}_COLOR, SRC_ALPHA_SATURATE, ZERO void BlendFunci (uint buf, enum src, enum dst); void BlendFuncSeparatei (uint buf, enum srcRGB, enum dstRGB, enum srcAlpha, enum dstAlpha); modeRGB, modeAlpha: See BlendFuncSeparate void BlendBarrier(void); Dithering [15.1.7] Enable/Disable/IsEnabled(DITHER); 2.5. Reading and Copying Pixels and Images","title":"\u540d\u8bcd\u89e3\u91ca"},{"location":"GLES/GLES%20Object%20Model.mm/#_1","text":"FBOs Fence Semephere Sampler Vertex Attribute Divisors","title":"\u540d\u8bcd\u89e3\u91ca"},{"location":"GLES/GLES%20Object%20Model.mm/#1-objects","text":"","title":"1. Objects \u5bf9\u8c61"},{"location":"GLES/GLES%20Object%20Model.mm/#11-buffer","text":"void GenBuffers (sizei n, uint buffers); void DeleteBuffers (sizei n,const uint buffers); boolean IsBuffer (uint buffer);","title":"1.1. Buffer"},{"location":"GLES/GLES%20Object%20Model.mm/#111-create-and-bind-buffer-objects-61","text":"void BindBuffer void BindBufferRange void BindBufferBase","title":"1.1.1. Create and Bind Buffer Objects [6.1]"},{"location":"GLES/GLES%20Object%20Model.mm/#112-buffer-object-data-stores-62","text":"void BufferData void BufferSubData","title":"1.1.2. Buffer Object Data Stores [6.2]"},{"location":"GLES/GLES%20Object%20Model.mm/#113-mapunmap-buffer-data-63","text":"void *MapBufferRange void FlushMappedBufferRange","title":"1.1.3. Map/Unmap Buffer Data [6.3]"},{"location":"GLES/GLES%20Object%20Model.mm/#114-copy-between-buffers-65","text":"void CopyBufferSubData","title":"1.1.4. Copy Between Buffers [6.5]"},{"location":"GLES/GLES%20Object%20Model.mm/#115-buffer-object-queries-66","text":"void GetBufferParameteri void GetBufferPointerv","title":"1.1.5. Buffer Object Queries [6.6]"},{"location":"GLES/GLES%20Object%20Model.mm/#12-shader","text":"uint CreateShader void ShaderSource void CompileShader void ReleaseShaderCompiler void DeleteShader boolean IsShader void ShaderBinary","title":"1.2. Shader"},{"location":"GLES/GLES%20Object%20Model.mm/#121-shader-memory-access","text":"","title":"1.2.1. Shader Memory Access"},{"location":"GLES/GLES%20Object%20Model.mm/#13-program","text":"","title":"1.3. Program"},{"location":"GLES/GLES%20Object%20Model.mm/#131-program-interfaces","text":"","title":"1.3.1. Program Interfaces"},{"location":"GLES/GLES%20Object%20Model.mm/#132-program-binaries","text":"","title":"1.3.2. Program Binaries"},{"location":"GLES/GLES%20Object%20Model.mm/#14-program-pipeline","text":"","title":"1.4. Program Pipeline"},{"location":"GLES/GLES%20Object%20Model.mm/#15-uniform-variables","text":"","title":"1.5. Uniform Variables"},{"location":"GLES/GLES%20Object%20Model.mm/#16-texture-sampler","text":"","title":"1.6. Texture &amp; Sampler"},{"location":"GLES/GLES%20Object%20Model.mm/#161-texture","text":"","title":"1.6.1. Texture"},{"location":"GLES/GLES%20Object%20Model.mm/#162-sampler","text":"","title":"1.6.2. Sampler"},{"location":"GLES/GLES%20Object%20Model.mm/#163-pixel-storage-modes-and-pixel-buffer-objects","text":"","title":"1.6.3. Pixel Storage Modes and Pixel Buffer Objects"},{"location":"GLES/GLES%20Object%20Model.mm/#164-texture-image","text":"TexImage3D TexImage2D","title":"1.6.4. Texture Image"},{"location":"GLES/GLES%20Object%20Model.mm/#165-alternate-texture-image","text":"CopyTexImage2D TexSubImage3D TexSubImage2D CopyTexSubImage3D CopyTexSubImage2D","title":"1.6.5. Alternate Texture Image"},{"location":"GLES/GLES%20Object%20Model.mm/#166-compressed-texture-images","text":"","title":"1.6.6. Compressed Texture Images"},{"location":"GLES/GLES%20Object%20Model.mm/#167-multisample-textures","text":"TexStorage2DMultisample TexStorage3DMultisample","title":"1.6.7. Multisample Textures"},{"location":"GLES/GLES%20Object%20Model.mm/#168-buffer-textures","text":"void TexBufferRange void TexBuffer","title":"1.6.8. Buffer Textures"},{"location":"GLES/GLES%20Object%20Model.mm/#169-manual-mipmap-generation","text":"void GenerateMipmap","title":"1.6.9. Manual Mipmap Generation"},{"location":"GLES/GLES%20Object%20Model.mm/#1610-immutable-format-tex-images","text":"void TexStorage2D void TexStorage3D","title":"1.6.10. Immutable-Format Tex. Images"},{"location":"GLES/GLES%20Object%20Model.mm/#1611-texture-image-loadsstores","text":"void BindImageTexture","title":"1.6.11. Texture Image Loads/Stores"},{"location":"GLES/GLES%20Object%20Model.mm/#17-renderbuffer","text":"","title":"1.7. Renderbuffer"},{"location":"GLES/GLES%20Object%20Model.mm/#18-framebuffer","text":"","title":"1.8. Framebuffer"},{"location":"GLES/GLES%20Object%20Model.mm/#19-vertex-array","text":"","title":"1.9. Vertex Array"},{"location":"GLES/GLES%20Object%20Model.mm/#191-generic-vertex-attributes","text":"","title":"1.9.1. Generic Vertex Attributes"},{"location":"GLES/GLES%20Object%20Model.mm/#192-vertex-attribute-divisors","text":"","title":"1.9.2. Vertex Attribute Divisors"},{"location":"GLES/GLES%20Object%20Model.mm/#193-drawing-commands","text":"For all the functions in this section: mode: LINE_LOOP, LINE_[STRIP_]ADJACENCY, LINES, LINES_ADJACENCY, PATCHES TRIANGLE_FAN, POINTS[ TRIANGLES_ADJACENCY], TRIANGLES, TRIANGLE_STRIP[ ADJACENCY] type: UNSIGNED_{BYTE, SHORT, INT} void DrawArrays (enum mode, int first, sizei count); void DrawArraysInstanced (enum mode, int first, sizei count, sizei instancecount); void DrawArraysIndirect (enum mode, const void *indirect); void DrawElements (enum mode, sizei count, enum type, const void *indices); void DrawElementsInstanced (enum mode, sizei count, enum type, const void *indices, sizei instancecount); void DrawRangeElements (enum mode, uint start, uint end, sizei count, enum type, const void *indices); void DrawElementsBaseVertex (enum mode, sizei count, enum type, const void *indices, int basevertex); void DrawRangeElementsBaseVertex (enum mode, uint start, uint end, sizei count, enum type, const void *indices, int basevertex); void DrawElementsInstancedBaseVertex(enum mode, sizei count,enum type, const void *indices, sizei instancecount, int basevertex); void DrawElementsIndirect (enum mode,enum type, const void *indirect);","title":"1.9.3. Drawing Commands"},{"location":"GLES/GLES%20Object%20Model.mm/#194-vertex-attributes","text":"","title":"1.9.4. Vertex Attributes"},{"location":"GLES/GLES%20Object%20Model.mm/#110-transform-feedback","text":"","title":"1.10. Transform Feedback"},{"location":"GLES/GLES%20Object%20Model.mm/#111-query","text":"","title":"1.11. Query"},{"location":"GLES/GLES%20Object%20Model.mm/#112-sync","text":"","title":"1.12. Sync"},{"location":"GLES/GLES%20Object%20Model.mm/#2-operation","text":"","title":"2. Operation \u64cd\u4f5c"},{"location":"GLES/GLES%20Object%20Model.mm/#21-vertex-post-processing","text":"","title":"2.1. Vertex Post-Processing"},{"location":"GLES/GLES%20Object%20Model.mm/#211-transform-feedback-121","text":"void GenTransformFeedbacks void DeleteTransformFeedbacks boolean IsTransformFeedback void BindTransformFeedback void BeginTransformFeedback void EndTransformFeedback void PauseTransformFeedback void ResumeTransformFeedback","title":"2.1.1. Transform Feedback [12.1]"},{"location":"GLES/GLES%20Object%20Model.mm/#212-controlling-viewport-1251","text":"void DepthRangef(float n, float f); void Viewport(int x, int y, sizei w, sizei h);","title":"2.1.2. Controlling Viewport [12.5.1]"},{"location":"GLES/GLES%20Object%20Model.mm/#22-rasterization","text":"","title":"2.2. Rasterization"},{"location":"GLES/GLES%20Object%20Model.mm/#221-primitive-bounding-box-132","text":"void PrimitiveBoundingBox(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW);","title":"2.2.1. Primitive Bounding Box [13.2]"},{"location":"GLES/GLES%20Object%20Model.mm/#222-multisampling-134","text":"Use to antialias points and lines. void GetMultisamplefv(enum pname, uint index, float *val); pname: SAMPLE_POSITION","title":"2.2.2. Multisampling [13.4]"},{"location":"GLES/GLES%20Object%20Model.mm/#223-sample-shading-1341","text":"void MinSampleShading(float value);","title":"2.2.3. Sample Shading [13.4.1]"},{"location":"GLES/GLES%20Object%20Model.mm/#224-points-135","text":"Point size is taken from the shader built-in gl_PointSize and clamped to the implementation-dependent point size range.","title":"2.2.4. Points [13.5]"},{"location":"GLES/GLES%20Object%20Model.mm/#225-line-segments-136","text":"void LineWidth(float width);","title":"2.2.5. Line Segments [13.6]"},{"location":"GLES/GLES%20Object%20Model.mm/#226-polygons-137","text":"void FrontFace(enum dir); Enable(CULL_FACE) Disable(CULL_FACE) IsEnabled(CULL_FACE) void CullFace(enum mode); Enable(POLYGON_OFFSET_FILL) Disable(POLYGON_OFFSET_FILL) IsEnabled(POLYGON_OFFSET_FILL) void PolygonOffset(float factor, float units);","title":"2.2.6. Polygons [13.7]"},{"location":"GLES/GLES%20Object%20Model.mm/#23-whole-framebuffer-operations","text":"Whole Framebuffer Operations","title":"2.3. Whole Framebuffer Operations"},{"location":"GLES/GLES%20Object%20Model.mm/#selecting-buffers-for-writing-1521","text":"void DrawBuffers(sizei n, const enum *bufs);","title":"Selecting Buffers for Writing [15.2.1]"},{"location":"GLES/GLES%20Object%20Model.mm/#fine-control-of-buffer-updates-1522","text":"void ColorMask(boolean r, boolean g, boolean b, boolean a); void ColorMaski(uint buf, boolean r, boolean g, boolean b, boolean a); void DepthMask(boolean mask); void StencilMask(uint mask); void StencilMaskSeparate(enum face, uint mask); face: FRONT, BACK, FRONT_AND_BACK","title":"Fine Control of Buffer Updates [15.2.2]"},{"location":"GLES/GLES%20Object%20Model.mm/#clearing-the-buffers-1523","text":"void Clear(bitfield buf); buf: Zero or Bitwise OR of {COLOR, DEPTH, STENCIL}_BUFFER_BIT void ClearColor(float r, float g, float b, float a); void ClearDepthf(float d); void ClearStencil(int s); void ClearBuffer{i f ui}v(enum buffer, int drawbuffer, const T *value); buffer: COLOR, DEPTH, STENCIL void ClearBufferfi(enum buffer, int drawbuffer, float depth, int stencil); buffer: DEPTH_STENCIL drawbuffer: 0","title":"Clearing the Buffers [15.2.3]"},{"location":"GLES/GLES%20Object%20Model.mm/#invalidating-framebuffer-contents-1524","text":"void InvalidateSubFramebuffer(enum target, sizei numAttachments, const enum *attachments, int x, int y, sizei width, sizei height); target: [DRAW_, READ_]FRAMEBUFFER attachments: points to an array of COLOR, STENCIL, {COLOR, DEPTH, STENCIL}_ATTACHMENT void InvalidateFramebuffer(","title":"Invalidating Framebuffer Contents [15.2.4]"},{"location":"GLES/GLES%20Object%20Model.mm/#24-per-fragment-operations","text":"","title":"2.4. Per-Fragment Operations"},{"location":"GLES/GLES%20Object%20Model.mm/#scissor-test-1382","text":"Enable/Disable(SCISSOR_TEST); void Scissor(int left, int bottom, sizei width, sizei height);","title":"Scissor Test [13.8.2]"},{"location":"GLES/GLES%20Object%20Model.mm/#multisample-fragment-ops-1383","text":"Enable/Disable(cap); cap: SAMPLE_ALPHA_TO_COVERAGE, SAMPLE_COVERAGE void SampleCoverage(float value, boolean invert); void SampleMaski(uint maskNumber, bitfield mask);","title":"Multisample Fragment Ops. [13.8.3]"},{"location":"GLES/GLES%20Object%20Model.mm/#stencil-test-1512","text":"Enable/Disable(STENCIL_TEST); void StencilFunc (enum func, int ref, uint mask); func: ALWAYS, EQUAL, GEQUAL, GREATER, LEQUAL, LESS, NEVER, NOTEQUAL void StencilFuncSeparate (enum face, enum func, int ref, uint mask); func: See StencilFunc face: BACK, FRONT, FRONT_AND_BACK void StencilOp (enum sfail, enum dpfail, enum dppass); void StencilOpSeparate (enum face, enum sfail, enum dpfail, enum dppass); face: BACK, FRONT, FRONT_AND_BACK sfail, dpfail, dppass: DECR, DECR_WRAP, INCR, INCR_WRAP, INVERT, KEEP, REPLACE, ZERO","title":"Stencil Test [15.1.2]"},{"location":"GLES/GLES%20Object%20Model.mm/#depth-buffer-test-1513","text":"Enable/Disable(DEPTH_TEST); void DepthFunc (enum func); func: See StencilFunc","title":"Depth Buffer Test [15.1.3]"},{"location":"GLES/GLES%20Object%20Model.mm/#blending-1515","text":"void Enablei (enum target, uint index); void Disablei (enum target, uint index); target: must be BLEND Enable/Disable/IsEnabled(BLEND); void BlendColor (float red, float green, float blue, float alpha); void BlendEquation (enum mode); void BlendEquationSeparate (enum modeRGB, enum modeAlpha); mode, modeRGB, modeAlpha: FUNC_{ADD, SUBTRACT, REVERSE_SUBTRACT}, MAX, MIN void BlendEquationi (uint buf, enum mode); void BlendEquationSeparatei (uint buf, enum modeRGB, enum modeAlpha ); modeRGB, modeAlpha: See BlendEquationSeparate void BlendFunc(enum src, enum dst); src, dst: See BlendFuncSeparate void BlendFuncSeparate (enum srcRGB, enum dstRGB, enum srcAlpha, enum dstAlpha); src, dst, srcRGB, dstRGB, srcAlpha, dstAlpha: {CONSTANT, DST, SRC} COLOR, {CONSTANT, DST, SRC}_ALPHA, ONE, ONE_MINUS_SRC {ALPHA, COLOR}, ONE_MINUS_{CONSTANT, DST} ALPHA , ONE_MINUS {CONSTANT, DST}_COLOR, SRC_ALPHA_SATURATE, ZERO void BlendFunci (uint buf, enum src, enum dst); void BlendFuncSeparatei (uint buf, enum srcRGB, enum dstRGB, enum srcAlpha, enum dstAlpha); modeRGB, modeAlpha: See BlendFuncSeparate void BlendBarrier(void);","title":"Blending [15.1.5]"},{"location":"GLES/GLES%20Object%20Model.mm/#dithering-1517","text":"Enable/Disable/IsEnabled(DITHER);","title":"Dithering [15.1.7]"},{"location":"GLES/GLES%20Object%20Model.mm/#25-reading-and-copying-pixels-and-images","text":"","title":"2.5. Reading and Copying Pixels and Images"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/","text":"Vulkan \u6269\u5c55 (\u672c\u7ae0\u6587\u672c\u5185\u5bb9\u7684\u66f4\u591a\u7ec6\u8282, \u53c2\u89c1 Vulkan Specification 1.1 , \u4ee3\u7801\u4e3a\u793a\u4f8b\u7528\u4f2a\u7801) \u5bf9\u4e8e\u4e0d\u540c\u7684\u5e73\u53f0, \u9a71\u52a8, \u64cd\u4f5c\u7cfb\u7edf\u7b49, \u5f53Vulkan\u7684\u5e95\u5c42\u5b9e\u73b0\u4e0d\u540c\u65f6, Vulkan \u53ef\u7528\u7684\u529f\u80fd\u96c6\u4e5f\u6709\u5f88\u591a\u533a\u522b. \u672c\u7ae0\u63cf\u8ff0\u4e86 Vulkan \u5982\u4f55\u5b9a\u4e49\u548c\u6269\u5c55\u529f\u80fd\u96c6, \u4e3b\u8981\u4ecb\u7ecd\u4e86\u56db\u4e2a\u6982\u5ff5: Extension, Feature, Limitation, \u548c Format. Vulkan \u521d\u59cb\u5316\u6d41\u7a0b \u5728\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u65f6, \u9700\u8981\u542f\u7528\u7684 Vulkan \u529f\u80fd\u96c6\u9700\u8981\u5728\u521d\u59cb\u5316 Device \u524d\u786e\u5b9a\u4e0b\u6765. \u5bf9\u5e94 vk \u521d\u59cb\u5316\u7684\u524d\u4e09\u6b65: Instance --> Physical Device --> Device \u4ee5\u4e0b\u662f\u521d\u59cb\u5316\u8fc7\u7a0b\u4e2d\u4e0e\u529f\u80fd\u76f8\u5173\u7684\u8fc7\u7a0b: \u679a\u4e3e vk \u652f\u6301\u7684 Instance-level Extensions \u521b\u5efa Instance \u679a\u4e3e \u7269\u7406\u8bbe\u5907, \u9009\u62e9 GPU, \u679a\u4e3e GPU \u652f\u6301\u7684 Device Extensions, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u200b \u67e5\u8be2\u652f\u6301\u7684 Extensions \u7684 Features \u7ed3\u6784\u4f53, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u200b \u67e5\u8be2\u652f\u6301\u7684 Extensions \u7684 Properties \u7ed3\u6784\u4f53 \u67e5\u8be2 GPU \u652f\u6301\u7684 Feature, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u67e5\u8be2 GPU \u7684 Properties \u5c06\u542f\u7528\u7684 Extensions \u548c Features \u5217\u8868\u653e\u5165 CreateInfo \u7ed3\u6784\u4f53, \u521b\u5efa\u903b\u8f91\u8bbe\u5907 Device, Extension: \u529f\u80fd\u96c6\u7684\u62bd\u8c61\u6982\u5ff5, \u7528\u6765\u4e3a Vulkan \u6dfb\u52a0\u65b0\u7684 Commands\uff0cStructures \u548c Enumerants. \u540c\u65f6\u53ef\u80fd\u65b0\u589e Features, Limitations, \u548c Format. Feature: bool \u503c\u96c6\u5408, \u53ef\u9009\u529f\u80fd\u7684\u5f00\u5173. \u53ef\u4ee5\u7528\u6765\u67e5\u8be2\u8bbe\u5907\u652f\u6301\u7684\u529f\u80fd, Limitation \u548c Format \u662f\u4e24\u4e2a\u53ea\u8bfb\u53c2\u6570\u96c6, Limitation \u53c8\u79f0\u505a Properties, \u8868\u793a\u8bbe\u5907\u7279\u5f81\u503c; Format \u8868\u793a\u652f\u6301\u7684\u683c\u5f0f. \u672c\u7ae0\u540e\u9762\u5404\u7ae0\u8282\u5bf9\u6b64\u6d41\u7a0b\u5404\u6b65\u9aa4\u8fdb\u884c\u89e3\u91ca, \u5e76\u5305\u542b\u793a\u4f8b\u4ee3\u7801. Extensions: \u6269\u5c55 \u6269\u5c55 (Extensions) \u53ef\u7528\u6765\u4e3a Vk \u6dfb\u52a0\u65b0\u529f\u80fd. Vk \u6838\u5fc3\u7684\u65b0\u7248\u672c (\u5982: VK_VERSION_1_1) \u4e5f\u53ef\u4ee5\u89c6\u4e3a\u4e00\u4e2a\u6269\u5c55. \u6269\u5c55\u53ef\u4ee5\u5b9a\u4e49\u65b0\u7684 \u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784. ( Commands\uff0cStructures \u548c Enumerants) \u6269\u5c55\u5206\u4e3a\u5b9e\u4f8b\u7ea7\u548c\u8bbe\u5907\u7ea7 (Instance-level \u548c Device-level) \u5f53 Commands \u7528\u6765\u679a\u4e3e\u5b9e\u4f8b\u5c5e\u6027 (instance properties), \u6216\u63a5\u53d7 VkInstance \u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570, \u5219\u88ab\u89c6\u4e3a\u5b9e\u4f8b\u7ea7\u529f\u80fd\u3002 \u5f53 Commands \u7528\u6765\u679a\u4e3e\u7269\u7406\u8bbe\u5907\u5c5e\u6027 (physical device properties), \u6216\u63a5\u53d7 VkDevice \u53ca\u5176\u5b50\u7c7b\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\uff0c\u5219\u88ab\u89c6\u4e3a\u8bbe\u5907\u7ea7\u529f\u80fd\u3002 \u4e3a\u4e86\u65b9\u4fbf\u7f16\u8bd1\uff0c\u5728 Khronos \u63d0\u4f9b\u7684 vulkan_core.h \u4e2d\u9664\u4e86\u6838\u5fc3API, \u8fd8\u5b9a\u4e49\u4e86\u5df2\u6ce8\u518c Extensions \u5b9a\u4e49\u7684\u63a5\u53e3\uff0c\u5305\u62ec\u65b0 \u7ed3\u6784, \u679a\u4e3e, \u548c\u547d\u4ee4\u7684\u51fd\u6570\u6307\u9488\u7c7b\u578b\u3002\u6269\u5c55\u7684\u5b9e\u73b0\u901a\u8fc7 Layers \u548c Vulkan\u5b9e\u73b0\u6765\u63d0\u4f9b\u3002 \u542f\u7528 Vk Extensions Vk Extensions \u9700\u8981\u5728\u521d\u59cb\u5316\u9636\u6bb5\u663e\u5f0f\u542f\u7528. \u542f\u7528 instance extension, \u8981\u5728\u521b\u5efa VKInstance \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkInstanceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. \u542f\u7528 device extension, \u8981\u5728 \u521b\u5efa VkDevice \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkDeviceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. Physical-Device-Level \u529f\u80fd\u6ca1\u6709\u542f\u7528\u673a\u5236\uff0c\u53ea\u8981 VkPhysicalDevice \u7684\u529f\u80fd\u5bf9\u5e94\u7684 Extensions \u5728\u679a\u4e3e\u51fd\u6570 vkEnumerateDeviceExtensionProperties \u4e2d\u88ab\u5217\u51fa. \u4ec5 \u542f\u7528 \u6269\u5c55\u64cd\u4f5c\u800c\u8a00, \u9664\u4e86 \u542f\u7528 \u8be5\u6269\u5c55\u81ea\u8eab\u5b9a\u4e49\u7684\u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784\u5916, \u4e0d\u4f1a\u66f4\u6539\u6838\u5fc3Vulkan API \u6216\u5176\u4ed6\u6269\u5c55\u7684\u529f\u80fd\u3002 \u793a\u4f8b: \u521b\u5efa VkInstance \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> extensions(); extensions.push_back(VK_KHR_WIN32_SURFACE_EXTENSION_NAME); VkInstanceCreateInfo inst_info = {}; inst_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; ... // Enable Instance Extensions inst_info.enabledExtensionCount = extensions.size(); inst_info.ppEnabledExtensionNames = extensions.data(); VkInstance instance; VkResult res = vkCreateInstance(&inst_info, NULL, &instance); \u5bf9 VkPhysicalDevice, \u679a\u4e3e\u5176\u652f\u6301\u7684 Extensions: // \u679a\u4e3e\u8bbe\u5907 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); // \u9009\u62e9\u8bbe\u5907 VkPhysicalDevice physicalDevice = devices[0]; // \u4ec5\u793a\u4f8b,\u6b63\u786e\u4ee3\u7801\u5e94\u9009\u62e9\u5bf9\u5e94 GPU \u8bbe\u5907 // \u679a\u4e3e Extensions uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, availableExtensions.data()); \u521b\u5efa VkDevice \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> device_extension_names(); // check if physicalDevice support extension: for (const auto& extension : availableExtensions) { if(strcmp(extension.extensionName, VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0) device_extension_names.push_back(extension.extensionName); } } VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; device_info.pNext = NULL; ... // Enable Device Extensions device_info.enabledExtensionCount = device_extension_names.size(); device_info.ppEnabledExtensionNames = enabledExtensionCount ? device_extension_names.data() : NULL; VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device); Features: \u529f\u80fd Features \u7528\u6765\u8bbe\u7f6e\u6216\u67e5\u8be2 \u975e\u6240\u6709\u5b9e\u73b0\u90fd\u652f\u6301 \u7684\u529f\u80fd\u3002 Feature \u5747\u4e3a bool \u503c. Features \u662f\u7269\u7406\u8bbe\u5907\u7684\u5c5e\u6027\u3002(physical device properties) \u8fd9\u4e9b\u529f\u80fd\u662f\u201c\u53ef\u9009\u201d\u7684\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u4f7f\u7528\u524d\u660e\u786e\u542f\u7528\u3002 \u6838\u5fc3 Features Vk \u6838\u5fc3\u4e2d\u5b9a\u4e49\u7684 Features, \u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceFeatures \u67e5\u8be2. VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); \u67e5\u8be2\u7ed3\u679c VkPhysicalDeviceFeatures \u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceFeatures { VkBool32 robustBufferAccess; VkBool32 fullDrawIndexUint32; VkBool32 imageCubeArray; VkBool32 independentBlend; VkBool32 geometryShader; VkBool32 tessellationShader; VkBool32 sampleRateShading; .... // \u603b\u8ba150+\u4e2a Bool \u503c } VkPhysicalDeviceFeatures \u5176\u4e2d\u6bcf\u4e2a Feature \u7684\u542b\u4e49 \u5728 Vulkan Specification 1.1/Features \u4e2d\u90fd\u6709\u89e3\u91ca. \u4f8b\u5982: IndependentBlend \u6307\u5b9a: \u662f\u5426\u6bcf\u4e2a attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u4e92\u76f8\u72ec\u7acb\u3002 \u672a\u542f\u7528\u6b64 Feature\uff0c\u5219\u6240\u6709 color attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u5fc5\u987b\u76f8\u540c\u3002 \u82e5\u542f\u7528\u6b64 Feature\uff0c\u5219\u53ef\u4ee5\u4e3a\u6bcf\u4e2a\u7ed1\u5b9a\u7684 color attachment \u63d0\u4f9b\u4e0d\u540c\u7684 VkPipelineColorBlendAttachmentState \u3002 \u6269\u5c55\u63d0\u4f9b\u7684Features \u67e5\u8be2\u51fd\u6570: vkGetPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 physicalDeviceFeatures2; vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &physicalDeviceFeatures2); \u67e5\u8be2\u7ed3\u679c: VkPhysicalDeviceFeatures2 \u7ed3\u6784: // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; sType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 pNext: \u6307\u9488\u94fe. VkPhysicalDeviceFeatures: Vulkan 1.0 \u63d0\u4f9b\u7684\u6838\u5fc3 Features \u6ce8: VkPhysicalDeviceFeatures2 \u7b49\u4ef7 VkPhysicalDeviceFeatures2KHR, vkGetPhysicalDeviceFeatures2 \u7b49\u4ef7 vkGetPhysicalDeviceFeatures2KHR \u901a\u8fc7 pNext , \u53ef\u4ee5\u83b7\u5f97\u6269\u5c55\u6240\u5b9a\u4e49\u7684 Features \u7ed3\u6784\u4f53, \u6709\u7684\u7531 Vulkan \u6838\u5fc3\u65b0\u7248\u672c\u63d0\u4f9b, \u6709\u7684\u7531\u5176\u4ed6 Extension\u63d0\u4f9b. \u4f8b\u5982: Vulkan 1.1 \u63d0\u4f9b\u7684 samplerYcbcrConversion. // Provided by VK_VERSION_1_1: VK_KHR_sampler_ycbcr_conversion typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures { VkStructureType sType; void* pNext; VkBool32 samplerYcbcrConversion; } VkPhysicalDeviceSamplerYcbcrConversionFeatures; VK_EXT_transform_feedback \u63d0\u4f9b\u7684 transformFeedback \u548c geometryStreams. // Provided by VK_EXT_transform_feedback typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 transformFeedback; VkBool32 geometryStreams; } VkPhysicalDeviceTransformFeedbackFeaturesEXT; \u67e5\u8be2\u793a\u4f8b: // \u6269\u5c55\u7684 Feature \u7ed3\u6784\u4f53 VkPhysicalDeviceSamplerYcbcrConversionFeatures mSamplerYcbcrConversionFeatures = {}; mSamplerYcbcrConversionFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; // vk1.1 \u7684 VkPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 deviceFeatures = {}; deviceFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; deviceFeatures.pNext = mVertexAttributeDivisorFeatures // \u67e5\u8be2 vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &deviceFeatures); // \u4f7f\u7528 if (mVertexAttributeDivisorFeatures.vertexAttributeInstanceRateDivisor) { ... } \u542f\u7528 Features Features \u9ed8\u8ba4\u7686\u4e3a\u4e0d\u542f\u7528\u72b6\u6001. \u5fc5\u987b\u5728 VkDevice \u521b\u5efa\u65f6\u663e\u5f0f\u542f\u7528\u3002\u5982\u679c\u542f\u7528\u4e86\u7269\u7406\u8bbe\u5907\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5219 VkDevice \u521b\u5efa\u5c06\u5931\u8d25\uff0c\u5e76\u8fd4\u56deVK_ERROR_FEATURE_NOT_PRESENT\u3002 \u542f\u7528\u65b9\u6cd5: \u521b\u5efa VkPhysicalDeviceFeatures \u7ed3\u6784\u7684\u6307\u9488 (\u62161.1\u7684 VkPhysicalDeviceFeatures2\u7ed3\u6784) \u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \u6216 VK_FALSE, eg: physicalDeviceFeatures.independentBlend = VK_TRUE \u901a\u8fc7\u4f20\u9012\u7ed9 vkCreateDevice \u7528\u7684 VkDeviceCreateInfo\u7ed3\u6784\u7684 pEnabledFeatures \u6210\u5458. \u8981\u542f\u52a8\u6240\u6709\u8bbe\u5907\u7684\u529f\u80fd (\u614e\u7528)\uff0c\u5219\u53ea\u9700\u4f20\u5165\u67e5\u8be2\u51fd\u6570 vkGetPhysicalDeviceFeatures \u8fd4\u56de\u7684 VkPhysicalDeviceFeatures \u7ed3\u6784\u5373\u53ef\u3002\u8981\u7981\u7528\u5355\u4e2a\u529f\u80fd\uff0c\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728\u76f8\u540c\u7ed3\u6784\u4e2d\u5c06\u6240\u9700\u6210\u5458\u8bbe\u7f6e\u4e3aVK_FALSE\u3002 \u7528\u8fc7\u7ed9 pNext\u94fe\u6dfb\u52a0 Extensions \u63d0\u4f9b\u7684 Features \u7ed3\u6784\u4f53, \u6765\u542f\u7528\u6269\u5c55\u7684 Features. // \u67e5\u8be2\u6838\u5fc3 Features \u662f\u5426\u652f\u6301 VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); // \u8bbe\u7f6e\u542f\u7528 Features VkPhysicalDeviceFeatures2KHR enabledFeatures = {}; enabledFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; enabledFeatures.features.imageCubeArray = mPhysicalDeviceFeatures.imageCubeArray; enabledFeatures.features.independentBlend = mPhysicalDeviceFeatures.independentBlend; // Create Device VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; // \u6307\u5411 Features \u7ed3\u6784\u4f53\u4ee5\u8bbe\u7f6e Extensions \u63d0\u4f9b\u7684 Features // mSamplerYcbcrConversionFeatures : \u524d\u9762\u67e5\u8be2\u793a\u4f8b\u4e2d\u7684\u7ed3\u6784\u4f53. device_info.pNext = mSamplerYcbcrConversionFeatures; // Enable Physical Device Features device_info.pEnabledFeatures = &enabledFeatures.features; ... VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device); Limitations Limits \u63d0\u4f9b\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u53ef\u80fd\u9700\u8981\u660e\u786e\u7684\u4e00\u4e9b\u8bbe\u5907\u7279\u5f81\u503c, \u8fd9\u4e9b\u7279\u5f81\u7684\u6700\u5c0f\u503c\uff0c\u6700\u5927\u503c\u7b49\u4f1a\u968f\u5e95\u5c42\u5b9e\u73b0\u7684\u4e0d\u540c\u800c\u5f02. \u901a\u8fc7 VkPhysicalDeviceLimits \u7ed3\u6784\u4f53\u83b7\u53d6\u6838\u5fc31.0\u7684 Limits, \u6216\u5229\u7528 vk1.1 \u4e2d\u52a0\u5165\u7684 VkPhysicalDeviceProperties2 \u7684 pNext \u94fe \u83b7\u53d6\u5404 Extension \u65b0\u589e\u7684 Limits . \u7ed3\u6784\u4f53 VkPhysicalDeviceLimits \u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7701\u7565\u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd: \u4f8b\u5982: maxUniformBufferRange : \u5f53\u5c06\u7ed3\u6784\u4f53 VkDescriptorBufferInfo \u4f5c\u4e3a\u53c2\u6570\u8c03\u7528 vkUpdateDescriptorSets , \u5e76\u4e14 descriptors \u7c7b\u578b\u4e3a VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER \u6216 VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC \u65f6, \u5176\u7ed3\u6784\u4f53\u6210\u5458 range \u53ef\u8bbe\u7684\u6700\u5927\u503c. \u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684Limits \u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684\u7ed3\u6784\u4f53\u5747\u4ee5 Properties \u800c\u975e Limits \u7ed3\u5c3e, \u5176\u67e5\u8be2\u65b9\u6cd5\u4e0e\u67e5\u8be2 \u6269\u5c55\u63d0\u4f9b\u7684 Feature \u4e00\u6837. \u67e5\u8be2\u51fd\u6570\u548c\u7ed3\u679c\u7ed3\u6784\u4f53\u5982\u4e0b: VkPhysicalDeviceProperties2 deviceProperties; vkGetPhysicalDeviceProperties2KHR(mPhysicalDevice, &deviceProperties); \u67e5\u8be2\u7ed3\u679c\u793a\u4f8b: \u7ed3\u6784\u4f53 VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT \u5305\u542b\u4e86\u6269\u5c55 VK_EXT_vertex_attribute_divisor \u63d0\u4f9b\u7684 limits \u503c maxVertexAttribDivisor : // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT; Formats \u5bf9\u4e8e\u4e0d\u540c\u7684 vk \u5b9e\u73b0, \u5176\u652f\u6301\u7684\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u683c\u5f0f\u53ef\u80fd\u4f1a\u4e0d\u540c\u3002\u867d\u7136 Vulkan \u89c4\u5b9a\u4e86\u4e00\u7ec4\u5fc5\u987b\u652f\u6301\u7684 Format \u7684\u6700\u5c0f\u96c6\uff0c\u4f46\u5728\u4f7f\u7528\u9664\u6b64\u4ee5\u5916\u7684 Format\u529f\u80fd\u4e4b\u524d, \u5fc5\u987b\u663e\u5f0f\u7684\u67e5\u8be2\uff0c\u4ee5\u786e\u4fdd\u5b9e\u73b0\u652f\u6301\u8fd9\u4e9b\u683c\u5f0f\u3002 \u67e5\u8be2\u547d\u4ee4: vkGetPhysicalDeviceFormatProperties , \u67e5\u8be2\u8fd4\u56de\u7684 VkFormat \u7ed3\u6784\u4f53\u7684\u5305\u542b\u4e86\u5f53\u524d\u5b9e\u73b0\u6240\u652f\u6301\u7684\u683c\u5f0f\u529f\u80fd\u3002 VkFormat \u7ed3\u6784\u4f53\u793a\u4f8b: // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d \u5173\u4e8e Format \u76f8\u5173\u7684\u5185\u5bb9\u6bd4\u8f83\u590d\u6742, \u672c\u7ae0\u8282\u4ee5\u53ca\u540e\u7eed\u7ae0\u8282\u90fd\u4e0d\u8fdb\u884c\u6df1\u5165. \u5982\u679c\u9700\u8981\u8003\u8651\u518d\u5355\u72ec\u8fdb\u884c\u7814\u7a76. 39. Extending Vulkan New functionality may be added to Vulkan via either new extensions or new versions of the core, or new versions of an extension in some cases. This chapter describes how Vulkan is versioned, how compatibility is affected between different versions, and compatibility rules that are followed by the Vulkan Working Group. 39.1. Instance and Device Functionality Commands that enumerate instance properties, or that accept a VkInstance object as a parameter, are considered instance-level functionality. Commands that enumerate physical device properties, or that accept a VkDevice object or any of a device\u2019s child objects as a parameter, are considered device-level functionality. 39.4. Extensions Extensions may define new Vulkan commands, structures, and enumerants. For compilation purposes, the interfaces defined by registered extensions, including new structures and enumerants as well as function pointer types for new commands, are defined in the Khronos-supplied vulkan_core.h together with the core API. However, commands defined by extensions may not be available for static linking - in which case function pointers to these commands should be queried at runtime as described in Command Function Pointers . Extensions may be provided by layers as well as by a Vulkan implementation. Because extensions may extend or change the behavior of the Vulkan API, extension authors should add support for their extensions to the Khronos validation layers. This is especially important for new commands whose parameters have been wrapped by the validation layers. See the \u201cVulkan Loader Specification and Architecture Overview\u201d document for additional information. 39.4.1. Instance Extensions Instance extensions add new instance-level functionality to the API, outside of the core specification. To query the available instance extensions, call: // Provided by VK_VERSION_1_0 VkResult vkEnumerateInstanceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties); pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, as described below. pProperties is either NULL or a pointer to an array of VkExtensionProperties structures. When pLayerName parameter is NULL , only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the instance extensions provided by that layer are returned. If pProperties is NULL , then the number of extensions properties available is returned in pPropertyCount . Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties . If pPropertyCount is less than the number of extension properties available, at most pPropertyCount structures will be written. If pPropertyCount is smaller than the number of extensions available, VK_INCOMPLETE will be returned instead of VK_SUCCESS , to indicate that not all the available properties were returned. Because the list of available layers may change externally between calls to vkEnumerateInstanceExtensionProperties , two calls may retrieve different results if a pLayerName is available in one call but not in another. The extensions supported by a layer may also change between two calls, e.g. if the layer implementation is replaced by a different version between those calls. Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version. 39.4.2. Device Extensions Device extensions add new device-level functionality to the API, outside of the core specification. To query the extensions available to a given physical device, call: // Provided by VK_VERSION_1_0 VkResult vkEnumerateDeviceExtensionProperties( VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties); physicalDevice is the physical device that will be queried. pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, and is treated in the same fashion as the vkEnumerateInstanceExtensionProperties :: pPropertyCount parameter. pProperties is either NULL or a pointer to an array of VkExtensionProperties structures. When pLayerName parameter is NULL , only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the device extensions provided by that layer are returned. Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version. 40. Features Features describe functionality which is not supported on all implementations. Features are properties of the physical device. Features are optional , and must be explicitly enabled before use. Support for features is reported and enabled on a per-feature basis. NoteFeatures are reported via the basic VkPhysicalDeviceFeatures structure, as well as the extensible structure VkPhysicalDeviceFeatures2 , which was added in the VK_KHR_get_physical_device_properties2 extension and included in Vulkan 1.1. When new features are added in future Vulkan versions or extensions, each extension should introduce one new feature structure, if needed. This structure can be added to the pNext chain of the VkPhysicalDeviceFeatures2 structure. For convenience, new core versions of Vulkan may introduce new unified features structures for features promoted from extensions. At the same time, the extension\u2019s original features structure (if any) is also promoted to the core API, and is an alias of the extension\u2019s structure. This results in multiple names for the same feature: in the original extension\u2019s feature structure and the promoted structure alias, in the unified feature structure. When a feature was implicitly supported and enabled in the extension, but an explicit name was added during promotion, then the extension itself acts as an alias for the feature as listed in the table below. All aliases of the same feature in the core API must be reported consistently: either all must be reported as supported, or none of them. When a promoted extension is available, any corresponding feature aliases must be supported. // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; The pNext chain of this structure is used to extend the structure with features defined by extensions. Fine-grained features used by a logical device must be enabled at VkDevice creation time. If a feature is enabled that the physical device does not support, VkDevice creation will fail and return VK_ERROR_FEATURE_NOT_PRESENT . The fine-grained features are enabled by passing a pointer to the VkPhysicalDeviceFeatures structure via the pEnabledFeatures member of the VkDeviceCreateInfo structure that is passed into the vkCreateDevice call. If a member of pEnabledFeatures is set to VK_TRUE or VK_FALSE , then the device will be created with the indicated feature enabled or disabled, respectively. Features can also be enabled by using the VkPhysicalDeviceFeatures2 structure. If an application wishes to enable all features supported by a device, it can simply pass in the VkPhysicalDeviceFeatures structure that was previously returned by vkGetPhysicalDeviceFeatures . To disable an individual feature, the application can set the desired member to VK_FALSE in the same structure. Setting pEnabledFeatures to NULL and not including a VkPhysicalDeviceFeatures2 in the pNext chain of VkDeviceCreateInfo is equivalent to setting all members of the structure to VK_FALSE . To query support for atomic operations on floating-point numbers, call vkGetPhysicalDeviceFeatures2 with a VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure included in the pNext chain of its pFeatures parameter. The VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure is defined as: // Provided by VK_EXT_shader_atomic_float typedef struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 shaderBufferFloat32Atomics; VkBool32 shaderBufferFloat32AtomicAdd; VkBool32 shaderBufferFloat64Atomics; VkBool32 shaderBufferFloat64AtomicAdd; VkBool32 shaderSharedFloat32Atomics; VkBool32 shaderSharedFloat32AtomicAdd; VkBool32 shaderSharedFloat64Atomics; VkBool32 shaderSharedFloat64AtomicAdd; VkBool32 shaderImageFloat32Atomics; VkBool32 shaderImageFloat32AtomicAdd; VkBool32 sparseImageFloat32Atomics; VkBool32 sparseImageFloat32AtomicAdd; } VkPhysicalDeviceShaderAtomicFloatFeaturesEXT; 41. Limits Limits are implementation-dependent minimums, maximums, and other device characteristics that an application may need to be aware of. NoteLimits are reported via the basic VkPhysicalDeviceLimits structure, as well as the extensible structure VkPhysicalDeviceProperties2 , which was added in VK_KHR_get_physical_device_properties2 and included in Vulkan 1.1. When limits are added in future Vulkan versions or extensions, each extension should introduce one new limit structure, if needed. This structure can be added to the pNext chain of the VkPhysicalDeviceProperties2 structure. The VkPhysicalDeviceLimits structure is defined as: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd The VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure is defined as: // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT; 42. Formats Supported buffer and image formats may vary across implementations. A minimum set of format features are guaranteed, but others must be explicitly queried before use to ensure they are supported by the implementation. The features for the set of formats ( VkFormat ) supported by the implementation are queried individually using the vkGetPhysicalDeviceFormatProperties command. 42.1. Format Definition The following image formats can be passed to, and may be returned from Vulkan commands. The memory required to store each format is discussed with that format, and also summarized in the Representation and Texel Block Size section and the Compatible formats table. // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d 43. Additional Capabilities This chapter describes additional capabilities beyond the minimum capabilities described in the ( Limits and Formats chapters, including: Additional Image Capabilities Additional Buffer Capabilities Optional Semaphore Capabilities Optional Fence Capabilities Timestamp Calibration Capabilities","title":"0.1. Vulkan \u6269\u5c55"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#vulkan","text":"(\u672c\u7ae0\u6587\u672c\u5185\u5bb9\u7684\u66f4\u591a\u7ec6\u8282, \u53c2\u89c1 Vulkan Specification 1.1 , \u4ee3\u7801\u4e3a\u793a\u4f8b\u7528\u4f2a\u7801) \u5bf9\u4e8e\u4e0d\u540c\u7684\u5e73\u53f0, \u9a71\u52a8, \u64cd\u4f5c\u7cfb\u7edf\u7b49, \u5f53Vulkan\u7684\u5e95\u5c42\u5b9e\u73b0\u4e0d\u540c\u65f6, Vulkan \u53ef\u7528\u7684\u529f\u80fd\u96c6\u4e5f\u6709\u5f88\u591a\u533a\u522b. \u672c\u7ae0\u63cf\u8ff0\u4e86 Vulkan \u5982\u4f55\u5b9a\u4e49\u548c\u6269\u5c55\u529f\u80fd\u96c6, \u4e3b\u8981\u4ecb\u7ecd\u4e86\u56db\u4e2a\u6982\u5ff5: Extension, Feature, Limitation, \u548c Format.","title":"Vulkan \u6269\u5c55"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#vulkan_1","text":"\u5728\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u65f6, \u9700\u8981\u542f\u7528\u7684 Vulkan \u529f\u80fd\u96c6\u9700\u8981\u5728\u521d\u59cb\u5316 Device \u524d\u786e\u5b9a\u4e0b\u6765. \u5bf9\u5e94 vk \u521d\u59cb\u5316\u7684\u524d\u4e09\u6b65: Instance --> Physical Device --> Device \u4ee5\u4e0b\u662f\u521d\u59cb\u5316\u8fc7\u7a0b\u4e2d\u4e0e\u529f\u80fd\u76f8\u5173\u7684\u8fc7\u7a0b: \u679a\u4e3e vk \u652f\u6301\u7684 Instance-level Extensions \u521b\u5efa Instance \u679a\u4e3e \u7269\u7406\u8bbe\u5907, \u9009\u62e9 GPU, \u679a\u4e3e GPU \u652f\u6301\u7684 Device Extensions, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u200b \u67e5\u8be2\u652f\u6301\u7684 Extensions \u7684 Features \u7ed3\u6784\u4f53, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u200b \u67e5\u8be2\u652f\u6301\u7684 Extensions \u7684 Properties \u7ed3\u6784\u4f53 \u67e5\u8be2 GPU \u652f\u6301\u7684 Feature, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u67e5\u8be2 GPU \u7684 Properties \u5c06\u542f\u7528\u7684 Extensions \u548c Features \u5217\u8868\u653e\u5165 CreateInfo \u7ed3\u6784\u4f53, \u521b\u5efa\u903b\u8f91\u8bbe\u5907 Device, Extension: \u529f\u80fd\u96c6\u7684\u62bd\u8c61\u6982\u5ff5, \u7528\u6765\u4e3a Vulkan \u6dfb\u52a0\u65b0\u7684 Commands\uff0cStructures \u548c Enumerants. \u540c\u65f6\u53ef\u80fd\u65b0\u589e Features, Limitations, \u548c Format. Feature: bool \u503c\u96c6\u5408, \u53ef\u9009\u529f\u80fd\u7684\u5f00\u5173. \u53ef\u4ee5\u7528\u6765\u67e5\u8be2\u8bbe\u5907\u652f\u6301\u7684\u529f\u80fd, Limitation \u548c Format \u662f\u4e24\u4e2a\u53ea\u8bfb\u53c2\u6570\u96c6, Limitation \u53c8\u79f0\u505a Properties, \u8868\u793a\u8bbe\u5907\u7279\u5f81\u503c; Format \u8868\u793a\u652f\u6301\u7684\u683c\u5f0f. \u672c\u7ae0\u540e\u9762\u5404\u7ae0\u8282\u5bf9\u6b64\u6d41\u7a0b\u5404\u6b65\u9aa4\u8fdb\u884c\u89e3\u91ca, \u5e76\u5305\u542b\u793a\u4f8b\u4ee3\u7801.","title":"Vulkan \u521d\u59cb\u5316\u6d41\u7a0b"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#extensions","text":"\u6269\u5c55 (Extensions) \u53ef\u7528\u6765\u4e3a Vk \u6dfb\u52a0\u65b0\u529f\u80fd. Vk \u6838\u5fc3\u7684\u65b0\u7248\u672c (\u5982: VK_VERSION_1_1) \u4e5f\u53ef\u4ee5\u89c6\u4e3a\u4e00\u4e2a\u6269\u5c55. \u6269\u5c55\u53ef\u4ee5\u5b9a\u4e49\u65b0\u7684 \u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784. ( Commands\uff0cStructures \u548c Enumerants) \u6269\u5c55\u5206\u4e3a\u5b9e\u4f8b\u7ea7\u548c\u8bbe\u5907\u7ea7 (Instance-level \u548c Device-level) \u5f53 Commands \u7528\u6765\u679a\u4e3e\u5b9e\u4f8b\u5c5e\u6027 (instance properties), \u6216\u63a5\u53d7 VkInstance \u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570, \u5219\u88ab\u89c6\u4e3a\u5b9e\u4f8b\u7ea7\u529f\u80fd\u3002 \u5f53 Commands \u7528\u6765\u679a\u4e3e\u7269\u7406\u8bbe\u5907\u5c5e\u6027 (physical device properties), \u6216\u63a5\u53d7 VkDevice \u53ca\u5176\u5b50\u7c7b\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\uff0c\u5219\u88ab\u89c6\u4e3a\u8bbe\u5907\u7ea7\u529f\u80fd\u3002 \u4e3a\u4e86\u65b9\u4fbf\u7f16\u8bd1\uff0c\u5728 Khronos \u63d0\u4f9b\u7684 vulkan_core.h \u4e2d\u9664\u4e86\u6838\u5fc3API, \u8fd8\u5b9a\u4e49\u4e86\u5df2\u6ce8\u518c Extensions \u5b9a\u4e49\u7684\u63a5\u53e3\uff0c\u5305\u62ec\u65b0 \u7ed3\u6784, \u679a\u4e3e, \u548c\u547d\u4ee4\u7684\u51fd\u6570\u6307\u9488\u7c7b\u578b\u3002\u6269\u5c55\u7684\u5b9e\u73b0\u901a\u8fc7 Layers \u548c Vulkan\u5b9e\u73b0\u6765\u63d0\u4f9b\u3002","title":"Extensions: \u6269\u5c55"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#vk-extensions","text":"Vk Extensions \u9700\u8981\u5728\u521d\u59cb\u5316\u9636\u6bb5\u663e\u5f0f\u542f\u7528. \u542f\u7528 instance extension, \u8981\u5728\u521b\u5efa VKInstance \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkInstanceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. \u542f\u7528 device extension, \u8981\u5728 \u521b\u5efa VkDevice \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkDeviceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. Physical-Device-Level \u529f\u80fd\u6ca1\u6709\u542f\u7528\u673a\u5236\uff0c\u53ea\u8981 VkPhysicalDevice \u7684\u529f\u80fd\u5bf9\u5e94\u7684 Extensions \u5728\u679a\u4e3e\u51fd\u6570 vkEnumerateDeviceExtensionProperties \u4e2d\u88ab\u5217\u51fa. \u4ec5 \u542f\u7528 \u6269\u5c55\u64cd\u4f5c\u800c\u8a00, \u9664\u4e86 \u542f\u7528 \u8be5\u6269\u5c55\u81ea\u8eab\u5b9a\u4e49\u7684\u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784\u5916, \u4e0d\u4f1a\u66f4\u6539\u6838\u5fc3Vulkan API \u6216\u5176\u4ed6\u6269\u5c55\u7684\u529f\u80fd\u3002 \u793a\u4f8b: \u521b\u5efa VkInstance \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> extensions(); extensions.push_back(VK_KHR_WIN32_SURFACE_EXTENSION_NAME); VkInstanceCreateInfo inst_info = {}; inst_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; ... // Enable Instance Extensions inst_info.enabledExtensionCount = extensions.size(); inst_info.ppEnabledExtensionNames = extensions.data(); VkInstance instance; VkResult res = vkCreateInstance(&inst_info, NULL, &instance); \u5bf9 VkPhysicalDevice, \u679a\u4e3e\u5176\u652f\u6301\u7684 Extensions: // \u679a\u4e3e\u8bbe\u5907 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); // \u9009\u62e9\u8bbe\u5907 VkPhysicalDevice physicalDevice = devices[0]; // \u4ec5\u793a\u4f8b,\u6b63\u786e\u4ee3\u7801\u5e94\u9009\u62e9\u5bf9\u5e94 GPU \u8bbe\u5907 // \u679a\u4e3e Extensions uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, availableExtensions.data()); \u521b\u5efa VkDevice \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> device_extension_names(); // check if physicalDevice support extension: for (const auto& extension : availableExtensions) { if(strcmp(extension.extensionName, VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0) device_extension_names.push_back(extension.extensionName); } } VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; device_info.pNext = NULL; ... // Enable Device Extensions device_info.enabledExtensionCount = device_extension_names.size(); device_info.ppEnabledExtensionNames = enabledExtensionCount ? device_extension_names.data() : NULL; VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device);","title":"\u542f\u7528 Vk Extensions"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#features","text":"Features \u7528\u6765\u8bbe\u7f6e\u6216\u67e5\u8be2 \u975e\u6240\u6709\u5b9e\u73b0\u90fd\u652f\u6301 \u7684\u529f\u80fd\u3002 Feature \u5747\u4e3a bool \u503c. Features \u662f\u7269\u7406\u8bbe\u5907\u7684\u5c5e\u6027\u3002(physical device properties) \u8fd9\u4e9b\u529f\u80fd\u662f\u201c\u53ef\u9009\u201d\u7684\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u4f7f\u7528\u524d\u660e\u786e\u542f\u7528\u3002","title":"Features: \u529f\u80fd"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#features_1","text":"Vk \u6838\u5fc3\u4e2d\u5b9a\u4e49\u7684 Features, \u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceFeatures \u67e5\u8be2. VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); \u67e5\u8be2\u7ed3\u679c VkPhysicalDeviceFeatures \u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceFeatures { VkBool32 robustBufferAccess; VkBool32 fullDrawIndexUint32; VkBool32 imageCubeArray; VkBool32 independentBlend; VkBool32 geometryShader; VkBool32 tessellationShader; VkBool32 sampleRateShading; .... // \u603b\u8ba150+\u4e2a Bool \u503c } VkPhysicalDeviceFeatures \u5176\u4e2d\u6bcf\u4e2a Feature \u7684\u542b\u4e49 \u5728 Vulkan Specification 1.1/Features \u4e2d\u90fd\u6709\u89e3\u91ca. \u4f8b\u5982: IndependentBlend \u6307\u5b9a: \u662f\u5426\u6bcf\u4e2a attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u4e92\u76f8\u72ec\u7acb\u3002 \u672a\u542f\u7528\u6b64 Feature\uff0c\u5219\u6240\u6709 color attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u5fc5\u987b\u76f8\u540c\u3002 \u82e5\u542f\u7528\u6b64 Feature\uff0c\u5219\u53ef\u4ee5\u4e3a\u6bcf\u4e2a\u7ed1\u5b9a\u7684 color attachment \u63d0\u4f9b\u4e0d\u540c\u7684 VkPipelineColorBlendAttachmentState \u3002","title":"\u6838\u5fc3 Features"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#features_2","text":"\u67e5\u8be2\u51fd\u6570: vkGetPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 physicalDeviceFeatures2; vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &physicalDeviceFeatures2); \u67e5\u8be2\u7ed3\u679c: VkPhysicalDeviceFeatures2 \u7ed3\u6784: // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; sType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 pNext: \u6307\u9488\u94fe. VkPhysicalDeviceFeatures: Vulkan 1.0 \u63d0\u4f9b\u7684\u6838\u5fc3 Features \u6ce8: VkPhysicalDeviceFeatures2 \u7b49\u4ef7 VkPhysicalDeviceFeatures2KHR, vkGetPhysicalDeviceFeatures2 \u7b49\u4ef7 vkGetPhysicalDeviceFeatures2KHR \u901a\u8fc7 pNext , \u53ef\u4ee5\u83b7\u5f97\u6269\u5c55\u6240\u5b9a\u4e49\u7684 Features \u7ed3\u6784\u4f53, \u6709\u7684\u7531 Vulkan \u6838\u5fc3\u65b0\u7248\u672c\u63d0\u4f9b, \u6709\u7684\u7531\u5176\u4ed6 Extension\u63d0\u4f9b. \u4f8b\u5982: Vulkan 1.1 \u63d0\u4f9b\u7684 samplerYcbcrConversion. // Provided by VK_VERSION_1_1: VK_KHR_sampler_ycbcr_conversion typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures { VkStructureType sType; void* pNext; VkBool32 samplerYcbcrConversion; } VkPhysicalDeviceSamplerYcbcrConversionFeatures; VK_EXT_transform_feedback \u63d0\u4f9b\u7684 transformFeedback \u548c geometryStreams. // Provided by VK_EXT_transform_feedback typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 transformFeedback; VkBool32 geometryStreams; } VkPhysicalDeviceTransformFeedbackFeaturesEXT; \u67e5\u8be2\u793a\u4f8b: // \u6269\u5c55\u7684 Feature \u7ed3\u6784\u4f53 VkPhysicalDeviceSamplerYcbcrConversionFeatures mSamplerYcbcrConversionFeatures = {}; mSamplerYcbcrConversionFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; // vk1.1 \u7684 VkPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 deviceFeatures = {}; deviceFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; deviceFeatures.pNext = mVertexAttributeDivisorFeatures // \u67e5\u8be2 vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &deviceFeatures); // \u4f7f\u7528 if (mVertexAttributeDivisorFeatures.vertexAttributeInstanceRateDivisor) { ... }","title":"\u6269\u5c55\u63d0\u4f9b\u7684Features"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#features_3","text":"Features \u9ed8\u8ba4\u7686\u4e3a\u4e0d\u542f\u7528\u72b6\u6001. \u5fc5\u987b\u5728 VkDevice \u521b\u5efa\u65f6\u663e\u5f0f\u542f\u7528\u3002\u5982\u679c\u542f\u7528\u4e86\u7269\u7406\u8bbe\u5907\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5219 VkDevice \u521b\u5efa\u5c06\u5931\u8d25\uff0c\u5e76\u8fd4\u56deVK_ERROR_FEATURE_NOT_PRESENT\u3002 \u542f\u7528\u65b9\u6cd5: \u521b\u5efa VkPhysicalDeviceFeatures \u7ed3\u6784\u7684\u6307\u9488 (\u62161.1\u7684 VkPhysicalDeviceFeatures2\u7ed3\u6784) \u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \u6216 VK_FALSE, eg: physicalDeviceFeatures.independentBlend = VK_TRUE \u901a\u8fc7\u4f20\u9012\u7ed9 vkCreateDevice \u7528\u7684 VkDeviceCreateInfo\u7ed3\u6784\u7684 pEnabledFeatures \u6210\u5458. \u8981\u542f\u52a8\u6240\u6709\u8bbe\u5907\u7684\u529f\u80fd (\u614e\u7528)\uff0c\u5219\u53ea\u9700\u4f20\u5165\u67e5\u8be2\u51fd\u6570 vkGetPhysicalDeviceFeatures \u8fd4\u56de\u7684 VkPhysicalDeviceFeatures \u7ed3\u6784\u5373\u53ef\u3002\u8981\u7981\u7528\u5355\u4e2a\u529f\u80fd\uff0c\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728\u76f8\u540c\u7ed3\u6784\u4e2d\u5c06\u6240\u9700\u6210\u5458\u8bbe\u7f6e\u4e3aVK_FALSE\u3002 \u7528\u8fc7\u7ed9 pNext\u94fe\u6dfb\u52a0 Extensions \u63d0\u4f9b\u7684 Features \u7ed3\u6784\u4f53, \u6765\u542f\u7528\u6269\u5c55\u7684 Features. // \u67e5\u8be2\u6838\u5fc3 Features \u662f\u5426\u652f\u6301 VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); // \u8bbe\u7f6e\u542f\u7528 Features VkPhysicalDeviceFeatures2KHR enabledFeatures = {}; enabledFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; enabledFeatures.features.imageCubeArray = mPhysicalDeviceFeatures.imageCubeArray; enabledFeatures.features.independentBlend = mPhysicalDeviceFeatures.independentBlend; // Create Device VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; // \u6307\u5411 Features \u7ed3\u6784\u4f53\u4ee5\u8bbe\u7f6e Extensions \u63d0\u4f9b\u7684 Features // mSamplerYcbcrConversionFeatures : \u524d\u9762\u67e5\u8be2\u793a\u4f8b\u4e2d\u7684\u7ed3\u6784\u4f53. device_info.pNext = mSamplerYcbcrConversionFeatures; // Enable Physical Device Features device_info.pEnabledFeatures = &enabledFeatures.features; ... VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device);","title":"\u542f\u7528 Features"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#limitations","text":"Limits \u63d0\u4f9b\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u53ef\u80fd\u9700\u8981\u660e\u786e\u7684\u4e00\u4e9b\u8bbe\u5907\u7279\u5f81\u503c, \u8fd9\u4e9b\u7279\u5f81\u7684\u6700\u5c0f\u503c\uff0c\u6700\u5927\u503c\u7b49\u4f1a\u968f\u5e95\u5c42\u5b9e\u73b0\u7684\u4e0d\u540c\u800c\u5f02. \u901a\u8fc7 VkPhysicalDeviceLimits \u7ed3\u6784\u4f53\u83b7\u53d6\u6838\u5fc31.0\u7684 Limits, \u6216\u5229\u7528 vk1.1 \u4e2d\u52a0\u5165\u7684 VkPhysicalDeviceProperties2 \u7684 pNext \u94fe \u83b7\u53d6\u5404 Extension \u65b0\u589e\u7684 Limits . \u7ed3\u6784\u4f53 VkPhysicalDeviceLimits \u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7701\u7565\u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd: \u4f8b\u5982: maxUniformBufferRange : \u5f53\u5c06\u7ed3\u6784\u4f53 VkDescriptorBufferInfo \u4f5c\u4e3a\u53c2\u6570\u8c03\u7528 vkUpdateDescriptorSets , \u5e76\u4e14 descriptors \u7c7b\u578b\u4e3a VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER \u6216 VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC \u65f6, \u5176\u7ed3\u6784\u4f53\u6210\u5458 range \u53ef\u8bbe\u7684\u6700\u5927\u503c.","title":"Limitations"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#limits","text":"\u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684\u7ed3\u6784\u4f53\u5747\u4ee5 Properties \u800c\u975e Limits \u7ed3\u5c3e, \u5176\u67e5\u8be2\u65b9\u6cd5\u4e0e\u67e5\u8be2 \u6269\u5c55\u63d0\u4f9b\u7684 Feature \u4e00\u6837. \u67e5\u8be2\u51fd\u6570\u548c\u7ed3\u679c\u7ed3\u6784\u4f53\u5982\u4e0b: VkPhysicalDeviceProperties2 deviceProperties; vkGetPhysicalDeviceProperties2KHR(mPhysicalDevice, &deviceProperties); \u67e5\u8be2\u7ed3\u679c\u793a\u4f8b: \u7ed3\u6784\u4f53 VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT \u5305\u542b\u4e86\u6269\u5c55 VK_EXT_vertex_attribute_divisor \u63d0\u4f9b\u7684 limits \u503c maxVertexAttribDivisor : // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;","title":"\u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684Limits"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#formats","text":"\u5bf9\u4e8e\u4e0d\u540c\u7684 vk \u5b9e\u73b0, \u5176\u652f\u6301\u7684\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u683c\u5f0f\u53ef\u80fd\u4f1a\u4e0d\u540c\u3002\u867d\u7136 Vulkan \u89c4\u5b9a\u4e86\u4e00\u7ec4\u5fc5\u987b\u652f\u6301\u7684 Format \u7684\u6700\u5c0f\u96c6\uff0c\u4f46\u5728\u4f7f\u7528\u9664\u6b64\u4ee5\u5916\u7684 Format\u529f\u80fd\u4e4b\u524d, \u5fc5\u987b\u663e\u5f0f\u7684\u67e5\u8be2\uff0c\u4ee5\u786e\u4fdd\u5b9e\u73b0\u652f\u6301\u8fd9\u4e9b\u683c\u5f0f\u3002 \u67e5\u8be2\u547d\u4ee4: vkGetPhysicalDeviceFormatProperties , \u67e5\u8be2\u8fd4\u56de\u7684 VkFormat \u7ed3\u6784\u4f53\u7684\u5305\u542b\u4e86\u5f53\u524d\u5b9e\u73b0\u6240\u652f\u6301\u7684\u683c\u5f0f\u529f\u80fd\u3002 VkFormat \u7ed3\u6784\u4f53\u793a\u4f8b: // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d \u5173\u4e8e Format \u76f8\u5173\u7684\u5185\u5bb9\u6bd4\u8f83\u590d\u6742, \u672c\u7ae0\u8282\u4ee5\u53ca\u540e\u7eed\u7ae0\u8282\u90fd\u4e0d\u8fdb\u884c\u6df1\u5165. \u5982\u679c\u9700\u8981\u8003\u8651\u518d\u5355\u72ec\u8fdb\u884c\u7814\u7a76.","title":"Formats"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#39-extending-vulkan","text":"New functionality may be added to Vulkan via either new extensions or new versions of the core, or new versions of an extension in some cases. This chapter describes how Vulkan is versioned, how compatibility is affected between different versions, and compatibility rules that are followed by the Vulkan Working Group.","title":"39. Extending Vulkan"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#391-instance-and-device-functionality","text":"Commands that enumerate instance properties, or that accept a VkInstance object as a parameter, are considered instance-level functionality. Commands that enumerate physical device properties, or that accept a VkDevice object or any of a device\u2019s child objects as a parameter, are considered device-level functionality.","title":"39.1. Instance and Device Functionality"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#394-extensions","text":"Extensions may define new Vulkan commands, structures, and enumerants. For compilation purposes, the interfaces defined by registered extensions, including new structures and enumerants as well as function pointer types for new commands, are defined in the Khronos-supplied vulkan_core.h together with the core API. However, commands defined by extensions may not be available for static linking - in which case function pointers to these commands should be queried at runtime as described in Command Function Pointers . Extensions may be provided by layers as well as by a Vulkan implementation. Because extensions may extend or change the behavior of the Vulkan API, extension authors should add support for their extensions to the Khronos validation layers. This is especially important for new commands whose parameters have been wrapped by the validation layers. See the \u201cVulkan Loader Specification and Architecture Overview\u201d document for additional information.","title":"39.4. Extensions"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#3941-instance-extensions","text":"Instance extensions add new instance-level functionality to the API, outside of the core specification. To query the available instance extensions, call: // Provided by VK_VERSION_1_0 VkResult vkEnumerateInstanceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties); pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, as described below. pProperties is either NULL or a pointer to an array of VkExtensionProperties structures. When pLayerName parameter is NULL , only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the instance extensions provided by that layer are returned. If pProperties is NULL , then the number of extensions properties available is returned in pPropertyCount . Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties . If pPropertyCount is less than the number of extension properties available, at most pPropertyCount structures will be written. If pPropertyCount is smaller than the number of extensions available, VK_INCOMPLETE will be returned instead of VK_SUCCESS , to indicate that not all the available properties were returned. Because the list of available layers may change externally between calls to vkEnumerateInstanceExtensionProperties , two calls may retrieve different results if a pLayerName is available in one call but not in another. The extensions supported by a layer may also change between two calls, e.g. if the layer implementation is replaced by a different version between those calls. Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version.","title":"39.4.1. Instance Extensions"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#3942-device-extensions","text":"Device extensions add new device-level functionality to the API, outside of the core specification. To query the extensions available to a given physical device, call: // Provided by VK_VERSION_1_0 VkResult vkEnumerateDeviceExtensionProperties( VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties); physicalDevice is the physical device that will be queried. pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, and is treated in the same fashion as the vkEnumerateInstanceExtensionProperties :: pPropertyCount parameter. pProperties is either NULL or a pointer to an array of VkExtensionProperties structures. When pLayerName parameter is NULL , only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the device extensions provided by that layer are returned. Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version.","title":"39.4.2. Device Extensions"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#40-features","text":"Features describe functionality which is not supported on all implementations. Features are properties of the physical device. Features are optional , and must be explicitly enabled before use. Support for features is reported and enabled on a per-feature basis. NoteFeatures are reported via the basic VkPhysicalDeviceFeatures structure, as well as the extensible structure VkPhysicalDeviceFeatures2 , which was added in the VK_KHR_get_physical_device_properties2 extension and included in Vulkan 1.1. When new features are added in future Vulkan versions or extensions, each extension should introduce one new feature structure, if needed. This structure can be added to the pNext chain of the VkPhysicalDeviceFeatures2 structure. For convenience, new core versions of Vulkan may introduce new unified features structures for features promoted from extensions. At the same time, the extension\u2019s original features structure (if any) is also promoted to the core API, and is an alias of the extension\u2019s structure. This results in multiple names for the same feature: in the original extension\u2019s feature structure and the promoted structure alias, in the unified feature structure. When a feature was implicitly supported and enabled in the extension, but an explicit name was added during promotion, then the extension itself acts as an alias for the feature as listed in the table below. All aliases of the same feature in the core API must be reported consistently: either all must be reported as supported, or none of them. When a promoted extension is available, any corresponding feature aliases must be supported. // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; The pNext chain of this structure is used to extend the structure with features defined by extensions. Fine-grained features used by a logical device must be enabled at VkDevice creation time. If a feature is enabled that the physical device does not support, VkDevice creation will fail and return VK_ERROR_FEATURE_NOT_PRESENT . The fine-grained features are enabled by passing a pointer to the VkPhysicalDeviceFeatures structure via the pEnabledFeatures member of the VkDeviceCreateInfo structure that is passed into the vkCreateDevice call. If a member of pEnabledFeatures is set to VK_TRUE or VK_FALSE , then the device will be created with the indicated feature enabled or disabled, respectively. Features can also be enabled by using the VkPhysicalDeviceFeatures2 structure. If an application wishes to enable all features supported by a device, it can simply pass in the VkPhysicalDeviceFeatures structure that was previously returned by vkGetPhysicalDeviceFeatures . To disable an individual feature, the application can set the desired member to VK_FALSE in the same structure. Setting pEnabledFeatures to NULL and not including a VkPhysicalDeviceFeatures2 in the pNext chain of VkDeviceCreateInfo is equivalent to setting all members of the structure to VK_FALSE . To query support for atomic operations on floating-point numbers, call vkGetPhysicalDeviceFeatures2 with a VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure included in the pNext chain of its pFeatures parameter. The VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure is defined as: // Provided by VK_EXT_shader_atomic_float typedef struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 shaderBufferFloat32Atomics; VkBool32 shaderBufferFloat32AtomicAdd; VkBool32 shaderBufferFloat64Atomics; VkBool32 shaderBufferFloat64AtomicAdd; VkBool32 shaderSharedFloat32Atomics; VkBool32 shaderSharedFloat32AtomicAdd; VkBool32 shaderSharedFloat64Atomics; VkBool32 shaderSharedFloat64AtomicAdd; VkBool32 shaderImageFloat32Atomics; VkBool32 shaderImageFloat32AtomicAdd; VkBool32 sparseImageFloat32Atomics; VkBool32 sparseImageFloat32AtomicAdd; } VkPhysicalDeviceShaderAtomicFloatFeaturesEXT;","title":"40. Features"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#41-limits","text":"Limits are implementation-dependent minimums, maximums, and other device characteristics that an application may need to be aware of. NoteLimits are reported via the basic VkPhysicalDeviceLimits structure, as well as the extensible structure VkPhysicalDeviceProperties2 , which was added in VK_KHR_get_physical_device_properties2 and included in Vulkan 1.1. When limits are added in future Vulkan versions or extensions, each extension should introduce one new limit structure, if needed. This structure can be added to the pNext chain of the VkPhysicalDeviceProperties2 structure. The VkPhysicalDeviceLimits structure is defined as: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd The VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure is defined as: // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;","title":"41. Limits"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#42-formats","text":"Supported buffer and image formats may vary across implementations. A minimum set of format features are guaranteed, but others must be explicitly queried before use to ensure they are supported by the implementation. The features for the set of formats ( VkFormat ) supported by the implementation are queried individually using the vkGetPhysicalDeviceFormatProperties command.","title":"42. Formats"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#421-format-definition","text":"The following image formats can be passed to, and may be returned from Vulkan commands. The memory required to store each format is discussed with that format, and also summarized in the Representation and Texel Block Size section and the Compatible formats table. // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d","title":"42.1. Format Definition"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#43-additional-capabilities","text":"This chapter describes additional capabilities beyond the minimum capabilities described in the ( Limits and Formats chapters, including: Additional Image Capabilities Additional Buffer Capabilities Optional Semaphore Capabilities Optional Fence Capabilities Timestamp Calibration Capabilities","title":"43. Additional Capabilities"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/","text":"1. \u6d41\u7a0b\u603b\u89c8 2. \u521d\u59cb\u5316\u65f6, \u6d89\u53ca\u7684 API 2. \u7406\u89e3 Vulkan\u00ae Objects 1. Instance 2. PhysicalDevice 3. Device 4. Queue 5. CommandPool 6. CommandBuffer 7. Sampler 8. Image & Buffer TODO 9. DeviceMemory \u5bf9\u8c61\u7ec4 \u8bbe\u5907 \u56fe\u50cf \u7ba1\u9053 3. Pipeline 4. \u8be6\u7ec6 1. \u6d41\u7a0b\u603b\u89c8 \u521d\u59cb\u8bbe\u7f6e Instance \u5b9e\u4f8b [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 \u5448\u73b0 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b \u7ed8\u5236 Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe \u6ce8: []: \u975e Vulkan \u6838\u5fc3 init_global_layer_properties(info); init_instance_extension_names(info); init_device_extension_names(info); init_instance(info, sample_title); init_enumerate_device(info); init_window_size(info, 500, 500); init_connection(info); init_window(info); init_swapchain_extension(info); init_device(info); init_command_pool(info); init_command_buffer(info); execute_begin_command_buffer(info); init_device_queue(info); init_swap_chain(info); init_depth_buffer(info); init_uniform_buffer(info); init_descriptor_and_pipeline_layouts(info, false); init_renderpass(info, depthPresent); #include \"15-draw_cube.vert.h\" #include \"15-draw_cube.frag.h\" VkShaderModuleCreateInfo vert_info = {}; VkShaderModuleCreateInfo frag_info = {}; vert_info.sType = frag_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; vert_info.codeSize = sizeof(__draw_cube_vert); vert_info.pCode = __draw_cube_vert; frag_info.codeSize = sizeof(__draw_cube_frag); frag_info.pCode = __draw_cube_frag; init_shaders(info, &vert_info, &frag_info); init_framebuffers(info, depthPresent); init_vertex_buffer(info, g_vb_solid_face_colors_Data, sizeof(g_vb_solid_face_colors_Data), sizeof(g_vb_solid_face_colors_Data[0]), false); init_descriptor_pool(info, false); init_descriptor_set(info, false); init_pipeline_cache(info); init_pipeline(info, depthPresent); 2. \u521d\u59cb\u5316\u65f6, \u6d89\u53ca\u7684 API \u521d\u59cb\u8bbe\u7f6e Instance \u5b9e\u4f8b vkCreateInstance [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf vkEnumeratePhysicalDevices vkGetPhysicalDeviceQueueFamilyProperties Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 \u5448\u73b0 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b \u7ed8\u5236 Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe 2. \u7406\u89e3 Vulkan\u00ae Objects \u7eff\u8272\u6846: \u65e0\u7c7b\u578b, \u4ee5 uint32_t \u8868\u793a \u5b9e\u7ebf+\u7bad\u5934: \u521b\u5efa\u987a\u5e8f \u5b9e\u7ebf+\u83f1\u5f62: \u7ec4\u5408 (\u88ab\u5305\u542b) \u865a\u7ebf: \u901a\u4fe1 \u4e09\u4e2a\u533a\u57df\u4e2d, \u7ea2\u8272\u4e3a\u4e3b Object, \u5176\u4ed6\u5bf9\u8c61\u90fd\u76f4\u63a5\u6216\u95f4\u63a5\u7684\u7531\u6b64\u5bf9\u8c61\u521b\u5efa. \u8868\u73b0\u4e3a vkCreateSwapchainKHR \u9700\u8981 Device \u4e3a\u53c2\u6570. 1. Instance Instance \u662f\u521b\u5efa\u7684\u7b2c\u4e00\u4e2a\u5bf9\u8c61\u3002 \u5b83\u8868\u793a\u4ece\u5e94\u7528\u7a0b\u5e8f\u5230 Vulkan \u8fd0\u884c\u65f6\u7684 \u8fde\u63a5 \uff0c\u56e0\u6b64\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u4ec5\u5e94 \u5b58\u5728\u4e00\u6b21 \u3002 \u5b83\u8fd8\u5b58\u50a8\u4f7f\u7528 Vulkan \u6240\u9700\u7684\u6240\u6709\u7279\u5b9a\u4e8e \u5e94\u7528\u7a0b\u5e8f \u7684\u72b6\u6001\u3002 \u56e0\u6b64\uff0c\u60a8\u5fc5\u987b\u6307\u5b9a\u521b\u5efa\u5b9e\u4f8b\u65f6\u8981\u542f\u7528\u7684\u6240\u6709\u5c42 Layers \uff08\u4f8b\u5982\u9a8c\u8bc1\u5c42\uff09\u548c\u6240\u6709\u6269\u5c55 Extensions\u3002 2. PhysicalDevice \u8868\u793a\u7279\u5b9a\u7684 Vulkan \u517c\u5bb9\u8bbe\u5907\uff0c\u4f8b\u5982\u56fe\u5f62\u5361\u3002 vkEnumeratePhysicalDevices \u60a8\u53ef\u4ee5\u4ece Instance \u4e2d \u679a\u4e3e \u5b83\u4eec\uff0c\u7136\u540e\u53ef\u4ee5\u67e5\u8be2\u5b83\u4eec\u7684 vendorID\uff0cdeviceID \u548c\u652f\u6301\u7684\u529f\u80fd\u4ee5\u53ca\u5176\u4ed6\u5c5e\u6027\u548c\u9650\u5236\u3002 vkGetPhysicalDeviceQueueFamilyProperties PhysicalDevice \u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u53ef\u7528\u7684 Queue Families \u7c7b\u578b\u3002 \u56fe\u5f62\u961f\u5217 Graphics Queue \u662f\u6700\u4e3b\u8981\u7684\u961f\u5217\uff0c\u4f46\u662f\u60a8\u53ef\u80fd\u8fd8\u6709\u5176\u4ed6\u4ec5\u652f\u6301\u8ba1\u7b97Compute \u6216\u4f20\u8f93 Transfer\u7684\u961f\u5217\u3002 PhysicalDevice\u8fd8\u53ef\u4ee5\u679a\u4e3e\u5176\u5185\u90e8\u7684\u5185\u5b58\u5806 Memory Heaps \u548c\u5185\u5b58\u7c7b\u578b Memory Types \u3002 Memory Heaps \u4ee3\u8868\u7279\u5b9a\u7684RAM\u6c60\u3002 \u5b83\u53ef\u80fd\u4f1a\u63d0\u53d6 \u4e3b\u677f\u4e0a\u7684\u7cfb\u7edfRAM, \u6216\u4e13\u7528\u56fe\u5f62\u5361\u4e0a\u7684\u89c6\u9891RAM\u4e2d\u7684\u7279\u5b9a\u5185\u5b58\u7a7a\u95f4\uff0c\u6216\u8005\u5b9e\u73b0\u8981\u516c\u5f00\u7684\u4efb\u4f55\u5176\u4ed6\u7279\u5b9a\u4e8e\u4e3b\u673a\u6216\u8bbe\u5907\u7684\u5185\u5b58\u3002 \u5206\u914d\u5185\u5b58 Allocate Memory \u65f6\u5fc5\u987b\u6307\u5b9a Memory Types \u3002 \u5b83\u5177\u6709\u5bf9 Memory Blob \u7684\u7279\u5b9a\u8981\u6c42\uff0c\u4f8b\u5982\u5bf9 host \u53ef\u89c1\uff0c\u4e00\u81f4\u6027 coherent\uff08\u5728CPU\u548cGPU\u4e4b\u95f4\uff09\u548c\u5df2\u7f13\u5b58 cached\u3002\u8fd9\u4e9b\u53ef\u80fd\u4f1a\u4efb\u610f\u7ec4\u5408\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f\u3002 3. Device \u53c8\u88ab\u89c6\u4e3a \u903b\u8f91\u8bbe\u5907 Logical Device \u6216 Opened Device. \u5b83\u4ee3\u8868\u4e86\u4e00\u4e2a\u5df2\u7ecf\u521d\u59cb\u5316\u7684 Vulkan \u8bbe\u5907, \u51c6\u5907\u597d\u521b\u5efa\u5176\u4ed6\u5bf9\u8c61 \u521b\u5efa\u8bbe\u5907\u65f6, \u9700\u6307\u5b9a\u542f\u7528\u54ea\u4e9b Features , \u5e76\u58f0\u660e\u6240\u6709\u4f7f\u7528\u7684 Queue , \u5176\u7f16\u53f7 \u548c\u5176 Queue Family 4. Queue Device \u4e0a\u6267\u884c\u7684\u547d\u4ee4\u961f\u5217 Queue of Commands\u3002 \u901a\u8fc7\u4f7f\u7528 vkQueueSubmit \u586b\u5145 CommandBuffer \u5e76\u5c06\u5176\u63d0\u4ea4\u5230 Queue\uff0c\u6765\u8bf7\u6c42 GPU \u5b8c\u6210\u7684\u6240\u6709\u5b9e\u9645\u5de5\u4f5c\u3002 \u5982\u679c\u6709\u591a\u4e2a\u961f\u5217\uff0c\u4f8b\u5982 Graphic Queue \u548c Compute Queue\uff0c\u5219\u53ef\u4ee5\u5411\u6bcf\u4e2a\u961f\u5217\u63d0\u4ea4\u4e0d\u540c\u7684CommandBuffer\u3002\u8fd9\u6837\uff0c\u60a8\u5c31\u53ef\u4ee5\u542f\u7528\u5f02\u6b65\u8ba1\u7b97\uff0c\u5982\u679c\u6267\u884c\u6b63\u786e\u7684\u8bdd\uff0c\u53ef\u4ee5\u5927\u5927\u63d0\u9ad8\u901f\u5ea6\u3002 5. CommandPool \u7528\u4e8e\u5206\u914d CommandBuffer \u3002\u5b83\u5df2\u8fde\u63a5\u5230\u7279\u5b9a\u7684 Queue Family \u3002 6. CommandBuffer \u4ece\u6307\u5b9a\u7684 CommandPool \u5206\u914d\u3002\u5b83\u4ee3\u8868 Device \u8981\u6267\u884c\u7684\u5404\u79cd\u547d\u4ee4\u7684\u7f13\u51b2\u533a\u3002 \u53ef\u4ee5\u5728 Command Buffer \u4e0a\u8c03\u7528\u5404 vkCmd \u5f00\u5934\u7684\u51fd\u6570\uff0c\u7528\u4e8e\u6307\u5b9a \u6267\u884c\u7684\u4efb\u52a1\u7684\u987a\u5e8f\uff0c\u7c7b\u578b\u548c\u53c2\u6570\u3002 \u4e4b\u540e CommandBuffer \u63d0\u4ea4\u5230 Queue \u5e76\u6700\u7ec8\u7531 Device \u6267\u884c 7. Sampler \u91c7\u6837\u5668 Sampler \u672a\u7ed1\u5b9a\u5230\u4efb\u4f55\u7279\u5b9a\u56fe\u50cf Image\u3002\u5b83\u53ea\u662f\u4e00\u7ec4\u72b6\u6001\u53c2\u6570 state parameters \uff0c \u4f8b\u5982\u8fc7\u6ee4\u6a21\u5f0f (filtering mode)\uff08\u6700\u8fd1\u6216\u7ebf\u6027 nearest or linear\uff09,\u6216\u5bfb\u5740\u6a21\u5f0f (addressing mode)\uff08\u91cd\u590d\uff0c\u94b3\u4f4d\u5230\u8fb9\u7f18\uff0c\u94b3\u4f4d\u5230\u8fb9\u754c\u7b49 repeat, clamp-to-edge, clamp-to-border\uff09\u3002 8. Image & Buffer TODO \u7f13\u51b2\u533a\u548c\u56fe\u50cf\u662f\u5360\u7528\u8bbe\u5907\u5185\u5b58\u7684\u4e24\u79cd\u8d44\u6e90\u3002 \u7f13\u51b2\u533a\u6bd4\u8f83\u7b80\u5355\u3002 \u5b83\u662f\u4efb\u4f55\u5177\u6709\u957f\u5ea6\u7684\u4e8c\u8fdb\u5236\u6570\u636e\u7684\u5bb9\u5668, \u4ee5\u5b57\u8282\u8868\u793a\u3002 \u53e6\u4e00\u65b9\u9762\uff0c\u56fe\u50cf\u4ee3\u8868\u4e00\u7ec4\u50cf\u7d20\u3002 \u8fd9\u662f\u5176\u4ed6\u56fe\u5f62API\u4e2d\u79f0\u4e3a\u7eb9\u7406\u7684\u5bf9\u8c61\u3002 \u9700\u8981\u66f4\u591a\u53c2\u6570\u6765\u6307\u5b9a\u56fe\u50cf\u7684\u521b\u5efa\u3002 \u5b83\u53ef\u4ee5\u662f1D\uff0c2D\u62163D\uff0c\u5177\u6709\u5404\u79cd\u50cf\u7d20\u683c\u5f0f\uff08\u5982R8G8B8A8_UNORM\u6216R32_SFLOAT\uff09\uff0c \u5e76\u4e14\u8fd8\u53ef\u4ee5\u5305\u542b\u8bb8\u591a\u79bb\u6563\u56fe\u50cf\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u5177\u6709\u591a\u4e2a\u9635\u5217\u5c42\u6216MIP\u7ea7\u522b\uff08\u6216\u4e24\u8005\uff09\u3002 \u56fe\u7247\u662f\u4e00\u79cd\u72ec\u7acb\u7684\u5bf9\u8c61\u7c7b\u578b\uff0c\u56e0\u4e3a\u5b83\u4e0d\u4e00\u5b9a\u53ea\u5305\u542b\u53ef\u4ee5\u76f4\u63a5\u8bbf\u95ee\u7684\u7ebf\u6027\u50cf\u7d20\u96c6\u3002 \u56fe\u50cf\u53ef\u4ee5\u5177\u6709\u7531\u56fe\u5f62\u9a71\u52a8\u7a0b\u5e8f\u7ba1\u7406\u7684\u4e0d\u540c\u7684\u7279\u5b9a\u4e8e\u5b9e\u73b0\u7684\u5185\u90e8\u683c\u5f0f\uff08\u5e73\u94fa\u548c\u5e03\u5c40\uff09\u3002 9. DeviceMemory \u521b\u5efa\u4e00\u5b9a\u957f\u5ea6\u7684\u7f13\u51b2\u533a\u6216\u5177\u6709\u7279\u5b9a\u5c3a\u5bf8\u7684\u56fe\u50cf\u4e0d\u4f1a\u81ea\u52a8\u4e3a\u5176\u5206\u914d\u5185\u5b58\u3002 \u8fd9\u662f\u4e00\u4e2a\u4e09\u6b65\u8fc7\u7a0b\uff0c\u5fc5\u987b\u7531\u60a8\u624b\u52a8\u6267\u884c\u3002 \u60a8\u4e5f\u53ef\u4ee5\u9009\u62e9\u4f7f\u7528\u6211\u4eec\u7684Vulkan\u5185\u5b58\u5206\u914d\u5668\u5e93\uff0c\u8be5\u5e93\u5c06\u4e3a\u60a8\u5206\u914d\u8d44\u6e90\u3002 1.\u5206\u914dDeviceMemory\uff0c 2.\u521b\u5efa\u7f13\u51b2\u533a\u6216\u56fe\u50cf\uff0c 3.\u4f7f\u7528\u529f\u80fdvkBindBufferMemory\u6216vkBindImageMemory\u5c06\u5b83\u4eec\u7ed1\u5b9a\u5728\u4e00\u8d77\u3002 \u56e0\u6b64\uff0c\u60a8\u8fd8\u5fc5\u987b\u521b\u5efa\u4e00\u4e2aDeviceMemory\u5bf9\u8c61\u3002 \u5b83\u4ee3\u8868\u4ece\u7279\u5b9a\u5185\u5b58\u7c7b\u578b\uff08\u7531PhysicalDevice\u652f\u6301\uff09\u5206\u914d\u7684\u5185\u5b58\u5757\uff0c\u5177\u6709\u7279\u5b9a\u7684\u5b57\u8282\u957f\u5ea6\u3002 \u60a8\u4e0d\u5e94\u8be5\u4e3a\u6bcf\u4e2a\u7f13\u51b2\u533a\u6216\u6620\u50cf\u5206\u914d\u5355\u72ec\u7684DeviceMemory\u3002 \u76f8\u53cd\uff0c\u60a8\u5e94\u8be5\u5206\u914d\u66f4\u5927\u7684\u5185\u5b58\u5757\uff0c\u5e76\u5c06\u5176\u4e2d\u7684\u4e00\u90e8\u5206\u5206\u914d\u7ed9\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u3002 \u5206\u914d\u662f\u4e00\u9879\u6602\u8d35\u7684\u64cd\u4f5c\uff0c\u5e76\u4e14\u6700\u5927\u5206\u914d\u6570\u91cf\u4e5f\u53d7\u5230\u9650\u5236\uff0c\u6240\u6709\u8fd9\u4e9b\u90fd\u53ef\u4ee5\u4ecePhysicalDevice\u4e2d\u67e5\u8be2\u3002 \u5bf9\u8c61\u7ec4 \u8bbe\u5907 Instance PhysicalDevice Queue Family Memory Heap Memory Type --> Device Memory Device Queue <-- Queue Family \u56fe\u50cf Surface Swapchain Image ImageView Framebuffer <--RenderPass \u7ba1\u9053 DescriptorSetLayout PipelineLayout ShaderModule Pipeline Cache PipeLine DescriptorSet <-- DescriptorSetLayout, DescriptorPool 3. Pipeline 4. \u8be6\u7ec6 Instance \u5b9e\u4f8b [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe","title":"1. Vulkan \u521d\u59cb\u5316 \u4e09\u89d2"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#1","text":"\u521d\u59cb\u8bbe\u7f6e Instance \u5b9e\u4f8b [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 \u5448\u73b0 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b \u7ed8\u5236 Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe \u6ce8: []: \u975e Vulkan \u6838\u5fc3 init_global_layer_properties(info); init_instance_extension_names(info); init_device_extension_names(info); init_instance(info, sample_title); init_enumerate_device(info); init_window_size(info, 500, 500); init_connection(info); init_window(info); init_swapchain_extension(info); init_device(info); init_command_pool(info); init_command_buffer(info); execute_begin_command_buffer(info); init_device_queue(info); init_swap_chain(info); init_depth_buffer(info); init_uniform_buffer(info); init_descriptor_and_pipeline_layouts(info, false); init_renderpass(info, depthPresent); #include \"15-draw_cube.vert.h\" #include \"15-draw_cube.frag.h\" VkShaderModuleCreateInfo vert_info = {}; VkShaderModuleCreateInfo frag_info = {}; vert_info.sType = frag_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; vert_info.codeSize = sizeof(__draw_cube_vert); vert_info.pCode = __draw_cube_vert; frag_info.codeSize = sizeof(__draw_cube_frag); frag_info.pCode = __draw_cube_frag; init_shaders(info, &vert_info, &frag_info); init_framebuffers(info, depthPresent); init_vertex_buffer(info, g_vb_solid_face_colors_Data, sizeof(g_vb_solid_face_colors_Data), sizeof(g_vb_solid_face_colors_Data[0]), false); init_descriptor_pool(info, false); init_descriptor_set(info, false); init_pipeline_cache(info); init_pipeline(info, depthPresent);","title":"1. \u6d41\u7a0b\u603b\u89c8"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#2-api","text":"\u521d\u59cb\u8bbe\u7f6e Instance \u5b9e\u4f8b vkCreateInstance [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf vkEnumeratePhysicalDevices vkGetPhysicalDeviceQueueFamilyProperties Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 \u5448\u73b0 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b \u7ed8\u5236 Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe","title":"2. \u521d\u59cb\u5316\u65f6, \u6d89\u53ca\u7684 API"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#2-vulkan-objects","text":"\u7eff\u8272\u6846: \u65e0\u7c7b\u578b, \u4ee5 uint32_t \u8868\u793a \u5b9e\u7ebf+\u7bad\u5934: \u521b\u5efa\u987a\u5e8f \u5b9e\u7ebf+\u83f1\u5f62: \u7ec4\u5408 (\u88ab\u5305\u542b) \u865a\u7ebf: \u901a\u4fe1 \u4e09\u4e2a\u533a\u57df\u4e2d, \u7ea2\u8272\u4e3a\u4e3b Object, \u5176\u4ed6\u5bf9\u8c61\u90fd\u76f4\u63a5\u6216\u95f4\u63a5\u7684\u7531\u6b64\u5bf9\u8c61\u521b\u5efa. \u8868\u73b0\u4e3a vkCreateSwapchainKHR \u9700\u8981 Device \u4e3a\u53c2\u6570.","title":"2. \u7406\u89e3 Vulkan\u00ae Objects"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#1-instance","text":"Instance \u662f\u521b\u5efa\u7684\u7b2c\u4e00\u4e2a\u5bf9\u8c61\u3002 \u5b83\u8868\u793a\u4ece\u5e94\u7528\u7a0b\u5e8f\u5230 Vulkan \u8fd0\u884c\u65f6\u7684 \u8fde\u63a5 \uff0c\u56e0\u6b64\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u4ec5\u5e94 \u5b58\u5728\u4e00\u6b21 \u3002 \u5b83\u8fd8\u5b58\u50a8\u4f7f\u7528 Vulkan \u6240\u9700\u7684\u6240\u6709\u7279\u5b9a\u4e8e \u5e94\u7528\u7a0b\u5e8f \u7684\u72b6\u6001\u3002 \u56e0\u6b64\uff0c\u60a8\u5fc5\u987b\u6307\u5b9a\u521b\u5efa\u5b9e\u4f8b\u65f6\u8981\u542f\u7528\u7684\u6240\u6709\u5c42 Layers \uff08\u4f8b\u5982\u9a8c\u8bc1\u5c42\uff09\u548c\u6240\u6709\u6269\u5c55 Extensions\u3002","title":"1. Instance"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#2-physicaldevice","text":"\u8868\u793a\u7279\u5b9a\u7684 Vulkan \u517c\u5bb9\u8bbe\u5907\uff0c\u4f8b\u5982\u56fe\u5f62\u5361\u3002 vkEnumeratePhysicalDevices \u60a8\u53ef\u4ee5\u4ece Instance \u4e2d \u679a\u4e3e \u5b83\u4eec\uff0c\u7136\u540e\u53ef\u4ee5\u67e5\u8be2\u5b83\u4eec\u7684 vendorID\uff0cdeviceID \u548c\u652f\u6301\u7684\u529f\u80fd\u4ee5\u53ca\u5176\u4ed6\u5c5e\u6027\u548c\u9650\u5236\u3002 vkGetPhysicalDeviceQueueFamilyProperties PhysicalDevice \u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u53ef\u7528\u7684 Queue Families \u7c7b\u578b\u3002 \u56fe\u5f62\u961f\u5217 Graphics Queue \u662f\u6700\u4e3b\u8981\u7684\u961f\u5217\uff0c\u4f46\u662f\u60a8\u53ef\u80fd\u8fd8\u6709\u5176\u4ed6\u4ec5\u652f\u6301\u8ba1\u7b97Compute \u6216\u4f20\u8f93 Transfer\u7684\u961f\u5217\u3002 PhysicalDevice\u8fd8\u53ef\u4ee5\u679a\u4e3e\u5176\u5185\u90e8\u7684\u5185\u5b58\u5806 Memory Heaps \u548c\u5185\u5b58\u7c7b\u578b Memory Types \u3002 Memory Heaps \u4ee3\u8868\u7279\u5b9a\u7684RAM\u6c60\u3002 \u5b83\u53ef\u80fd\u4f1a\u63d0\u53d6 \u4e3b\u677f\u4e0a\u7684\u7cfb\u7edfRAM, \u6216\u4e13\u7528\u56fe\u5f62\u5361\u4e0a\u7684\u89c6\u9891RAM\u4e2d\u7684\u7279\u5b9a\u5185\u5b58\u7a7a\u95f4\uff0c\u6216\u8005\u5b9e\u73b0\u8981\u516c\u5f00\u7684\u4efb\u4f55\u5176\u4ed6\u7279\u5b9a\u4e8e\u4e3b\u673a\u6216\u8bbe\u5907\u7684\u5185\u5b58\u3002 \u5206\u914d\u5185\u5b58 Allocate Memory \u65f6\u5fc5\u987b\u6307\u5b9a Memory Types \u3002 \u5b83\u5177\u6709\u5bf9 Memory Blob \u7684\u7279\u5b9a\u8981\u6c42\uff0c\u4f8b\u5982\u5bf9 host \u53ef\u89c1\uff0c\u4e00\u81f4\u6027 coherent\uff08\u5728CPU\u548cGPU\u4e4b\u95f4\uff09\u548c\u5df2\u7f13\u5b58 cached\u3002\u8fd9\u4e9b\u53ef\u80fd\u4f1a\u4efb\u610f\u7ec4\u5408\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f\u3002","title":"2. PhysicalDevice"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#3-device","text":"\u53c8\u88ab\u89c6\u4e3a \u903b\u8f91\u8bbe\u5907 Logical Device \u6216 Opened Device. \u5b83\u4ee3\u8868\u4e86\u4e00\u4e2a\u5df2\u7ecf\u521d\u59cb\u5316\u7684 Vulkan \u8bbe\u5907, \u51c6\u5907\u597d\u521b\u5efa\u5176\u4ed6\u5bf9\u8c61 \u521b\u5efa\u8bbe\u5907\u65f6, \u9700\u6307\u5b9a\u542f\u7528\u54ea\u4e9b Features , \u5e76\u58f0\u660e\u6240\u6709\u4f7f\u7528\u7684 Queue , \u5176\u7f16\u53f7 \u548c\u5176 Queue Family","title":"3. Device"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#4-queue","text":"Device \u4e0a\u6267\u884c\u7684\u547d\u4ee4\u961f\u5217 Queue of Commands\u3002 \u901a\u8fc7\u4f7f\u7528 vkQueueSubmit \u586b\u5145 CommandBuffer \u5e76\u5c06\u5176\u63d0\u4ea4\u5230 Queue\uff0c\u6765\u8bf7\u6c42 GPU \u5b8c\u6210\u7684\u6240\u6709\u5b9e\u9645\u5de5\u4f5c\u3002 \u5982\u679c\u6709\u591a\u4e2a\u961f\u5217\uff0c\u4f8b\u5982 Graphic Queue \u548c Compute Queue\uff0c\u5219\u53ef\u4ee5\u5411\u6bcf\u4e2a\u961f\u5217\u63d0\u4ea4\u4e0d\u540c\u7684CommandBuffer\u3002\u8fd9\u6837\uff0c\u60a8\u5c31\u53ef\u4ee5\u542f\u7528\u5f02\u6b65\u8ba1\u7b97\uff0c\u5982\u679c\u6267\u884c\u6b63\u786e\u7684\u8bdd\uff0c\u53ef\u4ee5\u5927\u5927\u63d0\u9ad8\u901f\u5ea6\u3002","title":"4. Queue"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#5-commandpool","text":"\u7528\u4e8e\u5206\u914d CommandBuffer \u3002\u5b83\u5df2\u8fde\u63a5\u5230\u7279\u5b9a\u7684 Queue Family \u3002","title":"5. CommandPool"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#6-commandbuffer","text":"\u4ece\u6307\u5b9a\u7684 CommandPool \u5206\u914d\u3002\u5b83\u4ee3\u8868 Device \u8981\u6267\u884c\u7684\u5404\u79cd\u547d\u4ee4\u7684\u7f13\u51b2\u533a\u3002 \u53ef\u4ee5\u5728 Command Buffer \u4e0a\u8c03\u7528\u5404 vkCmd \u5f00\u5934\u7684\u51fd\u6570\uff0c\u7528\u4e8e\u6307\u5b9a \u6267\u884c\u7684\u4efb\u52a1\u7684\u987a\u5e8f\uff0c\u7c7b\u578b\u548c\u53c2\u6570\u3002 \u4e4b\u540e CommandBuffer \u63d0\u4ea4\u5230 Queue \u5e76\u6700\u7ec8\u7531 Device \u6267\u884c","title":"6. CommandBuffer"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#7-sampler","text":"\u91c7\u6837\u5668 Sampler \u672a\u7ed1\u5b9a\u5230\u4efb\u4f55\u7279\u5b9a\u56fe\u50cf Image\u3002\u5b83\u53ea\u662f\u4e00\u7ec4\u72b6\u6001\u53c2\u6570 state parameters \uff0c \u4f8b\u5982\u8fc7\u6ee4\u6a21\u5f0f (filtering mode)\uff08\u6700\u8fd1\u6216\u7ebf\u6027 nearest or linear\uff09,\u6216\u5bfb\u5740\u6a21\u5f0f (addressing mode)\uff08\u91cd\u590d\uff0c\u94b3\u4f4d\u5230\u8fb9\u7f18\uff0c\u94b3\u4f4d\u5230\u8fb9\u754c\u7b49 repeat, clamp-to-edge, clamp-to-border\uff09\u3002","title":"7. Sampler"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#8-image-buffer","text":"","title":"8. Image &amp; Buffer"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#todo","text":"\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u662f\u5360\u7528\u8bbe\u5907\u5185\u5b58\u7684\u4e24\u79cd\u8d44\u6e90\u3002 \u7f13\u51b2\u533a\u6bd4\u8f83\u7b80\u5355\u3002 \u5b83\u662f\u4efb\u4f55\u5177\u6709\u957f\u5ea6\u7684\u4e8c\u8fdb\u5236\u6570\u636e\u7684\u5bb9\u5668, \u4ee5\u5b57\u8282\u8868\u793a\u3002 \u53e6\u4e00\u65b9\u9762\uff0c\u56fe\u50cf\u4ee3\u8868\u4e00\u7ec4\u50cf\u7d20\u3002 \u8fd9\u662f\u5176\u4ed6\u56fe\u5f62API\u4e2d\u79f0\u4e3a\u7eb9\u7406\u7684\u5bf9\u8c61\u3002 \u9700\u8981\u66f4\u591a\u53c2\u6570\u6765\u6307\u5b9a\u56fe\u50cf\u7684\u521b\u5efa\u3002 \u5b83\u53ef\u4ee5\u662f1D\uff0c2D\u62163D\uff0c\u5177\u6709\u5404\u79cd\u50cf\u7d20\u683c\u5f0f\uff08\u5982R8G8B8A8_UNORM\u6216R32_SFLOAT\uff09\uff0c \u5e76\u4e14\u8fd8\u53ef\u4ee5\u5305\u542b\u8bb8\u591a\u79bb\u6563\u56fe\u50cf\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u5177\u6709\u591a\u4e2a\u9635\u5217\u5c42\u6216MIP\u7ea7\u522b\uff08\u6216\u4e24\u8005\uff09\u3002 \u56fe\u7247\u662f\u4e00\u79cd\u72ec\u7acb\u7684\u5bf9\u8c61\u7c7b\u578b\uff0c\u56e0\u4e3a\u5b83\u4e0d\u4e00\u5b9a\u53ea\u5305\u542b\u53ef\u4ee5\u76f4\u63a5\u8bbf\u95ee\u7684\u7ebf\u6027\u50cf\u7d20\u96c6\u3002 \u56fe\u50cf\u53ef\u4ee5\u5177\u6709\u7531\u56fe\u5f62\u9a71\u52a8\u7a0b\u5e8f\u7ba1\u7406\u7684\u4e0d\u540c\u7684\u7279\u5b9a\u4e8e\u5b9e\u73b0\u7684\u5185\u90e8\u683c\u5f0f\uff08\u5e73\u94fa\u548c\u5e03\u5c40\uff09\u3002","title":"TODO"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#9-devicememory","text":"\u521b\u5efa\u4e00\u5b9a\u957f\u5ea6\u7684\u7f13\u51b2\u533a\u6216\u5177\u6709\u7279\u5b9a\u5c3a\u5bf8\u7684\u56fe\u50cf\u4e0d\u4f1a\u81ea\u52a8\u4e3a\u5176\u5206\u914d\u5185\u5b58\u3002 \u8fd9\u662f\u4e00\u4e2a\u4e09\u6b65\u8fc7\u7a0b\uff0c\u5fc5\u987b\u7531\u60a8\u624b\u52a8\u6267\u884c\u3002 \u60a8\u4e5f\u53ef\u4ee5\u9009\u62e9\u4f7f\u7528\u6211\u4eec\u7684Vulkan\u5185\u5b58\u5206\u914d\u5668\u5e93\uff0c\u8be5\u5e93\u5c06\u4e3a\u60a8\u5206\u914d\u8d44\u6e90\u3002 1.\u5206\u914dDeviceMemory\uff0c 2.\u521b\u5efa\u7f13\u51b2\u533a\u6216\u56fe\u50cf\uff0c 3.\u4f7f\u7528\u529f\u80fdvkBindBufferMemory\u6216vkBindImageMemory\u5c06\u5b83\u4eec\u7ed1\u5b9a\u5728\u4e00\u8d77\u3002 \u56e0\u6b64\uff0c\u60a8\u8fd8\u5fc5\u987b\u521b\u5efa\u4e00\u4e2aDeviceMemory\u5bf9\u8c61\u3002 \u5b83\u4ee3\u8868\u4ece\u7279\u5b9a\u5185\u5b58\u7c7b\u578b\uff08\u7531PhysicalDevice\u652f\u6301\uff09\u5206\u914d\u7684\u5185\u5b58\u5757\uff0c\u5177\u6709\u7279\u5b9a\u7684\u5b57\u8282\u957f\u5ea6\u3002 \u60a8\u4e0d\u5e94\u8be5\u4e3a\u6bcf\u4e2a\u7f13\u51b2\u533a\u6216\u6620\u50cf\u5206\u914d\u5355\u72ec\u7684DeviceMemory\u3002 \u76f8\u53cd\uff0c\u60a8\u5e94\u8be5\u5206\u914d\u66f4\u5927\u7684\u5185\u5b58\u5757\uff0c\u5e76\u5c06\u5176\u4e2d\u7684\u4e00\u90e8\u5206\u5206\u914d\u7ed9\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u3002 \u5206\u914d\u662f\u4e00\u9879\u6602\u8d35\u7684\u64cd\u4f5c\uff0c\u5e76\u4e14\u6700\u5927\u5206\u914d\u6570\u91cf\u4e5f\u53d7\u5230\u9650\u5236\uff0c\u6240\u6709\u8fd9\u4e9b\u90fd\u53ef\u4ee5\u4ecePhysicalDevice\u4e2d\u67e5\u8be2\u3002","title":"9. DeviceMemory"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#_1","text":"","title":"\u5bf9\u8c61\u7ec4"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#_2","text":"Instance PhysicalDevice Queue Family Memory Heap Memory Type --> Device Memory Device Queue <-- Queue Family","title":"\u8bbe\u5907"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#_3","text":"Surface Swapchain Image ImageView Framebuffer <--RenderPass","title":"\u56fe\u50cf"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#_4","text":"DescriptorSetLayout PipelineLayout ShaderModule Pipeline Cache PipeLine DescriptorSet <-- DescriptorSetLayout, DescriptorPool","title":"\u7ba1\u9053"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#3-pipeline","text":"","title":"3. Pipeline"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#4","text":"Instance \u5b9e\u4f8b [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe","title":"4. \u8be6\u7ec6"},{"location":"Vulkan/Pipeline/","text":"Pipeline \u5728 Vulkan \u4e2d, \u6e32\u67d3\u7ba1\u7ebf\u9700\u8981\u624b\u52a8\u521b\u5efa. Vulkan\u4e2d\u521b\u5efa\u5bf9\u8c61\u7684\u8fc7\u7a0b\u5927\u591a\u90fd\u901a\u8fc7\u4f7f\u7528 VkXXXCreateInfo \u7ed3\u6784\u4f53, \u4e3a\u7ed3\u6784\u4f53\u5404\u5c5e\u6027\u8d4b\u503c\u540e\u8c03\u7528 vk API\u521b\u5efa. \u5bf9\u5e94Pipeline\u7684\u521b\u5efa\u7ed3\u6784\u4f53\u4e3a VkGraphicsPipelineCreateInfo , \u5176\u9664\u4e86\u6240\u6709\u7ed3\u6784\u4f53\u7684\u5171\u6709\u5c5e\u6027(sType, pNext)\u5916, \u8fd8\u5305\u62ec\u4e86 10\u4e2a\u5b50\u7ed3\u6784\u4f53\u5c5e\u6027, \u5206\u522b\u5bf9\u5e94\u6e32\u67d3\u7ba1\u7ebf\u7684\u5341\u4e2a\u56fa\u5b9a\u6d41\u7a0b. \u4ee5\u53ca 3\u4e2a\u5bf9\u8c61: PipelineLayout, RenderPass, subpass Pipeline Fixed Functions: VkPipeline Shader StageCreateInfo* pStages; VkPipeline VertexInput StateCreateInfo* pVertexInputState; VkPipeline InputAssembly StateCreateInfo* pInputAssemblyState; VkPipeline Tessellation StateCreateInfo* pTessellationState; VkPipeline Viewport StateCreateInfo* pViewportState; VkPipeline Rasterization StateCreateInfo* pRasterizationState; VkPipeline Multisample StateCreateInfo* pMultisampleState; VkPipeline DepthStencil StateCreateInfo* pDepthStencilState; VkPipeline ColorBlend StateCreateInfo* pColorBlendState; VkPipeline Dynamic StateCreateInfo* pDynamicState; Objects: PipelineLayout layout; RenderPass renderPass; int subpass; // Shader Stages <-- Shader Modules VkPipelineShaderStageCreateInfo vertShaderStageInfo{}; vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; vertShaderStageInfo.module = vertShaderModule; vertShaderStageInfo.pName = \"main\"; VkPipelineShaderStageCreateInfo fragShaderStageInfo{}; fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; fragShaderStageInfo.module = fragShaderModule; fragShaderStageInfo.pName = \"main\"; VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo }; // Vertex Input State VkPipelineVertexInputStateCreateInfo vertexInputInfo{}; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.vertexAttributeDescriptionCount = 0; // Input Assembly State VkPipelineInputAssemblyStateCreateInfo inputAssembly{}; inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; inputAssembly.primitiveRestartEnable = VK_FALSE; VkViewport viewport{}; viewport.x = 0.0f; viewport.y = 0.0f; viewport.width = (float)swapChainExtent.width; viewport.height = (float)swapChainExtent.height; viewport.minDepth = 0.0f; viewport.maxDepth = 1.0f; VkRect2D scissor{}; scissor.offset = { 0, 0 }; scissor.extent = VkExtent2D; // Viewport State <-- viewport extent, scissor extent VkPipelineViewportStateCreateInfo viewportState{}; viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; viewportState.pScissors = &scissor; // Rasterization State VkPipelineRasterizationStateCreateInfo rasterizer{}; rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterizer.depthClampEnable = VK_FALSE; rasterizer.rasterizerDiscardEnable = VK_FALSE; rasterizer.polygonMode = VK_POLYGON_MODE_FILL; rasterizer.lineWidth = 1.0f; rasterizer.cullMode = VK_CULL_MODE_BACK_BIT; rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; rasterizer.depthBiasEnable = VK_FALSE; // Multisample State VkPipelineMultisampleStateCreateInfo multisampling{}; multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampling.sampleShadingEnable = VK_FALSE; multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; // Color Blend Attachment State VkPipelineColorBlendAttachmentState colorBlendAttachment{}; colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; colorBlendAttachment.blendEnable = VK_FALSE; VkPipelineColorBlendStateCreateInfo colorBlending{}; colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; colorBlending.logicOpEnable = VK_FALSE; colorBlending.logicOp = VK_LOGIC_OP_COPY; colorBlending.attachmentCount = 1; colorBlending.pAttachments = &colorBlendAttachment; colorBlending.blendConstants[0] = 0.0f; colorBlending.blendConstants[1] = 0.0f; colorBlending.blendConstants[2] = 0.0f; colorBlending.blendConstants[3] = 0.0f; // Pipeline Layout VkPipelineLayoutCreateInfo pipelineLayoutInfo{}; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; pipelineLayoutInfo.pushConstantRangeCount = 0; if (vkCreatePipelineLayout(mDevice, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) { throw std::runtime_error(\"failed to create pipeline layout!\"); } //------ Pipeline Layout & Render Pass are ready, setup finish // ----- Create Graphics Pipeline ---------- VkGraphicsPipelineCreateInfo pipelineInfo{}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 2; pipelineInfo.pStages = shaderStages; // shaders pipelineInfo.pVertexInputState = &vertexInputInfo; // vertex input pipelineInfo.pInputAssemblyState = &inputAssembly; // input assembly pipelineInfo.pViewportState = &viewportState; // viewport pipelineInfo.pRasterizationState = &rasterizer; // rasterizer pipelineInfo.pMultisampleState = &multisampling; // multisampling pipelineInfo.pColorBlendState = &colorBlending; // colorBlending pipelineInfo.layout = pipelineLayout; pipelineInfo.renderPass = renderPass; // render pass pipelineInfo.subpass = 0; pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; Pipeline Fixed Function Properties: // \u7701\u7565\u4e86\u6240\u6709 CreateInfo \u7684 sType, pNext, \u548c xxxxflags Graphics_Pipeline { stageCount = 2; // create infos pStages = [ // shader modules vertShaderStageInfo = { stage = VK_SHADER_STAGE_VERTEX_BIT; module = vertShaderModule; // VkShaderModule pName = \"main\"; // const VkSpecializationInfo* pSpecializationInfo; } fragShaderStageInfo = { stage = VK_SHADER_STAGE_FRAGMENT_BIT; module = fragShaderModule; // VkShaderModule pName = \"main\"; // const VkSpecializationInfo* pSpecializationInfo; } ], pVertexInputState = Vertex_Input_State { // vertex input vertexBindingDescriptionCount = 0; pVertexBindingDescriptions = null; vertexAttributeDescriptionCount = 0; pVertexAttributeDescriptions = null; }; pInputAssemblyState = { // input assembly topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; primitiveRestartEnable = VK_FALSE; }; pTessellationState = null; // Tessellation pViewportState = { // Viewport viewportCount = 1; pViewports = { x = 0.0f; y = 0.0f; width = (float)swapChainExtent.width; // VkExtent2D height = (float)swapChainExtent.height; minDepth = 0.0f; maxDepth = 1.0f; }; scissorCount = 1; pScissors = { offset: { 0, 0 }; extent = swapChainExtent; // VkExtent2D }; }; pRasterizationState = { // Rasterizer depthClampEnable = VK_FALSE; rasterizerDiscardEnable = VK_FALSE; polygonMode = VK_POLYGON_MODE_FILL; lineWidth = 1.0f; cullMode = VK_CULL_MODE_BACK_BIT; frontFace = VK_FRONT_FACE_CLOCKWISE; depthBiasEnable = VK_FALSE; //float depthBiasConstantFactor; //float depthBiasClamp; //float depthBiasSlopeFactor; }; pMultisampleState = { // multisampling sampleShadingEnable = VK_FALSE; rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; // float minSampleShading; // const VkSampleMask* pSampleMask; // VkBool32 alphaToCoverageEnable; // VkBool32 alphaToOneEnable; }; pDepthStencilState : null, pColorBlendState = { // colorBlending logicOpEnable = VK_FALSE; logicOp = VK_LOGIC_OP_COPY; attachmentCount = 1; pAttachments = &colorBlendAttachment; blendConstants[0] = 0.0f; blendConstants[1] = 0.0f; blendConstants[2] = 0.0f; blendConstants[3] = 0.0f; }; pDynamicState : null, // vars layout = { setLayoutCount = 0; // const VkDescriptorSetLayout* pSetLayouts; pushConstantRangeCount = 0; //const VkPushConstantRange* pPushConstantRanges; }; renderPass = renderPass; // render pass subpass = 0; basePipelineHandle = VK_NULL_HANDLE; basePipelineIndex = 0, } Render Pass VkAttachmentDescription colorAttachment{}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; VkAttachmentReference colorAttachmentRef{}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkSubpassDescription subpass{}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; // \u540e\u52a0\u7684?? VkSubpassDependency dependency{}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; VkRenderPassCreateInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; if (vkCreateRenderPass(mDevice, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } Json RenderPass { attachmentCount = 1; pAttachments = { // VkAttachmentDescription colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; }; subpassCount = 1; pSubpasses = { // VkSubpassDescription pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; colorAttachmentCount = 1; pColorAttachments = { // VkAttachmentReference colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; }; // uint32_t inputAttachmentCount; // const VkAttachmentReference* pInputAttachments; // const VkAttachmentReference* pResolveAttachments; // const VkAttachmentReference* pDepthStencilAttachment; // uint32_t preserveAttachmentCount; // const uint32_t* pPreserveAttachments; }; dependencyCount = 1; pDependencies = { srcSubpass = VK_SUBPASS_EXTERNAL; dstSubpass = 0; srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; srcAccessMask = 0; dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; }; // VkSubpassDependency }","title":"Pipeline"},{"location":"Vulkan/Pipeline/#pipeline","text":"\u5728 Vulkan \u4e2d, \u6e32\u67d3\u7ba1\u7ebf\u9700\u8981\u624b\u52a8\u521b\u5efa. Vulkan\u4e2d\u521b\u5efa\u5bf9\u8c61\u7684\u8fc7\u7a0b\u5927\u591a\u90fd\u901a\u8fc7\u4f7f\u7528 VkXXXCreateInfo \u7ed3\u6784\u4f53, \u4e3a\u7ed3\u6784\u4f53\u5404\u5c5e\u6027\u8d4b\u503c\u540e\u8c03\u7528 vk API\u521b\u5efa. \u5bf9\u5e94Pipeline\u7684\u521b\u5efa\u7ed3\u6784\u4f53\u4e3a VkGraphicsPipelineCreateInfo , \u5176\u9664\u4e86\u6240\u6709\u7ed3\u6784\u4f53\u7684\u5171\u6709\u5c5e\u6027(sType, pNext)\u5916, \u8fd8\u5305\u62ec\u4e86 10\u4e2a\u5b50\u7ed3\u6784\u4f53\u5c5e\u6027, \u5206\u522b\u5bf9\u5e94\u6e32\u67d3\u7ba1\u7ebf\u7684\u5341\u4e2a\u56fa\u5b9a\u6d41\u7a0b. \u4ee5\u53ca 3\u4e2a\u5bf9\u8c61: PipelineLayout, RenderPass, subpass Pipeline Fixed Functions: VkPipeline Shader StageCreateInfo* pStages; VkPipeline VertexInput StateCreateInfo* pVertexInputState; VkPipeline InputAssembly StateCreateInfo* pInputAssemblyState; VkPipeline Tessellation StateCreateInfo* pTessellationState; VkPipeline Viewport StateCreateInfo* pViewportState; VkPipeline Rasterization StateCreateInfo* pRasterizationState; VkPipeline Multisample StateCreateInfo* pMultisampleState; VkPipeline DepthStencil StateCreateInfo* pDepthStencilState; VkPipeline ColorBlend StateCreateInfo* pColorBlendState; VkPipeline Dynamic StateCreateInfo* pDynamicState; Objects: PipelineLayout layout; RenderPass renderPass; int subpass; // Shader Stages <-- Shader Modules VkPipelineShaderStageCreateInfo vertShaderStageInfo{}; vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; vertShaderStageInfo.module = vertShaderModule; vertShaderStageInfo.pName = \"main\"; VkPipelineShaderStageCreateInfo fragShaderStageInfo{}; fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; fragShaderStageInfo.module = fragShaderModule; fragShaderStageInfo.pName = \"main\"; VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo }; // Vertex Input State VkPipelineVertexInputStateCreateInfo vertexInputInfo{}; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.vertexAttributeDescriptionCount = 0; // Input Assembly State VkPipelineInputAssemblyStateCreateInfo inputAssembly{}; inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; inputAssembly.primitiveRestartEnable = VK_FALSE; VkViewport viewport{}; viewport.x = 0.0f; viewport.y = 0.0f; viewport.width = (float)swapChainExtent.width; viewport.height = (float)swapChainExtent.height; viewport.minDepth = 0.0f; viewport.maxDepth = 1.0f; VkRect2D scissor{}; scissor.offset = { 0, 0 }; scissor.extent = VkExtent2D; // Viewport State <-- viewport extent, scissor extent VkPipelineViewportStateCreateInfo viewportState{}; viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; viewportState.pScissors = &scissor; // Rasterization State VkPipelineRasterizationStateCreateInfo rasterizer{}; rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterizer.depthClampEnable = VK_FALSE; rasterizer.rasterizerDiscardEnable = VK_FALSE; rasterizer.polygonMode = VK_POLYGON_MODE_FILL; rasterizer.lineWidth = 1.0f; rasterizer.cullMode = VK_CULL_MODE_BACK_BIT; rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; rasterizer.depthBiasEnable = VK_FALSE; // Multisample State VkPipelineMultisampleStateCreateInfo multisampling{}; multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampling.sampleShadingEnable = VK_FALSE; multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; // Color Blend Attachment State VkPipelineColorBlendAttachmentState colorBlendAttachment{}; colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; colorBlendAttachment.blendEnable = VK_FALSE; VkPipelineColorBlendStateCreateInfo colorBlending{}; colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; colorBlending.logicOpEnable = VK_FALSE; colorBlending.logicOp = VK_LOGIC_OP_COPY; colorBlending.attachmentCount = 1; colorBlending.pAttachments = &colorBlendAttachment; colorBlending.blendConstants[0] = 0.0f; colorBlending.blendConstants[1] = 0.0f; colorBlending.blendConstants[2] = 0.0f; colorBlending.blendConstants[3] = 0.0f; // Pipeline Layout VkPipelineLayoutCreateInfo pipelineLayoutInfo{}; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; pipelineLayoutInfo.pushConstantRangeCount = 0; if (vkCreatePipelineLayout(mDevice, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) { throw std::runtime_error(\"failed to create pipeline layout!\"); } //------ Pipeline Layout & Render Pass are ready, setup finish // ----- Create Graphics Pipeline ---------- VkGraphicsPipelineCreateInfo pipelineInfo{}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 2; pipelineInfo.pStages = shaderStages; // shaders pipelineInfo.pVertexInputState = &vertexInputInfo; // vertex input pipelineInfo.pInputAssemblyState = &inputAssembly; // input assembly pipelineInfo.pViewportState = &viewportState; // viewport pipelineInfo.pRasterizationState = &rasterizer; // rasterizer pipelineInfo.pMultisampleState = &multisampling; // multisampling pipelineInfo.pColorBlendState = &colorBlending; // colorBlending pipelineInfo.layout = pipelineLayout; pipelineInfo.renderPass = renderPass; // render pass pipelineInfo.subpass = 0; pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; Pipeline Fixed Function Properties: // \u7701\u7565\u4e86\u6240\u6709 CreateInfo \u7684 sType, pNext, \u548c xxxxflags Graphics_Pipeline { stageCount = 2; // create infos pStages = [ // shader modules vertShaderStageInfo = { stage = VK_SHADER_STAGE_VERTEX_BIT; module = vertShaderModule; // VkShaderModule pName = \"main\"; // const VkSpecializationInfo* pSpecializationInfo; } fragShaderStageInfo = { stage = VK_SHADER_STAGE_FRAGMENT_BIT; module = fragShaderModule; // VkShaderModule pName = \"main\"; // const VkSpecializationInfo* pSpecializationInfo; } ], pVertexInputState = Vertex_Input_State { // vertex input vertexBindingDescriptionCount = 0; pVertexBindingDescriptions = null; vertexAttributeDescriptionCount = 0; pVertexAttributeDescriptions = null; }; pInputAssemblyState = { // input assembly topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; primitiveRestartEnable = VK_FALSE; }; pTessellationState = null; // Tessellation pViewportState = { // Viewport viewportCount = 1; pViewports = { x = 0.0f; y = 0.0f; width = (float)swapChainExtent.width; // VkExtent2D height = (float)swapChainExtent.height; minDepth = 0.0f; maxDepth = 1.0f; }; scissorCount = 1; pScissors = { offset: { 0, 0 }; extent = swapChainExtent; // VkExtent2D }; }; pRasterizationState = { // Rasterizer depthClampEnable = VK_FALSE; rasterizerDiscardEnable = VK_FALSE; polygonMode = VK_POLYGON_MODE_FILL; lineWidth = 1.0f; cullMode = VK_CULL_MODE_BACK_BIT; frontFace = VK_FRONT_FACE_CLOCKWISE; depthBiasEnable = VK_FALSE; //float depthBiasConstantFactor; //float depthBiasClamp; //float depthBiasSlopeFactor; }; pMultisampleState = { // multisampling sampleShadingEnable = VK_FALSE; rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; // float minSampleShading; // const VkSampleMask* pSampleMask; // VkBool32 alphaToCoverageEnable; // VkBool32 alphaToOneEnable; }; pDepthStencilState : null, pColorBlendState = { // colorBlending logicOpEnable = VK_FALSE; logicOp = VK_LOGIC_OP_COPY; attachmentCount = 1; pAttachments = &colorBlendAttachment; blendConstants[0] = 0.0f; blendConstants[1] = 0.0f; blendConstants[2] = 0.0f; blendConstants[3] = 0.0f; }; pDynamicState : null, // vars layout = { setLayoutCount = 0; // const VkDescriptorSetLayout* pSetLayouts; pushConstantRangeCount = 0; //const VkPushConstantRange* pPushConstantRanges; }; renderPass = renderPass; // render pass subpass = 0; basePipelineHandle = VK_NULL_HANDLE; basePipelineIndex = 0, } Render Pass VkAttachmentDescription colorAttachment{}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; VkAttachmentReference colorAttachmentRef{}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkSubpassDescription subpass{}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; // \u540e\u52a0\u7684?? VkSubpassDependency dependency{}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; VkRenderPassCreateInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; if (vkCreateRenderPass(mDevice, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } Json RenderPass { attachmentCount = 1; pAttachments = { // VkAttachmentDescription colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; }; subpassCount = 1; pSubpasses = { // VkSubpassDescription pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; colorAttachmentCount = 1; pColorAttachments = { // VkAttachmentReference colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; }; // uint32_t inputAttachmentCount; // const VkAttachmentReference* pInputAttachments; // const VkAttachmentReference* pResolveAttachments; // const VkAttachmentReference* pDepthStencilAttachment; // uint32_t preserveAttachmentCount; // const uint32_t* pPreserveAttachments; }; dependencyCount = 1; pDependencies = { srcSubpass = VK_SUBPASS_EXTERNAL; dstSubpass = 0; srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; srcAccessMask = 0; dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; }; // VkSubpassDependency }","title":"Pipeline"},{"location":"Vulkan/VkFramebuffer/","text":"Vulken Framebuffer Vulkan_\u5c4f\u5e55\u7a7a\u95f4\u53cd\u5c04(SSR) \u5ef6\u8fdf\u6e32\u67d3 VkRenderPass \u5728\u8fdb\u884c\u7ba1\u7ebf\u521b\u5efa\u4e4b\u524d\uff0c\u9700\u8981\u8bbe\u7f6e\u7528\u4e8e\u6e32\u67d3\u7684\u5e27\u7f13\u51b2\u9644\u7740\u3002\u6211\u4eec \u9700\u8981\u6307\u5b9a\u4f7f\u7528\u7684\u989c\u8272\u548c\u6df1\u5ea6\u7f13\u51b2\uff0c\u4ee5\u53ca\u91c7\u6837\u6570\uff0c\u6e32\u67d3\u64cd\u4f5c\u5982\u4f55\u5904\u7406\u7f13\u51b2\u7684 \u5185\u5bb9\u3002\u6240\u6709\u8fd9\u4e9b\u4fe1\u606f\u88abVulkan \u5305\u88c5\u4e3a\u4e00\u4e2a\u6e32\u67d3\u6d41\u7a0b\u5bf9\u8c61\uff0c void createRenderPass() { VkAttachmentDescription colorAttachment{}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; VkAttachmentReference colorAttachmentRef{}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkSubpassDescription subpass{}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; VkSubpassDependency dependency{}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; VkRenderPassCreateInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } } Draw \u591a\u4e2a Framebuffer \u4e0e ES FBO\u5bf9\u6bd4 \u9ed8\u8ba4fbo \u9644\u7740 \u79bb\u5c4f\u6e32\u67d3 \u62f7\u8d1d","title":"Vulken Framebuffer"},{"location":"Vulkan/VkFramebuffer/#vulken-framebuffer","text":"Vulkan_\u5c4f\u5e55\u7a7a\u95f4\u53cd\u5c04(SSR) \u5ef6\u8fdf\u6e32\u67d3","title":"Vulken Framebuffer"},{"location":"Vulkan/VkFramebuffer/#vkrenderpass","text":"\u5728\u8fdb\u884c\u7ba1\u7ebf\u521b\u5efa\u4e4b\u524d\uff0c\u9700\u8981\u8bbe\u7f6e\u7528\u4e8e\u6e32\u67d3\u7684\u5e27\u7f13\u51b2\u9644\u7740\u3002\u6211\u4eec \u9700\u8981\u6307\u5b9a\u4f7f\u7528\u7684\u989c\u8272\u548c\u6df1\u5ea6\u7f13\u51b2\uff0c\u4ee5\u53ca\u91c7\u6837\u6570\uff0c\u6e32\u67d3\u64cd\u4f5c\u5982\u4f55\u5904\u7406\u7f13\u51b2\u7684 \u5185\u5bb9\u3002\u6240\u6709\u8fd9\u4e9b\u4fe1\u606f\u88abVulkan \u5305\u88c5\u4e3a\u4e00\u4e2a\u6e32\u67d3\u6d41\u7a0b\u5bf9\u8c61\uff0c void createRenderPass() { VkAttachmentDescription colorAttachment{}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; VkAttachmentReference colorAttachmentRef{}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkSubpassDescription subpass{}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; VkSubpassDependency dependency{}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; VkRenderPassCreateInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } }","title":"VkRenderPass"},{"location":"Vulkan/VkFramebuffer/#draw","text":"","title":"Draw"},{"location":"Vulkan/VkFramebuffer/#framebuffer","text":"","title":"\u591a\u4e2a Framebuffer"},{"location":"Vulkan/VkFramebuffer/#es-fbo","text":"\u9ed8\u8ba4fbo \u9644\u7740 \u79bb\u5c4f\u6e32\u67d3 \u62f7\u8d1d","title":"\u4e0e ES FBO\u5bf9\u6bd4"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/","text":"Vulkan \u521b\u5efaVulkan\u5b9e\u4f8b Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217\u7c07 Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b Vulkan \u9a8c\u8bc1\u5c42 Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217 Vulkan \u4ea4\u6362\u94fe Vulkan Window Surface Vulkan \u56fe\u5f62\u7ba1\u7ebf Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe Vulkan \u7740\u8272\u5668\u6a21\u5757 Vulkan \u56fa\u6709\u529f\u80fd Vulkan \u5e27\u7f13\u51b2\u533a Vulkan \u96c6\u6210\u7ba1\u7ebf Vulkan \u6e32\u67d3\u901a\u9053 Vulkan \u547d\u4ee4\u7f13\u51b2\u533a Vulkan \u6e32\u67d3\u548c\u663e\u793a Vulkan \u91cd\u6784\u4ea4\u6362\u94fe Vulkan \u9876\u70b9\u8f93\u5165 Vulkan \u521b\u5efa\u9876\u70b9\u7f13\u51b2\u533a Vulkan \u4e34\u65f6\u7f13\u51b2\u533a Vulkan \u7d22\u5f15\u7f13\u51b2\u533a Vulkan \u63cf\u8ff0\u7b26\u5e03\u5c40\u548c\u7f13\u51b2\u533a Vulkan \u63cf\u8ff0\u7b26\u6c60\u548c\u96c6\u5408 Vulkan \u56fe\u50cf(Images) Vulkan \u56fe\u50cf\u89c6\u56fe\u548c\u91c7\u6837\u5668 Vulkan \u7ec4\u5408\u56fe\u50cf\u53d6\u6837\u5668 Vulkan \u6df1\u5ea6\u7f13\u51b2\u533a Vulkan \u52a0\u8f7d\u6a21\u578b Vulkan \u751f\u6210\u8d34\u56fe(mipmap) \u7b2c\u4e00\u7ae0 Vulkan \u521b\u5efaVulkan\u5b9e\u4f8b \u521b\u5efaVulkan\u5b9e\u4f8b \uff0c\u4e0e Vulkan \u6253\u4ea4\u9053\uff0c\u901a\u5e38\u7684\u6b65\u9aa4\u662f\u521b\u5efa\u4e00\u4e2a intance \u53bb\u521d\u59cb\u5316 Vulkan library \u3002\u8fd9\u4e2a instance \u662f\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u4e0e Vulkan \u5e93\u4e4b\u95f4\u7684\u8fde\u63a5\u6865\u6881,\u901a\u5e38\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u9700\u8981\u5411\u9a71\u52a8\u7a0b\u5e8f\u63d0\u4f9b\u4e00\u4e9b\u5e94\u7528\u5c42\u7684\u4fe1\u606f\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b 2 \u68c0\u67e5\u53ef\u9009\u529f\u80fd 3 \u9000\u51fa 4 \u6e90\u4ee3\u7801 \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b Vulkan API \u4f7f\u7528 vkInstance \u5bf9\u8c61\u6765\u5b58\u50a8\u6240\u6709\u6bcf\u4e2a\u5e94\u7528\u7684\u72b6\u6001\u3002\u5e94\u7528\u7a0b\u5e8f\u5fc5\u987b\u5728\u6267\u884c\u4efb\u4f55\u5176\u4ed6 Vulkan \u64cd\u4f5c\u4e4b\u524d\u521b\u5efa\u4e00\u4e2a Vulkan \u5b9e\u4f8b\uff0c\u57fa\u672c\u7684 Vulkan \u67b6\u6784\u770b\u8d77\u6765\u662f\u8fd9\u6837\u7684\uff1a \u8bf7\u6ce8\u610f\uff0c\u56fe\u4e2d\u6709\u4e00\u4e9b\u5c42\uff08 Layer )\uff0c\u8fd9\u4e9b\u5c42\u4e5f\u88ab\u52a0\u8f7d\u5668\u52a0\u8f7d\u3002\u5c42\u901a\u5e38\u7528\u4e8e\u9a8c\u8bc1\uff0c\u901a\u5e38\u662f\u7531\u9a71\u52a8\u6267\u884c\u7684\u9519\u8bef\u68c0\u67e5\u3002\u5728 Vulkan \u4e2d\uff0c\u9a71\u52a8\u7a0b\u5e8f\u6bd4 OpenGL \u7b49\u5176\u4ed6 API \u8981\u8f7b\u91cf\u5f97\u591a\uff0c\u90e8\u5206\u539f\u56e0\u662f\u5b83\u5c06\u529f\u80fd\u9a8c\u8bc1\u59d4\u6258\u7ed9\u9a8c\u8bc1\u5c42\u3002\u5c42\u662f\u53ef\u9009\u7684\uff0c\u6bcf\u6b21\u5e94\u7528\u7a0b\u5e8f\u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u65f6\u90fd\u53ef\u4ee5\u9009\u62e9\u6027\u5730\u88c5\u8f7d\u3002 Vulkan Layer \u8d85\u51fa\u4e86\u672c\u7ae0\u7684\u8303\u56f4\uff0c\u4e0b\u9762\u5f00\u59cb\u521b\u5efavulkan\u5b9e\u4f8b\uff0c\u9996\u5148\u6dfb\u52a0\u4e00\u4e2a createInstance \u51fd\u6570\uff0c\u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\u3002 void initVulkan() { createInstance(); } C++ \u53e6\u5916\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u6765\u4fdd\u5b58 instance \u53e5\u67c4: private: VkInstance instance; C++ \u73b0\u5728\u6211\u4eec\u521b\u5efa\u4e00\u4e2a instance \uff0c\u5e76\u4e14\u4e3a\u8be5\u6570\u636e\u7ed3\u6784\u8d4b\u4e88\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u4fe1\u606f\u3002\u8fd9\u4e9b\u6570\u636e\u4ece\u6280\u672f\u89d2\u5ea6\u662f\u53ef\u9009\u62e9\u7684\uff0c\u4f46\u662f\u5b83\u53ef\u4ee5\u4e3a\u9a71\u52a8\u7a0b\u5e8f\u63d0\u4f9b\u4e00\u4e9b\u6709\u7528\u7684\u4fe1\u606f\u6765\u4f18\u5316\u7a0b\u5e8f\u7279\u6b8a\u7684\u4f7f\u7528\u60c5\u666f\uff0c\u6bd4\u5982\u9a71\u52a8\u7a0b\u5e8f\u4f7f\u7528\u4e00\u4e9b\u56fe\u5f62\u5f15\u64ce\u7684\u7279\u6b8a\u884c\u4e3a\u3002\u8fd9\u4e2a\u6570\u636e\u7ed3\u6784\u79f0\u4e3a VkApplicationInfo : VkApplicationInfo appInfo = {}; appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;appInfo.pNext = nullptr; appInfo.pApplicationName = \"Hello Triangle\"; appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.pEngineName = \"No Engine\"; appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.apiVersion = VK_API_VERSION_1_0; C++ \u5982\u524d\u6240\u8ff0\uff0c Vulkan \u4e2d\u7684\u8bb8\u591a\u6570\u636e\u7ed3\u6784\u8981\u6c42\u5728 sType \u6210\u5458\u4e2d\u660e\u786e\u7684\u6307\u5b9a\u7c7b\u578b\u3002 pNext \u6210\u5458\u53ef\u7528\u4e8e\u6307\u5411\u7279\u5b9a\u7684\u6269\u5c55\u7ed3\u6784\u3002\u6211\u4eec\u5728\u8fd9\u91cc\u4f7f\u7528\u9ed8\u8ba4\u521d\u59cb\u5316\uff0c\u5c06\u5176\u8bbe\u7f6e\u4e3a nullptr \u3002 Vulkan \u4e2d\u7684\u5927\u91cf\u4fe1\u606f\u901a\u8fc7\u7ed3\u6784\u4f53\u800c\u4e0d\u662f\u51fd\u6570\u53c2\u6570\u4f20\u9012\uff0c\u6211\u4eec\u5c06\u586b\u5145\u4e00\u4e2a\u7ed3\u6784\u4f53\u4ee5\u63d0\u4f9b\u8db3\u591f\u7684\u4fe1\u606f\u521b\u5efa instance \u3002\u4e0b\u4e00\u4e2a\u7ed3\u6784\u4f53\u4e0d\u662f\u53ef\u9009\u7684\uff0c\u5b83\u9700\u8981\u544a\u77e5 Vulkan \u9a71\u52a8\u7a0b\u5e8f\u6211\u4eec\u9700\u8981\u4f7f\u7528\u54ea\u4e9b\u5168\u5c40\u7684 extensions \u548c validation layers \u3002\u8fd9\u91cc\u7684\u5168\u5c40\u610f\u5473\u7740\u5b83\u9002\u7528\u4e8e\u6574\u4e2a\u7a0b\u5e8f\uff0c\u800c\u4e0d\u662f\u7279\u5b9a\u7684\u8bbe\u5907\uff0c\u8fd9\u4e9b\u5185\u5bb9\u5c06\u5728\u63a5\u4e0b\u6765\u7684\u5c0f\u8282\u4e2d\u8bf4\u660e\u3002 VkInstanceCreateInfo \u7ed3\u6784\u4f53\u4fe1\u606f\u5982\u4e0b\uff1a VkInstanceCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pApplicationInfo = &appInfo; C++ \u524d\u51e0\u4e2a\u53c2\u6570\u6bd4\u8f83\u7b80\u5355\u3002\u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u6307\u5b9a\u9700\u8981\u7684\u5168\u5c40\u6269\u5c55\uff0c Vulakn \u5bf9\u4e8e\u5e73\u53f0\u7279\u6027\u662f\u96f6 API \u652f\u6301\u7684(\u81f3\u5c11\u6682\u65f6\u8fd9\u6837)\uff0c\u8fd9\u610f\u5473\u7740\u9700\u8981\u4e00\u4e2a\u6269\u5c55\u624d\u80fd\u4e0e\u4e0d\u540c\u5e73\u53f0\u7684\u7a97\u4f53\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002 GLFW \u6709\u4e00\u4e2a\u65b9\u4fbf\u7684\u5185\u7f6e\u51fd\u6570\uff0c\u8fd4\u56de\u5b83\u6709\u5173\u7684\u6269\u5c55\u4fe1\u606f\uff0c\u6211\u4eec\u53ef\u4ee5\u4f20\u9012\u7ed9 struct : unsigned int glfwExtensionCount = 0; const char** glfwExtensions; glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount); createInfo.enabledExtensionCount = glfwExtensionCount; createInfo.ppEnabledExtensionNames = glfwExtensions; C++ \u7ed3\u6784\u4f53\u7684\u6700\u540e\u4e24\u4e2a\u6210\u5458\u786e\u5b9a\u9700\u8981\u5f00\u542f\u7684\u5168\u5c40\u7684 validation layers \u3002\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u4e00\u8282\u4e2d\u6df1\u5165\u63a2\u8ba8\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u5728\u8fd9\u4e00\u8282\u8bbe\u7f6e\u4e3a\u7a7a\u3002 createInfo.enabledLayerCount = 0; C++ \u6211\u4eec\u73b0\u5728\u5df2\u7ecf\u6307\u5b9a\u4e86 Vulkan \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u9700\u8981\u7684\u4e00\u5207\u4fe1\u606f\uff0c\u8c03\u7528 vkCreateInstance \u521b\u5efa\u5c5e\u4e8e\u6211\u4eec\u7684\u7b2c\u4e00\u4e2a instance : VkResult result = vkCreateInstance(&createInfo, nullptr, &instance); C++ \u5982\u4f60\u6240\u89c1\uff0c Vulkan \u4e2d\u521b\u5efa\u3001\u5b9e\u4f8b\u5316\u76f8\u5173\u7684\u51fd\u6570\u53c2\u6570\u4e00\u822c\u9075\u5faa\u5982\u4e0b\u539f\u5219\u5b9a\u4e49: \u4f7f\u7528\u6709\u5173creation info \u7684\u7ed3\u6784\u4f53\u6307\u9488 \u4f7f\u7528\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u56de\u8c03\u7684\u6307\u9488 \u4f7f\u7528\u4fdd\u5b58\u65b0\u5bf9\u8c61\u53e5\u67c4\u7684\u6307\u9488 \u5982\u679c\u4e00\u5207\u987a\u5229\uff0c\u6b64\u523binstance\u7684\u53e5\u67c4\u5e94\u8be5\u5b58\u50a8\u5728 VkInstance \u7c7b\u6210\u5458\u4e2d\u4e86\u3002\u51e0\u4e4e\u6240\u6709\u7684Vulkan\u51fd\u6570\u90fd\u8fd4\u56de\u4e00\u4e2a\u503c\u4e3a VK_SUCCESS \u6216\u9519\u8bef\u4ee3\u7801\u7684 VkResult \u7c7b\u578b\u7684\u503c\u3002\u8981\u68c0\u67e5 instance \u662f\u5426\u5df2\u7ecf\u6210\u529f\u521b\u5efa\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u4fdd\u5b58\u7ed3\u679c\uff0c\u4ec5\u4ec5\u4f7f\u7528 VK_SUCCESS \u503c\u6765\u68c0\u6d4b\u5373\u53ef\uff1a if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) { throw std::runtime_error(\"failed to create instance!\"); } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\uff0c\u786e\u8ba4\u6211\u4eec\u7684 instance \u521b\u5efa\u6210\u529f\u3002 \u68c0\u67e5\u53ef\u9009\u529f\u80fd \u5982\u679c\u4f60\u67e5\u770b vkCreateInstance \u7684\u6587\u6863\uff0c\u4f60\u4f1a\u770b\u5230\u4e00\u4e2a\u53ef\u80fd\u51fa\u73b0\u7684\u9519\u8bef\u4ee3\u7801\u662f VK_ERROR_EXTENSION_NOT_PRESENT \u3002\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u5730\u6307\u5b9a\u6211\u4eec\u9700\u8981\u7684\u6269\u5c55\uff0c\u5982\u679c\u8be5\u9519\u8bef\u4ee3\u7801\u8fd4\u56de\uff0c\u5219\u7ec8\u6b62\u5b83\u4eec\u3002\u8fd9\u5bf9\u4e8e\u7a97\u4f53\u7cfb\u7edf\u6216\u8005\u8bf8\u5982\u6b64\u7c7b\u7684\u6269\u5c55\u662f\u6709\u610f\u4e49\u7684\uff0c\u90a3\u4e48\u5982\u4f55\u68c0\u67e5\u53ef\u9009\u529f\u80fd\u5462\uff1f \u5728\u521b\u5efa instance \u4e4b\u524d\u68c0\u7d22\u652f\u6301\u7684\u6269\u5c55\u5217\u8868\uff0c\u901a\u8fc7 vkEnumerateInstanceExtensionProperties \u51fd\u6570\u3002\u5b83\u6307\u5411\u4e00\u4e2a\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u5b58\u50a8\u6269\u5c55\u6570\u91cf\u548c\u4e00\u4e2a VkExtensionProperties \u6570\u7ec4\u6765\u5b58\u50a8\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f\u3002\u5b83\u4e5f\u63a5\u53d7\u4e00\u4e2a\u53ef\u9009\u62e9\u7684\u53c2\u6570\uff0c\u5141\u8bb8\u6211\u4eec\u901a\u8fc7\u7279\u5b9a\u7684 validation layers \u8fc7\u6ee4\u6269\u5c55\uff0c\u73b0\u5728\u6211\u4eec\u6682\u65f6\u5ffd\u7565\u8fd9\u4e9b\u3002 \u8981\u5206\u914d\u4e00\u4e2a\u6570\u7ec4\u6765\u4fdd\u5b58\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u77e5\u9053\u6709\u591a\u5c11\u4e2a\u6269\u5c55\u5b58\u5728\u3002\u53ef\u4ee5\u901a\u8fc7\u5c06\u540e\u4e00\u4e2a\u53c2\u6570\u7f6e\u7a7a\u6765\u83b7\u53d6\u6269\u5c55\u6570\u91cf: uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr); C++ \u73b0\u5728\u6211\u4eec\u5206\u914d\u4e00\u4e2a\u96c6\u5408\u53bb\u6301\u6709\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f( include ) std::vector<VkExtensionProperties> extensions(extensionCount); C++ \u6700\u540e\u6211\u4eec\u53ef\u4ee5\u904d\u5386\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f: vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data()); C++ \u6bcf\u4e2a VkExtensionProperties \u7ed3\u6784\u4f53\u5305\u542b\u6269\u5c55\u7684\u540d\u79f0\u548c\u7248\u672c\u3002\u6211\u4eec\u53ef\u4ee5\u7528\u7b80\u5355\u7684for\u5faa\u73af\u6253\u5370\u4ed6\u4eec(\\t\u662f\u7f29\u8fdb) std::cout << \"available extensions:\" << std::endl; for (const auto& extension : extensions) { std::cout << \"\\t\" << extension.extensionName << std::endl; } C++ \u5982\u679c\u9700\u8981\u83b7\u53d6\u6709\u5173 Vulkan \u652f\u6301\u7684\u4e00\u4e9b\u8be6\u7ec6\u4fe1\u606f\uff0c\u53ef\u4ee5\u5c06\u6b64\u4ee3\u7801\u6dfb\u52a0\u5230 createInstance \u51fd\u6570\u3002\u4f5c\u4e3a\u4e00\u4e2a\u5c1d\u8bd5\uff0c\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\uff0c\u68c0\u67e5 glfwGetRequiredInstanceExtensions \u8fd4\u56de\u7684\u6240\u6709\u6269\u5c55\u662f\u5426\u90fd\u5305\u542b\u5728\u53d7\u652f\u6301\u7684\u6269\u5c55\u5217\u8868\u4e2d\u3002 \u9000\u51fa \u5728\u7a0b\u5e8f\u9000\u51fa\u524d\uff0c\u8bf7\u6b63\u786e\u9500\u6bc1 VkInstance \u3002\u8fd9\u90e8\u5206\u53ef\u4ee5\u5b9a\u4e49\u5728cleanup\u51fd\u6570\u4e2d\uff0c\u8c03\u7528 vkDestroyInstance \u51fd\u6570\u5b8c\u6210\u3002 void cleanup() { vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate(); } C++ vkDestroyInstance \u51fd\u6570\u7684\u53c2\u6570\u5f88\u7b80\u5355\u3002\u50cf\u4e4b\u524d\u5c0f\u8282\u63d0\u5230\u7684\uff0cVulkan\u4e2d\u7684\u5206\u914d\u548c\u91ca\u653e\u529f\u80fd\u6709\u4e00\u4e2a\u53ef\u9009\u7684\u5206\u914d\u5668\u56de\u8c03\uff0c\u6211\u4eec\u901a\u8fc7\u5c06 nullptr \u8bbe\u7f6e\u5ffd\u7565\u3002\u540e\u7eed\u5c0f\u8282\u4e2d\u521b\u5efa\u7684\u6240\u6709Vulkan\u76f8\u5173\u8d44\u6e90\uff0c\u96c6\u4e2d\u5728cleanup\u51fd\u6570\u4e2d\u8fdb\u884c\u6e05\u7406\uff0c\u4e14\u786e\u4fdd\u5728\u9500\u6bc1 instance \u4e4b\u524d\u9500\u6bc1\u3002 \u5728\u8fdb\u884c\u66f4\u590d\u6742\u7684\u5185\u5bb9\u4e4b\u524d\uff0c\u662f\u65f6\u5019\u4e86\u89e3 validation layers \u4e86\u3002 Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217\u7c07 Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217 \uff0c\u901a\u8fc7 VkInstance \u521d\u59cb\u5316 Vulkan \u540e\uff0c\u6211\u4eec\u9700\u8981\u5728\u7cfb\u7edf\u4e2d\u67e5\u627e\u5e76\u9009\u62e9\u4e00\u4e2a\u652f\u6301\u6211\u4eec\u6240\u9700\u529f\u80fd\u7684\u663e\u5361\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u6570\u91cf\u7684\u663e\u5361\u5e76\u540c\u65f6\u4f7f\u7528\u4ed6\u4eec\uff0c\u4f46\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u5355\u7684\u8bbe\u5b9a\u9009\u62e9\u89c4\u5219\uff0c\u5373\u5c06\u67e5\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u56fe\u5f62\u5361\u4f5c\u4e3a\u6211\u4eec\u9002\u5408\u7684\u7269\u7406\u8bbe\u5907\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9009\u62e9\u7269\u7406\u8bbe\u5907 2 \u8bbe\u5907\u9700\u6c42\u68c0\u6d4b 3 \u961f\u5217\u65cf 4 \u6e90\u4ee3\u7801 \u9009\u62e9\u7269\u7406\u8bbe\u5907 \u901a\u8fc7 VkInstance \u521d\u59cb\u5316Vulkan\u540e\uff0c\u6211\u4eec\u9700\u8981\u5728\u7cfb\u7edf\u4e2d\u67e5\u627e\u5e76\u9009\u62e9\u4e00\u4e2a\u652f\u6301\u6211\u4eec\u6240\u9700\u529f\u80fd\u7684\u663e\u5361\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u6570\u91cf\u7684\u663e\u5361\u5e76\u540c\u65f6\u4f7f\u7528\u4ed6\u4eec\uff0c\u4f46\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u5355\u7684\u8bbe\u5b9a\u9009\u62e9\u89c4\u5219\uff0c\u5373\u5c06\u67e5\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u56fe\u5f62\u5361\u4f5c\u4e3a\u6211\u4eec\u9002\u5408\u7684\u7269\u7406\u8bbe\u5907\u3002 \u6211\u4eec\u6dfb\u52a0\u51fd\u6570 pickPhysicalDevice \u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); pickPhysicalDevice(); } void pickPhysicalDevice() { } C++ \u6700\u7ec8\u6211\u4eec\u9009\u62e9\u7684\u56fe\u5f62\u663e\u5361\u5b58\u50a8\u5728\u7c7b\u6210\u5458 VkPhysicalDevice \u53e5\u67c4\u4e2d\u3002\u5f53 VkInstance \u9500\u6bc1\u65f6\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u5c06\u4f1a\u88ab\u9690\u5f0f\u9500\u6bc1\uff0c\u6240\u4ee5\u6211\u4eec\u5e76\u4e0d\u9700\u8981\u5728 cleanup \u51fd\u6570\u4e2d\u505a\u4efb\u4f55\u64cd\u4f5c\u3002 VkPhysicalDevice physicalDevice = VK_NULL_HANDLE; C++ \u5173\u4e8e\u83b7\u53d6\u56fe\u5f62\u5361\u5217\u8868\u7684\u65b9\u5f0f\u4e0e\u83b7\u5f97\u6269\u5c55\u5217\u8868\u7684\u65b9\u5f0f\u7c7b\u4f3c\u3002 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); C++ \u5982\u679c Vulkan \u652f\u6301\u7684\u8bbe\u5907\u6570\u4e3a0\uff0c\u90a3\u4e48\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u8fdb\u884c\u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u9009\u62e9\u629b\u51fa\u5f02\u5e38\u3002 if (deviceCount == 0) { throw std::runtime_error(\"failed to find GPUs with Vulkan support!\"); } C++ \u5426\u5219\u6211\u4eec\u5206\u914d\u6570\u7ec4\u5b58\u50a8\u6240\u6709 VkPhysicalDevice \u7684\u53e5\u67c4\u3002 std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); C++ \u73b0\u5728\u6211\u4eec\u9700\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u8bc4\u4f30\uff0c\u68c0\u67e5\u5b83\u4eec\u662f\u5426\u9002\u5408\u6211\u4eec\u8981\u6267\u884c\u7684\u64cd\u4f5c\uff0c\u56e0\u4e3a\u5e76\u4e0d\u662f\u6240\u6709\u7684\u663e\u5361\u529f\u80fd\u4e00\u81f4\u3002\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u51fd\u6570: bool isDeviceSuitable(VkPhysicalDevice device) { return true; } C++ \u6211\u4eec\u5c06\u68c0\u67e5\u662f\u5426\u6709\u4efb\u4f55\u7269\u7406\u8bbe\u5907\u7b26\u5408\u6211\u4eec\u7684\u529f\u80fd\u9700\u6c42\u3002 for (const auto& device : devices) { if (isDeviceSuitable(device)) { physicalDevice = device; break; } } if (physicalDevice == VK_NULL_HANDLE) { throw std::runtime_error(\"failed to find a suitable GPU!\"); } C++ \u4e0b\u4e00\u8282\u6211\u4eec\u4ecb\u7ecd isDeviceSuitable \u51fd\u6570\uff0c\u5e76\u68c0\u67e5\u7b2c\u4e00\u4e2a\u9700\u8981\u6ee1\u8db3\u7684\u529f\u80fd\u3002\u5728\u540e\u7eed\u7684\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u5f00\u59cb\u4f7f\u7528\u66f4\u591a\u7684 Vulkan \u529f\u80fd\uff0c\u6211\u4eec\u4f1a\u6269\u5c55\u6b64\u529f\u80fd\u51fd\u6570\u4ee5\u6ee1\u8db3\u66f4\u591a\u7684\u68c0\u67e5\u6761\u4ef6\u3002 \u8bbe\u5907\u9700\u6c42\u68c0\u6d4b \u8bc4\u4f30\u5408\u9002\u7684\u8bbe\u5907\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u904d\u5386\u4e00\u4e9b\u7ec6\u8282\u6765\u5b8c\u6210\u3002\u57fa\u672c\u7684\u8bbe\u5907\u5c5e\u6027\u50cfname, type\u4ee5\u53ca Vulkan \u7248\u672c\u90fd\u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceProperties \u6765\u904d\u5386\u5f97\u5230\u3002 VkPhysicalDeviceProperties deviceProperties; vkGetPhysicalDeviceProperties(device, &deviceProperties); C++ \u53ef\u4ee5\u4f7f\u7528 vkGetPhysicalDeviceFeatures \u67e5\u8be2\u5bf9\u7eb9\u7406\u538b\u7f29\uff0c64\u4f4d\u6d6e\u70b9\u6570\u548c\u591a\u89c6\u56fe\u6e32\u67d3(VR\u975e\u5e38\u6709\u7528)\u7b49\u53ef\u9009\u529f\u80fd\u7684\u652f\u6301: VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceFeatures(device, &deviceFeatures); C++ \u66f4\u591a\u904d\u5386\u7269\u7406\u8bbe\u5907\u7ec6\u8282\u7684\u4fe1\u606f\uff0c\u8bf8\u5982\u8bbe\u5907\u5185\u5b58\u3001\u961f\u5217\u7c07\u6211\u4eec\u5c06\u4f1a\u5728\u540e\u7eed\u5c0f\u8282\u8ba8\u8bba\u3002 \u4f8b\u5982\uff0c\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u4ec5\u9002\u7528\u4e8e\u652f\u6301 geometry shaders \u7684\u4e13\u7528\u663e\u5361\u3002\u90a3\u4e48 isDeviceSuitable \u51fd\u6570\u5c06\u5982\u4e0b\u6240\u793a: bool isDeviceSuitable(VkPhysicalDevice device) { VkPhysicalDeviceProperties deviceProperties; VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceProperties(device, &deviceProperties); vkGetPhysicalDeviceFeatures(device, &deviceFeatures); return deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU && deviceFeatures.geometryShader; } C++ \u4e3a\u4e86\u907f\u514d\u7eaf\u7cb9\u7684\u5355\u4e00\u7684\u5224\u65ad\u4e00\u4e2a\u8bbe\u5907\u662f\u5426\u5408\u9002\uff0c\u5c24\u5176\u662f\u5f53\u4f60\u53d1\u73b0\u591a\u4e2a\u8bbe\u5907\u90fd\u5408\u9002\u7684\u6761\u4ef6\u4e0b\uff0c\u4f60\u4e5f\u53ef\u4ee5\u7ed9\u6bcf\u4e00\u4e2a\u8bbe\u5907\u505a\u6743\u503c\uff0c\u9009\u62e9\u6700\u9ad8\u7684\u4e00\u4e2a\u3002\u8fd9\u6837\uff0c\u53ef\u4ee5\u901a\u8fc7\u7ed9\u4e88\u66f4\u9ad8\u6743\u503c\u83b7\u53d6\u5b9a\u5236\u5316\u7684\u56fe\u5f62\u8bbe\u5907\uff0c\u4f46\u5982\u679c\u6ca1\u6709\u4e00\u4e2a\u53ef\u7528\u7684\u8bbe\u5907\uff0c\u53ef\u4ee5\u56de\u6eda\u5230\u96c6\u6210\u56fe\u5f62\u8bbe\u5907\u3002\u4f60\u53ef\u4ee5\u6309\u7167\u5982\u4e0b\u65b9\u5f0f\u5b9e\u73b0: #include <map> ... void pickPhysicalDevice() { ... // Use an ordered map to automatically sort candidates by increasing score std::multimap<int, VkPhysicalDevice> candidates; for (const auto& device : devices) { int score = rateDeviceSuitability(device); candidates.insert(std::make_pair(score, device)); } // Check if the best candidate is suitable at all if (candidates.rbegin()->first > 0) { physicalDevice = candidates.rbegin()->second; } else { throw std::runtime_error(\"failed to find a suitable GPU!\"); } } int rateDeviceSuitability(VkPhysicalDevice device) { ... int score = 0; // Discrete GPUs have a significant performance advantage if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) { score += 1000; } // Maximum possible size of textures affects graphics quality score += deviceProperties.limits.maxImageDimension2D; // Application can't function without geometry shaders if (!deviceFeatures.geometryShader) { return 0; } return score; } C++ \u6211\u4eec\u4e0d\u9700\u8981\u5728\u5c0f\u8282\u5185\u5b9e\u73b0\u6240\u6709\u5185\u5bb9\uff0c\u4f46\u6211\u4eec\u53ef\u4ee5\u4e86\u89e3\u5982\u4f55\u9009\u62e9\u56fe\u5f62\u8bbe\u5907\u7684\u8fc7\u7a0b\u3002\u5f53\u7136\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u793a\u56fe\u5f62\u8bbe\u5907\u7684\u540d\u79f0\u5217\u8868\uff0c\u8ba9\u7528\u6237\u9009\u62e9\u3002 \u56e0\u4e3a\u6211\u4eec\u521a\u521a\u5f00\u59cb\uff0c Vulkan \u7684\u652f\u6301\u662f\u6211\u4eec\u552f\u4e00\u9700\u8981\u7684\uff0c\u5728\u8fd9\u91cc\u5047\u8bbe\u4efb\u4f55GPU\u90fd\u53ef\u4ee5: bool isDeviceSuitable(VkPhysicalDevice device) { return true; } C++ \u5728\u4e0b\u4e00\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u8ba8\u8bba\u7b2c\u4e00\u4e2a\u771f\u6b63\u9700\u8981\u68c0\u67e5\u7684\u8bbe\u5907\u529f\u80fd\u3002 \u961f\u5217\u65cf \u4e4b\u524d\u5df2\u7ecf\u7b80\u8981\u7684\u4ecb\u7ecd\u8fc7\uff0c\u51e0\u4e4e\u6240\u6709\u7684 Vulkan \u64cd\u4f5c\uff0c\u4ece\u7ed8\u56fe\u5230\u4e0a\u4f20\u7eb9\u7406\uff0c\u90fd\u9700\u8981\u5c06\u547d\u4ee4\u63d0\u4ea4\u5230\u961f\u5217\u4e2d\u3002\u6709\u4e0d\u540c\u7c7b\u578b\u7684\u961f\u5217\u6765\u6e90\u4e8e\u4e0d\u540c\u7684\u961f\u5217\u7c07\uff0c\u6bcf\u4e2a\u961f\u5217\u7c07\u53ea\u5141\u8bb8\u90e8\u5206 commands \u3002\u4f8b\u5982\uff0c\u53ef\u4ee5\u6709\u4e00\u4e2a\u961f\u5217\u7c07\uff0c\u53ea\u5141\u8bb8\u5904\u7406\u8ba1\u7b97 commands \u6216\u8005\u53ea\u5141\u8bb8\u5185\u5b58\u4f20\u8f93 commands : \u6211\u4eec\u9700\u8981\u68c0\u6d4b\u8bbe\u5907\u4e2d\u652f\u6301\u7684\u961f\u5217\u7c07\uff0c\u5176\u4e2d\u54ea\u4e00\u4e2a\u961f\u5217\u7c07\u652f\u6301\u6211\u4eec\u60f3\u8981\u7684 commands \u3002\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u51fd\u6570 findQueueFamilies \u6765\u67e5\u627e\u6211\u4eec\u9700\u8981\u7684\u961f\u5217\u7c07\u3002\u73b0\u5728\u6211\u4eec\u53ea\u4f1a\u5bfb\u627e\u4e00\u4e2a\u652f\u6301\u56fe\u5f62 commands \u961f\u5217\u7c07\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u5728\u7a0d\u540e\u7684\u5c0f\u8282\u4e2d\u6269\u5c55\u66f4\u591a\u7684\u5185\u5bb9\u3002 \u6b64\u51fd\u6570\u8fd4\u56de\u6ee1\u8db3\u67d0\u4e2a\u5c5e\u6027\u7684\u961f\u5217\u7c07\u7d22\u5f15\u3002\u5b9a\u4e49\u7ed3\u6784\u4f53\uff0c\u5176\u4e2d\u7d22\u5f15 -1 \u8868\u793a\u201d\u672a\u627e\u5230\u201d: struct QueueFamilyIndices { int graphicsFamily = -1; bool isComplete() { return graphicsFamily >= 0; } }; C++ \u73b0\u5728\u6211\u4eec\u5b9e\u73b0 findQueueFamilies \u51fd\u6570: QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) { QueueFamilyIndices indices; ... return indices; } C++ \u83b7\u53d6\u961f\u5217\u7c07\u7684\u5217\u8868\u51fd\u6570\u4e3a vkGetPhysicalDeviceQueueFamilyProperties : uint32_t queueFamilyCount = 0; vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr); std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount); vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data()); C++ \u6709\u5173\u961f\u5217\u7c07\uff0c\u7ed3\u6784\u4f53 VkQueueFamilyProperties \u5305\u542b\u4e86\u5177\u4f53\u4fe1\u606f\uff0c\u5305\u62ec\u652f\u6301\u7684\u64cd\u4f5c\u7c7b\u578b\u548c\u57fa\u4e8e\u5f53\u524d\u961f\u5217\u7c07\u53ef\u4ee5\u521b\u5efa\u7684\u6709\u6548\u961f\u5217\u6570\u3002\u6211\u4eec\u81f3\u5c11\u9700\u8981\u627e\u5230\u4e00\u4e2a\u652f\u6301 VK_QUEUE_GRAPHICS_BIT \u7684\u961f\u5217\u7c07\u3002 int i = 0; for (const auto& queueFamily : queueFamilies) { if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) { indices.graphicsFamily = i; } if (indices.isComplete()) { break; } i++; } C++ \u73b0\u5728\u6211\u4eec\u6709\u4e86\u6bd4\u8f83\u7406\u60f3\u7684\u961f\u5217\u7c07\u67e5\u8be2\u529f\u80fd\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 isDeviceSuitable \u51fd\u6570\u4e2d\u4f7f\u7528\uff0c\u786e\u4fdd\u7269\u7406\u8bbe\u5907\u53ef\u4ee5\u5904\u7406\u6211\u4eec\u9700\u8981\u7684\u547d\u4ee4: bool isDeviceSuitable(VkPhysicalDevice device) { QueueFamilyIndices indices = findQueueFamilies(device); return indices.isComplete(); } C++ \u5f88\u597d\uff0c\u6211\u4eec\u5df2\u7ecf\u627e\u5230\u4e86\u6211\u4eec\u9700\u8981\u7684\u7269\u7406\u8bbe\u5907\uff0c\u5728 \u4e0b\u4e00\u4e2a\u5c0f\u8282 \u6211\u4eec\u4f1a\u8ba8\u8bba\u903b\u8f91\u8bbe\u5907\u3002 Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b \uff0c \u4e0a\u4e00\u8282 \u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6b63\u786e\u914d\u7f6e\u3001\u53ef\u8fd0\u884c\u7684\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u4f7f\u7528\u6d4b\u8bd5\u4ee3\u7801\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u672c\u8282\u4e2d\u6211\u4eec\u4ece\u5934\u5f00\u59cb\uff0c\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u6784\u5efa\u4e00\u4e2a\u57fa\u4e8e GLFW \u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\u539f\u578b\u6846\u67b6\u7684\u96cf\u5f62\u3002 \u64cd\u4f5c\u7cfb\u7edf: Windows8.1 \u663e\u5361:Nivida GTX965M \u5f00\u53d1\u5de5\u5177\uff1aVisual Studio 2017 \u6587\u7ae0\u76ee\u5f55 1 \u603b\u4f53\u7ed3\u6784 2 \u8d44\u6e90\u7ba1\u7406 3 \u6574\u5408GLFW \u603b\u4f53\u7ed3\u6784 \u5728\u4e0a\u4e00\u8282\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6b63\u786e\u914d\u7f6e\u3001\u53ef\u8fd0\u884c\u7684\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u4f7f\u7528\u6d4b\u8bd5\u4ee3\u7801\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u672c\u8282\u4e2d\u6211\u4eec\u4ece\u5934\u5f00\u59cb\uff0c\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u6784\u5efa\u4e00\u4e2a\u57fa\u4e8eGLFW\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\u539f\u578b\u6846\u67b6\u7684\u96cf\u5f62\u3002 #include <vulkan/vulkan.h> #include <iostream> #include <stdexcept> #include <functional> class HelloTriangleApplication { public: void run() { initVulkan(); mainLoop(); cleanup(); } private: void initVulkan() { } void mainLoop() { } void cleanup() { } }; int main() { HelloTriangleApplication app; try { app.run(); } catch (const std::runtime_error& e) { std::cerr << e.what() << std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; } C++ \u9996\u5148\u4ece LunarG SDK \u4e2d\u6dfb\u52a0 Vulkan \u5934\u6587\u4ef6\uff0c\u5b83\u63d0\u4f9b\u4e86\u8d2d\u673a\u7231\u4f60 Vulkan \u5e94\u7528\u7a0b\u5e8f\u9700\u8981\u7684\u51fd\u6570\u3001\u7ed3\u6784\u4f53\u3001\u548c\u679a\u4e3e\u3002\u6211\u4eec\u5305\u542b stdexcept \u548c iostream \u5934\u6587\u4ef6\u7528\u4e8e\u629b\u51fa\u5f02\u5e38\u4fe1\u606f\uff0c\u800c functional \u5934\u6587\u4ef6\u7528\u4e8e\u8d44\u6e90\u7ba1\u7406\u90e8\u5206\u652f\u6301 lambda \u8868\u8fbe\u5f0f\u3002 \u7a0b\u5e8f\u88ab\u5c01\u88c5\u5230\u4e00\u4e2a\u7c7b\u4e2d\uff0c\u8be5\u7c7b\u7ed3\u6784\u5c06\u4f1a\u5b58\u50a8Vulkan\u79c1\u6709\u6210\u5458\u5bf9\u8c61\uff0c\u5e76\u6dfb\u52a0\u57fa\u672c\u7684\u51fd\u6570\u6765\u521d\u59cb\u5316\u4ed6\u4eec\u3002\u9996\u5148\u4f1a\u4ece initVulkan \u51fd\u6570\u5f00\u59cb\u8c03\u7528\u3002\u5f53\u4e00\u5207\u51c6\u5907\u597d\uff0c\u6211\u4eec\u8fdb\u5165\u4e3b\u5faa\u73af\u5f00\u59cb\u6e32\u67d3\u5e27\u3002\u6211\u4eec\u5c06\u4f1a\u52a0\u5165 mainLoop \u51fd\u6570\u5305\u542bloop\u5faa\u73af\u8c03\u7528\uff0c\u8be5\u5faa\u73af\u8c03\u7528\u76f4\u5230GLFW\u7a97\u4f53\u7ba1\u7406\u624d\u4f1a\u505c\u6b62\u3002\u5f53\u7a97\u4f53\u5173\u95ed\u5e76\u4e14 mainLoop \u8fd4\u56de\u65f6\uff0c\u6211\u4eec\u9700\u8981\u91ca\u653e\u6211\u4eec\u5df2\u7ecf\u7533\u8bf7\u8fc7\u7684\u4efb\u4f55\u8d44\u6e90\uff0c\u8be5\u6e05\u7406\u903b\u8f91\u5728 cleanup \u51fd\u6570\u4e2d\u53bb\u5b9a\u4e49\u3002 \u7a0b\u5e8f\u8fd0\u884c\u671f\u95f4\uff0c\u5982\u679c\u53d1\u751f\u4e86\u4efb\u4f55\u4e25\u91cd\u7684\u9519\u8bef\u5f02\u5e38\uff0c\u6211\u4eec\u4f1a\u629b\u51fa std::runtime_error \u5e76\u6ce8\u660e\u5f02\u5e38\u63cf\u8ff0\u4fe1\u606f,\u8fd9\u4e2a\u5f02\u5e38\u4fe1\u606f\u4f1a\u88ab main \u51fd\u6570\u6355\u83b7\u53ca\u6253\u5370\u63d0\u793a\u3002\u5f88\u5feb\u4f60\u5c06\u4f1a\u9047\u5230\u4e00\u4e2a\u629b\u51faerror\u7684\u4f8b\u5b50\uff0c\u662f\u5173\u4e8e Vulkan \u5e94\u7528\u7a0b\u5e8f\u4e0d\u652f\u6301\u67d0\u4e2a\u5fc5\u8981\u7684\u6269\u5c55\u529f\u80fd\u3002 \u57fa\u672c\u4e0a\u5728\u4e4b\u540e\u7684\u6bcf\u4e00\u4e2a\u5c0f\u8282\u4e2d\u90fd\u4f1a\u4ece initVulkan \u51fd\u6570\u4e2d\u589e\u52a0\u4e00\u4e2a\u65b0\u7684 Vulkan \u51fd\u6570\u8c03\u7528,\u589e\u52a0\u7684\u51fd\u6570\u4f1a\u4ea7\u751f Vulkan objects \u5e76\u4fdd\u5b58\u4e3a\u7c7b\u7684\u79c1\u6709\u6210\u5458\uff0c\u8bf7\u8bb0\u5f97\u5728 cleanup \u4e2d\u8fdb\u884c\u8d44\u6e90\u7684\u6e05\u7406\u548c\u91ca\u653e\u3002 \u8d44\u6e90\u7ba1\u7406 \u6211\u4eec\u77e5\u9053\u901a\u8fc7 malloc \u5206\u914d\u7684\u6bcf\u4e00\u4e2a\u5185\u5b58\u5feb\u5728\u4f7f\u7528\u5b8c\u4e4b\u540e\u90fd\u9700\u8981 free \u5185\u5b58\u8d44\u6e90\uff0c\u6bcf\u4e00\u4e2a\u6211\u4eec\u521b\u5efa\u7684 Vulkan object \u4e0d\u5728\u4f7f\u7528\u65f6\u90fd\u9700\u8981\u660e\u786e\u7684\u9500\u6bc1\u3002\u5728 C++ \u4e2d\u53ef\u4ee5\u5229\u7528 \u5b8c\u6210auto\u8d44\u6e90\u7ba1\u7406\uff0c\u4f46\u662f\u5728\u672c\u8282\u4e2d\uff0c\u9009\u62e9\u660e\u786e\u7f16\u5199\u6240\u6709\u7684\u5185\u5b58\u7684\u5206\u914d\u548c\u91ca\u653e\u64cd\u4f5c\uff0c\u5176\u4e3b\u8981\u539f\u56e0\u662f`\u7684\u8bbe\u8ba1\u7406\u5ff5\u5c31\u662f\u660e\u786e\u6bcf\u4e00\u6b65\u64cd\u4f5c\uff0c\u6e05\u695a\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f\uff0c\u907f\u514d\u53ef\u80fd\u5b58\u5728\u7684\u672a\u77e5\u4ee3\u7801\u9020\u6210\u7684\u5f02\u5e38\u3002 \u5f53\u7136\u5728\u672c\u8282\u4e4b\u540e,\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u91cd\u8f7d std::shared_ptr \u6765\u5b9e\u73b0auto \u8d44\u6e90\u7ba1\u7406\u3002\u5bf9\u4e8e\u66f4\u5927\u4f53\u91cf\u7684Vulkan\u7a0b\u5e8f,\u5efa\u8bae\u9075\u5faa RAII \u7684\u539f\u5219\u7ef4\u62a4\u8d44\u6e90\u7684\u7ba1\u7406\u3002 Vulkan \u5bf9\u8c61\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 vkCreateXXX \u7cfb\u51fd\u6570\u521b\u5efa\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u5177\u6709 vkAllocateXXX \u7b49\u529f\u80fd\u7684\u4e00\u4e2a\u5bf9\u8c61\u8fdb\u884c\u5206\u914d\u3002\u786e\u4fdd\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u5728\u4e0d\u4f7f\u7528\u7684\u65f6\u5019\u8c03\u7528 vkDestroyXXX \u548c vkFreeXXX \u9500\u6bc1\u3001\u91ca\u653e\u5bf9\u5e94\u7684\u8d44\u6e90\u3002\u8fd9\u4e9b\u51fd\u6570\u7684\u53c2\u6570\u901a\u5e38\u56e0\u4e0d\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u800c\u4e0d\u540c\uff0c\u4f46\u662f\u4ed6\u4eec\u5171\u4eab\u4e00\u4e2a\u53c2\u6570:pAllocator\u3002\u8fd9\u662f\u4e00\u4e2a\u53ef\u9009\u7684\u53c2\u6570\uff0c Vulkan \u5141\u8bb8\u6211\u4eec\u81ea\u5b9a\u4e49\u5185\u5b58\u5206\u914d\u5668\u3002\u6211\u4eec\u5c06\u5728\u672c\u6559\u7a0b\u5ffd\u7565\u6b64\u53c2\u6570\uff0c\u59cb\u7ec8\u4ee5 nullptr \u4f5c\u4e3a\u53c2\u6570\u3002 \u6574\u5408GLFW \u5982\u679c\u6211\u4eec\u5f00\u53d1\u4e00\u4e9b\u4e0d\u9700\u8981\u57fa\u4e8e\u5c4f\u5e55\u663e\u793a\u7684\u7a0b\u5e8f\uff0c\u90a3\u4e48\u7eaf\u7cb9\u7684 Vulkan \u672c\u8eab\u53ef\u4ee5\u5b8c\u7f8e\u7684\u652f\u6301\u5f00\u53d1\u3002\u4f46\u662f\u5982\u679c\u521b\u5efa\u4e00\u4e9b\u8ba9\u4eba\u5174\u594b\u7684\u53ef\u89c6\u5316\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u5c31\u9700\u8981\u5f15\u5165\u7a97\u4f53\u7cfb\u7edf GLFW \uff0c\u5e76\u5c06 #include \u8fdb\u884c\u76f8\u5e94\u7684\u66ff\u6362\u3002 #define GLFW_INCLUDE_VULKAN #include <GLFW/glfw3.h> C++ \u5728\u65b0\u7248\u672c\u7684 GLFW \u4e2d\u5df2\u7ecf\u63d0\u4f9b\u4e86 Vulkan \u76f8\u5173\u7684\u652f\u6301\uff0c\u8be6\u7ec6\u7684\u4f7f\u7528\u5efa\u8bae\u53c2\u9605\u5b98\u65b9\u8d44\u6599\u3002 \u901a\u8fc7\u66ff\u6362\uff0c\u5c06\u4f1a\u4f7f\u7528 GLFW \u5bf9 Vulkan \u7684\u652f\u6301\uff0c\u5e76\u81ea\u52a8\u52a0\u8f7d Vulkan \u7684\u5934\u6587\u4ef6\u3002\u5728 run \u51fd\u6570\u4e2d\u6dfb\u52a0\u4e00\u4e2a initWindow \u51fd\u6570\u8c03\u7528\uff0c\u5e76\u786e\u4fdd\u5728\u5176\u4ed6\u51fd\u6570\u8c03\u7528\u524d\u4f18\u5148\u8c03\u7528\u3002\u6211\u4eec\u5c06\u4f1a\u901a\u8fc7\u8be5\u51fd\u6570\u5b8c\u6210 GLFW \u7684\u7a97\u4f53\u521d\u59cb\u5316\u5de5\u4f5c\u3002 void run() { initWindow(); initVulkan(); mainLoop(); cleanup(); } private: void initWindow() { } C++ initWindow \u4e2d\u7684\u7b2c\u4e00\u4e2a\u8c03\u7528\u662f glfwInit() ,\u5b83\u4f1a\u521d\u59cb\u5316 GLFW \u5e93\u3002\u56e0\u4e3a\u6700\u521d GLFW \u662f\u4e3a OpenGL \u521b\u5efa\u4e0a\u4e0b\u6587\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u4eec\u9700\u8981\u544a\u8bc9\u5b83\u4e0d\u8981\u8c03\u7528 OpenGL \u76f8\u5173\u7684\u521d\u59cb\u5316\u64cd\u4f5c\u3002 glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); C++ \u7279\u522b\u6ce8\u610f\u7a97\u53e3\u5927\u5c0f\u7684\u8bbe\u7f6e\uff0c\u7a0d\u540e\u6211\u4eec\u4f1a\u8c03\u7528\uff0c\u73b0\u5728\u4f7f\u7528\u53e6\u4e00\u4e2a\u7a97\u53e3\u63d0\u793a\u6765\u4ec5\u7528\u5b83\u3002 glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); C++ \u73b0\u5728\u5269\u4e0b\u7684\u5c31\u662f\u521b\u5efa\u5b9e\u9645\u7684\u7a97\u4f53\u3002\u6dfb\u52a0\u4e00\u4e2a GLFWwindow* \u7a97\u4f53\uff0c\u79c1\u6709\u7c7b\u6210\u5458\u5b58\u50a8\u5176\u5f15\u7528\u5e76\u521d\u59cb\u5316\u7a97\u4f53: window = glfwCreateWindow(800, 600, \"Vulkan\", nullptr, nullptr); C++ \u524d\u4e09\u4e2a\u53c2\u6570\u5b9a\u4e49\u7a97\u4f53\u7684\u5bbd\u5ea6\u3001\u9ad8\u5ea6\u548c Title \u3002\u7b2c\u56db\u4e2a\u53c2\u6570\u5141\u8bb8\u5236\u5b9a\u4e00\u4e2a\u76d1\u542c\u5668\u6765\u6253\u5f00\u7a97\u4f53\uff0c\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u4e0e OpenGL \u6709\u5173\uff0c\u6211\u4eec\u9009\u62e9 nullptr \u3002 \u4f7f\u7528\u5e38\u91cf\u4ee3\u66ff\u786c\u7f16\u7801\u5bbd\u5ea6\u548c\u9ad8\u5ea6\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u540e\u7eed\u7684\u5185\u5bb9\u4e2d\u4f1a\u5f15\u7528\u8be5\u6570\u503c\u591a\u6b21\u3002\u5728 HelloTriangleApplication \u7c7b\u5b9a\u4e49\u4e4b\u4e0a\u6dfb\u52a0\u4ee5\u4e0b\u51e0\u884c: const int WIDTH = 800; const int HEIGHT = 600; C++ \u5e76\u66ff\u6362\u7a97\u4f53\u521b\u5efa\u7684\u4ee3\u7801\u8bed\u53e5\u4e3a: window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); C++ \u4f60\u73b0\u5728\u5e94\u8be5\u6709\u4e00\u4e2a\u5982\u4e0b\u6240\u793a\u7684initWindow\u51fd\u6570: void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); } C++ \u4fdd\u6301\u7a0b\u5e8f\u8fd0\u884c\uff0c\u76f4\u5230\u53d1\u751f\u9519\u8bef\u6216\u8005\u7a97\u4f53\u5173\u95ed\uff0c\u6211\u4eec\u9700\u8981\u5411 mainLoop \u51fd\u6570\u6dfb\u52a0\u4e8b\u4ef6\u5faa\u73af\uff0c\u5982\u4e0b\u6240\u793a: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); } } C++ \u8fd9\u6bb5\u4ee3\u7801\u5e94\u8be5\u5f88\u5bb9\u6613\u770b\u61c2\u3002\u5b83\u5faa\u73af\u5e76\u68c0\u67e5 GLFW \u4e8b\u4ef6\uff0c\u76f4\u5230\u6309\u4e0b X \u6309\u94ae\uff0c\u6216\u8005\u5173\u95ed\u7a97\u4f53\u3002\u8be5\u5faa\u73af\u7ed3\u6784\u7a0d\u540e\u4f1a\u8c03\u7528\u6e32\u67d3\u51fd\u6570\u3002 \u4e00\u65e6\u7a97\u4f53\u5173\u95ed\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7 cleanup \u51fd\u6570\u6e05\u7406\u8d44\u6e90\u3001\u7ed3\u675f GLFW \u672c\u8eab\u3002 void cleanup() { glfwDestroyWindow(window); glfwTerminate(); } C++ \u8fd0\u884c\u7a0b\u5e8f\uff0c\u6211\u4eec\u5e94\u8be5\u4f1a\u770b\u5230\u4e00\u4e2a\u540d\u4e3a Vulkan \u7684\u767d\u8272\u7a97\u4f53\uff0c\u76f4\u5230\u5173\u95ed\u7a97\u4f53\u7ec8\u6b62\u5e94\u7528\u7a0b\u5e8f\u3002 ok\uff0c\u5230\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86\u4e00\u4e2a Vulkan \u7a0b\u5e8f\u7684\u9aa8\u67b6\u539f\u578b\uff0c\u5728 \u4e0b\u4e00\u8282 \u6211\u4eec\u4f1a\u521b\u5efa\u7b2c\u4e00\u4e2a Vulkan Object ! [Vulkan \u9a8c\u8bc1\u5c42] PASS Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217 Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217 \uff0c\u5728\u9009\u62e9\u8981\u4f7f\u7528\u7684\u7269\u7406\u8bbe\u5907\u4e4b\u540e\uff0c\u6211\u4eec\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u903b\u8f91\u8bbe\u5907\u7528\u4e8e\u4ea4\u4e92\u3002\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u8fc7\u7a0b\u4e0einstance\u521b\u5efa\u8fc7\u7a0b\u7c7b\u4f3c\uff0c\u4e5f\u9700\u8981\u63cf\u8ff0\u6211\u4eec\u9700\u8981\u4f7f\u7528\u7684\u529f\u80fd\u3002\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u67e5\u8be2\u8fc7\u54ea\u4e9b\u961f\u5217\u7c07\u53ef\u7528\uff0c\u5728\u8fd9\u91cc\u9700\u8981\u8fdb\u4e00\u6b65\u4e3a\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u5177\u4f53\u7c7b\u578b\u7684\u547d\u4ee4\u961f\u5217\u3002\u5982\u679c\u6709\u4e0d\u540c\u7684\u9700\u6c42\uff0c\u4e5f\u53ef\u4ee5\u57fa\u4e8e\u540c\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u521b\u5efa\u591a\u4e2a\u903b\u8f91\u8bbe\u5907\u3002 \u9996\u5148\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u7c7b\u6210\u5458\u6765\u5b58\u50a8\u903b\u8f91\u8bbe\u5907\u53e5\u67c4\u3002 VkDevice device; C++ \u63a5\u4e0b\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u51fd\u6570 createLogicalDevice \uff0c\u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\uff0c\u4ee5\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u3002 void initVulkan() { createInstance(); setupDebugCallback(); pickPhysicalDevice(); createLogicalDevice(); } void createLogicalDevice() { } C++ https://geek-docs.com/vulkan/vulkan-tutorial/vulkan-logical-devices-and-queues.html#i-5) \u6307\u5b9a\u521b\u5efa\u7684\u961f\u5217 \u521b\u5efa\u903b\u8f91\u8bbe\u5907\u9700\u8981\u5728\u7ed3\u6784\u4f53\u4e2d\u660e\u786e\u5177\u4f53\u7684\u4fe1\u606f\uff0c\u9996\u5148\u7b2c\u4e00\u4e2a\u7ed3\u6784\u4f53 VkDeviceQueueCreateInfo \u3002\u8fd9\u4e2a\u7ed3\u6784\u4f53\u63cf\u8ff0\u961f\u5217\u7c07\u4e2d\u9884\u8981\u7533\u8bf7\u4f7f\u7528\u7684\u961f\u5217\u6570\u91cf\u3002\u73b0\u5728\u6211\u4eec\u4ec5\u5173\u5fc3\u5177\u5907\u56fe\u5f62\u80fd\u529b\u7684\u961f\u5217\u3002 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); VkDeviceQueueCreateInfo queueCreateInfo = {}; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = indices.graphicsFamily; queueCreateInfo.queueCount = 1; C++ \u5f53\u524d\u53ef\u7528\u7684\u9a71\u52a8\u7a0b\u5e8f\u6240\u63d0\u4f9b\u7684\u961f\u5217\u7c07\u53ea\u5141\u8bb8\u521b\u5efa\u5c11\u91cf\u7684\u961f\u5217\uff0c\u5e76\u4e14\u5f88\u591a\u65f6\u5019\u6ca1\u6709\u5fc5\u8981\u521b\u5efa\u591a\u4e2a\u961f\u5217\u3002\u8fd9\u662f\u56e0\u4e3a\u53ef\u4ee5\u5728\u591a\u4e2a\u7ebf\u7a0b\u4e0a\u521b\u5efa\u6240\u6709\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u7136\u540e\u5728\u4e3b\u7ebf\u7a0b\u4e00\u6b21\u6027\u7684\u4ee5\u8f83\u4f4e\u5f00\u9500\u7684\u8c03\u7528\u63d0\u4ea4\u961f\u5217\u3002 Vulkan \u5141\u8bb8\u4f7f\u75280.0\u52301.0\u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u5206\u914d\u961f\u5217\u4f18\u5148\u7ea7\u6765\u5f71\u54cd\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u7684\u8c03\u7528\u3002\u5373\u4f7f\u53ea\u6709\u4e00\u4e2a\u961f\u5217\u4e5f\u662f\u5fc5\u987b\u7684: float queuePriority = 1.0f; queueCreateInfo.pQueuePriorities = &queuePriority; C++ \u6307\u5b9a\u4f7f\u7528\u7684\u8bbe\u5907\u7279\u6027 \u4e0b\u4e00\u4e2a\u8981\u660e\u786e\u7684\u4fe1\u606f\u6709\u5173\u8bbe\u5907\u8981\u4f7f\u7528\u7684\u529f\u80fd\u7279\u6027\u3002\u8fd9\u4e9b\u662f\u6211\u4eec\u5728\u4e0a\u4e00\u8282\u4e2d\u7528 vkGetPhysicalDeviceFeatures \u67e5\u8be2\u652f\u6301\u7684\u529f\u80fd\uff0c\u6bd4\u5982geometry shaders\u3002\u73b0\u5728\u6211\u4eec\u4e0d\u9700\u8981\u4efb\u4f55\u7279\u6b8a\u7684\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7684\u5b9a\u4e49\u5b83\u5e76\u5c06\u6240\u6709\u5185\u5bb9\u4fdd\u7559\u5230 VK_FALSE \u3002\u4e00\u65e6\u6211\u4eec\u8981\u5f00\u59cb\u7528Vulkan\u505a\u66f4\u591a\u7684\u4e8b\u60c5\uff0c\u6211\u4eec\u4f1a\u56de\u5230\u8fd9\u4e2a\u7ed3\u6784\u4f53\uff0c\u8fdb\u4e00\u6b65\u8bbe\u7f6e\u3002 VkPhysicalDeviceFeatures deviceFeatures = {}; C++ \u521b\u5efa\u903b\u8f91\u8bbe\u5907 \u4f7f\u7528\u524d\u9762\u7684\u4e24\u4e2a\u7ed3\u6784\u4f53\uff0c\u6211\u4eec\u53ef\u4ee5\u586b\u5145 VkDeviceCreateInfo \u7ed3\u6784\u3002 VkDeviceCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; C++ \u9996\u5148\u6dfb\u52a0\u6307\u5411\u961f\u5217\u521b\u5efa\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\u548c\u8bbe\u5907\u529f\u80fd\u7ed3\u6784\u4f53: createInfo.pQueueCreateInfos = &queueCreateInfo; createInfo.queueCreateInfoCount = 1; createInfo.pEnabledFeatures = &deviceFeatures; C++ \u7ed3\u6784\u4f53\u5176\u4f59\u7684\u90e8\u5206\u4e0e VkInstanceCreateInfo \u76f8\u4f3c\uff0c\u9700\u8981\u6307\u5b9a\u6269\u5c55\u548c validation layers \uff0c\u603b\u800c\u8a00\u4e4b\u8fd9\u6b21\u4e0d\u540c\u4e4b\u5904\u662f\u4e3a\u5177\u4f53\u7684\u8bbe\u5907\u8bbe\u7f6e\u4fe1\u606f\u3002 \u8bbe\u7f6e\u5177\u4f53\u6269\u5c55\u7684\u4e00\u4e2a\u6848\u4f8b\u662f VK_KHR_swapchain \uff0c\u5b83\u5141\u8bb8\u5c06\u6765\u81ea\u8bbe\u5907\u7684\u6e32\u67d3\u56fe\u5f62\u5448\u73b0\u5230 Windows \u3002\u7cfb\u7edf\u4e2d\u7684 Vulkan \u8bbe\u5907\u53ef\u80fd\u7f3a\u5c11\u8be5\u529f\u80fd\uff0c\u4f8b\u5982\u4ec5\u4ec5\u652f\u6301\u8ba1\u7b97\u64cd\u4f5c\u3002\u6211\u4eec\u5c06\u5728\u4ea4\u6362\u94fe\u7ae0\u8282\u4e2d\u5c55\u5f00\u8fd9\u4e2a\u6269\u5c55\u3002 \u5c31\u50cf\u4e4b\u524d validation layers \u5c0f\u8282\u4e2d\u63d0\u5230\u7684\uff0c\u5141\u8bb8\u4e3a instance \u5f00\u542f validation layers \uff0c\u73b0\u5728\u6211\u4eec\u5c06\u4e3a\u8bbe\u5907\u5f00\u542f validation layers \uff0c\u800c\u4e0d\u9700\u8981\u4e3a\u8bbe\u5907\u6307\u5b9a\u4efb\u4f55\u6269\u5c55\u3002 createInfo.enabledExtensionCount = 0; if (enableValidationLayers) { createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size()); createInfo.ppEnabledLayerNames = validationLayers.data(); } else { createInfo.enabledLayerCount = 0; } C++ \u5c31\u8fd9\u6837\uff0c\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 vkCreateDevice \u51fd\u6570\u6765\u521b\u5efa\u5b9e\u4f8b\u5316\u903b\u8f91\u8bbe\u5907\u3002 if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) { throw std::runtime_error(\"failed to create logical device!\"); } C++ \u8fd9\u4e9b\u53c2\u6570\u5206\u522b\u662f\u5305\u542b\u5177\u4f53\u961f\u5217\u4f7f\u7528\u4fe1\u606f\u7684\u7269\u7406\u8bbe\u5907\uff0c\u53ef\u9009\u7684\u5206\u914d\u5668\u56de\u8c03\u6307\u9488\u4ee5\u53ca\u7528\u4e8e\u5b58\u50a8\u903b\u8f91\u8bbe\u5907\u7684\u53e5\u67c4\u3002\u4e0e instance \u521b\u5efa\u7c7b\u4f3c\uff0c\u6b64\u8c03\u7528\u53ef\u80fd\u7531\u4e8e\u542f\u7528\u4e0d\u5b58\u5728\u7684\u6269\u5c55\u6216\u8005\u6307\u5b9a\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5bfc\u81f4\u8fd4\u56de\u9519\u8bef\u3002 \u5728 cleanup \u51fd\u6570\u4e2d\u903b\u8f91\u8bbe\u5907\u9700\u8981\u8c03\u7528 vkDestroyDevice \u9500\u6bc1: void cleanup() { vkDestroyDevice(device, nullptr); ... } C++ \u903b\u8f91\u8bbe\u5907\u4e0d\u4e0e instance \u4ea4\u4e92\uff0c\u6240\u4ee5\u53c2\u6570\u4e2d\u4e0d\u5305\u542b instance \u3002 \u68c0\u7d22\u961f\u5217\u5904\u7406 \u8fd9\u4e9b\u961f\u5217\u4e0e\u903b\u8f91\u8bbe\u5907\u81ea\u52a8\u7684\u4e00\u540c\u521b\u5efa\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u4e00\u4e2a\u4e0e\u5b83\u4eec\u8fdb\u884c\u4ea4\u4e92\u7684\u53e5\u67c4\u3002\u5728\u8fd9\u91cc\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u7c7b\u6210\u5458\u6765\u5b58\u50a8\u56fe\u5f62\u961f\u5217\u53e5\u67c4: VkQueue graphicsQueue; C++ \u8bbe\u5907\u961f\u5217\u5728\u8bbe\u5907\u88ab\u9500\u6bc1\u7684\u65f6\u5019\u9690\u5f0f\u6e05\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u5728 cleanup \u51fd\u6570\u4e2d\u505a\u4efb\u4f55\u64cd\u4f5c\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 vkGetDeviceQueue \u51fd\u6570\u6765\u68c0\u6d4b\u6bcf\u4e2a\u961f\u5217\u7c07\u4e2d\u961f\u5217\u7684\u53e5\u67c4\u3002\u53c2\u6570\u662f\u903b\u8f91\u8bbe\u5907\uff0c\u961f\u5217\u7c07\uff0c\u961f\u5217\u7d22\u5f15\u548c\u5b58\u50a8\u83b7\u53d6\u961f\u5217\u53d8\u91cf\u53e5\u67c4\u7684\u6307\u9488\u3002\u56e0\u4e3a\u6211\u4eec\u53ea\u662f\u4ece\u8fd9\u4e2a\u961f\u5217\u7c07\u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u6240\u4ee5\u9700\u8981\u4f7f\u7528\u7d22\u5f15 0 \u3002 vkGetDeviceQueue(device, indices.graphicsFamily, 0, &graphicsQueue); C++ \u5728\u6210\u529f\u83b7\u53d6\u903b\u8f91\u8bbe\u5907\u548c\u961f\u5217\u53e5\u67c4\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u663e\u5361\u505a\u4e00\u4e9b\u5b9e\u9645\u7684\u4e8b\u60c5\u4e86\uff0c\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u4f1a\u8bbe\u7f6e\u8d44\u6e90\u5e76\u5c06\u76f8\u5e94\u7684\u7ed3\u679c\u63d0\u4ea4\u5230\u7a97\u4f53\u7cfb\u7edf\u3002 Vulkan \u4ea4\u6362\u94fe Vulkan \u4ea4\u6362\u94fe \uff0c\u5728\u8fd9\u4e00\u7ae0\u8282\uff0c\u6211\u4eec\u4e86\u89e3\u4e00\u4e0b\u5c06\u6e32\u67d3\u56fe\u50cf\u63d0\u4ea4\u5230\u5c4f\u5e55\u7684\u57fa\u672c\u673a\u5236\u3002\u8fd9\u79cd\u673a\u5236\u79f0\u4e3a\u4ea4\u6362\u94fe\uff0c\u5e76\u4e14\u9700\u8981\u5728 Vulkan \u4e0a\u4e0b\u6587\u4e2d\u88ab\u660e\u786e\u521b\u5efa\u3002\u4ece\u5c4f\u5e55\u7684\u89d2\u5ea6\u89c2\u5bdf\uff0c\u4ea4\u6362\u94fe\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u56fe\u50cf\u961f\u5217\u3002\u5e94\u7528\u7a0b\u5e8f\u4f5c\u4e3a\u751f\u4ea7\u8005\u4f1a\u83b7\u53d6\u56fe\u50cf\u8fdb\u884c\u7ed8\u5236\uff0c\u7136\u540e\u5c06\u5176\u8fd4\u8fd8\u7ed9\u4ea4\u6362\u94fe\u56fe\u50cf\u961f\u5217\uff0c\u7b49\u5f85\u5c4f\u5e55\u6d88\u8d39\u3002\u4ea4\u6362\u94fe\u7684\u5177\u4f53\u914d\u7f6e\u4fe1\u606f\u51b3\u5b9a\u4e86\u5e94\u7528\u7a0b\u5e8f\u63d0\u4ea4\u7ed8\u5236\u56fe\u50cf\u5230\u961f\u5217\u7684\u6761\u4ef6\u4ee5\u53ca\u56fe\u50cf\u961f\u5217\u8868\u73b0\u7684\u6548\u679c\uff0c\u4f46\u4ea4\u6362\u94fe\u7684\u901a\u5e38\u4f7f\u7528\u76ee\u7684\u662f\u4f7f\u7ed8\u5236\u56fe\u50cf\u7684\u6700\u7ec8\u5448\u73b0\u4e0e\u5c4f\u5e55\u7684\u5237\u65b0\u9891\u7387\u540c\u6b65\u3002\u53ef\u4ee5\u7b80\u5355\u5c06\u4ea4\u6362\u94fe\u7406\u89e3\u4e3a\u4e00\u4e2a\u961f\u5217\uff0c\u540c\u6b65\u4ece\u751f\u4ea7\u8005\uff0c\u5373\u5e94\u7528\u7a0b\u5e8f\u7ed8\u5236\u56fe\u50cf\uff0c\u5230\u6d88\u8d39\u8005\uff0c\u5c4f\u5e55\u5237\u65b0\u7684 Produce-Consume \u5173\u7cfb\u3002\u5728\u6df1\u5165\u5185\u5bb9\u524d\u770b\u4e00\u4e0b\u5b98\u65b9\u7ed9\u51fa\u7684\u6574\u4f53\u4ea4\u6362\u94fe\u793a\u4f8b\u56fe\u3002 \u5f53\u7136\u56fe\u793a\u4e0a\u6709\u4e00\u4e9b\u964c\u751f\u7684\u5173\u952e\u5b57\u4f1a\u5728\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\u4e2d\u9010\u4e00\u4ecb\u7ecd\uff0c\u5728\u6b64\u6709\u4e00\u4e2a\u6574\u4f53\u6982\u5ff5\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u68c0\u67e5\u4ea4\u6362\u94fe\u652f\u6301 2 \u67e5\u8be2\u4ea4\u6362\u94fe\u652f\u6301\u7684\u8be6\u60c5 3 \u4e3a\u4ea4\u6362\u94fe\u9009\u62e9\u6b63\u786e\u7684\u8bbe\u7f6e 4 Surface \u683c\u5f0f 5 \u6f14\u793a\u6a21\u5f0f 6 \u4ea4\u6362\u8303\u56f4 7 \u521b\u5efa\u4ea4\u6362\u94fe 8 \u83b7\u53d6\u4ea4\u6362\u94fe\u56fe\u50cf \u68c0\u67e5\u4ea4\u6362\u94fe\u652f\u6301 \u5e76\u4e0d\u662f\u6240\u6709\u7684\u56fe\u5f62\u5361\u5177\u5907\u80fd\u529b\u5c06\u7ed8\u5236\u7684\u56fe\u50cf\u76f4\u63a5\u663e\u793a\u5230\u5c4f\u5e55\u4e0a\u3002\u6bd4\u5982\u4e00\u4e2aGPU\u5361\u662f\u4e3a\u670d\u52a1\u5668\u8bbe\u8ba1\u7684\uff0c\u90a3\u5c31\u4e0d\u4f1a\u5177\u5907\u4efb\u4f55\u6709\u5173\u663e\u793a\u7684\u8f93\u51fa\u3002\u5176\u6b21\uff0c\u56fe\u50cf\u5448\u73b0\u662f\u4e0e surface \u6253\u4ea4\u9053\uff0c\u800c surface \u53c8\u4e0e\u5177\u4f53\u7684\u7a97\u4f53\u7cfb\u7edf\u5f3a\u5173\u8054\uff0c\u4ece\u8fd9\u4e2a\u89d2\u5ea6\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u5b83\u4e0d\u662f Vulkan \u6838\u5fc3\u7684\u90e8\u5206\u3002\u5728\u67e5\u8be2\u56fe\u5f62\u5361\u662f\u5426\u652f\u6301\u540e\uff0c\u9700\u8981\u542f\u7528 VK_KHR_swapchain \u8bbe\u5907\u7ea7\u522b\u7684\u6269\u5c55\u3002 \u6240\u4ee5\u5462\uff0c\u6211\u4eec\u9996\u5148\u6269\u5c55\u4e4b\u524d\u7684 isDeviceSuitable \u51fd\u6570\uff0c\u786e\u8ba4\u8bbe\u5907\u662f\u5426\u652f\u6301\u3002\u4e4b\u524d\u6211\u4eec\u5df2\u7ecf\u4e86\u89e3\u5982\u4f55\u5217\u51fa VkPhysicalDevice \u652f\u6301\u7684\u6269\u5c55\u5217\u8868\uff0c\u5728\u6b64\u5c31\u4e0d\u5c55\u5f00\u5177\u4f53\u7ec6\u8282\u4e86\u3002\u8bf7\u6ce8\u610f\u7684\u662f\uff0cVulkan\u5934\u6587\u4ef6\u63d0\u4f9b\u7ed9\u4e86\u4e00\u4e2a\u65b9\u4fbf\u7684\u5b8f VK_KHR_SWAPCHAIN_EXTENSION_NAME \uff0c\u8be5\u5b8f\u5b9a\u4e49\u4e3a VK_KHR_swapchain \u3002\u4f7f\u7528\u5b8f\u7684\u4f18\u70b9\u5c31\u662f\u907f\u514d\u62fc\u5199\u9519\u8bef\u3002 \u9996\u5148\u58f0\u660e\u9700\u8981\u7684\u8bbe\u5907\u6269\u5c55\u6e05\u5355\uff0c\u4e0e\u4e4b\u524d\u5f00\u542f validation layers \u7684\u5217\u8868\u662f\u76f8\u4f3c\u7684\u3002 const std::vector<const char*> deviceExtensions = { VK_KHR_SWAPCHAIN_EXTENSION_NAME }; C++ \u63a5\u4e0b\u6765\uff0c\u521b\u5efa\u4e00\u4e2a\u4ece isDeviceSuitable \u8c03\u7528\u7684\u65b0\u51fd\u6570 checkDeviceExtensionSupport \u4f5c\u4e3a\u989d\u5916\u7684\u68c0\u67e5\u903b\u8f91: bool isDeviceSuitable(VkPhysicalDevice device) { QueueFamilyIndices indices = findQueueFamilies(device); bool extensionsSupported = checkDeviceExtensionSupport(device); return indices.isComplete() && extensionsSupported; } bool checkDeviceExtensionSupport(VkPhysicalDevice device) { return true; } C++ \u4fee\u6539\u51fd\u6570\u4f53\u4ee5\u4fbf\u4e8e\u679a\u4e3e\u8bbe\u5907\u6240\u6709\u96c6\u5408\uff0c\u5e76\u68c0\u6d4b\u662f\u5426\u6240\u6709\u9700\u8981\u7684\u6269\u5c55\u5728\u5176\u4e2d\u3002 bool checkDeviceExtensionSupport(VkPhysicalDevice device) { uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availableExtensions.data()); std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end()); for (const auto& extension : availableExtensions) { requiredExtensions.erase(extension.extensionName); } return requiredExtensions.empty(); } C++ \u9009\u62e9\u4e00\u7ec4\u5b57\u7b26\u4e32\u6765\u8868\u793a\u672a\u7ecf\u786e\u8ba4\u8fc7\u7684\u6269\u5c55\u540d\u3002\u8fd9\u6837\u505a\u53ef\u4ee5\u6bd4\u8f83\u5bb9\u6613\u7684\u8fdb\u884c\u589e\u5220\u53ca\u904d\u5386\u7684\u6b21\u5e8f\u3002\u5f53\u7136\u4e5f\u53ef\u4ee5\u50cf CheckValidationLayerSupport \u51fd\u6570\u90a3\u6837\u505a\u5d4c\u5957\u7684\u5faa\u73af\u3002\u6027\u80fd\u7684\u5dee\u5f02\u5728\u8fd9\u91cc\u662f\u4e0d\u5173\u7d27\u8981\u7684\u3002\u73b0\u5728\u8fd0\u884c\u4ee3\u7801\u9a8c\u8bc1\u56fe\u5f62\u5361\u662f\u5426\u80fd\u591f\u987a\u5229\u521b\u5efa\u4e00\u4e2a\u4ea4\u6362\u94fe\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u524d\u4e00\u4e2a\u7ae0\u8282\u4e2d\u9a8c\u8bc1\u8fc7\u7684 presentation \u961f\u5217\u6709\u6548\u6027\uff0c\u5e76\u6ca1\u6709\u660e\u786e\u6307\u51fa\u4ea4\u6362\u94fe\u6269\u5c55\u4e5f\u5fc5\u987b\u6709\u6548\u652f\u6301\u3002\u597d\u5728\u6269\u5c55\u5fc5\u987b\u660e\u786e\u7684\u5f00\u542f\u3002 \u542f\u7528\u6269\u5c55\u9700\u8981\u5bf9\u903b\u8f91\u8bbe\u5907\u7684\u521b\u5efa\u7ed3\u6784\u4f53\u505a\u4e00\u4e9b\u5c0f\u7684\u6539\u52a8: createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size()); createInfo.ppEnabledExtensionNames = deviceExtensions.data(); C++ \u67e5\u8be2\u4ea4\u6362\u94fe\u652f\u6301\u7684\u8be6\u60c5 \u5982\u679c\u4ec5\u4ec5\u662f\u4e3a\u4e86\u6d4b\u8bd5\u4ea4\u6362\u94fe\u7684\u6709\u6548\u6027\u662f\u8fdc\u8fdc\u4e0d\u591f\u7684\uff0c\u56e0\u4e3a\u5b83\u8fd8\u4e0d\u80fd\u5f88\u597d\u7684\u4e0e\u7a97\u4f53 surface \u517c\u5bb9\u3002\u521b\u5efa\u4ea4\u6362\u94fe\u540c\u6837\u4e5f\u9700\u8981\u5f88\u591a\u8bbe\u7f6e\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4e86\u89e3\u4e00\u4e9b\u6709\u5173\u8bbe\u7f6e\u7684\u7ec6\u8282\u3002 \u57fa\u672c\u4e0a\u6709\u4e09\u5927\u7c7b\u5c5e\u6027\u9700\u8981\u8bbe\u7f6e: \u57fa\u672c\u7684surface\u529f\u80fd\u5c5e\u6027(min/max number of images in swap chain, min/max width and height of images) Surface\u683c\u5f0f(pixel format, color space) \u6709\u6548\u7684presentation\u6a21\u5f0f \u4e0e findQueueFamilies \u7c7b\u4f3c\uff0c\u6211\u4eec\u4f7f\u7528\u7ed3\u6784\u4f53\u4e00\u6b21\u6027\u7684\u4f20\u9012\u8be6\u7ec6\u7684\u4fe1\u606f\u3002\u4e09\u7c7b\u5c5e\u6027\u5c01\u88c5\u5728\u5982\u4e0b\u7ed3\u6784\u4f53\u4e2d\uff1a struct SwapChainSupportDetails { VkSurfaceCapabilitiesKHR capabilities; std::vector<VkSurfaceFormatKHR> formats; std::vector<VkPresentModeKHR> presentModes; }; C++ \u73b0\u5728\u521b\u5efa\u65b0\u7684\u51fd\u6570 querySwapChainSupport \u586b\u5145\u8be5\u7ed3\u6784\u4f53\u3002 SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) { SwapChainSupportDetails details; return details; } C++ \u672c\u5c0f\u8282\u6d89\u53ca\u5982\u4f55\u67e5\u8be2\u5305\u542b\u6b64\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\uff0c\u8fd9\u4e9b\u7ed3\u6784\u4f53\u7684\u542b\u4e49\u53ca\u5305\u542b\u7684\u6570\u636e\u5c06\u5728\u4e0b\u4e00\u8282\u8ba8\u8bba\u3002 \u6211\u4eec\u73b0\u5728\u5f00\u59cb\u57fa\u672c\u7684 surface \u529f\u80fd\u8bbe\u7f6e\u90e8\u5206\u3002\u8fd9\u4e9b\u5c5e\u6027\u53ef\u4ee5\u901a\u8fc7\u7b80\u5355\u7684\u51fd\u6570\u8c03\u7528\u67e5\u8be2\uff0c\u5e76\u8fd4\u56de\u5230\u5355\u4e2a VkSurfaceCapabilitiesKHR \u7ed3\u6784\u4f53\u4e2d\u3002 vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &details.capabilities); C++ \u8fd9\u4e2a\u51fd\u6570\u9700\u8981 VkPhysicalDevice \u548c VkSurfaceKHR \u7a97\u4f53 surface \u51b3\u5b9a\u652f\u6301\u54ea\u4e9b\u5177\u4f53\u529f\u80fd\u3002\u6240\u6709\u7528\u4e8e\u67e5\u770b\u652f\u6301\u529f\u80fd\u7684\u51fd\u6570\u90fd\u9700\u8981\u8fd9\u4e24\u4e2a\u53c2\u6570\uff0c\u56e0\u4e3a\u5b83\u4eec\u662f\u4ea4\u6362\u94fe\u7684\u6838\u5fc3\u7ec4\u4ef6\u3002 \u4e0b\u4e00\u6b65\u67e5\u8be2\u652f\u6301\u7684 surface \u683c\u5f0f\u3002\u56e0\u4e3a\u83b7\u53d6\u5230\u7684\u662f\u4e00\u4e2a\u7ed3\u6784\u4f53\u5217\u8868\uff0c\u5177\u4f53\u5e94\u7528\u5f62\u5f0f\u5982\u4e0b: uint32_t formatCount; vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, nullptr); if (formatCount != 0) { details.formats.resize(formatCount); vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, details.formats.data()); } C++ \u786e\u4fdd\u96c6\u5408\u5bf9\u4e8e\u6240\u6709\u6709\u6548\u7684\u683c\u5f0f\u53ef\u6269\u5145\u3002\u6700\u540e\u67e5\u8be2\u652f\u6301\u7684 presentation \u6a21\u5f0f\uff0c\u540c\u6837\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528 vkGetPhysicalDeviceSurfacePresentModesKHR : uint32_t presentModeCount; vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, nullptr); if (presentModeCount != 0) { details.presentModes.resize(presentModeCount); vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, details.presentModes.data()); } C++ \u73b0\u5728\u7ed3\u6784\u4f53\u7684\u76f8\u5173\u7ec6\u8282\u4ecb\u7ecd\u5b8c\u6bd5\uff0c\u8ba9\u6211\u4eec\u6269\u5145 isDeviceSuitable \u51fd\u6570\uff0c\u4ece\u800c\u5229\u7528\u8be5\u51fd\u6570\u9a8c\u8bc1\u4ea4\u6362\u94fe\u8db3\u591f\u7684\u652f\u6301\u3002\u5728\u672c\u7ae0\u8282\u4e2d\u4ea4\u6362\u94fe\u7684\u652f\u6301\u662f\u8db3\u591f\u7684\uff0c\u56e0\u4e3a\u5bf9\u4e8e\u7ed9\u5b9a\u7684\u7a97\u4f53 surface \uff0c\u5b83\u81f3\u5c11\u652f\u6301\u4e00\u4e2a\u56fe\u50cf\u683c\u5f0f\uff0c\u4e00\u4e2a presentaion \u6a21\u5f0f\u3002 bool swapChainAdequate = false; if (extensionsSupported) { SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device); swapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty(); } C++ \u6bd4\u8f83\u91cd\u8981\u7684\u662f\u5c1d\u8bd5\u67e5\u8be2\u4ea4\u6362\u94fe\u7684\u652f\u6301\u662f\u5728\u9a8c\u8bc1\u5b8c\u6269\u5c55\u6709\u6548\u6027\u4e4b\u540e\u8fdb\u884c\u3002\u51fd\u6570\u7684\u6700\u540e\u4e00\u884c\u4ee3\u7801\u4fee\u6539\u4e3a: return indices.isComplete() && extensionsSupported && swapChainAdequate; C++ \u4e3a\u4ea4\u6362\u94fe\u9009\u62e9\u6b63\u786e\u7684\u8bbe\u7f6e \u5982\u679c swapChainAdequate \u6761\u4ef6\u8db3\u591f\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u652f\u6301\u7684\u8db3\u591f\u7684\uff0c\u4f46\u662f\u6839\u636e\u4e0d\u540c\u7684\u6a21\u5f0f\u4ecd\u7136\u6709\u4e0d\u540c\u7684\u6700\u4f73\u9009\u62e9\u3002\u6211\u4eec\u7f16\u5199\u4e00\u7ec4\u51fd\u6570\uff0c\u901a\u8fc7\u8fdb\u4e00\u6b65\u7684\u8bbe\u7f6e\u67e5\u627e\u6700\u5339\u914d\u7684\u4ea4\u6362\u94fe\u3002\u8fd9\u91cc\u6709\u4e09\u79cd\u7c7b\u578b\u7684\u8bbe\u7f6e\u53bb\u786e\u5b9a: Surface\u683c\u5f0f (color depth) Presentation mode (conditions for \u201cswapping\u201d image to the screen) Swap extent (resolution of images in swap chain) \u9996\u5148\u5728\u8111\u6d77\u4e2d\u5bf9\u6bcf\u4e00\u4e2a\u8bbe\u7f6e\u90fd\u6709\u4e00\u4e2a\u7406\u60f3\u7684\u6570\u503c\uff0c\u5982\u679c\u8fbe\u6210\u4e00\u81f4\u6211\u4eec\u5c31\u4f7f\u7528\uff0c\u5426\u5219\u6211\u4eec\u4e00\u8d77\u521b\u5efa\u4e00\u4e9b\u903b\u8f91\u53bb\u627e\u5230\u66f4\u597d\u7684\u89c4\u5219\u3001\u6570\u503c\u3002 Surface \u683c\u5f0f \u8fd9\u4e2a\u51fd\u6570\u7528\u6765\u8bbe\u7f6esurface\u683c\u5f0f\u3002\u6211\u4eec\u4f20\u9012 formats \u4f5c\u4e3a\u51fd\u6570\u7684\u53c2\u6570\uff0c\u7c7b\u578b\u4e3a SwapChainSupportDetails \u3002 VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) { } C++ \u6bcf\u4e2a VkSurfaceFormatKHR \u7ed3\u6784\u90fd\u5305\u542b\u4e00\u4e2a format \u548c\u4e00\u4e2a colorSpace \u6210\u5458\u3002 format \u6210\u5458\u53d8\u91cf\u6307\u5b9a\u8272\u5f69\u901a\u9053\u548c\u7c7b\u578b\u3002\u6bd4\u5982\uff0c VK_FORMAT_B8G8R8A8_UNORM \u4ee3\u8868\u4e86\u6211\u4eec\u4f7f\u7528B,G,R\u548calpha\u6b21\u5e8f\u7684\u901a\u9053\uff0c\u4e14\u6bcf\u4e00\u4e2a\u901a\u9053\u4e3a\u65e0\u7b26\u53f78bit\u6574\u6570\uff0c\u6bcf\u4e2a\u50cf\u7d20\u603b\u8ba132bits\u3002 colorSpace \u6210\u5458\u63cf\u8ff0 SRGB \u989c\u8272\u7a7a\u95f4\u662f\u5426\u901a\u8fc7 VK_COLOR_SPACE_SRGB_NONLINEAR_KHR \u6807\u5fd7\u652f\u6301\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u5728\u8f83\u65e9\u7248\u672c\u7684\u89c4\u8303\u4e2d\uff0c\u8fd9\u4e2a\u6807\u5fd7\u540d\u4e3a VK_COLORSPACE_SRGB_NONLINEAR_KHR \u3002 \u5982\u679c\u53ef\u4ee5\u6211\u4eec\u5c3d\u53ef\u80fd\u4f7f\u7528SRGB(\u5f69\u8272\u8bed\u8a00\u534f\u8bae)\uff0c \u56e0\u4e3a\u5b83\u4f1a\u5f97\u5230\u66f4\u5bb9\u6613\u611f\u77e5\u7684\u3001\u7cbe\u786e\u7684\u8272\u5f69 \u3002\u76f4\u63a5\u4e0e SRGB \u989c\u8272\u6253\u4ea4\u9053\u662f\u6bd4\u8f83\u6709\u6311\u6218\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u4f7f\u7528\u6807\u51c6\u7684RGB\u4f5c\u4e3a\u989c\u8272\u683c\u5f0f\uff0c\u8fd9\u4e5f\u662f\u901a\u5e38\u4f7f\u7528\u7684\u4e00\u4e2a\u683c\u5f0f VK_FORMAT_B8G8R8A8_UNORM \u3002 \u6700\u7406\u60f3\u7684\u60c5\u51b5\u662fsurface\u6ca1\u6709\u8bbe\u7f6e\u4efb\u4f55\u504f\u5411\u6027\u7684\u683c\u5f0f\uff0c\u8fd9\u4e2a\u65f6\u5019Vulkan\u4f1a\u901a\u8fc7\u4ec5\u8fd4\u56de\u4e00\u4e2a VkSurfaceFormatKHR \u7ed3\u6784\u8868\u793a\uff0c\u4e14\u8be5\u7ed3\u6784\u7684 format \u6210\u5458\u8bbe\u7f6e\u4e3a VK_FORMAT_UNDEFINED \u3002 if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) { return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; } C++ \u5982\u679c\u4e0d\u80fd\u81ea\u7531\u7684\u8bbe\u7f6e\u683c\u5f0f\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u904d\u5386\u5217\u8868\u8bbe\u7f6e\u5177\u6709\u504f\u5411\u6027\u7684\u7ec4\u5408: for (const auto& availableFormat : availableFormats) { if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { return availableFormat; } } C++ \u5982\u679c\u4ee5\u4e0a\u4e24\u79cd\u65b9\u5f0f\u90fd\u5931\u6548\u4e86\uff0c\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u201c\u4f18\u826f\u201d\u8fdb\u884c\u6253\u5206\u6392\u5e8f\uff0c\u4f46\u662f\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4f1a\u9009\u62e9\u7b2c\u4e00\u4e2a\u683c\u5f0f\u4f5c\u4e3a\u7406\u60f3\u7684\u9009\u62e9\u3002 VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) { if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) { return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; } for (const auto& availableFormat : availableFormats) { if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { return availableFormat; } } return availableFormats[0]; } C++ \u6f14\u793a\u6a21\u5f0f presentation \u6a21\u5f0f\u5bf9\u4e8e\u4ea4\u6362\u94fe\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u56e0\u4e3a\u5b83\u4ee3\u8868\u4e86\u5728\u5c4f\u5e55\u5448\u73b0\u56fe\u50cf\u7684\u6761\u4ef6\u3002\u5728 Vulkan \u4e2d\u6709\u56db\u4e2a\u6a21\u5f0f\u53ef\u4ee5\u4f7f\u7528: VK_PRESENT_MODE_IMMEDIATE_KHR : \u5e94\u7528\u7a0b\u5e8f\u63d0\u4ea4\u7684\u56fe\u50cf\u88ab\u7acb\u5373\u4f20\u8f93\u5230\u5c4f\u5e55\u5448\u73b0\uff0c\u8fd9\u79cd\u6a21\u5f0f\u53ef\u80fd\u4f1a\u9020\u6210\u6495\u88c2\u6548\u679c\u3002 VK_PRESENT_MODE_FIFO_KHR : \u4ea4\u6362\u94fe\u88ab\u770b\u4f5c\u4e00\u4e2a\u961f\u5217\uff0c\u5f53\u663e\u793a\u5185\u5bb9\u9700\u8981\u5237\u65b0\u7684\u65f6\u5019\uff0c\u663e\u793a\u8bbe\u5907\u4ece\u961f\u5217\u7684\u524d\u9762\u83b7\u53d6\u56fe\u50cf\uff0c\u5e76\u4e14\u7a0b\u5e8f\u5c06\u6e32\u67d3\u5b8c\u6210\u7684\u56fe\u50cf\u63d2\u5165\u961f\u5217\u7684\u540e\u9762\u3002\u5982\u679c\u961f\u5217\u662f\u6ee1\u7684\u7a0b\u5e8f\u4f1a\u7b49\u5f85\u3002\u8fd9\u79cd\u89c4\u6a21\u4e0e\u89c6\u9891\u6e38\u620f\u7684\u5782\u76f4\u540c\u6b65\u5f88\u7c7b\u4f3c\u3002\u663e\u793a\u8bbe\u5907\u7684\u5237\u65b0\u65f6\u523b\u88ab\u6210\u4e3a\u201c\u5782\u76f4\u4e2d\u65ad\u201d\u3002 VK_PRESENT_MODE_FIFO_RELAXED_KHR : \u8be5\u6a21\u5f0f\u4e0e\u4e0a\u4e00\u4e2a\u6a21\u5f0f\u7565\u6709\u4e0d\u540c\u7684\u5730\u65b9\u4e3a\uff0c\u5982\u679c\u5e94\u7528\u7a0b\u5e8f\u5b58\u5728\u5ef6\u8fdf\uff0c\u5373\u63a5\u53d7\u6700\u540e\u4e00\u4e2a\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\u65f6\u961f\u5217\u7a7a\u4e86\uff0c\u5c06\u4e0d\u4f1a\u7b49\u5f85\u4e0b\u4e00\u4e2a\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\uff0c\u800c\u662f\u5c06\u56fe\u50cf\u76f4\u63a5\u4f20\u9001\u3002\u8fd9\u6837\u505a\u53ef\u80fd\u5bfc\u81f4\u53ef\u89c1\u7684\u6495\u88c2\u6548\u679c\u3002 VK_PRESENT_MODE_MAILBOX_KHR : \u8fd9\u662f\u7b2c\u4e8c\u79cd\u6a21\u5f0f\u7684\u53d8\u79cd\u3002\u5f53\u4ea4\u6362\u94fe\u961f\u5217\u6ee1\u7684\u65f6\u5019\uff0c\u9009\u62e9\u65b0\u7684\u66ff\u6362\u65e7\u7684\u56fe\u50cf\uff0c\u4ece\u800c\u66ff\u4ee3\u963b\u585e\u5e94\u7528\u7a0b\u5e8f\u7684\u60c5\u5f62\u3002\u8fd9\u79cd\u6a21\u5f0f\u901a\u5e38\u7528\u6765\u5b9e\u73b0\u4e09\u91cd\u7f13\u51b2\u533a\uff0c\u4e0e\u6807\u51c6\u7684\u5782\u76f4\u540c\u6b65\u53cc\u7f13\u51b2\u76f8\u6bd4\uff0c\u5b83\u53ef\u4ee5\u6709\u6548\u907f\u514d\u5ef6\u8fdf\u5e26\u6765\u7684\u6495\u88c2\u6548\u679c\u3002 \u903b\u8f91\u4e0a\u770b\u4ec5\u4ec5 VR_PRESENT_MODE_FIFO_KHR \u6a21\u5f0f\u4fdd\u8bc1\u53ef\u7528\u6027\uff0c\u6240\u4ee5\u6211\u4eec\u518d\u6b21\u589e\u52a0\u4e00\u4e2a\u51fd\u6570\u67e5\u627e\u6700\u4f73\u7684\u6a21\u5f0f: VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { return VK_PRESENT_MODE_FIFO_KHR; } C++ \u6211\u4e2a\u4eba\u8ba4\u4e3a\u4e09\u7ea7\u7f13\u51b2\u662f\u4e00\u4e2a\u975e\u5e38\u597d\u7684\u7b56\u7565\u3002\u5b83\u5141\u8bb8\u6211\u4eec\u907f\u514d\u6495\u88c2\uff0c\u540c\u65f6\u4ecd\u7136\u4fdd\u6301\u76f8\u5bf9\u4f4e\u7684\u5ef6\u8fdf\uff0c\u901a\u8fc7\u6e32\u67d3\u5c3d\u53ef\u80fd\u65b0\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u63a5\u53d7\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\u3002\u6240\u4ee5\u6211\u4eec\u770b\u4e00\u4e0b\u5217\u8868\uff0c\u5b83\u662f\u5426\u53ef\u7528: VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { for (const auto& availablePresentMode : availablePresentModes) { if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { return availablePresentMode; } } return VK_PRESENT_MODE_FIFO_KHR; } C++ \u9057\u61be\u7684\u662f\uff0c\u4e00\u4e9b\u9a71\u52a8\u7a0b\u5e8f\u76ee\u524d\u5e76\u4e0d\u652f\u6301 VK_PRESENT_MODE_FIFO_KHR ,\u9664\u6b64\u4e4b\u5916\u5982\u679c VK_PRESENT_MODE_MAILBOX_KHR \u4e5f\u4e0d\u53ef\u7528\uff0c\u6211\u4eec\u66f4\u503e\u5411\u4f7f\u7528 VK_PRESENT_MODE_IMMEDIATE_KHR : VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { VkPresentModeKHR bestMode = VK_PRESENT_MODE_FIFO_KHR; for (const auto& availablePresentMode : availablePresentModes) { if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { return availablePresentMode; } else if (availablePresentMode == VK_PRESENT_MODE_IMMEDIATE_KHR) { bestMode = availablePresentMode; } } return bestMode; } C++ \u4ea4\u6362\u8303\u56f4 \u8fd8\u5269\u4e0b\u4e00\u4e2a\u5c5e\u6027\uff0c\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u51fd\u6570: VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) { } C++ \u4ea4\u6362\u8303\u56f4\u662f\u6307\u4ea4\u6362\u94fe\u56fe\u50cf\u7684\u5206\u8fa8\u7387\uff0c\u5b83\u51e0\u4e4e\u603b\u662f\u7b49\u4e8e\u6211\u4eec\u7ed8\u5236\u7a97\u4f53\u7684\u5206\u8fa8\u7387\u3002\u5206\u8fa8\u7387\u7684\u8303\u56f4\u88ab\u5b9a\u4e49\u5728 VkSurfaceCapabilitiesKHR \u7ed3\u6784\u4f53\u4e2d\u3002 Vulkan \u544a\u8bc9\u6211\u4eec\u901a\u8fc7\u8bbe\u7f6e currentExtent \u6210\u5458\u7684 width \u548c height \u6765\u5339\u914d\u7a97\u4f53\u7684\u5206\u8fa8\u7387\u3002\u7136\u800c\uff0c\u4e00\u4e9b\u7a97\u4f53\u7ba1\u7406\u5668\u5141\u8bb8\u4e0d\u540c\u7684\u8bbe\u7f6e\uff0c\u610f\u5473\u7740\u5c06 currentExtent \u7684width\u548cheight\u8bbe\u7f6e\u4e3a\u7279\u6b8a\u7684\u6570\u503c\u8868\u793a: uint32_t \u7684\u6700\u5927\u503c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53c2\u8003\u7a97\u4f53 minImageExtent \u548c maxImageExtent \u9009\u62e9\u6700\u5339\u914d\u7684\u5206\u8fa8\u7387\u3002 VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) { if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) { return capabilities.currentExtent; } else { VkExtent2D actualExtent = {WIDTH, HEIGHT}; actualExtent.width = std::max(capabilities.minImageExtent.width, std::min(capabilities.maxImageExtent.width, actualExtent.width)); actualExtent.height = std::max(capabilities.minImageExtent.height, std::min(capabilities.maxImageExtent.height, actualExtent.height)); return actualExtent; } } C++ max \u548c min \u51fd\u6570\u7528\u4e8e\u5c06 WIDTH \u548c HEIGHT \u6536\u655b\u5728\u5b9e\u9645\u652f\u6301\u7684 minimum \u548c maximum \u8303\u56f4\u4e2d\u3002\u5728\u8fd9\u91cc\u786e\u8ba4\u5305\u542b <algorithm> \u5934\u6587\u4ef6\u3002 \u521b\u5efa\u4ea4\u6362\u94fe \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6709\u4e86\u8fd9\u4e9b\u8f85\u52a9\u51fd\u6570\uff0c\u7528\u4ee5\u5728\u8fd0\u884c\u65f6\u5e2e\u52a9\u6211\u4eec\u505a\u51fa\u660e\u667a\u7684\u9009\u62e9\uff0c\u6700\u7ec8\u83b7\u5f97\u6709\u4e86\u521b\u5efa\u4ea4\u6362\u94fe\u6240\u9700\u8981\u7684\u6240\u6709\u4fe1\u606f\u3002 \u521b\u5efa\u4e00\u4e2a\u51fd\u6570 createSwapChain \uff0c\u5728 initVulkan \u51fd\u6570\u4e2d\uff0c\u8be5\u51fd\u6570\u4f1a\u5728\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u4e4b\u540e\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); } void createSwapChain() { SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice); VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats); VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes); VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities); } C++ \u5b9e\u9645\u4e0a\u8fd8\u6709\u4e00\u4e9b\u5c0f\u4e8b\u60c5\u9700\u8981\u786e\u5b9a\uff0c\u4f46\u662f\u6bd4\u8f83\u7b80\u5355\uff0c\u6240\u4ee5\u6ca1\u6709\u5355\u72ec\u521b\u5efa\u51fd\u6570\u3002\u7b2c\u4e00\u4e2a\u662f\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u53ef\u4ee5\u7406\u89e3\u4e3a\u961f\u5217\u7684\u957f\u5ea6\u3002\u5b83\u6307\u5b9a\u8fd0\u884c\u65f6\u56fe\u50cf\u7684\u6700\u5c0f\u6570\u91cf\uff0c\u6211\u4eec\u5c06\u5c1d\u8bd5\u5927\u4e8e1\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u4ee5\u5b9e\u73b0\u4e09\u91cd\u7f13\u51b2\u3002 uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1; if (swapChainSupport.capabilities.maxImageCount > 0 && imageCount > swapChainSupport.capabilities.maxImageCount) { imageCount = swapChainSupport.capabilities.maxImageCount; } C++ \u5bf9\u4e8e maxImageCount \u6570\u503c\u4e3a 0 \u4ee3\u8868\u9664\u4e86\u5185\u5b58\u4e4b\u5916\u6ca1\u6709\u9650\u5236\uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u9700\u8981\u68c0\u67e5\u3002 \u4e0eVulkan\u5176\u4ed6\u5bf9\u8c61\u7684\u521b\u5efa\u8fc7\u7a0b\u4e00\u6837\uff0c\u521b\u5efa\u4ea4\u6362\u94fe\u4e5f\u9700\u8981\u586b\u5145\u5927\u91cf\u7684\u7ed3\u6784\u4f53: VkSwapchainCreateInfoKHR createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; createInfo.surface = surface; C++ \u5728\u6307\u5b9a\u4ea4\u6362\u94fe\u7ed1\u5b9a\u5230\u5177\u4f53\u7684 surface \u4e4b\u540e\uff0c\u9700\u8981\u6307\u5b9a\u4ea4\u6362\u94fe\u56fe\u50cf\u6709\u5173\u7684\u8be6\u7ec6\u4fe1\u606f: createInfo.minImageCount = imageCount; createInfo.imageFormat = surfaceFormat.format; createInfo.imageColorSpace = surfaceFormat.colorSpace; createInfo.imageExtent = extent; createInfo.imageArrayLayers = 1; createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; C++ imageArrayLayers \u6307\u5b9a\u6bcf\u4e2a\u56fe\u50cf\u7ec4\u6210\u7684\u5c42\u6570\u3002\u9664\u975e\u6211\u4eec\u5f00\u53d13D\u5e94\u7528\u7a0b\u5e8f\uff0c\u5426\u5219\u59cb\u7ec8\u4e3a1\u3002 imageUsage \u4f4d\u5b57\u6bb5\u6307\u5b9a\u5728\u4ea4\u6362\u94fe\u4e2d\u5bf9\u56fe\u50cf\u8fdb\u884c\u7684\u5177\u4f53\u64cd\u4f5c\u3002\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u76f4\u63a5\u5bf9\u5b83\u4eec\u8fdb\u884c\u6e32\u67d3\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u4eec\u4f5c\u4e3a\u989c\u8272\u9644\u4ef6\u3002\u4e5f\u53ef\u4ee5\u9996\u5148\u5c06\u56fe\u50cf\u6e32\u67d3\u4e3a\u5355\u72ec\u7684\u56fe\u50cf\uff0c\u8fdb\u884c\u540e\u5904\u7406\u64cd\u4f5c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u53ef\u4ee5\u4f7f\u7528\u50cf VK_IMAGE_USAGE_TRANSFER_DST_BIT \u8fd9\u6837\u7684\u503c\uff0c\u5e76\u4f7f\u7528\u5185\u5b58\u64cd\u4f5c\u5c06\u6e32\u67d3\u7684\u56fe\u50cf\u4f20\u8f93\u5230\u4ea4\u6362\u94fe\u56fe\u50cf\u961f\u5217\u3002 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); uint32_t queueFamilyIndices[] = {(uint32_t) indices.graphicsFamily, (uint32_t) indices.presentFamily}; if (indices.graphicsFamily != indices.presentFamily) { createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT; createInfo.queueFamilyIndexCount = 2; createInfo.pQueueFamilyIndices = queueFamilyIndices; } else { createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; createInfo.queueFamilyIndexCount = 0; // Optional createInfo.pQueueFamilyIndices = nullptr; // Optional } C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u6307\u5b9a\u5982\u4f55\u5904\u7406\u8de8\u591a\u4e2a\u961f\u5217\u7c07\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u3002\u5982\u679cgraphics\u961f\u5217\u7c07\u4e0epresentation\u961f\u5217\u7c07\u4e0d\u540c\uff0c\u4f1a\u51fa\u73b0\u5982\u4e0b\u60c5\u5f62\u3002\u6211\u4eec\u5c06\u4ecegraphics\u961f\u5217\u4e2d\u7ed8\u5236\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\uff0c\u7136\u540e\u5728\u53e6\u4e00\u4e2apresentation\u961f\u5217\u4e2d\u63d0\u4ea4\u4ed6\u4eec\u3002\u591a\u961f\u5217\u5904\u7406\u56fe\u50cf\u6709\u4e24\u79cd\u65b9\u6cd5: VK_SHARING_MODE_EXCLUSIVE : \u540c\u4e00\u65f6\u95f4\u56fe\u50cf\u53ea\u80fd\u88ab\u4e00\u4e2a\u961f\u5217\u7c07\u5360\u7528\uff0c\u5982\u679c\u5176\u4ed6\u961f\u5217\u7c07\u9700\u8981\u5176\u6240\u6709\u6743\u9700\u8981\u660e\u786e\u6307\u5b9a\u3002\u8fd9\u79cd\u65b9\u5f0f\u63d0\u4f9b\u4e86\u6700\u597d\u7684\u6027\u80fd\u3002 VK_SHARING_MODE_CONCURRENT : \u56fe\u50cf\u53ef\u4ee5\u88ab\u591a\u4e2a\u961f\u5217\u7c07\u8bbf\u95ee\uff0c\u4e0d\u9700\u8981\u660e\u786e\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\u3002 \u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u5982\u679c\u961f\u5217\u7c07\u4e0d\u540c\uff0c\u5c06\u4f1a\u4f7f\u7528 concurrent \u6a21\u5f0f\uff0c\u907f\u514d\u5904\u7406\u56fe\u50cf\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\u7684\u5185\u5bb9\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u4f1a\u6d89\u53ca\u4e0d\u5c11\u6982\u5ff5\uff0c\u5efa\u8bae\u540e\u7eed\u7684\u7ae0\u8282\u8ba8\u8bba\u3002 Concurrent \u6a21\u5f0f\u9700\u8981\u9884\u5148\u6307\u5b9a\u961f\u5217\u7c07\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\uff0c\u901a\u8fc7 queueFamilyIndexCount \u548c pQueueFamilyIndices \u53c2\u6570\u8fdb\u884c\u5171\u4eab\u3002\u5982\u679c graphics \u961f\u5217\u7c07\u548cpresentation\u961f\u5217\u7c07\u76f8\u540c\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 exclusive \u6a21\u5f0f\uff0c\u56e0\u4e3a concurrent \u6a21\u5f0f\u9700\u8981\u81f3\u5c11\u4e24\u4e2a\u4e0d\u540c\u7684\u961f\u5217\u7c07\u3002 createInfo.preTransform = swapChainSupport.capabilities.currentTransform; C++ \u5982\u679c\u4ea4\u6362\u94fe\u652f\u6301( supportedTransforms in capabilities ),\u6211\u4eec\u53ef\u4ee5\u4e3a\u4ea4\u6362\u94fe\u56fe\u50cf\u6307\u5b9a\u67d0\u4e9b\u8f6c\u6362\u903b\u8f91\uff0c\u6bd4\u598290\u5ea6\u987a\u65f6\u9488\u65cb\u8f6c\u6216\u8005\u6c34\u5e73\u53cd\u8f6c\u3002\u5982\u679c\u4e0d\u9700\u8981\u4efb\u4f55 transoform \u64cd\u4f5c\uff0c\u53ef\u4ee5\u7b80\u5355\u7684\u8bbe\u7f6e\u4e3a currentTransoform \u3002 createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR; C++ \u6df7\u5408Alpha\u5b57\u6bb5\u6307\u5b9aalpha\u901a\u9053\u662f\u5426\u5e94\u7528\u4e0e\u4e0e\u5176\u4ed6\u7684\u7a97\u4f53\u7cfb\u7edf\u8fdb\u884c\u6df7\u5408\u64cd\u4f5c\u3002\u5982\u679c\u5ffd\u7565\u8be5\u529f\u80fd\uff0c\u7b80\u5355\u7684\u586b VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR \u3002 createInfo.presentMode = presentMode; createInfo.clipped = VK_TRUE; C++ presentMode \u6307\u5411\u81ea\u5df1\u3002\u5982\u679c clipped \u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u610f\u5473\u7740\u6211\u4eec\u4e0d\u5173\u5fc3\u88ab\u906e\u853d\u7684\u50cf\u7d20\u6570\u636e\uff0c\u6bd4\u5982\u7531\u4e8e\u5176\u4ed6\u7684\u7a97\u4f53\u7f6e\u4e8e\u524d\u65b9\u65f6\u6216\u8005\u6e32\u67d3\u7684\u90e8\u5206\u5185\u5bb9\u5b58\u5728\u4e8e\u53ef\u662f\u533a\u57df\u4e4b\u5916\uff0c\u9664\u975e\u771f\u7684\u9700\u8981\u8bfb\u53d6\u8fd9\u4e9b\u50cf\u7d20\u83b7\u6570\u636e\u8fdb\u884c\u5904\u7406\uff0c\u5426\u5219\u53ef\u4ee5\u5f00\u542f\u88c1\u526a\u83b7\u5f97\u6700\u4f73\u6027\u80fd\u3002 createInfo.oldSwapchain = VK_NULL_HANDLE; C++ \u6700\u540e\u4e00\u4e2a\u5b57\u6bb5 oldSwapChain \u3002Vulkan\u8fd0\u884c\u65f6\uff0c\u4ea4\u6362\u94fe\u53ef\u80fd\u5728\u67d0\u4e9b\u6761\u4ef6\u4e0b\u88ab\u66ff\u6362\uff0c\u6bd4\u5982\u7a97\u53e3\u8c03\u6574\u5927\u5c0f\u6216\u8005\u4ea4\u6362\u94fe\u9700\u8981\u91cd\u65b0\u5206\u914d\u66f4\u5927\u7684\u56fe\u50cf\u961f\u5217\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4ea4\u6362\u94fe\u5b9e\u9645\u4e0a\u9700\u8981\u91cd\u65b0\u5206\u914d\u521b\u5efa\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u6b64\u5b57\u6bb5\u4e2d\u6307\u5b9a\u5bf9\u65e7\u7684\u5f15\u7528\uff0c\u7528\u4ee5\u56de\u6536\u8d44\u6e90\u3002\u8fd9\u662f\u4e00\u4e2a\u6bd4\u8f83\u590d\u6742\u7684\u8bdd\u9898\uff0c\u6211\u4eec\u4f1a\u5728\u540e\u9762\u7684\u7ae0\u8282\u4e2d\u8be6\u7ec6\u4ecb\u7ecd\u3002\u73b0\u5728\u5047\u8bbe\u6211\u4eec\u53ea\u4f1a\u521b\u5efa\u4e00\u4e2a\u4ea4\u6362\u94fe\u3002 \u73b0\u5728\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u53d8\u91cf\u5b58\u50a8 VkSwapchainKHR \u5bf9\u8c61: VkSwapchainKHR swapChain; C++ \u521b\u5efa\u4ea4\u6362\u94fe\u53ea\u9700\u8981\u7b80\u5355\u7684\u8c03\u7528\u51fd\u6570: vkCreateSwapchainKHR : if (vkCreateSwapchainKHR(device, &createInfo, nullptr, &swapChain) != VK_SUCCESS) { throw std::runtime_error(\"failed to create swap chain!\"); } C++ \u53c2\u6570\u662f\u903b\u8f91\u8bbe\u5907\uff0c\u4ea4\u6362\u94fe\u521b\u5efa\u7684\u4fe1\u606f\uff0c\u53ef\u9009\u62e9\u7684\u5206\u914d\u5668\u548c\u4e00\u4e2a\u5b58\u50a8\u4ea4\u6362\u540e\u7684\u53e5\u67c4\u6307\u9488\u3002\u5b83\u4e5f\u9700\u8981\u5728\u8bbe\u5907\u88ab\u6e05\u7406\u524d\uff0c\u8fdb\u884c\u9500\u6bc1\u64cd\u4f5c\uff0c\u901a\u8fc7\u8c03\u7528 vkDestroySwapchainKHR \u3002 void cleanup() { vkDestroySwapchainKHR(device, swapChain, nullptr); ... } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\u786e\u4fdd\u4ea4\u6362\u94fe\u521b\u5efa\u6210\u529f\uff01 \u5c1d\u8bd5\u79fb\u9664 createInfo.imageExtent = extent; \u5e76\u5728validation layers\u5f00\u542f\u7684\u6761\u4ef6\u4e0b\uff0cvalidation layers\u4f1a\u7acb\u523b\u6355\u83b7\u5230\u6709\u5e2e\u52a9\u7684\u5f02\u5e38\u4fe1\u606f: \u83b7\u53d6\u4ea4\u6362\u94fe\u56fe\u50cf \u4ea4\u6362\u94fe\u521b\u5efa\u540e\uff0c\u9700\u8981\u83b7\u53d6 VkImage \u76f8\u5173\u7684\u53e5\u67c4\u3002\u5b83\u4f1a\u5728\u540e\u7eed\u6e32\u67d3\u7684\u7ae0\u8282\u4e2d\u5f15\u7528\u3002\u6dfb\u52a0\u7c7b\u6210\u5458\u53d8\u91cf\u5b58\u50a8\u8be5\u53e5\u67c4: std::vector<VkImage> swapChainImages; C++ \u56fe\u50cf\u88ab\u4ea4\u6362\u94fe\u521b\u5efa\uff0c\u4e5f\u4f1a\u5728\u4ea4\u6362\u94fe\u9500\u6bc1\u7684\u540c\u65f6\u81ea\u52a8\u6e05\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u6dfb\u52a0\u4efb\u4f55\u6e05\u7406\u4ee3\u7801\u3002 \u6211\u4eec\u5728 createSwapChain \u51fd\u6570\u4e0b\u9762\u6dfb\u52a0\u4ee3\u7801\u83b7\u53d6\u53e5\u67c4\uff0c\u5728 vkCreateSwapchainKHR \u540e\u8c03\u7528\u3002\u83b7\u53d6\u53e5\u67c4\u7684\u64cd\u4f5c\u540c\u4e4b\u524d\u83b7\u53d6\u6570\u7ec4\u96c6\u5408\u7684\u64cd\u4f5c\u975e\u5e38\u7c7b\u4f3c\u3002\u9996\u5148\u901a\u8fc7\u8c03\u7528 vkGetSwapchainImagesKHR \u83b7\u53d6\u4ea4\u6362\u94fe\u4e2d\u56fe\u50cf\u7684\u6570\u91cf\uff0c\u5e76\u6839\u636e\u6570\u91cf\u8bbe\u7f6e\u5408\u9002\u7684\u5bb9\u5668\u5927\u5c0f\u4fdd\u5b58\u83b7\u53d6\u5230\u7684\u53e5\u67c4\u96c6\u5408\u3002 vkGetSwapchainImagesKHR(device, swapChain, &imageCount, nullptr); swapChainImages.resize(imageCount); vkGetSwapchainImagesKHR(device, swapChain, &imageCount, swapChainImages.data()); C++ \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e4b\u524d\u521b\u5efa\u4ea4\u6362\u94fe\u6b65\u9aa4\u4e2d\u6211\u4eec\u4f20\u9012\u4e86\u671f\u671b\u7684\u56fe\u50cf\u5927\u5c0f\u5230\u5b57\u6bb5 minImageCount \u3002\u800c\u5b9e\u9645\u7684\u8fd0\u884c\uff0c\u5141\u8bb8\u6211\u4eec\u521b\u5efa\u66f4\u591a\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u9700\u8981\u518d\u4e00\u6b21\u83b7\u53d6\u6570\u91cf\u3002 \u6700\u540e\uff0c\u5b58\u50a8\u4ea4\u6362\u94fe\u683c\u5f0f\u548c\u8303\u56f4\u5230\u6210\u5458\u53d8\u91cf\u4e2d\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7ae0\u8282\u4f7f\u7528\u3002 VkSwapchainKHR swapChain; std::vector<VkImage> swapChainImages; VkFormat swapChainImageFormat; VkExtent2D swapChainExtent; ... swapChainImageFormat = surfaceFormat.format; swapChainExtent = extent; C++ \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u56fe\u50cf\uff0c\u8fd9\u4e9b\u56fe\u50cf\u53ef\u4ee5\u88ab\u7ed8\u5236\uff0c\u5e76\u5448\u73b0\u5230\u7a97\u4f53\u3002 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u5f00\u59cb\u8ba8\u8bba\u5982\u4f55\u4e3a\u56fe\u50cf\u8bbe\u7f6e\u6e32\u67d3\u76ee\u6807\uff0c\u5e76\u4e86\u89e3\u5b9e\u9645\u7684\u56fe\u50cf\u7ba1\u7ebf\u548c\u7ed8\u5236\u547d\u4ee4\u3002 Vulkan Window Surface Vulkan Window Surface \uff0c\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u4e86\u89e3\u5230 Vulkan \u662f\u4e00\u4e2a\u4e0e\u5e73\u53f0\u7279\u6027\u65e0\u5173\u8054\u7684 API \u96c6\u5408\u3002\u5b83\u4e0d\u80fd\u76f4\u63a5\u4e0e\u7a97\u53e3\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002\u4e3a\u4e86\u5c06\u6e32\u67d3\u7ed3\u679c\u5448\u73b0\u5230\u5c4f\u5e55\uff0c\u9700\u8981\u5efa\u7acb Vulkan \u4e0e\u7a97\u4f53\u7cfb\u7edf\u4e4b\u95f4\u7684\u8fde\u63a5\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 WSI (\u7a97\u4f53\u7cfb\u7edf\u96c6\u6210)\u6269\u5c55\u3002\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u8ba8\u8bba\u7b2c\u4e00\u4e2a\uff0c\u5373 VK_KHR_surface \u3002\u5b83\u66b4\u9732\u4e86 VkSurfaceKHR \uff0c\u5b83\u4ee3\u8868 surface \u7684\u4e00\u4e2a\u62bd\u8c61\u7c7b\u578b\uff0c\u7528\u4ee5\u5448\u73b0\u6e32\u67d3\u56fe\u50cf\u4f7f\u7528\u3002\u6211\u4eec\u7a0b\u5e8f\u4e2d\u5c06\u8981\u4f7f\u7528\u5230\u7684 surface \u662f\u7531\u6211\u4eec\u5df2\u7ecf\u5f15\u5165\u7684 GLFW \u6269\u5c55\u53ca\u5176\u6253\u5f00\u7684\u76f8\u5173\u7a97\u4f53\u652f\u6301\u7684\u3002\u7b80\u5355\u6765\u8bf4surface\u5c31\u662fVulkan\u4e0e\u7a97\u4f53\u7cfb\u7edf\u7684\u8fde\u63a5\u6865\u6881\u3002 VK_KHR_surface \u6269\u5c55\u662f\u4e00\u4e2ainstance\u7ea7\u6269\u5c55\uff0c\u6211\u4eec\u76ee\u524d\u4e3a\u6b62\u5df2\u7ecf\u542f\u7528\u8fc7\u5b83\uff0c\u5b83\u5305\u542b\u5728 glfwGetRequiredInstanceExtensions \u8fd4\u56de\u7684\u5217\u8868\u4e2d\u3002\u8be5\u5217\u8868\u8fd8\u5305\u62ec\u5c06\u5728\u63a5\u4e0b\u6765\u51e0\u5c0f\u8282\u4e2d\u4f7f\u7528\u7684\u4e00\u4e9b\u5176\u4ed6WSI\u6269\u5c55\u3002 \u9700\u8981\u5728 instance \u521b\u5efa\u4e4b\u540e\u7acb\u5373\u521b\u5efa\u7a97\u4f53 surface \uff0c\u56e0\u4e3a\u5b83\u4f1a\u5f71\u54cd\u7269\u7406\u8bbe\u5907\u7684\u9009\u62e9\u3002\u4e4b\u6240\u4ee5\u5728\u672c\u5c0f\u8282\u5c06 surface \u521b\u5efa\u903b\u8f91\u7eb3\u5165\u8ba8\u8bba\u8303\u56f4\uff0c\u662f\u56e0\u4e3a\u7a97\u4f53 surface \u5bf9\u4e8e\u6e32\u67d3\u3001\u5448\u73b0\u65b9\u5f0f\u662f\u4e00\u4e2a\u6bd4\u8f83\u5927\u7684\u8bfe\u9898\uff0c\u5982\u679c\u8fc7\u65e9\u7684\u5728\u521b\u5efa\u7269\u7406\u8bbe\u5907\u52a0\u5165\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u4f1a\u6df7\u6dc6\u57fa\u672c\u7684\u7269\u7406\u8bbe\u5907\u8bbe\u7f6e\u5de5\u4f5c\u3002\u53e6\u5916\u7a97\u4f53 surface \u672c\u8eab\u5bf9\u4e8e Vulkan \u4e5f\u662f\u975e\u5f3a\u5236\u7684\u3002 Vulkan \u5141\u8bb8\u8fd9\u6837\u505a\uff0c\u4e0d\u9700\u8981\u540c OpenGL \u4e00\u6837\u5fc5\u987b\u8981\u521b\u5efa\u7a97\u4f53 surface \u3002 \u6587\u7ae0\u76ee\u5f55 1 \u521b\u5efa Window Surface 2 \u67e5\u8be2\u6f14\u793a\u652f\u6301 3 \u521b\u5efa\u6f14\u793a\u961f\u5217 \u521b\u5efa Window Surface \u73b0\u5728\u5f00\u59cb\u7740\u624b\u521b\u5efa\u7a97\u4f53 surface \uff0c\u5728\u7c7b\u6210\u5458 debugCallback \u4e0b\u52a0\u5165\u6210\u5458\u53d8\u91cf surface \u3002 VkSurfaceKHR surface; C++ \u867d\u7136 VkSurfaceKHR \u5bf9\u8c61\u53ca\u5176\u7528\u6cd5\u4e0e\u5e73\u53f0\u65e0\u5173\u8054\uff0c\u4f46\u521b\u5efa\u8fc7\u7a0b\u9700\u8981\u4f9d\u8d56\u5177\u4f53\u7684\u7a97\u4f53\u7cfb\u7edf\u7684\u7ec6\u8282\u3002\u6bd4\u5982\uff0c\u5728 Windows \u5e73\u53f0\u4e2d\uff0c\u5b83\u9700\u8981 WIndows \u4e0a\u7684 HWND \u548c HMODULE \u53e5\u67c4\u3002\u56e0\u6b64\u9488\u5bf9\u7279\u5b9a\u5e73\u53f0\u63d0\u4f9b\u76f8\u5e94\u7684\u6269\u5c55\uff0c\u5728 Windows \u4e0a\u4e3a VK_KHR_win32_surface \uff0c\u5b83\u81ea\u52a8\u5305\u542b\u5728 glfwGetRequiredInstanceExtensions \u5217\u8868\u4e2d\u3002 \u6211\u4eec\u5c06\u4f1a\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u7279\u5b9a\u5e73\u53f0\u7684\u6269\u5c55\u6765\u521b\u5efa Windows \u4e0a\u7684 surface \u6865\uff0c\u4f46\u662f\u4e0d\u4f1a\u5728\u6559\u7a0b\u4e2d\u5b9e\u9645\u4f7f\u7528\u5b83\u3002\u4f7f\u7528GLFW\u8fd9\u6837\u7684\u5e93\u907f\u514d\u4e86\u7f16\u5199\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u7684\u8de8\u5e73\u53f0\u76f8\u5173\u4ee3\u7801\u3002 GLFW \u5b9e\u9645\u4e0a\u901a\u8fc7 glfwCreateWindowSurface \u5f88\u597d\u7684\u5904\u7406\u4e86\u5e73\u53f0\u5dee\u5f02\u6027\u3002\u5f53\u7136\u4e86\uff0c\u6bd4\u8f83\u7406\u60f3\u662f\u5728\u4f9d\u8d56\u5b83\u4eec\u5e2e\u52a9\u6211\u4eec\u5b8c\u6210\u5177\u4f53\u5de5\u4f5c\u4e4b\u524d\uff0c\u4e86\u89e3\u4e00\u4e0b\u80cc\u540e\u7684\u5b9e\u73b0\u662f\u6709\u5e2e\u52a9\u7684\u3002 \u56e0\u4e3a\u4e00\u4e2a\u7a97\u4f53 surface \u662f\u4e00\u4e2a Vulkan \u5bf9\u8c61\uff0c\u5b83\u9700\u8981\u586b\u5145 VkWin32SurfaceCreateInfoKHR \u7ed3\u6784\u4f53\uff0c\u8fd9\u91cc\u6709\u4e24\u4e2a\u6bd4\u8f83\u91cd\u8981\u7684\u53c2\u6570: hwnd \u548c hinstance \u3002\u5982\u679c\u719f\u6089 windows \u4e0b\u5f00\u53d1\u5e94\u8be5\u77e5\u9053\uff0c\u8fd9\u4e9b\u662f\u7a97\u53e3\u548c\u8fdb\u7a0b\u7684\u53e5\u67c4\u3002 VkWin32SurfaceCreateInfoKHR createInfo; createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR; createInfo.hwnd = glfwGetWin32Window(window); createInfo.hinstance = GetModuleHandle(nullptr); C++ glfwGetWin32Window \u51fd\u6570\u7528\u4e8e\u4eceGLFW\u7a97\u4f53\u5bf9\u8c61\u83b7\u53d6\u539f\u59cb\u7684 HWND \u3002 GetModuleHandle \u51fd\u6570\u8fd4\u56de\u5f53\u524d\u8fdb\u7a0b\u7684 HINSTANCE \u53e5\u67c4\u3002 \u586b\u5145\u5b8c\u7ed3\u6784\u4f53\u4e4b\u540e\uff0c\u53ef\u4ee5\u5229\u7528 vkCreateWin32SurfaceKHR \u521b\u5efasurface\u6865\uff0c\u548c\u4e4b\u524d\u83b7\u53d6\u521b\u5efa\u3001\u9500\u6bc1 DebugReportCallEXT \u4e00\u6837\uff0c\u8fd9\u91cc\u540c\u6837\u9700\u8981\u901a\u8fc7 instance \u83b7\u53d6\u521b\u5efa surface \u7528\u5230\u7684\u51fd\u6570\u3002\u8fd9\u91cc\u6d89\u53ca\u5230\u7684\u53c2\u6570\u5206\u522b\u4e3a instance , surface \u521b\u5efa\u7684\u4fe1\u606f\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u6700\u7ec8\u4fdd\u5b58 surface \u7684\u53e5\u67c4\u53d8\u91cf\u3002 auto CreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) vkGetInstanceProcAddr(instance, \"vkCreateWin32SurfaceKHR\"); if (!CreateWin32SurfaceKHR || CreateWin32SurfaceKHR(instance, &createInfo, nullptr, &surface) != VK_SUCCESS) { throw std::runtime_error(\"failed to create window surface!\"); } C++ \u8be5\u8fc7\u7a0b\u4e0e\u5176\u4ed6\u5e73\u53f0\u7c7b\u4f3c\uff0c\u6bd4\u5982 Linux \uff0c\u4f7f\u7528X11\u754c\u9762\u7a97\u4f53\u7cfb\u7edf\uff0c\u53ef\u4ee5\u901a\u8fc7 vkCreateXcbSurfaceKHR \u51fd\u6570\u5efa\u7acb\u8fde\u63a5\u3002 glfwCreateWindowSurface \u51fd\u6570\u6839\u636e\u4e0d\u540c\u5e73\u53f0\u7684\u5dee\u5f02\u6027\uff0c\u5728\u5b9e\u73b0\u7ec6\u8282\u4e0a\u4f1a\u6709\u6240\u4e0d\u540c\u3002\u6211\u4eec\u73b0\u5728\u5c06\u5176\u6574\u5408\u5230\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\u3002\u4ece initVulkan \u4e2d\u6dfb\u52a0\u4e00\u4e2a\u51fd\u6570 createSurface ,\u5b89\u6392\u5728 createInstnace \u548c setupDebugCallback \u51fd\u6570\u4e4b\u540e\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); } void createSurface() { } C++ GLFW \u6ca1\u6709\u4f7f\u7528\u7ed3\u6784\u4f53\uff0c\u800c\u662f\u9009\u62e9\u975e\u5e38\u76f4\u63a5\u7684\u53c2\u6570\u4f20\u9012\u6765\u8c03\u7528\u51fd\u6570\u3002 void createSurface() { if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) { throw std::runtime_error(\"failed to create window surface!\"); } } C++ \u53c2\u6570\u662f VkInstance , GLFW \u7a97\u4f53\u7684\u6307\u9488\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u7528\u4e8e\u5b58\u50a8 VkSurfaceKHR \u53d8\u91cf\u7684\u6307\u9488\u3002\u5bf9\u4e8e\u4e0d\u540c\u5e73\u53f0\u7edf\u4e00\u8fd4\u56de VkResult \u3002 GLFW \u6ca1\u6709\u63d0\u4f9b\u4e13\u7528\u7684\u51fd\u6570\u9500\u6bc1 surface ,\u4f46\u662f\u53ef\u4ee5\u7b80\u5355\u7684\u901a\u8fc7 Vulkan \u539f\u59cb\u7684 API \u5b8c\u6210: void cleanup() { ... vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); ... } C++ \u6700\u540e\u8bf7\u786e\u4fddsurface\u7684\u6e05\u7406\u662f\u5728instance\u9500\u6bc1\u4e4b\u524d\u5b8c\u6210\u3002 \u67e5\u8be2\u6f14\u793a\u652f\u6301 \u867d\u7136 Vulkan \u7684\u5b9e\u73b0\u652f\u6301\u7a97\u4f53\u96c6\u6210\u529f\u80fd\uff0c\u4f46\u662f\u5e76\u4e0d\u610f\u5473\u7740\u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u90fd\u652f\u6301\u5b83\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u6269\u5c55 isDeviceSuitable \u51fd\u6570\uff0c\u786e\u4fdd\u8bbe\u5907\u53ef\u4ee5\u5c06\u56fe\u50cf\u5448\u73b0\u5230\u6211\u4eec\u521b\u5efa\u7684 surface \u3002\u7531\u4e8e presentation \u662f\u4e00\u4e2a\u961f\u5217\u7684\u7279\u6027\u529f\u80fd\uff0c\u56e0\u6b64\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6cd5\u5c31\u662f\u627e\u5230\u652f\u6301 presentation \u7684\u961f\u5217\u7c07\uff0c\u6700\u7ec8\u83b7\u53d6\u961f\u5217\u6ee1\u8db3 surface \u521b\u5efa\u7684\u9700\u8981\u3002 \u5b9e\u9645\u60c5\u51b5\u662f\uff0c\u652f\u6301 graphics \u547d\u4ee4\u7684\u7684\u961f\u5217\u7c07\u548c\u652f\u6301 presentation \u547d\u4ee4\u7684\u961f\u5217\u7c07\u53ef\u80fd\u4e0d\u662f\u540c\u4e00\u4e2a\u7c07\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u4fee\u6539 QueueFamilyIndices \u7ed3\u6784\u4f53\uff0c\u4ee5\u652f\u6301\u5dee\u5f02\u5316\u7684\u5b58\u50a8\u3002 struct QueueFamilyIndices { int graphicsFamily = -1; int presentFamily = -1; bool isComplete() { return graphicsFamily >= 0 && presentFamily >= 0; } }; C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4fee\u6539 findQueueFamilies \u51fd\u6570\u6765\u67e5\u627e\u5177\u5907 presentation \u529f\u80fd\u7684\u961f\u5217\u7c07\u3002\u51fd\u6570\u4e2d\u7528\u4e8e\u68c0\u67e5\u7684\u6838\u5fc3\u4ee3\u7801\u662f vkGetPhysicalDeviceSurfaceSupportKHR ,\u5b83\u5c06\u7269\u7406\u8bbe\u5907\u3001\u961f\u5217\u7c07\u7d22\u5f15\u548c surface \u4f5c\u4e3a\u53c2\u6570\u3002\u5728 VK_QUEUE_GRAPHICS_BIT \u76f8\u540c\u7684\u5faa\u73af\u4f53\u4e2d\u6dfb\u52a0\u51fd\u6570\u7684\u8c03\u7528: VkBool32 presentSupport = false; vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport); C++ \u7136\u540e\u4e4b\u9700\u8981\u68c0\u67e5\u5e03\u5c14\u503c\u5e76\u5b58\u50a8 presentation \u961f\u5217\u7c07\u7684\u7d22\u5f15: if (queueFamily.queueCount > 0 && presentSupport) { indices.presentFamily = i; } C++ \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e3a\u4e86\u652f\u6301 graphics \u548c presentation \u529f\u80fd\uff0c\u6211\u4eec\u5b9e\u9645\u73af\u5883\u4e2d\u5f97\u5230\u7684\u53ef\u80fd\u662f\u540c\u4e00\u4e2a\u961f\u5217\u7c07\uff0c\u4e5f\u53ef\u80fd\u4e0d\u540c\uff0c\u4e3a\u6b64\u5728\u6211\u4eec\u7684\u7a0b\u5e8f\u6570\u636e\u7ed3\u6784\u53ca\u9009\u62e9\u903b\u8f91\u4e2d\uff0c\u5c06\u6309\u7167\u5747\u6765\u81ea\u4e0d\u540c\u7684\u961f\u5217\u7c07\u5206\u522b\u5904\u7406\uff0c\u8fd9\u6837\u4fbf\u53ef\u4ee5\u7edf\u4e00\u5904\u7406\u4ee5\u4e0a\u4e24\u79cd\u60c5\u51b5\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u51fa\u4e8e\u6027\u80fd\u7684\u8003\u8651\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u903b\u8f91\u660e\u786e\u7684\u6307\u5b9a\u7269\u7406\u8bbe\u5907\u6240\u4f7f\u7528\u7684 graphics \u548c presentation \u529f\u80fd\u6765\u81ea\u540c\u4e00\u4e2a\u961f\u5217\u7c07\u3002 \u521b\u5efa\u6f14\u793a\u961f\u5217 \u5269\u4e0b\u7684\u4e8b\u60c5\u662f\u4fee\u6539\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u8fc7\u7a0b\uff0c\u5728\u4e8e\u521b\u5efa presentation \u961f\u5217\u5e76\u83b7\u53d6 VkQueue \u7684\u53e5\u67c4\u3002\u6dfb\u52a0\u4fdd\u5b58\u961f\u5217\u53e5\u67c4\u7684\u6210\u5458\u53d8\u91cf: VkQueue presentQueue; C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u591a\u4e2a VkDeviceQueueCreateInfo \u7ed3\u6784\u6765\u521b\u5efa\u4e0d\u540c\u529f\u80fd\u7684\u961f\u5217\u3002\u4e00\u4e2a\u4f18\u96c5\u7684\u65b9\u5f0f\u662f\u9488\u5bf9\u4e0d\u540c\u529f\u80fd\u7684\u961f\u5217\u7c07\u521b\u5efa\u4e00\u4e2aset\u96c6\u5408\u786e\u4fdd\u961f\u5217\u7c07\u7684\u552f\u4e00\u6027: #include <set> ... QueueFamilyIndices indices = findQueueFamilies(physicalDevice); std::vector<VkDeviceQueueCreateInfo> queueCreateInfos; std::set<int> uniqueQueueFamilies = {indices.graphicsFamily, indices.presentFamily}; float queuePriority = 1.0f; for (int queueFamily : uniqueQueueFamilies) { VkDeviceQueueCreateInfo queueCreateInfo = {}; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = queueFamily; queueCreateInfo.queueCount = 1; queueCreateInfo.pQueuePriorities = &queuePriority; queueCreateInfos.push_back(queueCreateInfo); } C++ \u540c\u65f6\u8fd8\u8981\u4fee\u6539 VkDeviceCreateInfo \u6307\u5411\u961f\u5217\u96c6\u5408: createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size()); createInfo.pQueueCreateInfos = queueCreateInfos.data(); C++ \u5982\u679c\u961f\u5217\u7c07\u76f8\u540c\uff0c\u90a3\u4e48\u6211\u4eec\u4e4b\u9700\u8981\u4f20\u9012\u4e00\u6b21\u7d22\u5f15\u3002\u6700\u540e\uff0c\u6dfb\u52a0\u4e00\u4e2a\u8c03\u7528\u68c0\u7d22\u961f\u5217\u53e5\u67c4: vkGetDeviceQueue(device, indices.presentFamily, 0, &presentQueue); C++ \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u961f\u5217\u7c07\u662f\u76f8\u540c\u7684\uff0c\u4e24\u4e2a\u53e5\u67c4\u53ef\u80fd\u4f1a\u6709\u76f8\u540c\u7684\u503c\u3002\u5728 \u4e0b\u4e00\u4e2a\u7ae0\u8282 \u4e2d\u6211\u4eec\u4f1a\u770b\u770b\u4ea4\u6362\u94fe\uff0c\u4ee5\u53ca\u5b83\u4eec\u5982\u4f55\u4f7f\u6211\u4eec\u80fd\u591f\u5c06\u56fe\u50cf\u5448\u73b0\u7ed9 surface \u3002 Vulkan \u56fe\u5f62\u7ba1\u7ebf Vulkan \u56fe\u5f62\u7ba1\u7ebf \uff0c\u901a\u8fc7\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\uff0c\u6211\u4eec\u5c06\u4f1a\u5f00\u542f\u6709\u5173\u56fe\u5f62\u7ba1\u7ebf\u7684\u8bdd\u9898\uff0c\u901a\u8fc7\u5bf9\u56fe\u5f62\u6e32\u67d3\u7ba1\u7ebf\u7684\u914d\u7f6e\u5b8c\u6210\u6700\u540e\u7684\u4e09\u89d2\u5f62\u7ed8\u753b\u3002\u6240\u8c13\u56fe\u5f62\u7ba1\u7ebf\u5c31\u662f\u5c06 mesh \u4f7f\u7528\u5230\u7684 vertices \u5b9a\u70b9\u6570\u636e\u548c\u8d34\u56fe\u6570\u636e\uff0c\u8f6c\u5316\u4e3a\u6e32\u67d3 targets \u50cf\u7d20\u7684\u64cd\u4f5c\u5e8f\u5217\u3002\u7b80\u8981\u7684\u6982\u8ff0\u5982\u4e0b\u56fe\u6240\u793a: Input assembler \u6536\u96c6\u6700\u539f\u59cb\u7684\u9876\u70b9\u6570\u636e\uff0c\u5e76\u4e14\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7d22\u5f15\u7f13\u51b2\u533a\u590d\u7528\u8fd9\u4e9b\u6570\u636e\u5143\u7d20\uff0c\u800c\u4e0d\u5fc5\u590d\u5236\u5197\u4f59\u7684\u9876\u70b9\u6570\u636e\u526f\u672c\u3002 vertex shader \u4f1a\u5e94\u7528\u5728\u6bcf\u4e00\u4e2a\u9876\u70b9\u6570\u636e\uff0c\u901a\u5e38\u5e94\u7528\u53d8\u6362\u64cd\u4f5c\uff0c\u4ece\u800c\u5c06\u9876\u70b9\u7684\u4f4d\u7f6e\u5750\u6807\u6570\u636e\u4ece\u6a21\u578b\u7a7a\u95f4\u8f6c\u6362\u4e3a\u5c4f\u5e55\u7a7a\u95f4\u3002\u5728\u5904\u7406\u5b8c\u6bd5\u4e4b\u540e\u4f1a\u5c06\u6570\u636e\u7ee7\u7eed\u5728\u7ba1\u7ebf\u4f20\u9012\u4e0b\u53bb\u3002 tessellation shader \u66f2\u9762\u7740\u8272\u5668\u5141\u8bb8\u57fa\u4e8e\u67d0\u4e9b\u89c4\u5219\u8fdb\u4e00\u6b65\u7ec6\u5206\u51e0\u4f55\u6570\u636e\u589e\u52a0\u7f51\u683c\u7684\u8d28\u91cf\u3002\u7ecf\u5e38\u5e94\u7528\u4e0e\u5899\u9762\u548c\u697c\u68af\u8868\u9762\uff0c\u4f7f\u9644\u8fd1\u770b\u8d77\u6765\u4e0d\u662f\u90a3\u4e48\u5e73\u5766\u3002 geometry shader \u96c6\u5408\u7740\u8272\u5668\u5e94\u7528\u5728\u6bcf\u4e00\u4e2a\u56fe\u5143\u4e0a\uff0c\u53ef\u7528\u4e8e\u589e\u51cf\u56fe\u5143\uff0c\u5b83\u4e0e\u66f2\u9762\u7740\u8272\u5668\u7c7b\u4f3c\uff0c\u4f46\u66f4\u52a0\u7075\u6d3b\u3002\u7136\u800c\uff0c\u5b83\u5728\u4eca\u5929\u7684\u5e94\u7528\u4e2d\u5e76\u6ca1\u6709\u592a\u591a\u7684\u5e94\u7528\u60c5\u666f\uff0c\u56e0\u4e3a\u9664\u4e86 Intel \u7684\u96c6\u6210\u663e\u5361\u5916\uff0c\u5927\u591a\u6570\u663e\u5361\u6027\u80fd\u652f\u6301\u90fd\u4e0d\u7406\u60f3\u3002 \u5149\u6805\u5316\u9636\u6bb5\u5c06\u56fe\u5143\u5206\u89e3\u4e3a\u7247\u5143\u3002\u8fd9\u4e9b\u662f\u586b\u5145\u5728\u5e27\u7f13\u51b2\u533a\u4e0a\u7684\u50cf\u7d20\u5143\u7d20\u3002\u5c4f\u5e55\u5916\u533a\u57df\u7684\u7247\u5143\u4f1a\u88ab\u4e22\u5f03\uff0c\u9876\u70b9\u7740\u8272\u5668\u8f93\u51fa\u7684\u6570\u636e\u5728\u4f20\u9012\u5230\u7247\u5143\u7740\u8272\u5668\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u5982\u56fe\u6240\u793a\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u6839\u636e\u6df1\u5ea6\u6d4b\u8bd5\u7684\u7ed3\u679c\u4e5f\u4f1a\u5bf9\u7247\u5143\u8fdb\u884c\u4e22\u5f03\u3002 fragment shader \u5e94\u7528\u4e8e\u6bcf\u4e2a\u7247\u5143\uff0c\u786e\u5b9a\u6bcf\u4e2a\u5e27\u7f13\u51b2\u533a\u4e2d\u5199\u5165\u7684\u7247\u5143\u6570\u636e\u7684\u989c\u8272\u548c\u6df1\u5ea6\u503c\u3002\u7247\u5143\u7740\u8272\u5668\u53ef\u4ee5\u4f7f\u7528\u9876\u70b9\u7740\u8272\u5668\u7684\u63d2\u503c\u6570\u636e\uff0c\u8d34\u56fe\u7684UV\u5750\u6807\u548c\u5149\u6e90\u6cd5\u7ebf\u6570\u636e\u3002 \u6df7\u8272\u64cd\u4f5c\u9636\u6bb5\u4f1a\u5bf9\u4e0d\u540c\u7247\u5143\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\uff0c\u6700\u7ec8\u6620\u5c04\u5230\u5e27\u7f13\u51b2\u533a\u7684\u540c\u4e00\u4e2a\u50cf\u7d20\u4e0a\u3002\u7247\u5143\u4e5f\u53ef\u4ee5\u7b80\u5355\u7684\u4e92\u76f8\u91cd\u5199\uff0c\u53e0\u52a0\u6216\u8005\u6839\u636e\u900f\u660e\u5ea6\u6df7\u5408\u3002 \u7eff\u8272\u7684\u9636\u6bb5\u88ab\u79f0\u4e3a\u56fa\u5b9a\u6d41\u6c34\u7ebf\u3002\u8fd9\u4e2a\u9636\u6bb5\u5141\u8bb8\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684\u53c2\u6570\u6570\u503c\uff0c\u4f46\u662f\u5b83\u5185\u90e8\u7684\u5de5\u4f5c\u903b\u8f91\u662f\u9884\u5236\u597d\u7684\u3002 \u6a59\u8272\u7684\u9636\u6bb5\u88ab\u79f0\u4e3a\u53ef\u7f16\u7a0b\u9636\u6bb5 programmable \uff0c\u6211\u4eec\u53ef\u4ee5\u5411GPU\u63d0\u4ea4\u81ea\u5df1\u7f16\u5199\u7684\u4ee3\u7801\u6267\u884c\u5177\u4f53\u7684\u903b\u8f91\u3002\u6bd4\u5982\u5728\u4f7f\u7528 fragment shader \u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u5b9e\u73b0\u4efb\u4f55\u4ece\u8d34\u56fe\u5230\u706f\u5149\u7684\u5149\u7ebf\u8ffd\u8e2a\u3002\u8fd9\u4e9b\u7a0b\u5e8f\u540c\u65f6\u8fd0\u884c\u5728\u591a\u6838GPU\u4e0a\u5904\u7406\u8bb8\u591a\u5bf9\u8c61\uff0c\u6bd4\u5982\u5e76\u884c\u7684\u9876\u70b9\u548c\u7247\u6bb5\u7a0b\u5e8f\u3002 \u5982\u679c\u4e4b\u524d\u4f7f\u7528\u8fc7\u65e7\u7684API( OpenGL \u548c Direct3D ),\u90a3\u4e48\u5c06\u53ef\u4ee5\u968f\u610f\u901a\u8fc7 glBlendFunc \u548c OMSetBlendState \u8c03\u7528\u66f4\u6539\u7ba1\u7ebf\u8bbe\u7f6e\u3002 Vulkan\u4e2d \u7684\u56fe\u5f62\u7ba1\u7ebf\u51e0\u4e4e\u4e0d\u53ef\u6539\u53d8\uff0c\u56e0\u6b64\u5982\u679c\u9700\u8981\u66f4\u6539\u7740\u8272\u5668\uff0c\u7ed1\u5b9a\u5230\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u533a\u6216\u8005\u66f4\u6539\u6df7\u5408\u51fd\u6570\uff0c\u5219\u5fc5\u987b\u4ece\u5934\u521b\u5efa\u7ba1\u7ebf\u3002\u7f3a\u70b9\u662f\u5fc5\u987b\u521b\u5efa\u4e00\u4e9b\u7ba1\u7ebf\uff0c\u8fd9\u4e9b\u7ba1\u7ebf\u4ee3\u8868\u5728\u6e32\u67d3\u64cd\u4f5c\u4e2d\u4f7f\u7528\u7684\u4e0d\u540c\u7684\u7ec4\u5408\u72b6\u6001\u3002\u4f46\u662f\u7531\u4e8e\u6240\u6709\u7ba1\u7ebf\u7684\u64cd\u4f5c\u90fd\u662f\u63d0\u524d\u77e5\u9053\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7\u9a71\u52a8\u7a0b\u5e8f\u66f4\u597d\u7684\u4f18\u5316\u5b83\u3002 \u4e00\u4e9b\u53ef\u7f16\u7a0b\u9636\u6bb5\u662f\u57fa\u4e8e\u6253\u7b97\u505a\u4ec0\u4e48\u800c\u51b3\u5b9a\u7684\u3002\u6bd4\u5982\uff0c\u5982\u679c\u53ea\u662f\u7b80\u5355\u7684\u7ed8\u5236\u51e0\u4f55\u56fe\u5f62\uff0c\u5219\u53ef\u4ee5\u7981\u7528 tessellation \u548c geometry \u7740\u8272\u5668\u3002\u5982\u679c\u53ea\u5bf9\u6df1\u5ea6\u503c\u611f\u5174\u8da3\uff0c\u5219\u53ef\u4ee5\u7981\u7528 fragment \u7740\u8272\u5668\uff0c\u8fd9\u5bf9\u4e8e\u751f\u6210 shadow map \u751f\u6210\u5f88\u6709\u7528\u3002 \u5728\u4e0b\u4e00\u4e2a\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u9996\u5148\u521b\u5efa\u5c06\u4e09\u89d2\u5f62\u653e\u5728\u5c4f\u5e55\u4e0a\u6240\u9700\u8981\u7684\u4e24\u4e2a\u53ef\u7f16\u7a0b\u9636\u6bb5: vertice shader \u548c fragment shader \u3002\u56fa\u5b9a\u529f\u80fd\u7684\u8bbe\u7f6e\u5305\u62ec blending mode , viewport , rasterization \u5c06\u5728\u4e4b\u540e\u7684\u7ae0\u8282\u4e2d\u8bbe\u7f6e\u3002\u5728 Vulkan \u4e2d\u8bbe\u7f6e\u56fe\u5f62\u6d41\u6c34\u7ebf\u7684\u6700\u540e\u4e00\u90e8\u5206\u5185\u5bb9\u6d89\u53ca\u8f93\u5165\u548c\u8f93\u51fa\u5e27\u7f13\u51b2\u533a\u3002 \u5728 initVulkan \u4e2d\u521b\u5efa\u51fd\u6570 createGraphicsPipeline \u5e76\u5728 createImageViews \u540e\u7acb\u5373\u8c03\u7528\u3002\u6211\u4eec\u5728\u4e0b\u4e00\u7ae0\u8282\u4ecb\u7ecd\u51fd\u6570\u529f\u80fd\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createGraphicsPipeline(); } ... void createGraphicsPipeline() { } C++ \u5728\u7ed3\u5c3e\u5904\u5206\u4eab\u4e00\u4e0b Vulkan \u5b98\u65b9\u7684\u56fe\u5f62\u7ba1\u7ebf\u7ed3\u6784\u56fe\uff0c\u5982\u4e0b: Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe \uff0c\u4f7f\u7528\u4efb\u4f55\u7684 VkImage \uff0c\u5305\u62ec\u5728\u4ea4\u6362\u94fe\u6216\u8005\u6e32\u67d3\u7ba1\u7ebf\u4e2d\u7684\uff0c\u6211\u4eec\u90fd\u9700\u8981\u521b\u5efa VkImageView \u5bf9\u8c61\u3002\u4ece\u5b57\u9762\u4e0a\u7406\u89e3\u5b83\u5c31\u662f\u4e00\u4e2a\u9488\u5bf9\u56fe\u50cf\u7684\u89c6\u56fe\u6216\u5bb9\u5668\uff0c\u901a\u8fc7\u5b83\u5177\u4f53\u7684\u6e32\u67d3\u7ba1\u7ebf\u624d\u80fd\u591f\u8bfb\u5199\u6e32\u67d3\u6570\u636e\uff0c\u6362\u53e5\u8bdd\u8bf4 VkImage \u4e0d\u80fd\u4e0e\u6e32\u67d3\u7ba1\u7ebf\u8fdb\u884c\u4ea4\u4e92\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u56fe\u50cf\u89c6\u56fe\u53ef\u4ee5\u8fdb\u4e00\u6b65\u5b9a\u4e49\u5177\u4f53 Image \u7684\u683c\u5f0f\uff0c\u6bd4\u5982\u5b9a\u4e49\u4e3a2D\u8d34\u56fe\uff0c\u90a3\u4e48\u672c\u8d28\u4e0a\u5c31\u4e0d\u9700\u8981\u4efb\u4f55\u7ea7\u522b\u7684 mipmapping \u3002 \u5728\u672c\u7ae0\u8282\u6211\u4eec\u4f1a\u65b0\u589e\u4e00\u4e2a createImageViews \u51fd\u6570\uff0c\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u521b\u5efa\u57fa\u672c\u7684\u89c6\u56fe\uff0c\u8fd9\u4e9b\u89c6\u56fe\u5728\u540e\u9762\u7684\u5185\u5bb9\u4e2d\u4f1a\u88ab\u4f5c\u4e3a\u989c\u8272\u76ee\u6807\u4e0e\u6e32\u67d3\u7ba1\u7ebf\u914d\u5408\u4f7f\u7528\u3002 \u9996\u5148\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u7528\u4e8e\u4fdd\u5b58\u56fe\u50cf\u89c6\u56fe\u7684\u53e5\u67c4\u96c6: std::vector<VkImageView> swapChainImageViews; C++ \u521b\u5efa createImagesViews \u51fd\u6570\uff0c\u5e76\u5728\u521b\u5efa\u4ea4\u6362\u94fe\u5b8c\u6210\u4e4b\u540e\u8c03\u7528: void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); } void createImageViews() { } C++ \u6211\u4eec\u9700\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u9700\u8981\u5b9a\u4e49\u4fdd\u5b58\u56fe\u50cf\u89c6\u56fe\u96c6\u5408\u7684\u5927\u5c0f: void createImageViews() { swapChainImageViews.resize(swapChainImages.size()); } C++ \u4e0b\u4e00\u6b65\uff0c\u5faa\u73af\u8fed\u4ee3\u6240\u6709\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u3002 for (size_t i = 0; i < swapChainImages.size(); i++) { } C++ \u521b\u5efa\u56fe\u50cf\u89c6\u56fe\u7684\u53c2\u6570\u88ab\u5b9a\u4e49\u5728 VkImageViewCreateInfo \u7ed3\u6784\u4f53\u4e2d\u3002\u524d\u51e0\u4e2a\u53c2\u6570\u7684\u586b\u5145\u975e\u5e38\u7b80\u5355\u3001\u76f4\u63a5\u3002 VkImageViewCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; createInfo.image = swapChainImages[i]; C++ \u5176\u4e2d viewType \u548c format \u5b57\u6bb5\u7528\u4e8e\u63cf\u8ff0\u56fe\u50cf\u6570\u636e\u8be5\u88ab\u5982\u4f55\u89e3\u91ca\u3002 viewType \u53c2\u6570\u5141\u8bb8\u5c06\u56fe\u50cf\u5b9a\u4e49\u4e3a 1D textures , 2D textures , 3D textures \u548c cube maps \u3002 createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; createInfo.format = swapChainImageFormat; C++ components \u5b57\u6bb5\u5141\u8bb8\u8c03\u6574\u989c\u8272\u901a\u9053\u7684\u6700\u7ec8\u7684\u6620\u5c04\u903b\u8f91\u3002\u6bd4\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6240\u6709\u989c\u8272\u901a\u9053\u6620\u5c04\u4e3a\u7ea2\u8272\u901a\u9053\uff0c\u4ee5\u5b9e\u73b0\u5355\u8272\u7eb9\u7406\u3002\u6211\u4eec\u4e5f\u53ef\u4ee5\u5c06\u901a\u9053\u6620\u5c04\u5177\u4f53\u7684\u5e38\u91cf\u6570\u503c 0 \u548c 1 \u3002\u5728\u7ae0\u8282\u4e2d\u6211\u4eec\u4f7f\u7528\u9ed8\u8ba4\u7684\u6620\u5c04\u7b56\u7565\u3002 createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY; C++ subresourceRangle \u5b57\u6bb5\u7528\u4e8e\u63cf\u8ff0\u56fe\u50cf\u7684\u4f7f\u7528\u76ee\u6807\u662f\u4ec0\u4e48\uff0c\u4ee5\u53ca\u53ef\u4ee5\u88ab\u8bbf\u95ee\u7684\u6709\u6548\u533a\u57df\u3002\u6211\u4eec\u7684\u56fe\u50cf\u5c06\u4f1a\u4f5c\u4e3a color targets \uff0c\u6ca1\u6709\u4efb\u4f55 mipmapping levels \u6216\u662f\u591a\u5c42 multiple layers \u3002 createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; createInfo.subresourceRange.baseMipLevel = 0; createInfo.subresourceRange.levelCount = 1; createInfo.subresourceRange.baseArrayLayer = 0; createInfo.subresourceRange.layerCount = 1; C++ \u5982\u679c\u5728\u7f16\u5199\u6c89\u6d78\u5f0f\u7684 3D \u5e94\u7528\u7a0b\u5e8f\uff0c\u6bd4\u5982 VR \uff0c\u5c31\u9700\u8981\u521b\u5efa\u652f\u6301\u591a\u5c42\u7684\u4ea4\u6362\u94fe\u3002\u5e76\u4e14\u901a\u8fc7\u4e0d\u540c\u7684\u5c42\u4e3a\u6bcf\u4e00\u4e2a\u56fe\u50cf\u521b\u5efa\u591a\u4e2a\u89c6\u56fe\uff0c\u4ee5\u6ee1\u8db3\u4e0d\u540c\u5c42\u7684\u56fe\u50cf\u5728\u5de6\u53f3\u773c\u6e32\u67d3\u65f6\u5bf9\u89c6\u56fe\u7684\u9700\u8981\u3002 \u521b\u5efa\u56fe\u50cf\u89c6\u56fe\u8c03\u7528 vkCreateImageView \u51fd\u6570: if (vkCreateImageView(device, &createInfo, nullptr, &swapChainImageViews[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to create image views!\"); } C++ \u4e0e\u56fe\u50cf\u4e0d\u540c\u7684\u662f\uff0c\u56fe\u50cf\u89c6\u56fe\u9700\u8981\u660e\u786e\u7684\u521b\u5efa\u8fc7\u7a0b\uff0c\u6240\u4ee5\u5728\u7a0b\u5e8f\u9000\u51fa\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a\u5faa\u73af\u53bb\u9500\u6bc1\u4ed6\u4eec\u3002 void cleanup() { for (size_t i = 0; i < swapChainImageViews.size(); i++) { vkDestroyImageView(device, swapChainImageViews[i], nullptr); } ... } C++ \u62e5\u6709\u4e86\u56fe\u50cf\u89c6\u56fe\u540e\uff0c\u4f7f\u7528\u56fe\u50cf\u4f5c\u4e3a\u8d34\u56fe\u5df2\u7ecf\u8db3\u591f\u4e86\uff0c\u4f46\u662f\u5b83\u8fd8\u6ca1\u6709\u51c6\u5907\u597d\u4f5c\u4e3a\u6e32\u67d3\u7684 target \u3002\u5b83\u9700\u8981\u66f4\u591a\u7684\u95f4\u63a5\u6b65\u9aa4\u53bb\u51c6\u5907\uff0c\u5176\u4e2d\u4e00\u4e2a\u5c31\u662f framebuffer \uff0c\u88ab\u79f0\u4f5c\u5e27\u7f13\u51b2\u533a\u3002\u4f46\u9996\u5148\u6211\u4eec\u8981\u8bbe\u7f6e\u56fe\u5f62\u7ba1\u7ebf\u3002 Vulkan \u7740\u8272\u5668\u6a21\u5757 Vulkan \u7740\u8272\u5668\u6a21\u5757 \uff0c\u4e0e\u4e4b\u524d\u7684\u56fe\u50cf API \u4e0d\u540c\uff0c Vulkan \u4e2d\u7684\u7740\u8272\u5668\u4ee3\u7801\u5fc5\u987b\u4ee5\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u7684\u683c\u5f0f\u4f7f\u7528\uff0c\u800c\u4e0d\u662f\u50cf GLSL \u548c HLSL \u8fd9\u6837\u5177\u6709\u6bd4\u8f83\u597d\u7684\u53ef\u8bfb\u6027\u7684\u8bed\u6cd5\u3002\u6b64\u5b57\u8282\u683c\u5f0f\u6210\u4e3a SPIR-V \uff0c\u5b83\u53ef\u4ee5\u4e0e Vulkan \u548c OpenCL \u4e00\u540c\u4f7f\u7528\u3002\u8fd9\u662f\u4e00\u79cd\u53ef\u4ee5\u7f16\u5199\u56fe\u5f62\u548c\u8ba1\u7b97\u7740\u8272\u5668\u7684\u683c\u5f0f\uff0c\u4f46\u6211\u4eec\u91cd\u70b9\u4ecb\u7ecd\u672c\u6559\u7a0b\u4e2d Vulkan \u56fe\u5f62\u6d41\u6c34\u7ebf\u4f7f\u7528\u7684\u7740\u8272\u5668\u3002 \u4f7f\u7528\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u683c\u5f0f\u7684\u4f18\u70b9\u4e4b\u4e00\u662f \u4f7f\u5f97 GPU \u5382\u5546\u7f16\u5199\u5c06\u7740\u8272\u5668\u4ee3\u7801\u8f6c\u6362\u4e3a\u672c\u5730\u4ee3\u7801\u7684\u7f16\u8bd1\u5668\u590d\u6742\u5ea6\u51cf\u5c11\u4e86\u5f88\u591a\u3002\u7ecf\u9a8c\u8868\u660e\u4f7f\u7528\u53ef\u8bfb\u6027\u6bd4\u8f83\u5f3a\u7684\u8bed\u6cd5\uff0c\u6bd4\u5982 GLSL \u4e00\u4e9b GPU \u5382\u5546\u76f8\u5f53\u7075\u6d3b\u5730\u7406\u89e3\u8fd9\u4e2a\u6807\u51c6\u3002\u8fd9\u5bfc\u81f4\u4e00\u79cd\u60c5\u51b5\u4f1a\u53d1\u751f\uff0c\u6bd4\u5982\u7f16\u5199\u597d\uff0c\u5e76\u5728\u4e00\u4e2a\u5382\u5546\u7684 GPU \u8fd0\u884c\u7684\u4e0d\u9519\u7684\u7740\u8272\u5668\u7a0b\u5e8f\uff0c\u53ef\u80fd\u5728\u5176\u4ed6\u7684 GPU \u5382\u5546\u7684 GPU \u9a71\u52a8\u7a0b\u5e8f\u8fd0\u884c\u5f02\u5e38\uff0c\u53ef\u80fd\u662f\u8bed\u6cd5\u7684\u95ee\u9898\uff0c\u6216\u8005\u66f4\u7cdf\u7684\u662f\u4e0d\u540c GPU \u5382\u5546\u7f16\u5199\u7684\u7f16\u8bd1\u5668\u5dee\u5f02\uff0c\u5bfc\u81f4\u7740\u8272\u5668\u8fd0\u884c\u9519\u8bef\u3002\u5982\u679c\u76f4\u63a5\u4f7f\u7528\u7f16\u8bd1\u597d\u7684\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u683c\u5f0f\uff0c\u53ef\u4ee5\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\u3002 \u4f46\u662f\uff0c\u5e76\u4e0d\u610f\u5473\u7740\u6211\u4eec\u8981\u624b\u5199\u5b57\u8282\u7801\u3002 Khronos \u53d1\u5e03\u4e86\u4e0e\u5382\u5546\u65e0\u5173\u7684\u7f16\u8bd1\u5668\uff0c\u5b83\u5c06 GLSL \u7f16\u8bd1\u6210 SPIR-V \u3002\u8be5\u7f16\u8bd1\u5668\u7528\u4e8e\u9a8c\u8bc1\u7740\u8272\u5668\u4ee3\u7801\u662f\u5426\u7b26\u5408\u6807\u51c6\uff0c\u5e76\u751f\u6210\u4e0e Vulkan \u529f\u80fd\u8fd0\u884c\u7684 SPRIR-V \u4e8c\u8fdb\u5236\u6587\u4ef6\u3002\u9664\u6b64\u4e4b\u5916\u8fd8\u53ef\u4ee5\u5c06\u6b64\u7f16\u8bd1\u5668\u4f5c\u4e3a\u5e93\u5728\u8fd0\u884c\u65f6\u7f16\u8bd1\u751f\u6210 SPRI-V \uff0c\u4f46\u5728\u672c\u6559\u7a0b\u4e2d\u4e0d\u4f1a\u8fd9\u6837\u64cd\u4f5c\u3002\u7f16\u8bd1\u5668 glslangValidator.exe \u5305\u542b\u5728 LunarG SDK \u4e2d\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u4e0b\u8f7d\u4efb\u4f55\u989d\u5916\u7684\u5185\u5bb9\u3002 GLSL \u662f\u5177\u6709C\u98ce\u683c\u8bed\u6cd5\u7684\u7740\u8272\u8bed\u8a00\u3002\u5728\u7a0b\u5e8f\u4e2d\u9700\u8981\u5b9a\u4e49\u7f16\u5199 main \u51fd\u6570\u4f5c\u4e3a\u5165\u53e3\u3002 GLSL \u4e0d\u4f1a\u4f7f\u7528\u8f93\u5165\u53c2\u6570\u548c\u8fd4\u56de\u503c\u4f5c\u4e3a\u8f93\u51fa\uff0c\u800c\u662f\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\u6765\u5904\u7406\u8f93\u5165\u548c\u8f93\u51fa\u3002\u8be5\u8bed\u8a00\u5305\u62ec\u5f88\u591a\u529f\u80fd\u7b80\u5316\u56fe\u5f62\u7f16\u7a0b\uff0c\u6bd4\u5982\u5185\u7f6e\u7684\u57fa\u4e8e\u5411\u91cf\u548c\u77e9\u9635\u7684\u53c9\u79ef\u64cd\u4f5c\u51fd\u6570\uff0c\u77e9\u9635\u548c\u77e2\u91cf\u4e58\u6cd5\u64cd\u4f5c\u51fd\u6570\u3002\u77e2\u91cf\u7c7b\u578b\u4e3a vec \uff0c\u6570\u5b57\u8868\u793a\u5206\u91cf\u7684\u6570\u91cf\u3002\u4f8b\u59823D\u4f4d\u7f6e\u5b58\u50a8\u5728 vec3 \u4e2d\u3002\u53ef\u4ee5\u901a\u8fc7\u8bf8\u5982 .x \u4e4b\u7c7b\u7684\u6210\u5458\u8bbf\u95ee\u5355\u4e2a\u5206\u91cf\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u591a\u4e2a\u5206\u91cf\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5411\u91cf\u3002\u6bd4\u5982\uff0c\u8868\u8fbe\u5f0f vec3(1.0, 2.0, 3.0).xy \u622a\u53d6\u524d\u4e24\u4e2a\u5206\u91cf\uff0c\u5e76\u8d4b\u4e88\u65b0\u7684 vec2 \u4e2d\u3002\u5411\u91cf\u7684\u6784\u9020\u51fd\u6570\u4e5f\u53ef\u4ee5\u91c7\u7528\u77e2\u91cf\u5bf9\u8c61\u548c\u6807\u91cf\u503c\u7684\u7ec4\u5408\u3002\u6bd4\u5982 vec3 \u53ef\u4ee5\u7528 vec3(vec2(1.0, 2.0), 3.0) \u6784\u9020\u3002 \u5982\u524d\u9762\u63d0\u5230\u7684\u4e00\u6837\uff0c\u6211\u4eec\u9700\u8981\u7f16\u5199\u4e00\u4e2a vertex shader \u548c\u4e00\u4e2a fragment shader \u7ed8\u5236\u4e09\u89d2\u5f62\u5728\u5c4f\u5e55\u3002\u4e0b\u9762\u4e24\u4e2a\u5c0f\u8282\u4f1a\u63a2\u8ba8\u4e0e\u4e4b\u76f8\u5173\u7684 GLSL \u4ee3\u7801\uff0c\u5e76\u5c55\u793a\u5982\u4f55\u751f\u6210\u4e24\u4e2a SPIR-V \u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u6700\u540e\u52a0\u8f7d\u5230\u7a0b\u5e8f\u4e2d\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9876\u70b9\u7740\u8272\u5668 2 \u7247\u5143\u7740\u8272\u5668 3 \u9876\u70b9\u989c\u8272\u7ec4 4 \u7f16\u8bd1\u7740\u8272\u5668 5 \u52a0\u8f7d\u7740\u8272\u5668 6 \u521b\u5efa\u7740\u8272\u5668\u6a21\u578b 7 \u7740\u8272\u5668\u9636\u6bb5\u521b\u5efa \u9876\u70b9\u7740\u8272\u5668 \u9876\u70b9\u7740\u8272\u5668\u5904\u7406\u6bcf\u4e00\u4e2a\u9876\u70b9\u6570\u636e\u3002\u5b83\u7684\u5c5e\u6027\uff0c\u5982\u4e16\u754c\u5750\u6807\uff0c\u989c\u8272\uff0c\u6cd5\u7ebf\u548c\u7eb9\u7406UV\u5750\u6807\u4f5c\u4e3a\u8f93\u5165\u3002\u8f93\u51fa\u7684\u662f\u6700\u7ec8\u7684clip coordinates \u88c1\u526a\u5750\u6807\u548c\u9700\u8981\u4f20\u9012\u5230\u7247\u5143\u7740\u8272\u5668\u7684\u5c5e\u6027\uff0c\u5305\u62ec\u989c\u8272\u548c\u7eb9\u7406UV\u5750\u6807\u3002\u8fd9\u4e9b\u503c\u4f1a\u5728\u5149\u6805\u5316\u9636\u6bb5\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u4ee5\u4ea7\u751f\u5e73\u6ed1\u7684\u8fc7\u5ea6\u3002 \u88c1\u526a\u5750\u6807 clip coordinate \u662f\u4e00\u4e2a\u6765\u6b64\u9876\u70b9\u7740\u8272\u5668\u7684\u601d\u7ef4\u5411\u91cf\uff0c\u968f\u540e\u901a\u8fc7\u77e2\u91cf\u6700\u540e\u4e00\u4e2a\u5206\u91cf\u8fdb\u884c\u6574\u4f53\u5f52\u4e00\u5316\u64cd\u4f5c\u3002\u8fd9\u4e9b\u5f52\u4e00\u5316\u540e\u7684\u8bbe\u5907\u5750\u6807\u662f homogeneous coordinates ****\u6700\u7ec8\u6620\u5c04\u5230\u7f13\u51b2\u533a\u8303\u56f4\u4e3a [-1, 1] \u7684 [-1, 1] \u5750\u6807\u7cfb\u7edf\uff0c\u5982\u4e0b\u6240\u793a: \u5982\u679c\u4e4b\u524d\u7684\u8ba1\u7b97\u673a\u56fe\u5f62\u6bd4\u8f83\u719f\u6089\u7684\u8bdd\uff0c\u5bf9\u8fd9\u90e8\u5206\u4f1a\u6bd4\u8f83\u719f\u6089\u3002\u5982\u679c\u4f60\u4e4b\u524d\u4f7f\u7528\u8fc7 OpenGL \uff0c\u4f60\u4f1a\u6ce8\u610f\u5230Y\u5750\u6807\u8f74\u662f\u53cd\u8f6c\u7684\uff0cZ\u5750\u6807\u8f74\u7684\u8303\u56f4\u4e0e Direct3D \u662f\u4e00\u81f4\u7684\u8303\u56f4\uff0c\u4ece0\u52301. \u5bf9\u4e8e\u7b2c\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u6211\u4eec\u4e0d\u4f1a\u505a\u4efb\u4f55\u8f6c\u6362\u64cd\u4f5c\uff0c\u6211\u4eec\u5c06\u4e09\u4e2a\u9876\u70b9\u7684\u4f4d\u7f6e\u6307\u5b9a\u4e3a\u5f52\u4e00\u5316\u8bbe\u5907\u5750\u6807\uff0c\u521b\u5efa\u5982\u4e0b\u56fe\u5f62: \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5c06\u5176\u8f93\u51fa\u4e3a\u88c1\u526a\u5750\u6807\u76f4\u63a5\u8f93\u51fa\u5f52\u4e00\u5316\u7684\u8bbe\u5907\u5750\u6807\uff0c\u9876\u70b9\u7740\u8272\u5668\u7684\u5750\u6807\u4e0e\u6700\u540e\u4e00\u4e2a\u5206\u91cf\u8bbe\u7f6e\u4e3a 1 \u3002\u5c06\u88c1\u526a\u5750\u6807\u8f6c\u6362\u4e3a\u5f52\u4e00\u5316\u7684\u8bbe\u5907\u5750\u6807\u6ca1\u6709\u6539\u53d8\u4efb\u4f55\u4e1c\u897f\u3002 \u901a\u5e38\u60c5\u51b5\u4e0b\u9876\u70b9\u5750\u6807\u6570\u636e\u662f\u5b58\u50a8\u5728\u4e00\u4e2a\u9876\u70b9\u7f13\u51b2\u533a\u4e2d\uff0c\u4f46\u662f\u5728 Vulkan \u4e2d\u521b\u5efa\u4e00\u4e2a\u9876\u70b9\u7f13\u51b2\u533a\u5e76\u586b\u5145\u6570\u636e\u7684\u8fc7\u7a0b\u5e76\u4e0d\u662f\u76f4\u63a5\u7684\u3002\u6240\u4ee5\u6211\u4eec\u540e\u7f6e\u8fd9\u4e9b\u6b65\u9aa4\uff0c\u76f4\u5230\u6211\u4eec\u6ee1\u610f\u7684\u770b\u5230\u4e00\u4e2a\u4e09\u89d2\u5f62\u51fa\u73b0\u5728\u5c4f\u5e55\u4e0a\u3002\u540c\u65f6\u6211\u4eec\u9700\u8981\u505a\u4e00\u4e9b\u975e\u6b63\u7edf\u7684\u4e8b\u60c5:\u5c06\u5750\u6807\u76f4\u63a5\u5305\u542b\u5728\u9876\u70b9\u7740\u8272\u5668\u7684\u5185\u90e8\u3002\u4ee3\u7801\u5982\u4e0b\u6240\u793a: #version 450 #extension GL_ARB_separate_shader_objects : enable out gl_PerVertex { vec4 gl_Position; }; vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); } C++ main \u51fd\u6570\u7684\u6267\u884c\u5e94\u7528\u4e8e\u6bcf\u4e2a\u9876\u70b9\uff0c\u5185\u7f6e\u7684 gl_VertexIndex \u53d8\u91cf\u5305\u542b\u4e86\u5f53\u524d\u9876\u70b9\u7684\u7d22\u5f15\u4fe1\u606f\u3002\u901a\u5e38\u662f\u9876\u70b9\u7f13\u51b2\u533a\u7684\u7d22\u5f15\uff0c\u4f46\u662f\u5728\u8fd9\u91cc\u6211\u4eec\u786c\u7f16\u7801\u5230\u9876\u70b9\u6570\u636e\u7684\u96c6\u5408\u4e2d\u3002\u6bcf\u4e2a\u9876\u70b9\u7684\u4f4d\u7f6e\u4ece\u5e38\u91cf\u6570\u7ec4\u4e2d\u8bbf\u95ee\uff0c\u5e76\u4e0e z \u548c w \u5206\u91cf\u7ec4\u5408\u4f7f\u7528\uff0c\u4ee5\u4ea7\u751f\u88c1\u526a\u5750\u6807\u4e2d\u7684\u6709\u6548\u4f4d\u7f6e\u4fe1\u606f\u3002\u5185\u7f6e\u7684 gl_Position \u53d8\u91cf\u4f5c\u4e3a\u8f93\u51fa\u3002\u6700\u540eVulkan\u4e2d\u4f7f\u7528shader\uff0c\u9700\u8981\u786e\u4fdd GL_ARG_separate_shader_objects \u6269\u5c55\u5f00\u542f\u3002 \u7247\u5143\u7740\u8272\u5668 \u7531\u9876\u70b9\u7740\u8272\u5668\u7684\u4f4d\u7f6e\u6570\u636e\u5f62\u6210\u7684\u4e09\u89d2\u5f62\u7528\u7247\u6bb5\u7740\u8272\u5668\u586b\u5145\u5c4f\u5e55\u4e0a\u7684\u533a\u57df\u4e2d\u3002\u7247\u6bb5\u7740\u8272\u5668\u9488\u5bf9\u4e00\u4e2a\u6216\u8005\u591a\u4e2aframebuffer\u5e27\u7f13\u51b2\u533a\u7684\u6bcf\u4e2a\u7247\u5143\u4ea7\u751f\u5177\u4f53\u7684\u989c\u8272\u548c\u6df1\u5ea6\u4fe1\u606f\u3002\u4e00\u4e2a\u7b80\u5355\u7684\u7247\u6bb5\u7740\u8272\u5668\u4e3a\u5b8c\u6210\u7684\u4e09\u89d2\u5f62\u8f93\u51fa\u7ea2\u8272\u4fe1\u606f\u7684\u4ee3\u7801\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable layout(location = 0) out vec4 outColor; void main() { outColor = vec4(1.0, 0.0, 0.0, 1.0); } C++ fragment sahder\u4e2d\u7684 main \u51fd\u6570\u4e0e vertex shader \u4e2d\u7684 main \u51fd\u6570\u7c7b\u4f3c\uff0c\u4f1a\u4e3a\u6bcf\u4e00\u4e2a\u7247\u5143\u8c03\u7528\u5904\u7406\u3002\u989c\u8272\u7684\u4fe1\u606f\u5728GLSL\u4e2d\u662f4\u4e2a\u5206\u91cf\u7ec4\u6210\u7684\u77e2\u91cf\uff0c\u5305\u62ecR,G,B\u548cAlpha\u901a\u9053\uff0c\u503c\u57df\u6536\u655b\u5728[0, 1]\u8303\u56f4\u5185\u3002\u4e0d\u50cf\u9876\u70b9\u7740\u8272\u5668\u7684 gl_Position \uff0c\u5b83\u6ca1\u6709\u5185\u7f6e\u7684\u53d8\u91cf\u4e3a\u5f53\u524d\u7247\u5143\u8f93\u51fa\u989c\u8272\u4fe1\u606f\u3002\u5728\u8fd9\u91cc\u5fc5\u987b\u4e3aframebuffer\u5b9a\u4e49\u8f93\u51fa\u53d8\u91cf\uff0c layout(location = 0) \u4fee\u9970\u7b26\u660e\u786eframebuffer\u7684\u7d22\u5f15\u3002\u7ea2\u8272\u4fe1\u606f\u5199\u8fdb outColor \u53d8\u91cf\u4e2d\uff0c\u8be5\u53d8\u91cf\u94fe\u63a5\u7b2c\u4e00\u4e2aframebuffer\u4e2d\uff0c\u7d22\u5f15\u4e3a 0 \u3002 \u9876\u70b9\u989c\u8272\u7ec4 \u4e00\u4e2a\u7eaf\u7ea2\u8272\u7684\u4e09\u89d2\u5f62\u770b\u8d77\u6765\u5e76\u4e0d\u662f\u5f88\u9177\u70ab\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u8bd5\u7740\u9177\u70ab\u4e00\u4e9b\u5462? \u6211\u4eec\u9488\u5bf9\u4e24\u4e2a\u7c7b\u578b\u7684\u7740\u8272\u5668\u5c1d\u8bd5\u505a\u4e00\u4e9b\u6539\u53d8\uff0c\u5b8c\u6210\u4e0a\u56fe\u7684\u6548\u679c\u3002\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u6bcf\u4e2a\u9876\u70b9\u8bbe\u7f6e\u5dee\u5f02\u5316\u7684\u989c\u8272\u3002\u9876\u70b9\u7740\u8272\u5668\u5e94\u8be5\u5305\u542b\u4e00\u4e2a\u989c\u8272\u6570\u7ec4\uff0c\u5c31\u50cf\u4f4d\u7f6e\u4fe1\u606f\u7684\u6570\u7ec4\u4e00\u6837: vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) ); C++ \u73b0\u5728\u6211\u4eec\u9700\u8981\u628a\u6bcf\u4e2a\u9876\u70b9\u7684\u989c\u8272\u4f20\u9012\u5230\u7247\u6bb5\u7740\u8272\u5668\u4e2d\uff0c\u4ece\u800c\u8f93\u51fa\u7ecf\u8fc7\u63d2\u503c\u540e\u7684\u989c\u8272\u4fe1\u606f\u5230 framebuffer \u4e2d\u3002\u4e3a\u9876\u70b9\u7740\u8272\u5668\u6dfb\u589e\u52a0\u8f93\u51fa\u989c\u8272\u652f\u6301\uff0c\u5728 main \u51fd\u6570\u4e2d\u5b9a\u4e49\u5982\u4e0b: layout(location = 0) out vec3 fragColor; void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex]; } C++ \u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u9700\u8981\u5c06\u7247\u6bb5\u7740\u8272\u5668\u7684\u8f93\u5165\u5339\u914d\u9876\u70b9\u7740\u8272\u5668\u7684\u8f93\u51fa: layout(location = 0) in vec3 fragColor; void main() { outColor = vec4(fragColor, 1.0); } C++ \u8f93\u5165\u7684\u53d8\u91cf\u4e0d\u4e00\u5b9a\u8981\u540c\u540d\uff0c\u5b83\u4eec\u5c06\u901a\u8fc7 location \u7d22\u5f15\u6307\u4ee4\u94fe\u63a5\u5728\u4e00\u8d77\u3002 main \u51fd\u6570\u4e2d\u4fee\u6539\u5c06\u8981\u8f93\u51fa\u7684\u989c\u8272alpha\u503c\u3002\u5c31\u50cf\u4e4b\u524d\u8ba8\u8bba\u7684\u4e00\u6837\uff0c fragColor \u5c06\u4f1a\u4e3a\u4e09\u4e2a\u9876\u70b9\u6240\u5c5e\u7684\u7247\u5143\u81ea\u52a8\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u5f62\u6210\u5e73\u6ed1\u7684\u989c\u8272\u8fc7\u5ea6\u3002 \u7f16\u8bd1\u7740\u8272\u5668 \u5728\u9879\u76ee\u6839\u76ee\u5f55\u4e0b\u521b\u5efa\u4e00\u4e2a\u5b50\u76ee\u5f55\uff0c\u540d shaders \u7528\u4e8e\u5b58\u50a8\u9876\u70b9\u7740\u8272\u5668\u6587\u4ef6 shader.vert \u548c\u7247\u6bb5\u7740\u8272\u5668\u6587\u4ef6 shader.frag \u3002GLSL\u7740\u8272\u5668\u5b98\u65b9\u6ca1\u6709\u7ea6\u5b9a\u7684\u6269\u5c55\u540d\uff0c\u4f46\u662f\u8fd9\u4e24\u4e2a\u6269\u5c55\u540d\u662f\u6bd4\u8f83\u666e\u904d\u901a\u7528\u7684\u3002 shader.vert \u5185\u5bb9\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable out gl_PerVertex { vec4 gl_Position; }; layout(location = 0) out vec3 fragColor; vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex]; } C++ shader.frag \u6587\u4ef6\u5185\u5bb9\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable layout(location = 0) in vec3 fragColor; layout(location = 0) out vec4 outColor; void main() { outColor = vec4(fragColor, 1.0); } C++ \u73b0\u5728\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 glslangValidator \u7a0b\u5e8f\u7f16\u8bd1SPIR-V\u4e8c\u8fdb\u5236\u7801\u3002 \u521b\u5efa\u4e00\u4e2acompile.bat\u6279\u5904\u7406\u6587\u4ef6\uff0c\u5185\u5bb9\u5982\u4e0b: C:/VulkanSDK/1.0.17.0/Bin32/glslangValidator.exe -V shader.vert C:/VulkanSDK/1.0.17.0/Bin32/glslangValidator.exe -V shader.frag pause C++ \u5c06 glslangValidator.exe \u7684path\u8def\u5f84\u66ff\u6362\u4e3a\u4f60\u7684VulkanSDK\u5b89\u88c5\u8def\u5f84\uff0c\u7136\u540e\u53cc\u51fb\u8be5\u6587\u4ef6\u8fd0\u884c\u3002 \u8fd9\u4e24\u4e2a\u547d\u4ee4\u4f7f\u7528 -V \u6807\u5fd7\u8c03\u7528\u7f16\u8bd1\u5668\uff0c\u8be5\u6807\u5fd7\u544a\u8bc9\u5b83\u5c06GLSL\u6e90\u6587\u4ef6\u7f16\u8bd1\u4e3aSPIR-V\u5b57\u8282\u7801\u3002\u8fd0\u884c\u7f16\u8bd1\u811a\u672c\u65f6\uff0c\u4f1a\u770b\u5230\u521b\u5efa\u4e86\u4e24\u4e2aSPIR-V\u4e8c\u8fdb\u5236\u6587\u4ef6: vert.spv \u548c frag.spv \u3002\u8fd9\u4e9b\u540d\u79f0\u4ece\u7740\u8272\u5668\u4e2d\u6d3e\u751f\u800c\u6765\uff0c\u4f46\u662f\u53ef\u4ee5\u91cd\u547d\u540d\u4e3a\u4efb\u4f55\u540d\u5b57\u3002\u5728\u7f16\u8bd1\u7740\u8272\u5668\u65f6\uff0c\u53ef\u80fd\u6536\u5230\u5173\u4e8e\u67d0\u4e9b\u529f\u80fd\u7f3a\u5931\u7684\u8b66\u544a\u4fe1\u606f\uff0c\u5728\u8fd9\u91cc\u653e\u5fc3\u7684\u5ffd\u7565\u5b83\u4eec\u3002 \u5982\u679c\u7740\u8272\u5668\u5305\u542b\u8bed\u6cd5\u9519\u8bef\uff0c\u90a3\u4e48\u7f16\u8bd1\u5668\u4f1a\u6309\u7167\u60a8\u7684\u9884\u671f\u544a\u8bc9\u5177\u4f53\u7684\u884c\u53f7\u548c\u95ee\u9898\u3002\u5c1d\u8bd5\u7701\u7565\u4e00\u4e2a\u5206\u53f7\uff0c\u7136\u540e\u91cd\u65b0\u8fd0\u884c\u7f16\u8bd1\u811a\u672c\u3002\u8fd8\u53ef\u4ee5\u5c1d\u8bd5\u8fd0\u884c\u7f16\u8bd1\u5668\uff0c\u800c\u65e0\u9700\u4efb\u4f55\u53c2\u6570\u6765\u67e5\u770b\u5b83\u652f\u6301\u54ea\u4e9b\u7c7b\u578b\u7684\u6807\u5fd7\u3002\u4f8b\u5982\uff0c\u5b83\u53ef\u4ee5\u5c06\u5b57\u8282\u7801\u8f93\u51fa\u4e3a\u53ef\u8bfb\u7684\u683c\u5f0f\uff0c\u4ee5\u4fbf\u51c6\u786e\u4e86\u89e3\u7740\u8272\u5668\u6b63\u5728\u6267\u884c\u7684\u64cd\u4f5c\u4ee5\u53ca\u5728\u6b64\u9636\u6bb5\u5e94\u7528\u7684\u4efb\u4f55\u4f18\u5316\u3002 \u52a0\u8f7d\u7740\u8272\u5668 \u73b0\u5728\u6211\u4eec\u6709\u4e00\u79cd\u4ea7\u751fSPIR-V\u7740\u8272\u5668\u7684\u65b9\u6cd5\uff0c\u662f\u65f6\u5019\u52a0\u8f7d\u5b83\u4eec\u5230\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\uff0c\u4ee5\u4fbf\u5728\u9002\u5f53\u7684\u65f6\u5019\u63d2\u5165\u5230\u56fe\u5f62\u7ba1\u7ebf\u4e2d\u3002\u9996\u5148\u6211\u4eec\u7f16\u5199\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\u7528\u4ee5\u52a0\u8f7d\u4e8c\u8fdb\u5236\u6570\u636e\u6587\u4ef6\u3002 #include <fstream> ... static std::vector<char> readFile(const std::string& filename) { std::ifstream file(filename, std::ios::ate | std::ios::binary); if (!file.is_open()) { throw std::runtime_error(\"failed to open file!\"); } } C++ readFile \u51fd\u6570\u5c06\u4f1a\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6240\u6709\u7684\u4e8c\u8fdb\u5236\u6570\u636e\uff0c\u5e76\u7528 std::vector \u5b57\u8282\u96c6\u5408\u7ba1\u7406\u3002\u6211\u4eec\u4f7f\u7528\u4e24\u4e2a\u6807\u5fd7\u7528\u4ee5\u6253\u5f00\u6587\u4ef6: ate :\u5728\u6587\u4ef6\u672b\u5c3e\u5f00\u59cb\u8bfb\u53d6 binary :\u4ee5\u4e8c\u8fdb\u5236\u683c\u5f0f\u53bb\u8bfb\u6587\u4ef6(\u907f\u514d\u5b57\u7b26\u683c\u5f0f\u7684\u8f6c\u4e49) \u4ece\u6587\u4ef6\u672b\u5c3e\u5f00\u59cb\u8bfb\u53d6\u7684\u4f18\u70b9\u662f\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u8bfb\u53d6\u4f4d\u7f6e\u6765\u786e\u5b9a\u6587\u4ef6\u7684\u5927\u5c0f\u5e76\u5206\u914d\u7f13\u51b2\u533a: size_t fileSize = (size_t) file.tellg(); std::vector<char> buffer(fileSize); C++ \u4e4b\u540e\u6211\u4eec\u53ef\u4ee5\u8ffd\u6eaf\u5230\u6587\u4ef6\u7684\u5f00\u5934\uff0c\u540c\u65f6\u8bfb\u53d6\u6240\u6709\u7684\u5b57\u8282: file.seekg(0); file.read(buffer.data(), fileSize); C++ \u6700\u540e\u5173\u95ed\u6587\u4ef6\uff0c\u8fd4\u56de\u5b57\u8282\u6570\u636e: file.close(); return buffer; C++ \u6211\u4eec\u8c03\u7528\u51fd\u6570createGraphicsPipeline\u52a0\u8f7d\u4e24\u4e2a\u7740\u8272\u5668\u7684\u4e8c\u8fdb\u5236\u7801: void createGraphicsPipeline() { auto vertShaderCode = readFile(\"shaders/vert.spv\"); auto fragShaderCode = readFile(\"shaders/frag.spv\"); } C++ \u786e\u4fdd\u7740\u8272\u5668\u6b63\u786e\u52a0\u8f7d\uff0c\u5e76\u6253\u5370\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u662f\u5426\u4e0e\u6587\u4ef6\u5b9e\u9645\u5927\u5c0f\u4e00\u81f4\u3002 \u521b\u5efa\u7740\u8272\u5668\u6a21\u578b \u5728\u5c06\u4ee3\u7801\u4f20\u9012\u7ed9\u6e32\u67d3\u7ba1\u7ebf\u4e4b\u524d\uff0c\u6211\u4eec\u5fc5\u987b\u5c06\u5176\u5c01\u88c5\u5230 VkShaderModule \u5bf9\u8c61\u4e2d\u3002\u8ba9\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570 createShaderModule \u5b9e\u73b0\u8be5\u903b\u8f91\u3002 VkShaderModule createShaderModule(const std::vector<char>& code) { } C++ \u8be5\u51fd\u6570\u9700\u8981\u5b57\u8282\u7801\u7684\u7f13\u51b2\u533a\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u901a\u8fc7\u7f13\u51b2\u533a\u521b\u5efa VkShaderModule \u3002 \u521b\u5efashader module\u662f\u6bd4\u8f83\u7b80\u5355\u7684\uff0c\u6211\u4eec\u4ec5\u4ec5\u9700\u8981\u6307\u5b9a\u4e8c\u8fdb\u5236\u7801\u7f13\u51b2\u533a\u7684\u6307\u9488\u548c\u5b83\u7684\u5177\u4f53\u957f\u5ea6\u3002\u8fd9\u4e9b\u4fe1\u606f\u88ab\u586b\u5145\u5728 VkShaderModuleCreateInfo \u7ed3\u6784\u4f53\u4e2d\u3002\u9700\u8981\u7559\u610f\u7684\u662f\u5b57\u8282\u7801\u7684\u5927\u5c0f\u662f\u4ee5\u5b57\u8282\u6307\u5b9a\u7684\uff0c\u4f46\u662f\u5b57\u8282\u7801\u6307\u9488\u662f\u4e00\u4e2a uint32_t \u7c7b\u578b\u7684\u6307\u9488\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a char \u6307\u9488\u3002\u6240\u4ee5\u6211\u4eec\u4f7f\u7528 reinterpret_cast \u8fdb\u884c\u8f6c\u6362\u6307\u9488\u3002\u5982\u4e0b\u6240\u793a\uff0c\u5f53\u9700\u8981\u8f6c\u6362\u65f6\uff0c\u8fd8\u9700\u8981\u786e\u4fdd\u6570\u636e\u6ee1\u8db3 uint32_t \u7684\u5bf9\u9f50\u8981\u6c42\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u6570\u636e\u5b58\u50a8\u5728 std::vector \u4e2d\uff0c\u9ed8\u8ba4\u5206\u914d\u5668\u5df2\u7ecf\u786e\u4fdd\u6570\u636e\u6ee1\u8db3\u6700\u5dee\u60c5\u51b5\u4e0b\u7684\u5bf9\u9f50\u8981\u6c42\u3002 VkShaderModuleCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; createInfo.codeSize = code.size(); createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data()); C++ \u8c03\u7528 vkCreateShaderMoudle \u521b\u5efa VkShaderModule : VkShaderModule shaderModule; if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) { throw std::runtime_error(\"failed to create shader module!\"); } C++ \u53c2\u6570\u4e0e\u4e4b\u524d\u521b\u5efa\u5bf9\u8c61\u529f\u80fd\u7c7b\u4f3c:\u903b\u8f91\u8bbe\u5907\uff0c\u521b\u5efa\u5bf9\u8c61\u4fe1\u606f\u7ed3\u6784\u4f53\u7684\u6307\u9488\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u4fdd\u5b58\u7ed3\u679c\u7684\u53e5\u67c4\u53d8\u91cf\u3002\u5728shader module\u521b\u5efa\u5b8c\u6bd5\u540e\uff0c\u53ef\u4ee5\u5bf9\u4e8c\u8fdb\u5236\u7801\u7684\u7f13\u51b2\u533a\u8fdb\u884c\u7acb\u5373\u7684\u91ca\u653e\u3002\u6700\u540e\u4e0d\u8981\u5fd8\u8bb0\u8fd4\u56de\u521b\u5efa\u597d\u7684shader module\u3002 return shaderModule; C++ shader module\u5bf9\u8c61\u4ec5\u4ec5\u5728\u6e32\u67d3\u7ba1\u7ebf\u5904\u7406\u8fc7\u7a0b\u4e2d\u9700\u8981\uff0c\u6240\u4ee5\u6211\u4eec\u4f1a\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u5b9a\u4e49\u672c\u5730\u53d8\u91cf\u4fdd\u5b58\u5b83\u4eec\uff0c\u800c\u4e0d\u662f\u5b9a\u4e49\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709\u5b83\u4eec\u7684\u53e5\u67c4: VkShaderModule vertShaderModule; VkShaderModule fragShaderModule; C++ \u8c03\u7528\u52a0\u8f7dshader module\u7684\u8f85\u52a9\u51fd\u6570: vertShaderModule = createShaderModule(vertShaderCode); fragShaderModule = createShaderModule(fragShaderCode); C++ \u5728\u56fe\u5f62\u7ba1\u7ebf\u521b\u5efa\u5b8c\u6210\u4e14 createGraphicsPipeline \u51fd\u6570\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u5b83\u4eec\u5e94\u8be5\u88ab\u6e05\u7406\u6389\uff0c\u6240\u4ee5\u5728\u8be5\u51fd\u6570\u540e\u5220\u9664\u5b83\u4eec: ... vkDestroyShaderModule(device, fragShaderModule, nullptr); vkDestroyShaderModule(device, vertShaderModule, nullptr); } C++ \u7740\u8272\u5668\u9636\u6bb5\u521b\u5efa VkShaderModule \u5bf9\u8c61\u53ea\u662f\u5b57\u8282\u7801\u7f13\u51b2\u533a\u7684\u4e00\u4e2a\u5305\u88c5\u5bb9\u5668\u3002\u7740\u8272\u5668\u5e76\u6ca1\u6709\u5f7c\u6b64\u94fe\u63a5\uff0c\u751a\u81f3\u6ca1\u6709\u7ed9\u51fa\u76ee\u7684\u3002\u901a\u8fc7 VkPipelineShaderStageCreateInfo \u7ed3\u6784\u5c06\u7740\u8272\u5668\u6a21\u5757\u5206\u914d\u5230\u7ba1\u7ebf\u4e2d\u7684\u9876\u70b9\u6216\u8005\u7247\u6bb5\u7740\u8272\u5668\u9636\u6bb5\u3002VkPipelineShaderStageCreateInfo\u7ed3\u6784\u4f53\u662f\u5b9e\u9645\u7ba1\u7ebf\u521b\u5efa\u8fc7\u7a0b\u7684\u4e00\u90e8\u5206\u3002 \u6211\u4eec\u9996\u5148\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u586b\u5199\u9876\u70b9\u7740\u8272\u5668\u7ed3\u6784\u4f53\u3002 VkPipelineShaderStageCreateInfo vertShaderStageInfo = {}; vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; C++ \u9664\u4e86\u5f3a\u5236\u7684 sType \u6210\u5458\u5916\uff0c\u7b2c\u4e00\u4e2a\u9700\u8981\u544a\u77e5Vulkan\u5c06\u5728\u54ea\u4e2a\u6d41\u6c34\u7ebf\u9636\u6bb5\u4f7f\u7528\u7740\u8272\u5668\u3002\u5728\u4e0a\u4e00\u4e2a\u7ae0\u8282\u7684\u6bcf\u4e2a\u53ef\u7f16\u7a0b\u9636\u6bb5\u90fd\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u679a\u4e3e\u503c\u3002 vertShaderStageInfo.module = vertShaderModule; vertShaderStageInfo.pName = \"main\"; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u6210\u5458\u6307\u5b9a\u5305\u542b\u4ee3\u7801\u7684\u7740\u8272\u5668\u6a21\u5757\u548c\u8c03\u7528\u7684\u4e3b\u51fd\u6570\u3002\u8fd9\u610f\u5473\u7740\u53ef\u4ee5\u5c06\u591a\u4e2a\u7247\u6bb5\u7740\u8272\u5668\u7ec4\u5408\u5230\u5355\u4e2a\u7740\u8272\u5668\u6a21\u5757\u4e2d\uff0c\u5e76\u4f7f\u7528\u4e0d\u540c\u7684\u5165\u53e3\u70b9\u6765\u533a\u5206\u5b83\u4eec\u7684\u884c\u4e3a\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u575a\u6301\u4f7f\u7528\u6807\u51c6 main \u51fd\u6570\u4f5c\u4e3a\u5165\u53e3\u3002 \u8fd8\u6709\u4e00\u4e2a\u53ef\u9009\u6210\u5458\uff0c pSpecializationInfo ,\u5728\u8fd9\u91cc\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u5b83\uff0c\u4f46\u662f\u503c\u5f97\u8ba8\u8bba\u4e00\u4e0b\u3002\u5b83\u5141\u8bb8\u4e3a\u7740\u8272\u5668\u6307\u5b9a\u5e38\u91cf\u503c\u3002\u4f7f\u7528\u5355\u4e2a\u7740\u8272\u5668\u6a21\u5757\uff0c\u901a\u8fc7\u4e3a\u5176\u4e2d\u4f7f\u7528\u4e0d\u540c\u7684\u5e38\u91cf\u503c\uff0c\u53ef\u4ee5\u5728\u6d41\u6c34\u7ebf\u521b\u5efa\u65f6\u5bf9\u884c\u4e3a\u8fdb\u884c\u914d\u7f6e\u3002\u8fd9\u6bd4\u5728\u6e32\u67d3\u65f6\u4f7f\u7528\u53d8\u91cf\u914d\u7f6e\u7740\u8272\u5668\u66f4\u6709\u6548\u7387\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u53ef\u4ee5\u8fdb\u884c\u4f18\u5316\uff0c\u4f8b\u5982\u6d88\u9664 if \u503c\u5224\u65ad\u7684\u8bed\u53e5\u3002\u5982\u679c\u6ca1\u6709\u8fd9\u6837\u7684\u5e38\u91cf\uff0c\u53ef\u4ee5\u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a nullptr \uff0c\u6211\u4eec\u7684struct\u7ed3\u6784\u4f53\u521d\u59cb\u5316\u81ea\u52a8\u8fdb\u884c\u3002 \u4fee\u6539\u7ed3\u6784\u4f53\u6ee1\u8db3\u7247\u6bb5\u7740\u8272\u5668\u7684\u9700\u8981: VkPipelineShaderStageCreateInfo fragShaderStageInfo = {}; fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; fragShaderStageInfo.module = fragShaderModule; fragShaderStageInfo.pName = \"main\"; C++ \u5b8c\u6210\u4e24\u4e2a\u7ed3\u6784\u4f53\u7684\u521b\u5efa\uff0c\u5e76\u901a\u8fc7\u6570\u7ec4\u4fdd\u5b58\uff0c\u8fd9\u90e8\u5206\u5f15\u7528\u5c06\u4f1a\u5728\u5b9e\u9645\u7684\u7ba1\u7ebf\u521b\u5efa\u5f00\u59cb\u3002 VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo}; C++ \u5230\u6b64\u4e3a\u6b62\uff0c\u5c31\u662f\u6240\u6709\u5173\u4e8e\u53ef\u7f16\u7a0b\u7ba1\u7ebf\u9636\u6bb5\u7684\u903b\u8f91\u3002\u5728 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u4f1a\u770b\u4e00\u4e0b\u56fa\u5b9a\u7ba1\u7ebf\u5404\u4e2a\u9636\u6bb5\u3002 Vulkan \u56fa\u6709\u529f\u80fd Vulkan \u56fa\u6709\u529f\u80fd \uff0c\u65e9\u8d77\u7684\u56fe\u5f62API\u5728\u56fe\u5f62\u6e32\u67d3\u7ba1\u7ebf\u7684\u8bb8\u591a\u9636\u6bb5\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u7684\u72b6\u6001\u3002\u5728 Vulkan \u4e2d\uff0c\u4ece viewport \u7684\u5927\u5c0f\u5230\u6df7\u8272\u51fd\u6570\uff0c\u9700\u8981\u51e1\u4e8b\u505a\u5230\u4eb2\u5386\u4eb2\u4e3a\u3002\u5728\u672c\u7ae0\u8282\u4e2d\u6211\u4eec\u4f1a\u586b\u5145\u6709\u5173\u56fa\u6709\u529f\u80fd\u64cd\u4f5c\u7684\u6240\u6709\u7ed3\u6784\u4f53\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9876\u70b9\u8f93\u5165 2 \u8f93\u5165\u7ec4\u4ef6 3 \u89c6\u7a97\u548c\u88c1\u526a 4 \u5149\u6805\u5316 5 \u91cd\u91c7\u6837 6 \u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5 7 \u989c\u8272\u6df7\u5408 8 \u52a8\u6001\u4fee\u6539 9 \u7ba1\u9053\u5e03\u5c40 10 \u7ed3\u8bba \u9876\u70b9\u8f93\u5165 VkPipelineVertexInputStateCreateInfo \u7ed3\u6784\u4f53\u63cf\u8ff0\u4e86\u9876\u70b9\u6570\u636e\u7684\u683c\u5f0f\uff0c\u8be5\u7ed3\u6784\u4f53\u6570\u636e\u4f20\u9012\u5230 vertex shader \u4e2d\u3002\u5b83\u4ee5\u4e24\u79cd\u65b9\u5f0f\u8fdb\u884c\u63cf\u8ff0: Bindings :\u6839\u636e\u6570\u636e\u7684\u95f4\u9699\uff0c\u786e\u5b9a\u6570\u636e\u662f\u6bcf\u4e2a\u9876\u70b9\u6216\u8005\u662f\u6bcf\u4e2ainstance( instancing ) Attribute \u63cf\u8ff0:\u63cf\u8ff0\u5c06\u8981\u8fdb\u884c\u7ed1\u5b9a\u53ca\u52a0\u8f7d\u5c5e\u6027\u7684\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684\u76f8\u5173\u5c5e\u6027\u7c7b\u578b\u3002 \u56e0\u4e3a\u6211\u4eec\u5c06\u9876\u70b9\u6570\u636e\u786c\u7f16\u7801\u5230 vertex shader \u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u5c06\u8981\u586b\u5145\u7684\u7ed3\u6784\u4f53\u6ca1\u6709\u9876\u70b9\u6570\u636e\u53bb\u52a0\u8f7d\u3002\u6211\u4eec\u5c06\u4f1a\u5728 vertex buffer \u7ae0\u8282\u4e2d\u56de\u6765\u64cd\u4f5c\u3002 VkPipelineVertexInputStateCreateInfo vertexInputInfo = {}; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.pVertexBindingDescriptions = nullptr; // Optional vertexInputInfo.vertexAttributeDescriptionCount = 0; vertexInputInfo.pVertexAttributeDescriptions = nullptr; // Optional C++ pVertexBindingDescriptions \u548c pVertexAttributeDescriptions \u6210\u5458\u6307\u5411\u7ed3\u6784\u4f53\u6570\u7ec4\uff0c\u7528\u4e8e\u8fdb\u4e00\u6b65\u63cf\u8ff0\u52a0\u8f7d\u7684\u9876\u70b9\u6570\u636e\u4fe1\u606f\u3002\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u7684 shaderStages \u6570\u7ec4\u540e\u6dfb\u52a0\u8be5\u7ed3\u6784\u4f53\u3002 \u8f93\u5165\u7ec4\u4ef6 VkPipelineInputAssemblyStateCreateInfo \u7ed3\u6784\u4f53\u63cf\u8ff0\u4e24\u4ef6\u4e8b\u60c5:\u9876\u70b9\u6570\u636e\u4ee5\u4ec0\u4e48\u7c7b\u578b\u7684\u51e0\u4f55\u56fe\u5143\u62d3\u6251\u8fdb\u884c\u7ed8\u5236\u53ca\u662f\u5426\u542f\u7528\u9876\u70b9\u7d22\u91cd\u65b0\u5f00\u59cb\u56fe\u5143\u3002\u56fe\u5143\u7684\u62d3\u6251\u7ed3\u6784\u7c7b\u578b topology \u679a\u4e3e\u503c\u5982\u4e0b: VK_PRIMITIVE_TOPOLOGY_POINT_LIST : \u9876\u70b9\u5230\u70b9 VK_PRIMITIVE_TOPOLOGY_LINE_LIST : \u4e24\u70b9\u6210\u7ebf\uff0c\u9876\u70b9\u4e0d\u5171\u7528 VK_PRIMITIVE_TOPOLOGY_LINE_STRIP : \u4e24\u70b9\u6210\u7ebf\uff0c\u6bcf\u4e2a\u7ebf\u6bb5\u7684\u7ed3\u675f\u9876\u70b9\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u7ebf\u6bb5\u7684\u5f00\u59cb\u9876\u70b9 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST : \u4e09\u70b9\u6210\u9762\uff0c\u9876\u70b9\u4e0d\u5171\u7528 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP : \u6bcf\u4e2a\u4f46\u6559\u8bad\u7684\u7b2c\u4e8c\u4e2a\u3001\u7b2c\u4e09\u4e2a\u9876\u70b9\u90fd\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u4e09\u89d2\u5f62\u7684\u524d\u4e24\u4e2a\u9876\u70b9 \u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u9876\u70b9\u6570\u636e\u6309\u7167\u7f13\u51b2\u533a\u4e2d\u7684\u5e8f\u5217\u4f5c\u4e3a\u7d22\u5f15\uff0c\u4f46\u662f\u4e5f\u53ef\u4ee5\u901a\u8fc7element buffer\u7f13\u51b2\u533a\u81ea\u884c\u6307\u5b9a\u9876\u70b9\u6570\u636e\u7684\u7d22\u5f15\u3002\u901a\u8fc7\u590d\u7528\u9876\u70b9\u6570\u636e\u63d0\u5347\u6027\u80fd\u3002\u5982\u679c\u8bbe\u7f6e primitiveRestartEnable \u6210\u5458\u4e3a VK_TRUE \uff0c\u53ef\u4ee5\u901a\u8fc7 0xFFFF \u6216\u8005 0xFFFFFFFF \u4f5c\u4e3a\u7279\u6b8a\u7d22\u5f15\u6765\u5206\u89e3\u7ebf\u548c\u4e09\u89d2\u5f62\u5728 _STRIP \u6a21\u5f0f\u4e0b\u7684\u56fe\u5143\u62d3\u6251\u7ed3\u6784\u3002 \u901a\u8fc7\u672c\u6559\u7a0b\u7ed8\u5236\u4e09\u89d2\u5f62\uff0c\u6240\u4ee5\u6211\u4eec\u575a\u6301\u6309\u7167\u5982\u4e0b\u683c\u5f0f\u586b\u5145\u6570\u636e\u7ed3\u6784: VkPipelineInputAssemblyStateCreateInfo inputAssembly = {}; inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; inputAssembly.primitiveRestartEnable = VK_FALSE; C++ \u89c6\u7a97\u548c\u88c1\u526a Viewport\u7528\u4e8e\u63cf\u8ff0framebuffer\u4f5c\u4e3a\u6e32\u67d3\u8f93\u51fa\u7ed3\u679c\u76ee\u6807\u533a\u57df\u3002\u5b83\u7684\u6570\u503c\u5728\u672c\u6559\u7a0b\u4e2d\u603b\u662f\u8bbe\u7f6e\u5728 (0, 0) \u548c (width, height) \u3002 VkViewport viewport = {}; viewport.x = 0.0f; viewport.y = 0.0f; viewport.width = (float) swapChainExtent.width; viewport.height = (float) swapChainExtent.height; viewport.minDepth = 0.0f; viewport.maxDepth = 1.0f; C++ \u8bb0\u5f97\u4ea4\u6362\u94fe\u548c\u5b83\u7684images\u56fe\u50cf\u5927\u5c0f WIDTH \u548c HEIGHT \u4f1a\u6839\u636e\u4e0d\u540c\u7684\u7a97\u4f53\u800c\u4e0d\u540c\u3002\u4ea4\u6362\u94fe\u56fe\u50cf\u5c06\u4f1a\u5728\u5e27\u7f13\u51b2\u533aframebuffers\u4f7f\u7528\uff0c\u6240\u4ee5\u6211\u4eec\u5e94\u8be5\u575a\u6301\u5b83\u4eec\u7684\u5927\u5c0f\u3002 minDepth \u548c maxDepth \u6570\u503c\u6307\u5b9aframebuffer\u4e2d\u6df1\u5ea6\u7684\u8303\u56f4\u3002\u8fd9\u4e9b\u6570\u503c\u5fc5\u987b\u6536\u655b\u5728 [0.0f, 1.0f] \u533a\u95f4\u51b2\uff0c\u4f46\u662f minDepth \u53ef\u80fd\u4f1a\u5927\u4e8e maxDepth \u3002\u5982\u679c\u4f60\u4e0d\u505a\u4efb\u4f55\u6307\u5b9a\uff0c\u5efa\u8bae\u4f7f\u7528\u6807\u51c6\u7684\u6570\u503c 0.0 f\u548c 1.0f \u3002 viewports \u5b9a\u4e49\u4e86image\u56fe\u50cf\u5230framebuffer\u5e27\u7f13\u51b2\u533a\u7684\u8f6c\u6362\u5173\u7cfb\uff0c\u88c1\u526a\u77e9\u5f62\u5b9a\u4e49\u4e86\u54ea\u4e9b\u533a\u57df\u7684\u50cf\u7d20\u88ab\u5b58\u50a8\u3002\u4efb\u4f55\u5728\u88c1\u526a\u5de8\u578b\u5916\u7684\u50cf\u7d20\u90fd\u4f1a\u5728\u5149\u6805\u5316\u9636\u6bb5\u4e22\u5f03\u3002\u5b83\u4eec\u7684\u529f\u80fd\u66f4\u50cf\u8fc7\u6ee4\u5668\u800c\u4e0d\u662f\u5b9a\u4e49\u8f6c\u6362\u5173\u7cfb\u3002\u8fd9\u4e2a\u533a\u522b\u5982\u4e0b\u56fe\u6240\u793a\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5bf9\u4e8e\u56fe\u50cf\u6bd4 viewport \u5c3a\u5bf8\u5927\u7684\u60c5\u5f62\uff0c\u5de6\u4fa7\u7684\u88c1\u526a\u77e9\u5f62\u53ea\u662f\u4f17\u591a\u53ef\u80fd\u7684\u4e00\u4e2a\u8868\u73b0\u3002 \u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u9700\u8981\u5c06\u56fe\u50cf\u7ed8\u5236\u5230\u5b8c\u6574\u7684\u5e27\u7f13\u51b2\u533a framebuffer \u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u5b9a\u4e49\u88c1\u526a\u77e9\u5f62\u8986\u76d6\u5230\u6574\u4f53\u56fe\u50cf: VkRect2D scissor = {}; scissor.offset = {0, 0}; scissor.extent = swapChainExtent; C++ viewport\u548c\u88c1\u526a\u77e9\u5f62\u9700\u8981\u501f\u52a9 VkPipelineViewportStateCreateInfo \u7ed3\u6784\u4f53\u8054\u5408\u4f7f\u7528\u3002\u53ef\u4ee5\u4f7f\u7528\u591a viewports \u548c\u88c1\u526a\u77e9\u5f62\u5728\u4e00\u4e9b\u56fe\u5f62\u5361\uff0c\u901a\u8fc7\u6570\u7ec4\u5f15\u7528\u3002\u4f7f\u7528\u8be5\u7279\u6027\u9700\u8981GPU\u652f\u6301\u8be5\u529f\u80fd\uff0c\u5177\u4f53\u770b\u903b\u8f91\u8bbe\u5907\u7684\u521b\u5efa\u3002 VkPipelineViewportStateCreateInfo viewportState = {}; viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; viewportState.pScissors = &scissor; C++ \u5149\u6805\u5316 \u5149\u6805\u5316\u901a\u8fc7\u9876\u70b9\u7740\u8272\u5668\u53ca\u5177\u4f53\u7684\u51e0\u4f55\u7b97\u6cd5\u5c06\u9876\u70b9\u8fdb\u884c\u5851\u5f62\uff0c\u5e76\u5c06\u56fe\u5f62\u4f20\u9012\u5230\u7247\u6bb5\u7740\u8272\u5668\u8fdb\u884c\u7740\u8272\u5de5\u4f5c\u3002\u5b83\u4e5f\u4f1a\u6267\u884c\u6df1\u5ea6\u6d4b\u8bd5 depth testing \u3001\u9762\u88c1\u5207 face culling \u548c\u88c1\u526a\u6d4b\u8bd5\uff0c\u5b83\u53ef\u4ee5\u5bf9\u8f93\u51fa\u7684\u7247\u5143\u8fdb\u884c\u914d\u7f6e\uff0c\u51b3\u5b9a\u662f\u5426\u8f93\u51fa\u6574\u4e2a\u56fe\u5143\u62d3\u6251\u6216\u8005\u662f\u8fb9\u6846(\u7ebf\u6846\u6e32\u67d3)\u3002\u6240\u6709\u7684\u914d\u7f6e\u901a\u8fc7 VkPipelineRasterizationStateCreateInfo \u7ed3\u6784\u4f53\u5b9a\u4e49\u3002 VkPipelineRasterizationStateCreateInfo rasterizer = {}; rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterizer.depthClampEnable = VK_FALSE; C++ \u5b83\u7684 depthClampEnable \u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u8d85\u8fc7\u8fdc\u8fd1\u88c1\u526a\u9762\u7684\u7247\u5143\u4f1a\u8fdb\u884c\u6536\u655b\uff0c\u800c\u4e0d\u662f\u4e22\u5f03\u5b83\u4eec\u3002\u5b83\u5728\u7279\u6b8a\u7684\u60c5\u51b5\u4e0b\u6bd4\u8f83\u6709\u7528\uff0c\u50cf\u9634\u5f71\u8d34\u56fe\u3002\u4f7f\u7528\u8be5\u529f\u80fd\u9700\u8981\u5f97\u5230 GPU \u7684\u652f\u6301\u3002 rasterizer.rasterizerDiscardEnable = VK_FALSE; C++ \u5982\u679c rasterizerDiscardEnable \u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u90a3\u4e48\u51e0\u4f55\u56fe\u5143\u6c38\u8fdc\u4e0d\u4f1a\u4f20\u9012\u5230\u5149\u6805\u5316\u9636\u6bb5\u3002\u8fd9\u662f\u57fa\u672c\u7684\u7981\u6b62\u4efb\u4f55\u8f93\u51fa\u5230framebuffer\u5e27\u7f13\u51b2\u533a\u7684\u65b9\u6cd5\u3002 rasterizer.polygonMode = VK_POLYGON_MODE_FILL; C++ polygonMode \u51b3\u5b9a\u51e0\u4f55\u4ea7\u751f\u56fe\u7247\u7684\u5185\u5bb9\u3002\u4e0b\u5217\u6709\u6548\u6a21\u5f0f: VK_POLYGON_MODE_FILL : \u591a\u8fb9\u5f62\u533a\u57df\u586b\u5145 VK_POLYGON_MODE_LINE : \u591a\u8fb9\u5f62\u8fb9\u7f18\u7ebf\u6846\u7ed8\u5236 VK_POLYGON_MODE_POINT : \u591a\u8fb9\u5f62\u9876\u70b9\u4f5c\u4e3a\u63cf\u70b9\u7ed8\u5236 \u4f7f\u7528\u4efb\u4f55\u6a21\u5f0f\u586b\u5145\u9700\u8981\u5f00\u542fGPU\u529f\u80fd\u3002 rasterizer.lineWidth = 1.0f; C++ lineWidth \u6210\u5458\u662f\u76f4\u63a5\u586b\u5145\u7684\uff0c\u6839\u636e\u7247\u5143\u7684\u6570\u91cf\u63cf\u8ff0\u7ebf\u7684\u5bbd\u5ea6\u3002\u6700\u5927\u7684\u7ebf\u5bbd\u652f\u6301\u53d6\u51b3\u4e8e\u786c\u4ef6\uff0c\u4efb\u4f55\u5927\u4e8e 1.0 \u7684\u7ebf\u5bbd\u9700\u8981\u5f00\u542fGPU\u7684 wideLines \u7279\u6027\u652f\u6301\u3002 rasterizer.cullMode = VK_CULL_MODE_BACK_BIT; rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; C++ cullMode \u53d8\u91cf\u7528\u4e8e\u51b3\u5b9a\u9762\u88c1\u526a\u7684\u7c7b\u578b\u65b9\u5f0f\u3002\u53ef\u4ee5\u7981\u6b62 culling \uff0c\u88c1\u526a front faces \uff0c cull back faces \u6216\u8005\u5168\u90e8\u3002 frontFace \u7528\u4e8e\u63cf\u8ff0\u4f5c\u4e3a front-facing \u9762\u7684\u9876\u70b9\u7684\u987a\u5e8f\uff0c\u53ef\u4ee5\u662f\u987a\u65f6\u9488\u4e5f\u53ef\u4ee5\u662f\u9006\u65f6\u9488\u3002 rasterizer.depthBiasEnable = VK_FALSE; rasterizer.depthBiasConstantFactor = 0.0f; // Optional rasterizer.depthBiasClamp = 0.0f; // Optional rasterizer.depthBiasSlopeFactor = 0.0f; // Optional C++ \u5149\u6805\u5316\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u5e38\u91cf\u6216\u8005\u57fa\u4e8e\u7247\u5143\u7684\u659c\u7387\u6765\u66f4\u6539\u6df1\u5ea6\u503c\u3002\u4e00\u4e9b\u65f6\u5019\u5bf9\u4e8e\u9634\u5f71\u8d34\u56fe\u662f\u6709\u7528\u7684\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u4f1a\u5728\u7ae0\u8282\u4e2d\u4f7f\u7528\uff0c\u8bbe\u7f6e depthBiasEnable \u4e3a VK_FALSE \u3002 \u91cd\u91c7\u6837 VkPipelineMultisampleStateCreateInfo \u7ed3\u6784\u4f53\u7528\u4e8e\u914d\u7f6e\u591a\u91cd\u91c7\u6837\u3002\u6240\u8c13\u591a\u91cd\u91c7\u6837\u662f\u6297\u952f\u9f7f anti-aliasing \u7684\u4e00\u79cd\u5b9e\u73b0\u3002\u5b83\u901a\u8fc7\u7ec4\u5408\u591a\u4e2a\u591a\u8fb9\u5f62\u7684\u7247\u6bb5\u7740\u8272\u5668\u7ed3\u679c\uff0c\u5149\u6805\u5316\u5230\u540c\u4e00\u4e2a\u50cf\u7d20\u3002\u8fd9\u4e3b\u8981\u53d1\u751f\u5728\u8fb9\u7f18\uff0c\u8fd9\u4e5f\u662f\u6700\u5f15\u4eba\u6ce8\u76ee\u7684\u952f\u9f7f\u51fa\u73b0\u7684\u5730\u65b9\u3002\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u591a\u8fb9\u5f62\u6620\u5c04\u5230\u50cf\u7d20\u662f\u4e0d\u9700\u8981\u591a\u6b21\u8fd0\u884c\u7247\u6bb5\u7740\u8272\u5668\u8fdb\u884c\u91c7\u6837\u7684\uff0c\u76f8\u6bd4\u9ad8\u5206\u8fa8\u7387\u6765\u8bf4\uff0c\u5b83\u4f1a\u82b1\u8d39\u8f83\u4f4e\u7684\u5f00\u9500\u3002\u5f00\u542f\u8be5\u529f\u80fd\u9700\u8981GPU\u652f\u6301\u3002 VkPipelineMultisampleStateCreateInfo multisampling = {}; multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampling.sampleShadingEnable = VK_FALSE; multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; multisampling.minSampleShading = 1.0f; // Optional multisampling.pSampleMask = nullptr; // Optional multisampling.alphaToCoverageEnable = VK_FALSE; // Optional multisampling.alphaToOneEnable = VK_FALSE; // Optional C++ \u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u591a\u91cd\u91c7\u6837\uff0c\u4f46\u662f\u53ef\u4ee5\u968f\u610f\u7684\u5c1d\u8bd5\uff0c\u5177\u4f53\u7684\u53c2\u6570\u8bf7\u53c2\u9605\u89c4\u8303\u3002 \u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5 \u5982\u679c\u4f7f\u7528depth \u6216\u8005 stencil\u7f13\u51b2\u533a\uff0c\u9700\u8981\u4f7f\u7528 VkPipelineDepthStencilStateCreateInfo \u914d\u7f6e\u3002\u6211\u4eec\u73b0\u5728\u4e0d\u9700\u8981\u4f7f\u7528\uff0c\u6240\u4ee5\u7b80\u5355\u7684\u4f20\u9012 nullptr \uff0c\u5173\u4e8e\u8fd9\u90e8\u5206\u4f1a\u4e13\u95e8\u5728\u6df1\u5ea6\u7f13\u51b2\u533a\u7ae0\u8282\u4e2d\u8ba8\u8bba\u3002 \u989c\u8272\u6df7\u5408 \u7247\u6bb5\u7740\u8272\u5668\u8f93\u51fa\u5177\u4f53\u7684\u989c\u8272\uff0c\u5b83\u9700\u8981\u4e0e\u5e27\u7f13\u51b2\u533a framebuffer \u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\u3002\u8fd9\u4e2a\u8f6c\u6362\u7684\u8fc7\u7a0b\u6210\u4e3a\u6df7\u8272\uff0c\u5b83\u6709\u4e24\u79cd\u65b9\u5f0f: \u5c06old\u548cnew\u989c\u8272\u8fdb\u884c\u6df7\u5408\u4ea7\u51fa\u4e00\u4e2a\u6700\u7ec8\u7684\u989c\u8272 \u4f7f\u7528\u6309\u4f4d\u64cd\u4f5c\u6df7\u5408old\u548cnew\u989c\u8272\u7684\u503c \u6709\u4e24\u4e2a\u7ed3\u6784\u4f53\u7528\u4e8e\u914d\u7f6e\u989c\u8272\u6df7\u5408\u3002\u7b2c\u4e00\u4e2a\u7ed3\u6784\u4f53 VkPipelineColorBlendAttachmentState \u5305\u62ec\u4e86\u6bcf\u4e2a\u9644\u52a0\u5230\u5e27\u7f13\u51b2\u533a\u7684\u914d\u7f6e\u3002\u7b2c\u4e8c\u4e2a\u7ed3\u6784\u4f53 VkPipelineColorBlendStateCreateInfo \u5305\u542b\u4e86\u5168\u5c40\u6df7\u8272\u7684\u8bbe\u7f6e\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u4ec5\u4f7f\u7528\u7b2c\u4e00\u79cd\u65b9\u5f0f: VkPipelineColorBlendAttachmentState colorBlendAttachment = {}; colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; colorBlendAttachment.blendEnable = VK_FALSE; colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; // Optional colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; // Optional colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; // Optional colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; // Optional C++ \u8fd9\u79cd\u9488\u5bf9\u6bcf\u4e2a\u5e27\u7f13\u51b2\u533a\u914d\u7f6e\u6df7\u8272\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528\u5982\u4e0b\u4f2a\u4ee3\u7801\u8fdb\u884c\u8bf4\u660e: if (blendEnable) { finalColor.rgb = (srcColorBlendFactor * newColor.rgb) <colorBlendOp> (dstColorBlendFactor * oldColor.rgb); finalColor.a = (srcAlphaBlendFactor * newColor.a) <alphaBlendOp> (dstAlphaBlendFactor * oldColor.a); } else { finalColor = newColor; } finalColor = finalColor & colorWriteMask; C++ \u5982\u679c blendEnable \u8bbe\u7f6e\u4e3a VK_FALSE ,\u90a3\u4e48\u4ece\u7247\u6bb5\u7740\u8272\u5668\u8f93\u51fa\u7684\u65b0\u989c\u8272\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u5426\u5219\u4e24\u4e2a\u6df7\u8272\u64cd\u4f5c\u4f1a\u8ba1\u7b97\u65b0\u7684\u989c\u8272\u3002\u6240\u5f97\u5230\u7684\u7ed3\u679c\u4e0e colorWriteMask \u8fdb\u884cAND\u8fd0\u7b97\uff0c\u4ee5\u786e\u5b9a\u5b9e\u9645\u4f20\u9012\u7684\u901a\u9053\u3002 \u5927\u591a\u6570\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u6df7\u8272\u7528\u4e8e\u5b9e\u73b0 alpha blending \uff0c\u65b0\u7684\u989c\u8272\u4e0e\u65e7\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\u4f1a\u57fa\u4e8e\u5b83\u4eec\u7684 opacity \u900f\u660e\u901a\u9053\u3002 finalColor \u4f5c\u4e3a\u6700\u7ec8\u7684\u8f93\u51fa: finalColor.rgb = newAlpha * newColor + (1 - newAlpha) * oldColor; finalColor.a = newAlpha.a; C++ \u53ef\u4ee5\u901a\u8fc7\u4e00\u4e0b\u53c2\u6570\u5b8c\u6210: colorBlendAttachment.blendEnable = VK_TRUE; colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA; colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; C++ \u53ef\u4ee5\u5728\u89c4\u8303\u4e2d\u627e\u5230\u6240\u6709\u6709\u5173 VkBlendFactor \u548c VkBlendOp \u7684\u679a\u4e3e\u503c\u3002 \u7b2c\u4e8c\u4e2a\u7ed3\u6784\u4f53\u6301\u6709\u6240\u6709\u5e27\u7f13\u51b2\u533a\u7684\u5f15\u7528\uff0c\u5b83\u5141\u8bb8\u8bbe\u7f6e\u6df7\u5408\u64cd\u4f5c\u7684\u5e38\u91cf\uff0c\u8be5\u5e38\u91cf\u53ef\u4ee5\u4f5c\u4e3a\u540e\u7eed\u8ba1\u7b97\u7684\u6df7\u5408\u56e0\u5b50: VkPipelineColorBlendStateCreateInfo colorBlending = {}; colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; colorBlending.logicOpEnable = VK_FALSE; colorBlending.logicOp = VK_LOGIC_OP_COPY; // Optional colorBlending.attachmentCount = 1; colorBlending.pAttachments = &colorBlendAttachment; colorBlending.blendConstants[0] = 0.0f; // Optional colorBlending.blendConstants[1] = 0.0f; // Optional colorBlending.blendConstants[2] = 0.0f; // Optional colorBlending.blendConstants[3] = 0.0f; // Optional C++ \u5982\u679c\u9700\u8981\u4f7f\u7528\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u8bbe\u7f6e\u6df7\u5408\u64cd\u4f5c( bitwise combination ), \u9700\u8981\u8bbe\u7f6e logicOpEnable \u4e3a VK_TURE \u3002\u4e8c\u8fdb\u5236\u4f4d\u64cd\u4f5c\u5728 logicOp \u5b57\u6bb5\u4e2d\u6307\u5b9a\u3002\u5728\u7b2c\u4e00\u79cd\u65b9\u5f0f\u4e2d\u4f1a\u81ea\u52a8\u7981\u6b62\uff0c\u7b49\u540c\u4e8e\u4e3a\u6bcf\u4e00\u4e2a\u9644\u52a0\u7684\u5e27\u7f13\u51b2\u533aframebuffer\u5173\u95ed\u6df7\u5408\u64cd\u4f5c\uff0c blendEnable \u4e3a VK_FALSE \u3002 colorWriteMask \u63a9\u7801\u4f1a\u7528\u786e\u5b9a\u5e27\u7f13\u51b2\u533a\u4e2d\u5177\u4f53\u54ea\u4e2a\u901a\u9053\u7684\u989c\u8272\u53d7\u5230\u5f71\u54cd\u3002\u5b83\u4e5f\u53ef\u4ee5\u5728\u4e24\u79cd\u65b9\u5f0f\u4e0b\u7981\u6b62\uff0c\u622a\u81f3\u76ee\u524d\uff0c\u7247\u6bb5\u7f13\u51b2\u533a\u5411\u5e27\u7f13\u51b2\u533a\u4e2d\u8f93\u51fa\u7684\u989c\u8272\u4e0d\u4f1a\u8fdb\u884c\u4efb\u4f55\u53d8\u5316\u3002 \u52a8\u6001\u4fee\u6539 \u4e4b\u524d\u521b\u5efa\u7684\u4e00\u4e9b\u7ed3\u6784\u4f53\u7684\u72b6\u6001\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u52a8\u6001\u4fee\u6539\uff0c\u800c\u4e0d\u5fc5\u91cd\u65b0\u521b\u5efa\u3002\u6bd4\u5982 viewport \u7684\u5927\u5c0f, line width \u548c blend constants \u3002\u5982\u679c\u9700\u8981\u8fdb\u884c\u8fd9\u6837\u7684\u64cd\u4f5c\uff0c\u9700\u8981\u586b\u5145 VkPipelineDynamicStateCreateInfo \u7ed3\u6784\u4f53: VkDynamicState dynamicStates[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_LINE_WIDTH }; VkPipelineDynamicStateCreateInfo dynamicState = {}; dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO; dynamicState.dynamicStateCount = 2; dynamicState.pDynamicStates = dynamicStates; C++ \u5728\u7ed8\u5236\u7684\u8fc7\u7a0b\u4e2d\u6307\u5b9a\u8fd9\u4e9b\u6570\u636e\uff0c\u8fd9\u4f1a\u5bfc\u81f4\u5ffd\u7565\u4e4b\u524d\u7684\u76f8\u5173\u6570\u503c\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7684\u7ae0\u8282\u4e2d\u56de\u8fc7\u5934\u6765\u8ba8\u8bba\u3002\u5982\u679c\u6ca1\u6709\u4efb\u4f55\u9700\u8981\u52a8\u6001\u4fee\u6539\u7684\u6570\u503c\u6e05\u8bbe\u7f6e\u4e3a nullptr \u3002 \u7ba1\u9053\u5e03\u5c40 \u53ef\u4ee5\u5728\u7740\u8272\u5668\u4e2d\u4f7f\u7528 uniform \uff0c\u5b83\u662f\u7c7b\u4f3c\u4e0e\u52a8\u6001\u72b6\u6001\u53d8\u91cf\u7684\u5168\u5c40\u53d8\u91cf\uff0c\u53ef\u4ee5\u5728\u7ed8\u753b\u65f6\u4fee\u6539\uff0c\u53ef\u4ee5\u66f4\u6539\u7740\u8272\u5668\u7684\u884c\u4e3a\u800c\u65e0\u9700\u91cd\u65b0\u521b\u5efa\u5b83\u4eec\u3002\u5b83\u4eec\u901a\u5e38\u7528\u4e8e\u5c06\u53d8\u6362\u77e9\u9635\u4f20\u9012\u5230\u9876\u70b9\u7740\u8272\u5668\u6216\u8005\u5728\u7247\u6bb5\u7740\u8272\u5668\u51b2\u521b\u5efa\u7eb9\u7406\u91c7\u6837\u5668\u3002 \u8fd9\u4e9b uniform \u6570\u503c\u9700\u8981\u5728\u7ba1\u7ebf\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u901a\u8fc7 VkPipelineLayout \u5bf9\u8c61\u6307\u5b9a\u3002\u5373\u4f7f\u5728\u540e\u7eed\u5185\u5bb9\u4e2d\u7528\u5230\uff0c\u6211\u4eec\u4e5f\u4ecd\u7136\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u7a7a\u7684 pipeline layout \u3002 \u521b\u5efa\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709\u8be5\u5bf9\u8c61\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u540e\u7eed\u7ae0\u8282\u4e2d\u7684\u51fd\u6570\u4e2d\u5f15\u7528\u5b83: VkPipelineLayout pipelineLayout; C++ \u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u521b\u5efa\u5bf9\u8c61: VkPipelineLayoutCreateInfo pipelineLayoutInfo = {}; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; // Optional pipelineLayoutInfo.pSetLayouts = nullptr; // Optional pipelineLayoutInfo.pushConstantRangeCount = 0; // Optional pipelineLayoutInfo.pPushConstantRanges = 0; // Optional if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) { throw std::runtime_error(\"failed to create pipeline layout!\"); } C++ \u8be5\u7ed3\u6784\u4f53\u8fd8\u6307\u5b9a\u4e86 push \u5e38\u91cf\uff0c\u8fd9\u662f\u5c06\u52a8\u6001\u503c\u4f20\u9012\u7ed9\u7740\u8272\u5668\u7684\u62ce\u4e00\u4e2a\u65b9\u5f0f\u3002 pipeline layout \u53ef\u4ee5\u5728\u6574\u4e2a\u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\u5185\u5f15\u7528\uff0c\u6240\u4ee5\u5b83\u5728\u7a0b\u5e8f\u9000\u51fa\u7684\u65f6\u5019\u8fdb\u884c\u9500\u6bc1\u3002 void cleanup() { vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ... } C++ \u7ed3\u8bba \u8fd9\u5c31\u662f\u6240\u6709\u6709\u5173 fixed-function \u7684\u5185\u5bb9\uff0c\u770b\u8d77\u6765\u6709\u5f88\u591a\u7684\u5de5\u4f5c\u53bb\u505a\uff0c\u503c\u5f97\u5e86\u5e78\u7684\u662f\u6211\u4eec\u51e0\u4e4e\u4e86\u89e3\u4e86\u6240\u6709\u6709\u5173\u6e32\u67d3\u7ba1\u7ebf\u7684\u5185\u5bb9\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u51cf\u5c11\u4e86\u56e0\u4e3a\u4e0d\u4e86\u89e3\u67d0\u4e9b\u7ec4\u4ef6\u7684\u9ed8\u8ba4\u72b6\u6001\uff0c\u800c\u9020\u6210\u8fd0\u884c\u65f6\u78b0\u5230\u672a\u77e5\u884c\u4e3a\u7684\u53ef\u80fd\u6027\u3002 \u7136\u800c\uff0c\u5728\u6211\u4eec\u53ef\u4ee5\u6700\u7ec8\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u4e4b\u524d\uff0c\u8fd8\u6709\u4e00\u4e2a\u5bf9\u8c61\u9700\u8981\u521b\u5efa\uff0c\u5b83\u5c31\u662f render pass \u3002 Vulkan \u5e27\u7f13\u51b2\u533a Vulkan \u5e27\u7f13\u51b2\u533a \uff0c\u6211\u4eec\u5728\u524d\u9762\u7684\u7ae0\u8282\u4e2d\u5df2\u7ecf\u8ba8\u8bba\u4e86\u5f88\u591a\u6b21 framebuffers \u5e27\u7f13\u51b2\u533a\uff0c\u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u914d\u7f6e\u4e86 render pass \u6e32\u67d3\u901a\u9053\u5e76\u5e0c\u671b\u8f93\u51fa\u4e00\u4e2a\u4e0e\u4ea4\u6362\u94fe\u56fe\u50cf\u683c\u5f0f\u4e00\u81f4\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u4f46\u662f\u6211\u4eec\u5b9e\u9645\u4e0a\u8fd8\u6ca1\u6709\u521b\u5efa\u3002 \u5728 render pass \u521b\u5efa\u9636\u6bb5\u6211\u4eec\u6307\u5b9a\u4e86\u5177\u4f53\u7684\u9644\u4ef6\uff0c\u5e76\u901a\u8fc7 VkFramebuffer \u5bf9\u8c61\u5305\u88c5\u7ed1\u5b9a\u3002\u5e27\u7f13\u51b2\u533a\u5bf9\u8c61\u5f15\u7528\u8868\u793a\u4e3a\u9644\u4ef6\u7684\u6240\u6709\u7684 VkImageView \u5bf9\u8c61\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u53ea\u4f1a\u4f7f\u7528\u4e00\u4e2a\u5e27\u7f13\u51b2\u533a: color attachment \u3002\u7136\u800c\u6211\u4eec\u4f5c\u4e3a\u9644\u4ef6\u7684\u56fe\u50cf\u4f9d\u8d56\u4ea4\u6362\u94fe\u7528\u4e8e\u5448\u73b0\u65f6\u8fd4\u56de\u7684\u56fe\u50cf\u3002\u8fd9\u610f\u5473\u7740\u6211\u4eec\u5fc5\u987b\u4e3a\u4ea4\u6362\u94fe\u4e2d\u7684\u6240\u6709\u56fe\u50cf\u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u5728\u7ed8\u5236\u7684\u65f6\u5019\u4f7f\u7528\u5bf9\u5e94\u7684\u56fe\u50cf\u3002 \u6700\u540e\uff0c\u5728\u7c7b\u6210\u5458\u4e2d\u521b\u5efa\u53e6\u4e00\u4e2a std::vector \u7528\u4e8e\u4fdd\u5b58 framebuffers : std::vector<VkFramebuffer> swapChainFramebuffers; C++ \u6211\u4eec\u5728\u65b0\u7684\u51fd\u6570 createFramebuffers \u4e2d\u4e3a\u6570\u7ec4\u521b\u5efa\u5bf9\u8c61\u96c6\u5408\uff0c\u8fd9\u4e2a\u51fd\u6570\u5728 initVulkan \u521b\u5efa\u5b8c\u7ba1\u7ebf\u540e\u8c03\u7528: void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); } ... void createFramebuffers() { } C++ \u52a8\u6001\u8c03\u6574\u7528\u4e8e\u4fdd\u5b58 framebuffers \u7684\u5bb9\u5668\u5927\u5c0f: void createFramebuffers() { swapChainFramebuffers.resize(swapChainImageViews.size()); } C++ \u6211\u4eec\u63a5\u4e0b\u6765\u8fed\u4ee3\u5de6\u53f3\u7684\u56fe\u50cf\u89c6\u56fe\u5e76\u901a\u8fc7\u5b83\u4eec\u521b\u5efa\u5bf9\u5e94\u7684 framebuffers : for (size_t i = 0; i < swapChainImageViews.size(); i++) { VkImageView attachments[] = { swapChainImageViews[i] }; VkFramebufferCreateInfo framebufferInfo = {}; framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; framebufferInfo.renderPass = renderPass; framebufferInfo.attachmentCount = 1; framebufferInfo.pAttachments = attachments; framebufferInfo.width = swapChainExtent.width; framebufferInfo.height = swapChainExtent.height; framebufferInfo.layers = 1; if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &swapChainFramebuffers[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to create framebuffer!\"); } } C++ \u5982\u4f60\u6240\u89c1\uff0c\u521b\u5efa framebuffers \u662f\u975e\u5e38\u76f4\u63a5\u7684\u3002\u9996\u5148\u9700\u8981\u6307\u5b9a framebuffer \u9700\u8981\u517c\u5bb9\u7684 renderPass \u3002\u6211\u4eec\u53ea\u80fd\u4f7f\u7528\u4e0e\u5176\u517c\u5bb9\u7684\u6e32\u67d3\u901a\u9053\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u8fd9\u5927\u4f53\u4e0a\u610f\u5473\u7740\u5b83\u4eec\u4f7f\u7528\u76f8\u540c\u7684\u9644\u4ef6\u6570\u91cf\u548c\u7c7b\u578b\u3002 attachmentCount \u548c pAttachments \u53c2\u6570\u6307\u5b9a\u5728\u6e32\u67d3\u901a\u9053\u7684 pAttachment \u6570\u7ec4\u4e2d\u7ed1\u5b9a\u5230\u76f8\u5e94\u7684\u9644\u4ef6\u63cf\u8ff0\u7684 VkImageView \u5bf9\u8c61\u3002 width \u548c height \u53c2\u6570\u662f\u5bb9\u6613\u7406\u89e3\u7684\uff0c layer \u662f\u6307\u5b9a\u56fe\u50cf\u6570\u7ec4\u4e2d\u7684\u5c42\u6570\u3002\u6211\u4eec\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u662f\u5355\u4e2a\u56fe\u50cf\uff0c\u56e0\u6b64\u5c42\u6570\u4e3a 1 \u3002 \u6211\u4eec\u5728\u56fe\u50cf\u89c6\u56fe\u548c\u6e32\u67d3\u901a\u9053\u6e32\u67d3\u5b8c\u6bd5\u4e4b\u540e\uff0c\u5220\u9664\u5bf9\u5e94\u7684\u5e27\u7f13\u51b2\u533a: void cleanup() { for (size_t i = 0; i < swapChainFramebuffers.size(); i++) { vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); } ... } C++ \u6211\u4eec\u5df2\u7ecf\u8fbe\u5230\u4e86\u4e00\u4e2a\u91cc\u7a0b\u7891\uff0c\u6211\u4eec\u62e5\u6709\u6e32\u67d3\u9700\u8981\u7684\u6240\u6709\u5bf9\u8c61\u3002\u5728\u4e0b\u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u7f16\u5199\u7b2c\u4e00\u4e2a\u5b9e\u9645\u7ed8\u5236\u7684\u547d\u4ee4\u3002 Vulkan \u6e32\u67d3\u901a\u9053 Vulkan \u6e32\u67d3\u901a\u9053 \uff0c\u5728\u6211\u4eec\u5b8c\u6210\u7ba1\u7ebf\u7684\u521b\u5efa\u5de5\u4f5c\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9 Vulkan \u6e32\u67d3\u65f6\u5019\u4f7f\u7528\u7684 framebuffer \u5e27\u7f13\u51b2\u533a\u9644\u4ef6\u76f8\u5173\u4fe1\u606f\u3002\u6211\u4eec\u9700\u8981\u6307\u5b9a\u591a\u5c11\u4e2a\u989c\u8272\u548c\u6df1\u5ea6\u7f13\u51b2\u533a\u5c06\u4f1a\u88ab\u4f7f\u7528\uff0c\u6307\u5b9a\u591a\u5c11\u4e2a\u91c7\u6837\u5668\u88ab\u7528\u5230\u53ca\u5728\u6574\u4e2a\u6e32\u67d3\u64cd\u4f5c\u4e2d\u76f8\u5173\u7684\u5185\u5bb9\u5982\u4f55\u5904\u7406\u3002\u6240\u6709\u7684\u8fd9\u4e9b\u4fe1\u606f\u90fd\u88ab\u5c01\u88c5\u5728\u4e00\u4e2a\u53eb\u505a render pass \u7684\u5bf9\u8c61\u4e2d\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u8bbe\u7f6e 2 \u9644\u4ef6\u63cf\u8ff0 3 \u5b50\u901a\u9053\u548c\u9644\u4ef6\u5f15\u7528 4 \u6e32\u67d3\u901a\u9053 \u8bbe\u7f6e \u6211\u4eec\u65b0\u6dfb\u52a0\u4e00\u4e2a createRenderPass \u51fd\u6570\uff0c\u5728 initVulkan \u51fd\u6570\u4e2d\u786e\u4fdd createGraphicsPipeline \u8c03\u7528\u4e4b\u524d\uff0c\u8c03\u7528\u5b83\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); } ... void createRenderPass() { } C++ \u9644\u4ef6\u63cf\u8ff0 \u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u5c06\u53ea\u6709\u4e00\u4e2a\u989c\u8272\u7f13\u51b2\u533a\u9644\u4ef6\uff0c\u5b83\u7531\u4ea4\u6362\u94fe\u4e2d\u7684\u4e00\u4e2a\u56fe\u50cf\u6240\u8868\u793a\u3002 void createRenderPass() { VkAttachmentDescription colorAttachment = {}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; } C++ format \u662f\u989c\u8272\u9644\u4ef6\u7684\u683c\u5f0f\uff0c\u5b83\u5e94\u8be5\u4e0e\u4ea4\u6362\u94fe\u4e2d\u56fe\u50cf\u7684\u683c\u5f0f\u76f8\u5339\u914d\uff0c\u540c\u65f6\u6211\u4eec\u4e0d\u4f1a\u505a\u4efb\u4f55\u591a\u91cd\u91c7\u6837\u7684\u5de5\u4f5c\uff0c\u6240\u4ee5\u91c7\u6837\u5668\u8bbe\u7f6e\u4e3a1\u3002 colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; C++ loadOp \u548c storeOp \u51b3\u5b9a\u4e86\u6e32\u67d3\u524d\u548c\u6e32\u67d3\u540e\u6570\u636e\u5728\u5bf9\u5e94\u9644\u4ef6\u7684\u64cd\u4f5c\u884c\u4e3a\u3002\u5bf9\u4e8e loadOp \u6211\u4eec\u6709\u5982\u4e0b\u9009\u9879\uff1a VK_ATTACHMENT_LOAD_OP_LOAD : \u4fdd\u5b58\u5df2\u7ecf\u5b58\u5728\u4e8e\u5f53\u524d\u9644\u4ef6\u7684\u5185\u5bb9 VK_ATTACHMENT_LOAD_OP_CLEAR : \u8d77\u59cb\u9636\u6bb5\u4ee5\u4e00\u4e2a\u5e38\u91cf\u6e05\u7406\u9644\u4ef6\u5185\u5bb9 VK_ATTACHMENT_LOAD_OP_DONT_CARE : \u5b58\u5728\u7684\u5185\u5bb9\u672a\u5b9a\u4e49\uff0c\u5ffd\u7565\u5b83\u4eec \u5728\u7ed8\u5236\u65b0\u7684\u4e00\u5e27\u5185\u5bb9\u4e4b\u524d\uff0c\u6211\u4eec\u8981\u505a\u7684\u662f\u4f7f\u7528\u6e05\u7406\u64cd\u4f5c\u6765\u6e05\u7406\u5e27\u7f13\u51b2\u533aframebuffer\u4e3a\u9ed1\u8272\u3002\u540c\u65f6\u5bf9\u4e8e storeOp \u4ec5\u6709\u4e24\u4e2a\u9009\u9879\uff1a VK_ATTACHMENT_STORE_OP_STORE : \u6e32\u67d3\u7684\u5185\u5bb9\u4f1a\u5b58\u50a8\u5728\u5185\u5b58\uff0c\u5e76\u5728\u4e4b\u540e\u8fdb\u884c\u8bfb\u53d6\u64cd\u4f5c VK_ATTACHMENT_STORE_OP_DONT_CARE : \u5e27\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u5728\u6e32\u67d3\u64cd\u4f5c\u5b8c\u6bd5\u540e\u8bbe\u7f6e\u4e3aundefined \u6211\u4eec\u8981\u505a\u7684\u662f\u6e32\u67d3\u4e00\u4e2a\u4e09\u89d2\u5f62\u5728\u5c4f\u5e55\u4e0a\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u5b58\u50a8\u64cd\u4f5c\u3002 colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; C++ loadOp \u548c storeOp \u5e94\u7528\u5728\u989c\u8272\u548c\u6df1\u5ea6\u6570\u636e\uff0c\u540c\u65f6 stencilLoadOp / stencilStoreOp \u5e94\u7528\u5728\u6a21\u7248\u6570\u636e\u3002\u6211\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u4e0d\u4f1a\u505a\u4efb\u4f55\u6a21\u7248\u7f13\u51b2\u533a\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u5b83\u7684loading\u548cstoring\u65e0\u5173\u7d27\u8981\u3002 colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; C++ \u7eb9\u7406\u548c\u5e27\u7f13\u51b2\u533a\u5728Vulkan\u4e2d\u901a\u5e38\u7528 VkImage \u5bf9\u8c61\u914d\u4ee5\u67d0\u79cd\u50cf\u7d20\u683c\u5f0f\u6765\u4ee3\u8868\u3002\u4f46\u662f\u50cf\u7d20\u5728\u5185\u5b58\u4e2d\u7684\u5e03\u5c40\u53ef\u4ee5\u57fa\u4e8e\u9884\u8981\u5bf9image\u56fe\u50cf\u8fdb\u884c\u7684\u64cd\u4f5c\u53d1\u751f\u5185\u5b58\u5e03\u5c40\u7684\u53d8\u5316\u3002 \u4e00\u4e9b\u5e38\u7528\u7684\u5e03\u5c40: VK_IMAGE_LAYOUT_COLOR_ATTACHMET_OPTIMAL : \u56fe\u50cf\u4f5c\u4e3a\u989c\u8272\u9644\u4ef6 VK_IMAGE_LAYOUT_PRESENT_SRC_KHR : \u56fe\u50cf\u5728\u4ea4\u6362\u94fe\u4e2d\u88ab\u5448\u73b0 VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL : \u56fe\u50cf\u4f5c\u4e3a\u76ee\u6807\uff0c\u7528\u4e8e\u5185\u5b58COPY\u64cd\u4f5c \u6211\u4eec\u4f1a\u6df1\u5165\u8ba8\u8bba\u8fd9\u4e9b\u5185\u5bb9\u5728\u7eb9\u7406\u7ae0\u8282\uff0c\u73b0\u5728\u6700\u91cd\u8981\u7684\u662f\u4e3a\u9700\u8981\u8f6c\u53d8\u7684\u56fe\u50cf\u6307\u5b9a\u5408\u9002\u7684layout\u5e03\u5c40\u8fdb\u884c\u64cd\u4f5c\u3002 initialLayout \u6307\u5b9a\u56fe\u50cf\u5728\u5f00\u59cb\u8fdb\u5165\u6e32\u67d3\u901a\u9053render pass\u524d\u5c06\u8981\u4f7f\u7528\u7684\u5e03\u5c40\u7ed3\u6784\u3002 finalLayout \u6307\u5b9a\u5f53\u6e32\u67d3\u901a\u9053\u7ed3\u675f\u81ea\u52a8\u53d8\u6362\u65f6\u4f7f\u7528\u7684\u5e03\u5c40\u3002\u4f7f\u7528 VK_IMAGE_LAYOUT_UNDEFINED \u8bbe\u7f6e initialLayout \uff0c\u610f\u4e3a\u4e0d\u5173\u5fc3\u56fe\u50cf\u4e4b\u524d\u7684\u5e03\u5c40\u3002\u7279\u6b8a\u503c\u8868\u660e\u56fe\u50cf\u7684\u5185\u5bb9\u4e0d\u786e\u5b9a\u4f1a\u88ab\u4fdd\u7559\uff0c\u4f46\u662f\u8fd9\u5e76\u4e0d\u603b\u8981\uff0c\u56e0\u4e3a\u65e0\u8bba\u5982\u4f55\u6211\u4eec\u90fd\u8981\u6e05\u7406\u5b83\u3002\u6211\u4eec\u5e0c\u671b\u56fe\u50cf\u6e32\u67d3\u5b8c\u6bd5\u540e\u4f7f\u7528\u4ea4\u6362\u94fe\u8fdb\u884c\u5448\u73b0\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48 finalLayout \u8981\u8bbe\u7f6e\u4e3a VK_IMAGE_LAYOUT_PRESENT_SRC_KHR \u3002 \u5982\u679c\u6ca1\u6709\u641e\u6e05\u695a\u5e03\u5c40\u5b58\u5728\u7684\u610f\u4e49\uff0c\u8fdb\u4e00\u6b65\u89e3\u91calayout\u8bf7\u770b\u5982\u4e0b\u56fe\u793a: \u4e00\u822c\u610f\u4e49\u4e0a\uff0c\u6211\u4eec\u7406\u89e3 CPU \u8fdb\u884c\u5185\u5b58\u4e2d\u7684\u6570\u636e\u8bfb\u5199\u5f80\u5f80\u90fd\u662f\u7ebf\u6027\u6392\u5e8f\u7684 linear memory layout \uff0c\u53ef\u4ee5\u770b\u5230 AB \u4e0e CD \u4f5c\u4e3a\u6765\u4e2a\u8fde\u7eed\u7684\u884c\u6765\u8fdb\u884c\u8bfb\u53d6\u3002\u4f46\u662f\u5728\u5f88\u591a\u65f6\u5019\u5bf9\u4e8e\u50cf\u7d20\u7eb9\u7406\u6570\u636e\u7684\u64cd\u4f5c\u662f\u975e\u7ebf\u6027\u8fde\u7eed\u7684\uff0c\u8fd9\u79cd\u60c5\u666f\u66f4\u591a\u53d1\u751f\u5728 GPU \u64cd\u4f5c\u4e2d\uff0c\u6240\u4ee5 GPU \u786c\u4ef6\u66f4\u591a\u7684\u652f\u6301\u57fa\u4e8e( Tiled )\u5e73\u94fa\u7684\u6216\u8005\u6210\u4e3a\u6700\u4f73\u7684\u5185\u5b58\u5e03\u5c40\u7ed3\u6784\uff0c\u6765\u63d0\u964d\u4f4e GPU \u5904\u7406\u6570\u636e\u7684\u5f00\u9500\u3002 \u6240\u4ee5\u4ece CPU linear layout \u5185\u5b58\u6570\u636e \u5230 GPU optimal layout \u663e\u5b58\u6570\u636e\u7684\u8bfb\u5199 \u5f80\u8fd4\u4e4b\u95f4\u5b58\u5728\u6570\u636e\u5b58\u50a8\u683c\u5f0f\u7684\u4f18\u5316\u8f6c\u53d8\u6b65\u9aa4\u3002 \u5b50\u901a\u9053\u548c\u9644\u4ef6\u5f15\u7528 \u4e00\u4e2a\u5355\u72ec\u7684\u6e32\u67d3\u901a\u9053\u53ef\u4ee5\u7531\u591a\u4e2a\u5b50\u901a\u9053\u7ec4\u6210\u3002\u5b50\u901a\u9053\u662f\u6e32\u67d3\u64cd\u4f5c\u7684\u4e00\u4e2a\u5e8f\u5217\u3002\u5b50\u901a\u9053\u4f5c\u7528\u4e0e\u540e\u7eed\u7684\u6e32\u67d3\u64cd\u4f5c\uff0c\u5e76\u4f9d\u8d56\u4e4b\u524d\u6e32\u67d3\u901a\u9053\u8f93\u51fa\u5230\u5e27\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u3002\u6bd4\u5982\u8bf4\u540e\u5904\u7406\u6548\u679c\u7684\u5e8f\u5217\u901a\u5e38\u6bcf\u4e00\u6b65\u90fd\u4f9d\u8d56\u4e4b\u524d\u7684\u64cd\u4f5c\u3002\u5982\u679c\u5c06\u8fd9\u4e9b\u6e32\u67d3\u64cd\u4f5c\u5206\u7ec4\u5230\u4e00\u4e2a\u6e32\u67d3\u901a\u9053\u4e2d\uff0c\u901a\u8fc7 Vulkan \u5c06\u901a\u9053\u4e2d\u7684\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u91cd\u6392\u5e8f\uff0c\u53ef\u4ee5\u8282\u7701\u5185\u5b58\u4ece\u800c\u83b7\u5f97\u66f4\u597d\u7684\u6027\u80fd\u3002\u5bf9\u4e8e\u6211\u4eec\u8981\u7ed8\u5236\u7684\u4e09\u89d2\u5f62\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4e00\u4e2a\u5b50\u901a\u9053\u3002 \u6bcf\u4e2a\u5b50\u901a\u9053\u5f15\u7528\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\u4e4b\u524d\u4f7f\u7528\u7ed3\u6784\u4f53\u63cf\u8ff0\u7684\u9644\u4ef6\u3002\u8fd9\u4e9b\u5f15\u7528\u672c\u8eab\u5c31\u662f VkAttachmentReference \u7ed3\u6784\u4f53: VkAttachmentReference colorAttachmentRef = {}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; C++ attachment \u9644\u4ef6\u53c2\u6570\u901a\u8fc7\u9644\u4ef6\u63cf\u8ff0\u7b26\u96c6\u5408\u4e2d\u7684\u7d22\u5f15\u6765\u6301\u6709\u3002\u6211\u4eec\u7684\u96c6\u5408\u662f\u7531\u4e00\u4e2a VkAttachmentDesription \u7ec4\u6210\u7684\uff0c\u6240\u4ee5\u5b83\u7684\u7d22\u5f15\u4e3a 0 \u3002 layout \u4e3a\u9644\u4ef6\u6307\u5b9a\u5b50\u901a\u9053\u5728\u6301\u6709\u5f15\u7528\u65f6\u5019\u7684layout\u3002\u5f53\u5b50\u901a\u9053\u5f00\u59cb\u7684\u65f6\u5019Vulkan\u4f1a\u81ea\u52a8\u8f6c\u53d8\u9644\u4ef6\u5230\u8fd9\u4e2alayout\u3002\u56e0\u4e3a\u6211\u4eec\u671f\u671b\u9644\u4ef6\u8d77\u5230\u989c\u8272\u7f13\u51b2\u533a\u7684\u4f5c\u7528\uff0clayout\u8bbe\u7f6e\u4e3a VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL \u4f1a\u7ed9\u6211\u4eec\u6700\u597d\u7684\u6027\u80fd\u3002 \u5b50\u901a\u9053\u4f7f\u7528 VkSubpassDescription \u7ed3\u6784\u4f53\u63cf\u8ff0: VkSubpassDescription subpass = {}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; C++ Vulkan\u5728\u672a\u6765\u53ef\u80fd\u4f1a\u652f\u6301\u5173\u4e8e compute subpasses \u7684\u529f\u80fd\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u4eec\u660e\u786e\u6307\u5b9a graphics subpass \u56fe\u5f62\u5b50\u901a\u9053\u3002\u4e0b\u4e00\u6b65\u4e3a\u5b83\u6307\u5b9a\u989c\u8272\u9644\u4ef6\u7684\u5f15\u7528: subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; C++ \u9644\u4ef6\u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15\u76f4\u63a5\u4ece\u7247\u6bb5\u7740\u8272\u5668\u5f15\u7528\uff0c\u5176 layout(location = 0) out vec4 outColor \u6307\u4ee4! \u53ef\u4ee5\u88ab\u5b50\u901a\u9053\u5f15\u7528\u7684\u9644\u4ef6\u7c7b\u578b\u5982\u4e0b: pInputAttachments : \u9644\u4ef6\u4ece\u7740\u8272\u5668\u4e2d\u8bfb\u53d6 pResolveAttachments : \u9644\u4ef6\u7528\u4e8e\u989c\u8272\u9644\u4ef6\u7684\u591a\u91cd\u91c7\u6837 pDepthStencilAttachment : \u9644\u4ef6\u7528\u4e8e\u6df1\u5ea6\u548c\u6a21\u7248\u6570\u636e pPreserveAttachments : \u9644\u4ef6\u4e0d\u88ab\u5b50\u901a\u9053\u4f7f\u7528\uff0c\u4f46\u662f\u6570\u636e\u88ab\u4fdd\u5b58 \u6e32\u67d3\u901a\u9053 \u73b0\u5728\u9644\u4ef6\u548c\u57fa\u672c\u7684\u5b50\u901a\u9053\u5df2\u7ecf\u4ecb\u7ecd\u8fc7\u4e86\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u6e32\u67d3\u901a\u9053\u4e86\u3002\u9996\u5148\u65b0\u5efa\u4e00\u4e2a\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709 VkRenderPass \u5bf9\u8c61\uff0c\u8be5\u53d8\u91cf\u5728 pipelineLayout \u4e0a\u5b9a\u4e49: VkRenderPass renderPass; VkPipelineLayout pipelineLayout; C++ \u6e32\u67d3\u901a\u9053\u5bf9\u8c61\u521b\u5efa\u901a\u8fc7\u586b\u5145 VkRenderPassCreateInfo \u7ed3\u6784\u4f53\uff0c\u5e76\u914d\u5408\u76f8\u5173\u9644\u4ef6\u548c\u5b50\u901a\u9053\u6765\u5b8c\u6210\u3002 VkAttachmentReference \u5bf9\u8c61\u5f15\u7528\u9644\u4ef6\u6570\u7ec4\u3002 VkRenderPassCreateInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } C++ \u5c31\u50cf pipeline layout \u4e00\u6837\uff0c\u6e32\u67d3\u901a\u9053\u5728\u6574\u4e2a\u7a0b\u5e8f\u751f\u547d\u5468\u671f\u5185\u90fd\u88ab\u4f7f\u7528\uff0c\u6240\u4ee5\u9700\u8981\u5728\u9000\u51fa\u9636\u6bb5\u8fdb\u884c\u6e05\u7406\uff1a void cleanup() { vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); ... } C++ \u8fd9\u770b\u8d77\u6765\u5f88\u591a\u5de5\u4f5c\u91cf\uff0c\u4f46\u662f\u5728 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u4f1a\u628a\u6240\u6709\u7684\u7ec4\u4ef6\u6574\u5408\u8d77\u6765\uff0c\u521b\u5efa\u6700\u7ec8\u7684\u56fe\u5f62\u7ba1\u7ebf\u5bf9\u8c61\u3002 Vulkan \u96c6\u6210\u7ba1\u7ebf ulkan \u96c6\u6210\u7ba1\u7ebf \uff0c\u6211\u4eec\u73b0\u5728\u6574\u5408\u524d\u51e0\u7ae0\u8282\u7684\u7ed3\u6784\u4f53\u548c \u5bf9\u8c61\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf \uff01\u4ee5\u4e0b\u662f\u6211\u4eec\u73b0\u5728\u7528\u5230\u7684\u5bf9\u8c61\u7c7b\u578b\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u5feb\u901f\u56de\u987e: Shader stages : \u7740\u8272\u5668\u6a21\u5757\u5b9a\u4e49\u4e86\u56fe\u5f62\u7ba1\u7ebf\u53ef\u7f16\u7a0b\u9636\u6bb5\u7684\u529f\u80fd Fixed-function state : \u7ed3\u6784\u4f53\u5b9a\u4e49\u56fa\u5b9a\u7ba1\u7ebf\u529f\u80fd\uff0c\u6bd4\u5982\u8f93\u5165\u88c5\u914d\u3001\u5149\u6805\u5316\u3001viewport\u548ccolor blending Pipeline layout : \u7ba1\u7ebf\u5e03\u5c40\u5b9a\u4e49uniform \u548c push values\uff0c\u88ab\u7740\u8272\u5668\u6bcf\u4e00\u6b21\u7ed8\u5236\u7684\u65f6\u5019\u5f15\u7528 Render pass : \u6e32\u67d3\u901a\u9053\u901a\u8fc7\u7ba1\u7ebf\u9636\u6bb5\u5f15\u7528\u9644\u4ef6\uff0c\u5e76\u5b9a\u4e49\u5b83\u7684\u4f7f\u7528\u65b9\u5f0f \u6240\u6709\u8fd9\u4e9b\u51b3\u5b9a\u4e86\u56fe\u5f62\u7ba1\u7ebf\u7684\u6700\u7ec8\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u5728 createGraphicsPipeline \u51fd\u6570\u7684\u6700\u540e\u586b\u5145 VkGraphicsPipelineCreateInfo \u7ed3\u6784\u4f53\u3002 VkGraphicsPipelineCreateInfo pipelineInfo = {}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 2; pipelineInfo.pStages = shaderStages; C++ \u73b0\u5728\u5f00\u59cb\u5f15\u7528\u4e4b\u524d\u7684 VkPipelineShaderStageCreateInfo \u7ed3\u6784\u4f53\u6570\u7ec4\u3002 pipelineInfo.pVertexInputState = &vertexInputInfo; pipelineInfo.pInputAssemblyState = &inputAssembly; pipelineInfo.pViewportState = &viewportState; pipelineInfo.pRasterizationState = &rasterizer; pipelineInfo.pMultisampleState = &multisampling; pipelineInfo.pDepthStencilState = nullptr; // Optional pipelineInfo.pColorBlendState = &colorBlending; pipelineInfo.pDynamicState = nullptr; // Optional C++ \u5e76\u5f15\u7528\u4e4b\u524d\u63cf\u8ff0\u56fa\u5b9a\u7ba1\u7ebf\u529f\u80fd\u7684\u7ed3\u6784\u4f53\u3002 pipelineInfo.layout = pipelineLayout; C++ \u5b8c\u6210\u4e4b\u540e\uff0c pipeline layout \u7ba1\u7ebf\u5e03\u5c40\uff0c\u5b83\u662f\u4e00\u4e2a Vulkan \u53e5\u67c4\u800c\u4e0d\u662f\u7ed3\u6784\u4f53\u6307\u9488\u3002 pipelineInfo.renderPass = renderPass; pipelineInfo.subpass = 0; C++ \u6700\u540e\u6211\u4eec\u9700\u8981\u5f15\u7528 render pass \u548c\u56fe\u5f62\u7ba1\u7ebf\u5c06\u8981\u4f7f\u7528\u7684\u5b50\u901a\u9053 sub pass \u7684\u7d22\u5f15\u3002 pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; // Optional pipelineInfo.basePipelineIndex = -1; // Optional C++ \u5b9e\u9645\u4e0a\u8fd8\u6709\u4e24\u4e2a\u53c2\u6570: basePipelineHandle \u548c basePipelineIndex \u3002Vulkan\u5141\u8bb8\u60a8\u901a\u8fc7\u5df2\u7ecf\u5b58\u5728\u7684\u7ba1\u7ebf\u521b\u5efa\u65b0\u7684\u56fe\u5f62\u7ba1\u7ebf\u3002\u8fd9\u79cd\u884d\u751f\u51fa\u65b0\u7ba1\u7ebf\u7684\u60f3\u6cd5\u5728\u4e8e\uff0c\u5f53\u8981\u521b\u5efa\u7684\u7ba1\u7ebf\u4e0e\u73b0\u6709\u7ba1\u9053\u529f\u80fd\u76f8\u540c\u65f6\uff0c\u83b7\u5f97\u8f83\u4f4e\u7684\u5f00\u9500\uff0c\u540c\u65f6\u4e5f\u53ef\u4ee5\u66f4\u5feb\u7684\u5b8c\u6210\u7ba1\u7ebf\u5207\u6362\uff0c\u5f53\u5b83\u4eec\u6765\u81ea\u540c\u4e00\u4e2a\u7236\u7ba1\u7ebf\u3002\u53ef\u4ee5\u901a\u8fc7 basePipelineHandle \u6307\u5b9a\u73b0\u6709\u7ba1\u7ebf\u7684\u53e5\u67c4\uff0c\u4e5f\u53ef\u4ee5\u5f15\u7528\u7531 basePipelineIndex \u6240\u4ee5\u521b\u5efa\u7684\u53e6\u4e00\u4e2a\u7ba1\u7ebf\u3002\u76ee\u524d\u53ea\u6709\u4e00\u4e2a\u7ba1\u7ebf\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u6307\u5b9a\u4e00\u4e2a\u7a7a\u53e5\u67c4\u548c\u4e00\u4e2a\u65e0\u6548\u7684\u7d22\u5f15\u3002\u53ea\u6709\u5728 VkGraphicsPipelineCreateInfo \u7684 flags \u5b57\u6bb5\u4e2d\u4e5f\u6307\u5b9a\u4e86 VK_PIPELINE_CREATE_DERIVATIVE_BIT \u6807\u5fd7\u65f6\uff0c\u624d\u9700\u8981\u4f7f\u7528\u8fd9\u4e9b\u503c\u3002 \u73b0\u5728\u51c6\u5907\u6700\u540e\u4e00\u6b65\uff0c\u521b\u5efa\u4e00\u4e2a\u7c7b\u6210\u5458\u4fdd\u5b58 VkPipeline \u5bf9\u8c61: VkPipeline graphicsPipeline; C++ \u6700\u540e\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf: if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline) != VK_SUCCESS) { throw std::runtime_error(\"failed to create graphics pipeline!\"); } C++ vkCreateGraphicsPipelines \u51fd\u6570\u5728Vulkan\u4e2d\u6bd4\u8d77\u4e00\u822c\u7684\u521b\u5efa\u5bf9\u8c61\u51fd\u6570\u9700\u8981\u66f4\u591a\u7684\u53c2\u6570\u3002\u5b83\u53ef\u4ee5\u7528\u6765\u4f20\u9012\u591a\u4e2a VkGraphicsPipelineCreateInfo \u5bf9\u8c61\u5e76\u521b\u5efa\u591a\u4e2a VkPipeline \u5bf9\u8c61\u3002 \u6211\u4eec\u4f20\u9012 VK_NULL_HANDLE \u53c2\u6570\u4f5c\u4e3a\u7b2c\u4e8c\u4e2a\u53c2\u6570\uff0c\u4f5c\u4e3a\u53ef\u9009 VkPipelineCache \u5bf9\u8c61\u7684\u5f15\u7528\u3002\u7ba1\u7ebf\u7f13\u5b58\u53ef\u4ee5\u7528\u4e8e\u5b58\u50a8\u548c\u590d\u7528\u4e0e\u901a\u8fc7\u591a\u6b21\u8c03\u7528 vkCreateGraphicsPipelines \u51fd\u6570\u76f8\u5173\u7684\u6570\u636e\uff0c\u751a\u81f3\u5728\u7a0b\u5e8f\u6267\u884c\u7684\u65f6\u5019\u7f13\u5b58\u5230\u4e00\u4e2a\u6587\u4ef6\u4e2d\u3002\u8fd9\u6837\u53ef\u4ee5\u52a0\u901f\u540e\u7eed\u7684\u7ba1\u7ebf\u521b\u5efa\u903b\u8f91\u3002\u5177\u4f53\u7684\u5185\u5bb9\u6211\u4eec\u4f1a\u5728\u7ba1\u7ebf\u7f13\u5b58\u7ae0\u8282\u4ecb\u7ecd\u3002 \u56fe\u5f62\u7ba1\u7ebf\u5bf9\u4e8e\u5e38\u89c1\u7684\u7ed8\u56fe\u64cd\u4f5c\u662f\u5fc5\u987b\u7684\uff0c\u6240\u4ee5\u5b83\u4e5f\u5e94\u8be5\u5728\u7a0b\u5e8f\u7ed3\u675f\u65f6\u9500\u6bc1: void cleanup() { vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ... } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\uff0c\u786e\u8ba4\u6240\u6709\u5de5\u4f5c\u6b63\u5e38\uff0c\u5e76\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u6210\u529f\uff01\u6211\u4eec\u5df2\u7ecf\u65e0\u6bd4\u63a5\u8fd1\u5728\u5c4f\u5e55\u4e0a\u7ed8\u5236\u51fa\u4e1c\u897f\u6765\u4e86\u3002\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u4e2a\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4ece\u4ea4\u6362\u94fe\u56fe\u50cf\u4e2d\u8bbe\u7f6e\u5b9e\u9645\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u51c6\u5907\u7ed8\u5236\u547d\u4ee4\u3002 Vulkan \u547d\u4ee4\u7f13\u51b2\u533a Vulkan \u547d\u4ee4\u7f13\u51b2\u533a \uff0c\u8bf8\u5982\u7ed8\u5236\u548c\u5185\u5b58\u64cd\u4f5c\u76f8\u5173\u547d\u4ee4\uff0c\u5728 Vulkan \u4e2d\u4e0d\u662f\u901a\u8fc7\u51fd\u6570\u76f4\u63a5\u8c03\u7528\u7684\u3002\u6211\u4eec\u9700\u8981\u5728\u547d\u4ee4\u7f13\u51b2\u533a\u5bf9\u8c61\u4e2d\u8bb0\u5f55\u6211\u4eec\u671f\u671b\u7684\u4efb\u4f55\u64cd\u4f5c\u3002\u8fd9\u6837\u505a\u7684\u4f18\u70b9\u662f\u53ef\u4ee5\u63d0\u524d\u5728\u591a\u7ebf\u7a0b\u4e2d\u5b8c\u6210\u6240\u6709\u7ed8\u5236\u547d\u4ee4\u76f8\u5173\u7684\u88c5\u914d\u5de5\u4f5c\uff0c\u5e76\u5728\u4e3b\u7ebf\u7a0b\u5faa\u73af\u7ed3\u6784\u4e2d\u901a\u77e5 Vulkan \u6267\u884c\u5177\u4f53\u7684\u547d\u4ee4\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u547d\u4ee4\u6c60 2 \u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a 3 \u542f\u52a8\u547d\u4ee4\u7f13\u51b2\u8bb0\u5f55 4 \u542f\u52a8\u6e32\u67d3\u901a\u9053 5 \u57fa\u672c\u7ed8\u56fe\u547d\u4ee4 6 \u7ed3\u675f\u6e32\u67d3 \u547d\u4ee4\u6c60 \u6211\u4eec\u5728\u4f7f\u7528\u4efb\u4f55 command buffers \u4e4b\u524d\u9700\u8981\u521b\u5efa\u547d\u4ee4\u5bf9\u8c61\u6c60 command pool \u3002 Command pools \u7ba1\u7406\u7528\u4e8e\u5b58\u50a8\u7f13\u51b2\u533a\u7684\u5185\u5b58\uff0c\u5e76\u4ece\u4e2d\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u6dfb\u52a0\u65b0\u7684\u7c7b\u6210\u5458\u4fdd\u5b58 VkCommandPool : VkCommandPool commandPool; \u521b\u5efa\u65b0\u7684\u51fd\u6570 createCommandPool \u5e76\u5728 initVulkan \u51fd\u6570\u521b\u5efa\u5b8c framebuffers \u540e\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); } ... void createCommandPool() { } \u547d\u4ee4\u5bf9\u8c61\u6c60\u521b\u5efa\u4ec5\u4ec5\u9700\u8981\u4e24\u4e2a\u53c2\u6570: QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice); VkCommandPoolCreateInfo poolInfo = {}; poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily; poolInfo.flags = 0; // Optional \u547d\u4ee4\u7f13\u51b2\u533a\u901a\u8fc7\u5c06\u5176\u63d0\u4ea4\u5230\u5176\u4e2d\u4e00\u4e2a\u8bbe\u5907\u961f\u5217\u4e0a\u6765\u6267\u884c\uff0c\u5982\u6211\u4eec\u68c0\u7d22\u7684 graphics \u548c presentation \u961f\u5217\u3002\u6bcf\u4e2a\u547d\u4ee4\u5bf9\u8c61\u6c60\u53ea\u80fd\u5206\u914d\u5728\u5355\u4e00\u7c7b\u578b\u7684\u961f\u5217\u4e0a\u63d0\u4ea4\u7684\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u6362\u53e5\u8bdd\u8bf4\u8981\u5206\u914d\u7684\u547d\u4ee4\u9700\u8981\u4e0e\u961f\u5217\u7c7b\u578b\u4e00\u81f4\u3002\u6211\u4eec\u8981\u8bb0\u5f55\u7ed8\u5236\u7684\u547d\u4ee4\uff0c\u8fd9\u5c31\u8bf4\u660e\u4e3a\u4ec0\u4e48\u8981\u9009\u62e9\u56fe\u5f62\u961f\u5217\u7c07\u7684\u539f\u56e0\u3002 \u6709\u4e24\u4e2a\u6807\u5fd7\u4f4d\u7528\u4e8e command pools : VK_COMMAND_POOL_CREATE_TRANSIENT_BIT : \u63d0\u793a\u547d\u4ee4\u7f13\u51b2\u533a\u975e\u5e38\u9891\u7e41\u7684\u91cd\u65b0\u8bb0\u5f55\u65b0\u547d\u4ee4(\u53ef\u80fd\u4f1a\u6539\u53d8\u5185\u5b58\u5206\u914d\u884c\u4e3a) VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT : \u5141\u8bb8\u547d\u4ee4\u7f13\u51b2\u533a\u5355\u72ec\u91cd\u65b0\u8bb0\u5f55\uff0c\u6ca1\u6709\u8fd9\u4e2a\u6807\u5fd7\uff0c\u6240\u6709\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u90fd\u5fc5\u987b\u4e00\u8d77\u91cd\u7f6e \u6211\u4eec\u4ec5\u4ec5\u5728\u7a0b\u5e8f\u5f00\u59cb\u7684\u65f6\u5019\u8bb0\u5f55\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u5e76\u5728\u4e3b\u5faa\u73af\u4f53 main loop \u4e2d\u591a\u6b21\u6267\u884c\uff0c\u56e0\u6b64\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u8fd9\u4e9b\u6807\u5fd7\u3002 if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) { throw std::runtime_error(\"failed to create command pool!\"); } \u901a\u8fc7 vkCreateCommandPool \u51fd\u6570\u5b8c\u6210 command pool \u521b\u5efa\u5de5\u4f5c\u3002\u5b83\u4e0d\u9700\u8981\u4efb\u4f55\u7279\u6b8a\u7684\u53c2\u6570\u8bbe\u7f6e\u3002\u547d\u4ee4\u5c06\u88ab\u6574\u4e2a\u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\u4f7f\u7528\u4ee5\u5b8c\u6210\u5c4f\u5e55\u7684\u7ed8\u5236\u5de5\u4f5c\uff0c\u6240\u4ee5\u5bf9\u8c61\u6c60\u5e94\u8be5\u88ab\u5728\u6700\u540e\u9500\u6bc1: void cleanup() { vkDestroyCommandPool(device, commandPool, nullptr); ... } \u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a \u73b0\u5728\u6211\u4eec\u5f00\u59cb\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a\u5e76\u901a\u8fc7\u5b83\u4eec\u8bb0\u5f55\u7ed8\u5236\u6307\u4ee4\u3002\u56e0\u4e3a\u5176\u4e2d\u4e00\u4e2a\u7ed8\u56fe\u547d\u4ee4\u9700\u8981\u6b63\u786e\u7ed1\u5b9a VkFrameBuffer \uff0c\u6211\u4eec\u5b9e\u9645\u4e0a\u9700\u8981\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u8bb0\u5f55\u4e00\u4e2a\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u6700\u540e\u521b\u5efa\u4e00\u4e2a VkCommandBuffer \u5bf9\u8c61\u5217\u8868\u4f5c\u4e3a\u6210\u5458\u53d8\u91cf\u3002\u547d\u4ee4\u7f13\u51b2\u533a\u4f1a\u5728 common pool \u9500\u6bc1\u7684\u65f6\u5019\u81ea\u52a8\u91ca\u653e\u7cfb\u7edf\u8d44\u6e90\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u660e\u786e\u7f16\u5199 cleanup \u903b\u8f91\u3002 std::vector<VkCommandBuffer> commandBuffers; \u73b0\u5728\u5f00\u59cb\u4f7f\u7528\u4e00\u4e2a createCommandBuffers \u51fd\u6570\u6765\u5206\u914d\u548c\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u56fe\u50cf\u5c06\u8981\u5e94\u7528\u7684\u547d\u4ee4\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); } ... void createCommandBuffers() { commandBuffers.resize(swapChainFramebuffers.size()); } \u547d\u4ee4\u7f13\u51b2\u533a\u901a\u8fc7 vkAllocateCommandBuffers \u51fd\u6570\u5206\u914d\uff0c\u5b83\u9700\u8981 VkCommandBufferAllocateInfo \u7ed3\u6784\u4f53\u4f5c\u4e3a\u53c2\u6570\uff0c\u7528\u4ee5\u6307\u5b9a command pool \u548c\u7f13\u51b2\u533a\u5c06\u4f1a\u5206\u914d\u7684\u5927\u5c0f: VkCommandBufferAllocateInfo allocInfo = {}; allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; allocInfo.commandPool = commandPool; allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; allocInfo.commandBufferCount = (uint32_t) commandBuffers.size(); if (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.data()) != VK_SUCCESS) { throw std::runtime_error(\"failed to allocate command buffers!\"); } level \u53c2\u6570\u6307\u5b9a\u5206\u914d\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u4e3b\u4ece\u5173\u7cfb\u3002 VK_COMMAND_BUFFER_LEVEL_PRIMARY : \u53ef\u4ee5\u63d0\u4ea4\u5230\u961f\u5217\u6267\u884c\uff0c\u4f46\u4e0d\u80fd\u4ece\u5176\u4ed6\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u8c03\u7528\u3002 VK_COMMAND_BUFFER_LEVEL_SECONDARY : \u65e0\u6cd5\u76f4\u63a5\u63d0\u4ea4\uff0c\u4f46\u662f\u53ef\u4ee5\u4ece\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u8c03\u7528\u3002 \u6211\u4eec\u4e0d\u4f1a\u5728\u8fd9\u91cc\u4f7f\u7528\u8f85\u52a9\u7f13\u51b2\u533a\u529f\u80fd\uff0c\u4f46\u662f\u53ef\u4ee5\u60f3\u50cf\uff0c\u5bf9\u4e8e\u590d\u7528\u4e3b\u7f13\u51b2\u533a\u7684\u5e38\u7528\u64cd\u4f5c\u5f88\u6709\u5e2e\u52a9\u3002 \u542f\u52a8\u547d\u4ee4\u7f13\u51b2\u8bb0\u5f55 \u901a\u8fc7 vkBeginCommandBuffer \u6765\u5f00\u542f\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u8bb0\u5f55\u529f\u80fd\uff0c\u8be5\u51fd\u6570\u9700\u8981\u4f20\u9012 VkCommandBufferBeginInfo \u7ed3\u6784\u4f53\u4f5c\u4e3a\u53c2\u6570\uff0c\u7528\u4ee5\u6307\u5b9a\u547d\u4ee4\u7f13\u51b2\u533a\u5728\u4f7f\u7528\u8fc7\u7a0b\u4e2d\u7684\u4e00\u4e9b\u5177\u4f53\u4fe1\u606f\u3002 for (size_t i = 0; i < commandBuffers.size(); i++) { VkCommandBufferBeginInfo beginInfo = {}; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT; beginInfo.pInheritanceInfo = nullptr; // Optional vkBeginCommandBuffer(commandBuffers[i], &beginInfo); } flags \u6807\u5fd7\u4f4d\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u5982\u4f55\u4f7f\u7528\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u53ef\u9009\u7684\u53c2\u6570\u7c7b\u578b\u5982\u4e0b: VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT : \u547d\u4ee4\u7f13\u51b2\u533a\u5c06\u5728\u6267\u884c\u4e00\u6b21\u540e\u7acb\u5373\u91cd\u65b0\u8bb0\u5f55\u3002 VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT : \u8fd9\u662f\u4e00\u4e2a\u8f85\u52a9\u7f13\u51b2\u533a\uff0c\u5b83\u9650\u5236\u5728\u5728\u4e00\u4e2a\u6e32\u67d3\u901a\u9053\u4e2d\u3002 VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT : \u547d\u4ee4\u7f13\u51b2\u533a\u4e5f\u53ef\u4ee5\u91cd\u65b0\u63d0\u4ea4\uff0c\u540c\u65f6\u5b83\u4e5f\u5728\u7b49\u5f85\u6267\u884c\u3002 \u6211\u4eec\u4f7f\u7528\u4e86\u6700\u540e\u4e00\u4e2a\u6807\u5fd7\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u80fd\u5df2\u7ecf\u5728\u4e0b\u4e00\u5e27\u7684\u65f6\u5019\u5b89\u6392\u4e86\u7ed8\u5236\u547d\u4ee4\uff0c\u800c\u6700\u540e\u4e00\u5e27\u5c1a\u672a\u5b8c\u6210\u3002 pInheritanceInfo \u53c2\u6570\u4e0e\u8f85\u52a9\u7f13\u51b2\u533a\u76f8\u5173\u3002\u5b83\u6307\u5b9a\u4ece\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u7ee7\u627f\u7684\u72b6\u6001\u3002 \u5982\u679c\u547d\u4ee4\u7f13\u51b2\u533a\u5df2\u7ecf\u88ab\u8bb0\u5f55\u4e00\u6b21\uff0c\u90a3\u4e48\u8c03\u7528 vkBeginCommandBuffer \u4f1a\u9690\u5f0f\u5730\u91cd\u7f6e\u5b83\u3002\u5426\u5219\u5c06\u547d\u4ee4\u9644\u52a0\u5230\u7f13\u51b2\u533a\u662f\u4e0d\u53ef\u80fd\u7684\u3002 \u542f\u52a8\u6e32\u67d3\u901a\u9053 \u7ed8\u5236\u5f00\u59cb\u4e8e\u8c03\u7528 vkCmdBeginRenderPass \u5f00\u542f\u6e32\u67d3\u901a\u9053\u3002render pass\u4f7f\u7528 VkRenderPassBeginInfo \u7ed3\u6784\u4f53\u586b\u5145\u914d\u7f6e\u4fe1\u606f\u4f5c\u4e3a\u8c03\u7528\u65f6\u4f7f\u7528\u7684\u53c2\u6570\u3002 VkRenderPassBeginInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; renderPassInfo.renderPass = renderPass; renderPassInfo.framebuffer = swapChainFramebuffers[i]; \u7ed3\u6784\u4f53\u7b2c\u4e00\u4e2a\u53c2\u6570\u4f20\u9012\u4e3a\u7ed1\u5b9a\u5230\u5bf9\u5e94\u9644\u4ef6\u7684\u6e32\u67d3\u901a\u9053\u672c\u8eab\u3002\u6211\u4eec\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u521b\u5efa\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u6307\u5b9a\u4e3a\u989c\u8272\u9644\u4ef6\u3002 renderPassInfo.renderArea.offset = {0, 0}; renderPassInfo.renderArea.extent = swapChainExtent; \u540e\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u4e86\u6e32\u67d3\u533a\u57df\u7684\u5927\u5c0f\u3002\u6e32\u67d3\u533a\u57df\u5b9a\u4e49\u7740\u8272\u5668\u52a0\u8f7d\u548c\u5b58\u50a8\u5c06\u8981\u53d1\u751f\u7684\u4f4d\u7f6e\u3002\u533a\u57df\u5916\u7684\u50cf\u7d20\u5c06\u5177\u6709\u672a\u5b9a\u7684\u503c\u3002\u4e3a\u4e86\u6700\u4f73\u7684\u6027\u80fd\u5b83\u7684\u5c3a\u5bf8\u5e94\u8be5\u4e0e\u9644\u4ef6\u5339\u914d\u3002 VkClearValue clearColor = {0.0f, 0.0f, 0.0f, 1.0f}; renderPassInfo.clearValueCount = 1; renderPassInfo.pClearValues = &clearColor; \u6700\u540e\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u4e86\u7528\u4e8e VK_ATTACHMENT_LOAD_OP_CLEAR \u7684\u6e05\u9664\u503c\uff0c\u6211\u4eec\u5c06\u5176\u7528\u4f5c\u989c\u8272\u9644\u4ef6\u7684\u52a0\u8f7d\u64cd\u4f5c\u3002\u4e3a\u4e86\u7b80\u5316\u64cd\u4f5c\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86 clear color \u4e3a100%\u9ed1\u8272\u3002 vkCmdBeginRenderPass(commandBuffers[i], &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE); \u6e32\u67d3\u901a\u9053\u73b0\u5728\u53ef\u4ee5\u542f\u7528\u3002\u6240\u6709\u53ef\u4ee5\u88ab\u8bb0\u5f55\u7684\u547d\u4ee4\uff0c\u88ab\u8bc6\u522b\u7684\u524d\u63d0\u662f\u4f7f\u7528 vkCmd \u524d\u7f00\u3002\u5b83\u4eec\u5168\u90e8\u8fd4\u56de void \uff0c\u6240\u4ee5\u5728\u7ed3\u675f\u8bb0\u5f55\u4e4b\u524d\u4e0d\u4f1a\u6709\u4efb\u4f55\u9519\u8bef\u5904\u7406\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u547d\u4ee4\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u603b\u662f\u8bb0\u5f55\u8be5\u547d\u4ee4\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u7b2c\u4e8c\u4e2a\u53c2\u6570\u6307\u5b9a\u6211\u4eec\u4f20\u9012\u7684\u6e32\u67d3\u901a\u9053\u7684\u5177\u4f53\u4fe1\u606f\u3002\u6700\u540e\u7684\u53c2\u6570\u63a7\u5236\u5982\u4f55\u63d0\u4f9b render pass \u5c06\u8981\u5e94\u7528\u7684\u7ed8\u5236\u547d\u4ee4\u3002\u5b83\u4f7f\u7528\u4ee5\u4e0b\u6570\u503c\u4efb\u610f\u4e00\u4e2a: VK_SUBPASS_CONTENTS_INLINE : \u6e32\u67d3\u8fc7\u7a0b\u547d\u4ee4\u88ab\u5d4c\u5165\u5728\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u4e2d\uff0c\u6ca1\u6709\u8f85\u52a9\u7f13\u51b2\u533a\u6267\u884c\u3002 VK_SUBPASS_CONTENTS_SECONDARY_COOMAND_BUFFERS : \u6e32\u67d3\u901a\u9053\u547d\u4ee4\u5c06\u4f1a\u4ece\u8f85\u52a9\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u3002 \u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u8f85\u52a9\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u7b2c\u4e00\u4e2a\u3002 \u57fa\u672c\u7ed8\u56fe\u547d\u4ee4 \u73b0\u5728\u6211\u4eec\u7ed1\u5b9a\u56fe\u5f62\u7ba1\u7ebf: vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline); \u7b2c\u4e8c\u4e2a\u53c2\u6570\u6307\u5b9a\u5177\u4f53\u7ba1\u7ebf\u7c7b\u578b\uff0c graphics or compute pipeline \u3002\u6211\u4eec\u544a\u8bc9Vulkan\u5728\u56fe\u5f62\u7ba1\u7ebf\u4e2d\u6bcf\u4e00\u4e2a\u64cd\u4f5c\u5982\u4f55\u6267\u884c\u53ca\u54ea\u4e2a\u9644\u4ef6\u5c06\u4f1a\u5728\u7247\u6bb5\u7740\u8272\u5668\u4e2d\u4f7f\u7528\uff0c\u6240\u4ee5\u5269\u4e0b\u7684\u5c31\u662f\u544a\u8bc9\u5b83\u7ed8\u5236\u4e09\u89d2\u5f62\u3002 vkCmdDraw(commandBuffers[i], 3, 1, 0, 0); C++ \u5b9e\u9645\u7684 vkCmdDraw \u51fd\u6570\u6709\u70b9\u4e0e\u5b57\u9762\u610f\u601d\u4e0d\u4e00\u81f4\uff0c\u5b83\u662f\u5982\u6b64\u7b80\u5355\uff0c\u4ec5\u56e0\u4e3a\u6211\u4eec\u63d0\u524d\u6307\u5b9a\u6240\u6709\u6e32\u67d3\u76f8\u5173\u7684\u4fe1\u606f\u3002\u5b83\u6709\u5982\u4e0b\u7684\u53c2\u6570\u9700\u8981\u6307\u5b9a\uff0c\u9664\u4e86\u547d\u4ee4\u7f13\u51b2\u533a: vertexCount : \u5373\u4f7f\u6211\u4eec\u6ca1\u6709\u9876\u70b9\u7f13\u51b2\u533a\uff0c\u4f46\u662f\u6211\u4eec\u4ecd\u7136\u67093\u4e2a\u5b9a\u70b9\u9700\u8981\u7ed8\u5236\u3002 instanceCount : \u7528\u4e8einstanced \u6e32\u67d3\uff0c\u5982\u679c\u6ca1\u6709\u4f7f\u7528\u8bf7\u586b1\u3002 firstVertex : \u4f5c\u4e3a\u9876\u70b9\u7f13\u51b2\u533a\u7684\u504f\u79fb\u91cf\uff0c\u5b9a\u4e49gl_VertexIndex\u7684\u6700\u5c0f\u503c\u3002 firstInstance : \u4f5c\u4e3ainstanced \u6e32\u67d3\u7684\u504f\u79fb\u91cf\uff0c\u5b9a\u4e49\u4e86gl_InstanceIndex\u7684\u6700\u5c0f\u503c\u3002 \u7ed3\u675f\u6e32\u67d3 render pass \u6267\u884c\u5b8c\u7ed8\u5236\uff0c\u53ef\u4ee5\u7ed3\u675f\u6e32\u67d3\u4f5c\u4e1a: vkCmdEndRenderPass(commandBuffers[i]); C++ \u5e76\u505c\u6b62\u8bb0\u5f55\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u5de5\u4f5c: if (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to record command buffer!\"); } C++ \u5728\u4e0b\u4e00\u7ae0\u8282\u6211\u4eec\u4f1a\u5c1d\u8bd5\u5728 main loop \u4e2d\u7f16\u5199\u4ee3\u7801\uff0c\u7528\u4e8e\u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u56fe\u50cf\uff0c\u6267\u884c\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u547d\u4ee4\uff0c\u518d\u5c06\u6e32\u67d3\u540e\u7684\u56fe\u50cf\u8fd4\u8fd8\u7ed9\u4ea4\u6362\u94fe\u3002 Vulkan \u6e32\u67d3\u548c\u663e\u793a Vulkan \u6e32\u67d3\u548c\u663e\u793a \uff0c\u8fd9\u4e00\u7ae0\u8282\u4f1a\u628a\u4e4b\u524d\u7684\u6240\u6709\u5185\u5bb9\u8fdb\u884c\u6574\u5408\uff0c\u6211\u4eec\u5c06\u4f1a\u7f16\u5199 drawFrame \u51fd\u6570\uff0c\u901a\u8fc7\u4e3b\u5faa\u73af main loop \u5c06\u4e09\u89d2\u5f62\u7ed8\u5236\u5230\u5c4f\u5e55\u3002 drawFrame \u51fd\u6570\u5c06\u4f1a\u6267\u884c\u5982\u4e0b\u64cd\u4f5c: \u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u4e00\u4e2a\u56fe\u50cf \u5728\u5e27\u7f13\u51b2\u533a\u4e2d\uff0c\u4f7f\u7528\u4f5c\u4e3a\u9644\u4ef6\u7684\u56fe\u50cf\u6765\u6267\u884c\u547d\u4ee4\u7f13\u51b2\u533a\u4e2d\u7684\u547d\u4ee4 \u4e3a\u4e86\u6700\u7ec8\u5448\u73b0\uff0c\u5c06\u56fe\u50cf\u8fd4\u8fd8\u5230\u4ea4\u6362\u94fe \u6bcf\u4e2a\u4e8b\u4ef6\u6d3e\u53d1\u90fd\u6709\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u6765\u5bf9\u5e94\uff0c\u4f46\u5b83\u4eec\u7684\u6267\u884c\u662f\u5f02\u6b65\u7684\u3002\u51fd\u6570\u8c03\u7528\u5c06\u5728\u64cd\u4f5c\u5b9e\u9645\u5b8c\u6210\u4e4b\u524d\u8fd4\u56de\uff0c\u5e76\u4e14\u6267\u884c\u987a\u5e8f\u4e5f\u662f\u672a\u5b9a\u4e49\u7684\u3002\u8fd9\u662f\u4e0d\u7406\u60f3\u7684\uff0c\u56e0\u4e3a\u6bcf\u4e00\u4e2a\u64cd\u4f5c\u90fd\u53d6\u51b3\u4e8e\u524d\u4e00\u4e2a\u64cd\u4f5c\u3002 \u5728 mainLoop \u51fd\u6570\u8c03\u7528: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); drawFrame(); } } ... void drawFrame() { } C++ \u540c\u6b65\u4ea4\u6362\u94fe\u4e8b\u4ef6\u6709\u4e24\u79cd\u65b9\u6cd5:\u6805\u680f\u548c\u4fe1\u53f7\u91cf\u3002\u5b83\u4eec\u90fd\u662f\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u4e00\u4e2a\u64cd\u4f5c\u4fe1\u53f7\uff0c\u8d1f\u8d23\u534f\u8c03\u64cd\u4f5c\u7684\u5bf9\u8c61\u3002\u53e6\u4e00\u4e2a\u64cd\u4f5c\u7b49\u5f85\u6805\u680f\u6216\u8005\u4fe1\u53f7\u91cf\u4ece\u65e0\u4fe1\u53f7\u72b6\u6001\u8f6c\u53d8\u5230\u6709\u4fe1\u53f7\u72b6\u6001\u3002 \u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u53ef\u4ee5\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u8c03\u7528 vkWaitForFence \u8fdb\u5165\u6805\u680f\u72b6\u6001\uff0c\u800c\u4fe1\u53f7\u91cf\u4e0d\u53ef\u4ee5\u3002\u6805\u680f\u4e3b\u8981\u7528\u4e8e\u5e94\u7528\u7a0b\u5e8f\u81ea\u8eab\u4e0e\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u540c\u6b65\uff0c\u800c\u4fe1\u53f7\u91cf\u7528\u4e8e\u5728\u547d\u4ee4\u961f\u5217\u5185\u6216\u8005\u8de8\u547d\u4ee4\u961f\u5217\u540c\u6b65\u64cd\u4f5c\u3002\u6211\u4eec\u671f\u671b\u540c\u6b65\u7ed8\u5236\u4e0e\u5448\u73b0\u7684\u961f\u5217\u64cd\u4f5c\uff0c\u6240\u4ee5\u4f7f\u7528\u4fe1\u53f7\u91cf\u6700\u5408\u9002\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u4fe1\u53f7\u91cf 2 \u4ece\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf 3 \u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a 4 Subpass \u4f9d\u8d56\u6027 5 \u5448\u73b0 6 \u5185\u5b58\u6cc4\u6f0f 7 \u7ed3\u8bba \u4fe1\u53f7\u91cf \u5728\u83b7\u5f97\u4e00\u4e2a\u56fe\u50cf\u65f6\uff0c\u6211\u4eec\u9700\u8981\u53d1\u51fa\u4e00\u4e2a\u4fe1\u53f7\u91cf\u51c6\u5907\u8fdb\u884c\u6e32\u67d3\uff0c\u53e6\u4e00\u4e2a\u4fe1\u53f7\u91cf\u7684\u53d1\u51fa\u7528\u4e8e\u6e32\u67d3\u7ed3\u675f\uff0c\u51c6\u5907\u8fdb\u884c\u5448\u73b0presentation\u3002\u521b\u5efa\u4e24\u4e2a\u6210\u5458\u53d8\u91cf\u5b58\u50a8\u4fe1\u53f7\u91cf\u5bf9\u8c61: VkSemaphore imageAvailableSemaphore; VkSemaphore renderFinishedSemaphore; C++ \u4e3a\u4e86\u521b\u5efa\u4fe1\u53f7\u91cfsemaphores\uff0c\u6211\u4eec\u5c06\u8981\u65b0\u589e\u672c\u7cfb\u5217\u6559\u7a0b\u6700\u540e\u4e00\u4e2a\u51fd\u6570: createSemaphores : void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); createSemaphores(); } ... void createSemaphores() { } C++ \u521b\u5efa\u4fe1\u53f7\u91cf\u5bf9\u8c61\u9700\u8981\u586b\u5145 VkSemaphoreCreateInfo \u7ed3\u6784\u4f53\uff0c\u4f46\u662f\u5728\u5f53\u524d\u7248\u672c\u7684 API \u4e2d\uff0c\u5b9e\u9645\u4e0a\u4e0d\u9700\u8981\u586b\u5145\u4efb\u4f55\u5b57\u6bb5\uff0c\u9664 sType : void createSemaphores() { VkSemaphoreCreateInfo semaphoreInfo = {}; semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; } C++ Vulkan API\u672a\u6765\u7248\u672c\u6216\u8005\u6269\u5c55\u4e2d\u6216\u8bb8\u4f1a\u4e3a flags \u548c pNext \u53c2\u6570\u589e\u52a0\u529f\u80fd\u9009\u9879\u3002\u521b\u5efa\u4fe1\u53f7\u91cf\u5bf9\u8c61\u7684\u8fc7\u7a0b\u5f88\u719f\u6089\u4e86\uff0c\u5728\u8fd9\u91cc\u4f7f\u7528 vkCreateSemaphore : if (vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphore) != VK_SUCCESS || vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphore) != VK_SUCCESS) { throw std::runtime_error(\"failed to create semaphores!\"); } C++ \u5728\u7a0b\u5e8f\u7ed3\u675f\u65f6\uff0c\u5f53\u6240\u6709\u547d\u4ee4\u5b8c\u6210\u5e76\u4e0d\u9700\u8981\u540c\u6b65\u65f6\uff0c\u5e94\u8be5\u6e05\u9664\u4fe1\u53f7\u91cf: void cleanup() { vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); C++ \u4ece\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf \u5c31\u50cf\u4e4b\u524d\u8bf4\u5230\u7684\uff0c drawFrame \u51fd\u6570\u9700\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u56fe\u50cf\u3002\u56de\u60f3\u4e00\u4e0b\u4ea4\u6362\u94fe\u662f\u4e00\u4e2a\u6269\u5c55\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u4f7f\u7528\u5177\u6709vk*KHR\u547d\u540d\u7ea6\u5b9a\u7684\u51fd\u6570: void drawFrame() { uint32_t imageIndex; vkAcquireNextImageKHR(device, swapChain, std::numeric_limits<uint64_t>::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex); } C++ vkAcquireNextImageKHR \u51fd\u6570\u524d\u4e24\u4e2a\u53c2\u6570\u662f\u6211\u4eec\u5e0c\u671b\u83b7\u53d6\u5230\u56fe\u50cf\u7684\u903b\u8f91\u8bbe\u5907\u548c\u4ea4\u6362\u94fe\u3002\u7b2c\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u83b7\u53d6\u6709\u6548\u56fe\u50cf\u7684\u64cd\u4f5ctimeout\uff0c\u5355\u4f4d\u7eb3\u79d2\u3002\u6211\u4eec\u4f7f\u752864\u4f4d\u65e0\u7b26\u53f7\u6700\u5927\u503c\u7981\u6b62 timeout \u3002 \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u4f7f\u7528\u7684\u540c\u6b65\u5bf9\u8c61\uff0c\u5f53 presentation \u5f15\u64ce\u5b8c\u6210\u4e86\u56fe\u50cf\u7684\u5448\u73b0\u540e\u4f1a\u4f7f\u7528\u8be5\u5bf9\u8c61\u53d1\u8d77\u4fe1\u53f7\u3002\u8fd9\u5c31\u662f\u5f00\u59cb\u7ed8\u5236\u7684\u65f6\u95f4\u70b9\u3002\u5b83\u53ef\u4ee5\u6307\u5b9a\u4e00\u4e2a\u4fe1\u53f7\u91cf semaphore \u6216\u8005\u6805\u680f\u6216\u8005\u4e24\u8005\u3002\u51fa\u4e8e\u76ee\u7684\u6027\uff0c\u6211\u4eec\u4f1a\u4f7f\u7528 imageAvailableSemaphore \u3002 \u6700\u540e\u7684\u53c2\u6570\u6307\u5b9a\u4ea4\u6362\u94fe\u4e2d\u6210\u4e3a available \u72b6\u6001\u7684\u56fe\u50cf\u5bf9\u5e94\u7684\u7d22\u5f15\u3002\u5176\u4e2d\u7d22\u5f15\u4f1a\u5f15\u7528\u4ea4\u6362\u94fe\u56fe\u50cf\u6570\u7ec4 swapChainImages \u7684\u56fe\u50cf VkImage \u3002\u6211\u4eec\u4f7f\u7528\u8fd9\u4e2a\u7d22\u5f15\u9009\u62e9\u6b63\u786e\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002 \u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a \u961f\u5217\u63d0\u4ea4\u548c\u540c\u6b65\u901a\u8fc7 VkSubmitInfo \u7ed3\u6784\u4f53\u8fdb\u884c\u53c2\u6570\u914d\u7f6e\u3002 VkSubmitInfo submitInfo = {}; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; VkSemaphore waitSemaphores[] = {imageAvailableSemaphore}; VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT}; submitInfo.waitSemaphoreCount = 1; submitInfo.pWaitSemaphores = waitSemaphores; submitInfo.pWaitDstStageMask = waitStages; C++ \u524d\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u5728\u6267\u884c\u5f00\u59cb\u4e4b\u524d\u8981\u7b49\u5f85\u7684\u54ea\u4e2a\u4fe1\u53f7\u91cf\u53ca\u8981\u7b49\u5f85\u7684\u901a\u9053\u7684\u54ea\u4e2a\u9636\u6bb5\u3002\u4e3a\u4e86\u5411\u56fe\u50cf\u5199\u5165\u989c\u8272\uff0c\u6211\u4eec\u4f1a\u7b49\u5f85\u56fe\u50cf\u72b6\u6001\u53d8\u4e3a available \uff0c\u6240\u6211\u4eec\u6307\u5b9a\u5199\u5165\u989c\u8272\u9644\u4ef6\u7684\u56fe\u5f62\u7ba1\u7ebf\u9636\u6bb5\u3002\u7406\u8bba\u4e0a\u8fd9\u610f\u5473\u7740\uff0c\u5177\u4f53\u7684\u9876\u70b9\u7740\u8272\u5668\u5f00\u59cb\u6267\u884c\uff0c\u800c\u56fe\u50cf\u4e0d\u53ef\u7528\u3002 waitStages \u6570\u7ec4\u5bf9\u5e94 pWaitSemaphores \u4e2d\u5177\u6709\u76f8\u540c\u7d22\u5f15\u7684\u4fe1\u53f7\u91cf\u3002 submitInfo.commandBufferCount = 1; submitInfo.pCommandBuffers = &commandBuffers[imageIndex]; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u54ea\u4e2a\u547d\u4ee4\u7f13\u51b2\u533a\u88ab\u5b9e\u9645\u63d0\u4ea4\u6267\u884c\u3002\u5982\u521d\u671f\u63d0\u5230\u7684\uff0c\u6211\u4eec\u5e94\u8be5\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u5b83\u5c06\u6211\u4eec\u521a\u83b7\u53d6\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u505a\u4e3a\u989c\u8272\u9644\u4ef6\u8fdb\u884c\u7ed1\u5b9a\u3002 VkSemaphore signalSemaphores[] = {renderFinishedSemaphore}; submitInfo.signalSemaphoreCount = 1; submitInfo.pSignalSemaphores = signalSemaphores; C++ signalSemaphoreCount \u548c pSignalSemaphores \u53c2\u6570\u6307\u5b9a\u4e86\u5f53\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u7ed3\u675f\u5411\u54ea\u4e9b\u4fe1\u53f7\u91cf\u53d1\u51fa\u4fe1\u53f7\u3002\u6839\u636e\u6211\u4eec\u7684\u9700\u8981\u4f7f\u7528 renderFinishedSemaphore \u3002 if (vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE) != VK_SUCCESS) { throw std::runtime_error(\"failed to submit draw command buffer!\"); } C++ \u4f7f\u7528 vkQueueSubmit \u51fd\u6570\u5411\u56fe\u50cf\u961f\u5217\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u5f53\u5f00\u9500\u8d1f\u8f7d\u6bd4\u8f83\u5927\u7684\u65f6\u5019\uff0c\u5904\u4e8e\u6548\u7387\u8003\u8651\uff0c\u51fd\u6570\u53ef\u4ee5\u6301\u6709 VkSubmitInfo \u7ed3\u6784\u4f53\u6570\u7ec4\u3002\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u5f15\u7528\u4e86\u4e00\u4e2a\u53ef\u9009\u7684\u6805\u680f\uff0c\u5f53\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u5b8c\u6bd5\u65f6\u5019\u5b83\u4f1a\u88ab\u53d1\u9001\u4fe1\u53f7\u3002\u6211\u4eec\u4f7f\u7528\u4fe1\u53f7\u91cf\u8fdb\u884c\u540c\u6b65\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4f20\u9012 VK_NULL_HANDLE \u3002 Subpass \u4f9d\u8d56\u6027 \u8bf7\u8bb0\u4f4f\uff0c\u6e32\u67d3\u901a\u9053\u4e2d\u7684\u5b50\u901a\u9053\u4f1a\u81ea\u52a8\u5904\u7406\u5e03\u5c40\u7684\u53d8\u6362\u3002\u8fd9\u4e9b\u53d8\u6362\u901a\u8fc7\u5b50\u901a\u9053\u7684\u4f9d\u8d56\u5173\u7cfb\u8fdb\u884c\u63a7\u5236\uff0c\u5b83\u4eec\u6307\u5b9a\u4e86\u5f7c\u6b64\u4e4b\u95f4\u5185\u5b58\u548c\u6267\u884c\u7684\u4f9d\u8d56\u5173\u7cfb\u3002\u73b0\u5728\u53ea\u6709\u4e00\u4e2a\u5b50\u901a\u9053\uff0c\u4f46\u662f\u5728\u6b64\u5b50\u901a\u9053\u4e4b\u524d\u548c\u4e4b\u540e\u7684\u64cd\u4f5c\u4e5f\u88ab\u89c6\u4e3a\u9690\u5f0f\u201c\u5b50\u901a\u9053\u201d\u3002 \u6709\u4e24\u4e2a\u5185\u7f6e\u7684\u4f9d\u8d56\u5173\u7cfb\u5728\u6e32\u67d3\u901a\u9053\u5f00\u59cb\u548c\u6e32\u67d3\u901a\u9053\u7ed3\u675f\u5904\u7406\u8f6c\u6362\uff0c\u4f46\u662f\u524d\u8005\u4e0d\u4f1a\u5728\u5f53\u4e0b\u53d1\u751f\u3002\u5047\u8bbe\u8f6c\u6362\u53d1\u751f\u5728\u7ba1\u7ebf\u7684\u8d77\u59cb\u9636\u6bb5\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u83b7\u53d6\u56fe\u50cf\uff01\u6709\u4e24\u4e2a\u65b9\u6cd5\u5904\u7406\u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u5c06 imageAvailableSemaphore \u7684 waitStages \u66f4\u6539\u4e3a VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT \uff0c\u786e\u4fdd\u56fe\u50cf\u6709\u6548\u4e4b\u524d\u6e32\u67d3\u901a\u9053\u4e0d\u4f1a\u5f00\u59cb\uff0c\u6216\u8005\u6211\u4eec\u8ba9\u6e32\u67d3\u901a\u9053\u7b49\u5f85 VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT \u9636\u6bb5\u3002\u6211\u89c9\u5f97\u4f7f\u7528\u7b2c\u4e8c\u4e2a\u9009\u9879\uff0c\u56e0\u4e3a\u53ef\u4ee5\u6bd4\u8f83\u5168\u9762\u7684\u4e86\u89e3 subpass \u4f9d\u8d56\u5173\u7cfb\u53ca\u5176\u5de5\u4f5c\u65b9\u5f0f\u3002 \u5b50\u901a\u9053\u4f9d\u8d56\u5173\u7cfb\u53ef\u4ee5\u901a\u8fc7 VkSubpassDependency \u7ed3\u6784\u4f53\u6307\u5b9a\uff0c\u5728 createRenderPass \u51fd\u6570\u4e2d\u6dfb\u52a0: VkSubpassDependency dependency = {}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; C++ \u524d\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u4f9d\u8d56\u7684\u5173\u7cfb\u548c\u4ece\u5c5e\u5b50\u901a\u9053\u7684\u7d22\u5f15\u3002\u7279\u6b8a\u503c VK_SUBPASS_EXTERNAL \u662f\u6307\u5728\u6e32\u67d3\u901a\u9053\u4e4b\u524d\u6216\u8005\u4e4b\u540e\u7684\u9690\u5f0f\u5b50\u901a\u9053\uff0c\u53d6\u51b3\u4e8e\u5b83\u662f\u5426\u5728 srcSubpass \u6216\u8005 dstSubPass \u4e2d\u6307\u5b9a\u3002\u7d22\u5f150\u6307\u5b9a\u6211\u4eec\u7684\u5b50\u901a\u9053\uff0c\u8fd9\u662f\u7b2c\u4e00\u4e2a\u4e5f\u662f\u552f\u4e00\u7684\u3002 dstSubpass \u5fc5\u987b\u59cb\u7ec8\u9ad8\u4e8e srcSubPass \u4ee5\u9632\u6b62\u4f9d\u8d56\u5173\u7cfb\u51fa\u73b0\u5faa\u73af\u3002 dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u5b57\u6bb5\u6307\u5b9a\u8981\u7b49\u5f85\u7684\u64cd\u4f5c\u548c\u8fd9\u4e9b\u64cd\u4f5c\u53d1\u751f\u7684\u9636\u6bb5\u3002\u5728\u6211\u4eec\u53ef\u4ee5\u8bbf\u95ee\u5bf9\u8c61\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u7b49\u5f85\u4ea4\u6362\u94fe\u5b8c\u6210\u5bf9\u5e94\u56fe\u50cf\u7684\u8bfb\u53d6\u64cd\u4f5c\u3002\u8fd9\u53ef\u4ee5\u901a\u8fc7\u7b49\u5f85\u989c\u8272\u9644\u4ef6\u8f93\u51fa\u7684\u9636\u6bb5\u6765\u5b9e\u73b0\u3002 dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; C++ \u5728\u989c\u8272\u9644\u4ef6\u9636\u6bb5\u7684\u64cd\u4f5c\u53ca\u6d89\u53ca\u989c\u8272\u9644\u4ef6\u7684\u8bfb\u53d6\u548c\u5199\u5165\u7684\u64cd\u4f5c\u5e94\u8be5\u7b49\u5f85\u3002\u8fd9\u4e9b\u8bbe\u7f6e\u5c06\u963b\u6b62\u8f6c\u6362\u53d1\u751f\uff0c\u76f4\u5230\u5b9e\u9645\u9700\u8981(\u5e76\u5141\u8bb8):\u5f53\u6211\u4eec\u9700\u8981\u5199\u5165\u989c\u8272\u65f6\u5019\u3002 renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; C++ VkRenderPassCreateInfo \u7ed3\u6784\u4f53\u6709\u4e24\u4e2a\u5b57\u6bb5\u6307\u5b9a\u4f9d\u8d56\u7684\u6570\u7ec4\u3002 \u5448\u73b0 \u7ed8\u5236\u5e27\u6700\u540e\u4e00\u4e2a\u6b65\u9aa4\u662f\u5c06\u7ed3\u679c\u63d0\u4ea4\u5230\u4ea4\u6362\u94fe\uff0c\u4f7f\u5176\u6700\u7ec8\u663e\u793a\u5728\u5c4f\u5e55\u4e0a\u3002 Presentation \u901a\u8fc7 VkPresentInfoKHR \u7ed3\u6784\u4f53\u914d\u7f6e\uff0c\u5177\u4f53\u4f4d\u7f6e\u5728 drawFrame \u51fd\u6570\u6700\u540e\u3002 VkPresentInfoKHR presentInfo = {}; presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR; presentInfo.waitSemaphoreCount = 1; presentInfo.pWaitSemaphores = signalSemaphores; C++ \u524d\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u5728\u8fdb\u884cpresentation\u4e4b\u524d\u8981\u7b49\u5f85\u7684\u4fe1\u53f7\u91cf\uff0c\u5c31\u50cf VkSubmitInfo \u4e00\u6837\u3002 VkSwapchainKHR swapChains[] = {swapChain}; presentInfo.swapchainCount = 1; presentInfo.pSwapchains = swapChains; presentInfo.pImageIndices = &imageIndex; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u7528\u4e8e\u63d0\u4ea4\u56fe\u50cf\u7684\u4ea4\u6362\u94fe\u548c\u6bcf\u4e2a\u4ea4\u6362\u94fe\u56fe\u50cf\u7d22\u5f15\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4ec5\u4e00\u4e2a\u3002 presentInfo.pResults = nullptr; // Optional C++ \u6700\u540e\u4e00\u4e2a\u53ef\u9009\u53c2\u6570 pResults \uff0c\u5b83\u5141\u8bb8\u6307\u5b9a\u4e00\u7ec4 VkResult \u503c\uff0c\u4ee5\u4fbf\u5728 presentation \u6210\u529f\u65f6\u68c0\u67e5\u6bcf\u4e2a\u72ec\u7acb\u7684\u4ea4\u6362\u94fe\u3002\u5982\u679c\u53ea\u4f7f\u7528\u5355\u4e2a\u4ea4\u6362\u94fe\uff0c\u5219\u4e0d\u9700\u8981\uff0c\u56e0\u4e3a\u53ef\u4ee5\u7b80\u5355\u7684\u4f7f\u7528\u5f53\u524d\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002 vkQueuePresentKHR(presentQueue, &presentInfo); C++ vkQueuePresentKHR \u51fd\u6570\u63d0\u4ea4\u8bf7\u6c42\u5448\u73b0\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u3002\u6211\u4eec\u5728\u4e0b\u4e00\u4e2a\u7ae0\u8282\u4e3a vkAcquireNextImageKHR \u548c vkQueuePresentKHR \u53ef\u4ee5\u6dfb\u52a0\u9519\u8bef\u5904\u7406\u3002\u56e0\u4e3a\u5b83\u4eec\u5931\u8d25\u5e76\u4e0d\u4e00\u5b9a\u610f\u5473\u7740\u7a0b\u5e8f\u5e94\u8be5\u7ec8\u6b62\uff0c\u4e0e\u6211\u4eec\u8fc4\u4eca\u4e3a\u6b62\u770b\u5230\u7684\u529f\u80fd\u4e0d\u540c\u3002 \u5982\u679c\u4e00\u5207\u987a\u5229\uff0c\u5f53\u518d\u6b21\u8fd0\u884c\u7a0b\u5e8f\u65f6\u5019\uff0c\u5e94\u8be5\u53ef\u4ee5\u770b\u5230\u4e00\u4e0b\u5185\u5bb9: \u9057\u61be\u7684\u662f\uff0c\u53ea\u8981\u7a0b\u5e8f\u5173\u95ed\uff0c\u7531\u4e8e\u5f00\u542f\u4e86validation layers\u4f60\u5c06\u4f1a\u770b\u5230\u7a0b\u5e8f\u5d29\u6e83\u7684\u4fe1\u606f\u3002\u4ece\u7ec8\u7aef\u63a7\u5236\u53f0\u6253\u5370\u7684\u4fe1\u606f\u6765\u6e90 debugCallback \uff0c\u544a\u8bc9\u4e86\u6211\u4eec\u5177\u4f53\u7684\u539f\u56e0: \u9700\u8981\u4e86\u89e3\u7684\u662f drawFrame \u51fd\u6570\u4e2d\u6240\u6709\u7684\u64cd\u4f5c\u90fd\u662f\u5f02\u6b65\u7684\u3002\u610f\u5473\u7740\u5f53\u7a0b\u5e8f\u9000\u51fa mainLoop \uff0c\u7ed8\u5236\u548c\u5448\u73b0\u64cd\u4f5c\u53ef\u80fd\u4ecd\u7136\u5728\u6267\u884c\u3002\u6240\u4ee5\u6e05\u7406\u8be5\u90e8\u5206\u7684\u8d44\u6e90\u662f\u4e0d\u53cb\u597d\u7684\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u5e94\u8be5\u5728\u9000\u51fa mainLoop \u9500\u6bc1\u7a97\u4f53\u524d\u7b49\u5f85\u903b\u8f91\u8bbe\u5907\u7684\u64cd\u4f5c\u5b8c\u6210: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); drawFrame(); } vkDeviceWaitIdle(device); } C++ \u4e5f\u53ef\u4ee5\u4f7f\u7528 vkQueueWaitIdle \u7b49\u5f85\u7279\u5b9a\u547d\u4ee4\u961f\u5217\u4e2d\u7684\u64cd\u4f5c\u5b8c\u6210\u3002\u8fd9\u4e9b\u529f\u80fd\u53ef\u4ee5\u4f5c\u4e3a\u4e00\u4e2a\u975e\u5e38\u57fa\u672c\u7684\u65b9\u5f0f\u6765\u6267\u884c\u540c\u6b65\u3002\u8fd9\u4e2a\u65f6\u5019\u7a97\u4f53\u5173\u95ed\u540e\u8be5\u95ee\u9898\u4e0d\u4f1a\u51fa\u73b0\u3002 \u5185\u5b58\u6cc4\u6f0f \u5982\u679c\u8fd0\u884c\u65f6\u542f\u7528\u4e86 validation layers \u5e76\u76d1\u89c6\u5e94\u7528\u7a0b\u5e8f\u7684\u5185\u5b58\u4f7f\u7528\u60c5\u51b5\uff0c\u4f60\u4f1a\u53d1\u73b0\u5b83\u5728\u6162\u6162\u589e\u52a0\u3002\u539f\u56e0\u662f validation layers \u7684\u5b9e\u73b0\u671f\u671b\u4e0e GPU \u540c\u6b65\u3002\u867d\u7136\u5728\u6280\u672f\u4e0a\u662f\u4e0d\u9700\u8981\u7684\uff0c\u4f46\u662f\u4e00\u65e6\u8fd9\u6837\u505a\uff0c\u6bcf\u4e00\u9488\u5e27\u4e0d\u4f1a\u51fa\u73b0\u660e\u663e\u7684\u6027\u80fd\u5f71\u54cd\u3002 \u6211\u4eec\u53ef\u4ee5\u5728\u5f00\u59cb\u7ed8\u5236\u4e0b\u4e00\u5e27\u4e4b\u524d\u660e\u786e\u7684\u7b49\u5f85 presentation \u5b8c\u6210: void drawFrame() { ... vkQueuePresentKHR(presentQueue, &presentInfo); vkQueueWaitIdle(presentQueue); } C++ \u5728\u5f88\u591a\u5e94\u7528\u7a0b\u5e8f\u7684\u7684\u72b6\u6001\u4e5f\u4f1a\u5728\u6bcf\u4e00\u5e27\u66f4\u65b0\u3002\u4e3a\u6b64\u66f4\u9ad8\u6548\u7684\u7ed8\u5236\u4e00\u9635\u7684\u65b9\u5f0f\u5982\u4e0b\uff1a void drawFrame() { updateAppState(); vkQueueWaitIdle(presentQueue); vkAcquireNextImageKHR(...) submitDrawCommands(); vkQueuePresentKHR(presentQueue, &presentInfo); } C++ \u8be5\u65b9\u6cd5\u5141\u8bb8\u6211\u4eec\u66f4\u65b0\u5e94\u7528\u7a0b\u5e8f\u7684\u72b6\u6001\uff0c\u6bd4\u5982\u8fd0\u884c\u6e38\u620f\u7684AI\u534f\u540c\u7a0b\u5e8f\uff0c\u800c\u524d\u4e00\u5e27\u88ab\u6e32\u67d3\u3002\u8fd9\u6837\uff0c\u59cb\u7ec8\u4fdd\u6301 CPU \u548c GPU \u5904\u4e8e\u5de5\u4f5c\u72b6\u6001\u3002 \u7ed3\u8bba \u5927\u7ea6800\u884c\u4ee3\u7801\u4e4b\u540e\uff0c\u6211\u4eec\u7ec8\u4e8e\u770b\u5230\u4e86\u4e09\u89d2\u5f62\u7ed8\u5236\u5728\u5c4f\u5e55\u4e0a\uff01 Vulkan \u5f15\u5bfc\u7a0b\u5e8f\u9700\u8981\u5f88\u591a\u7684\u5de5\u4f5c\u8981\u53bb\u505a\uff0c\u4f46\u597d\u5904\u662f Vulkan \u901a\u8fc7\u8981\u6c42\u6bcf\u4e00\u4e2a\u660e\u786e\u7684\u5b9e\u73b0\uff0c\u5e26\u6765\u4e86\u4e86\u5de8\u5927\u7684\u63a7\u5236\u6743\u3002\u5efa\u8bae\u82b1\u8d39\u4e00\u4e9b\u65f6\u95f4\u91cd\u65b0\u8bfb\u4ee3\u7801\uff0c\u5e76\u5efa\u7acb\u4e00\u4e2a\u601d\u7ef4\u5bfc\u56fe\u6a21\u578b\uff0c\u76ee\u7684\u5728\u4e8e\u4e86\u89e3 Vulkan \u4e2d\u6bcf\u4e00\u4e2a\u5bf9\u8c61\uff0c\u4ee5\u53ca\u5b83\u4eec\u7684\u4e92\u76f8\u7684\u5173\u7cfb\u3002\u4e4b\u540e\u6211\u4eec\u5c06\u4f1a\u57fa\u4e8e\u8fd9\u4e2a\u57fa\u7840\u6784\u5efa\u6269\u5c55\u7a0b\u5e8f\u529f\u80fd\u3002 \u5728\u4e0b\u4e00\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u7ec6\u5316 Vulkan \u7a0b\u5e8f\u4e2d\u7684\u4e00\u4e9b\u7ec6\u8282\uff0c\u4f7f\u5176\u8868\u73b0\u66f4\u7a33\u5b9a\u3002 Vulkan \u91cd\u6784\u4ea4\u6362\u94fe Vulkan \u91cd\u6784\u4ea4\u6362\u94fe \uff0c\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6210\u529f\u7684\u5728\u5c4f\u5e55\u4e0a\u7ed8\u5236\u51fa\u4e09\u89d2\u5f62\uff0c\u4f46\u662f\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5b83\u4f1a\u51fa\u73b0\u5f02\u5e38\u60c5\u51b5\u3002\u7a97\u4f53 surface \u4f1a\u53d1\u751f\u6539\u53d8\uff0c\u4f7f\u5f97\u4ea4\u6362\u94fe\u4e0d\u5728\u4e0e\u5176\u517c\u5bb9\u3002\u53ef\u80fd\u5bfc\u81f4\u8fd9\u79cd\u60c5\u51b5\u53d1\u751f\u7684\u539f\u56e0\u4e4b\u4e00\u662f\u7a97\u4f53\u7684\u5927\u5c0f\u53d8\u5316\u3002\u6211\u4eec\u5fc5\u987b\u5728\u8fd9\u4e2a\u65f6\u673a\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe 2 \u7a97\u53e3\u5927\u5c0f\u8c03\u6574 3 \u6b21\u4f18\u6216\u8fc7\u671f\u7684\u4ea4\u6362\u94fe \u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe \u6dfb\u52a0\u65b0\u7684\u51fd\u6570 recreateSwapChain \u5e76\u8c03\u7528 createSwapChain \u53ca\u4f9d\u8d56\u4e8e\u4ea4\u6362\u94fe\u6216\u8005\u7a97\u4f53\u5927\u5c0f\u7684\u5bf9\u8c61\u76f8\u5173\u7684\u6240\u6709\u521b\u5efa\u51fd\u6570\u3002 void recreateSwapChain() { vkDeviceWaitIdle(device); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers(); } \u6211\u4eec\u9996\u5148\u8c03\u7528 vkDeviceIdle ,\u5c31\u50cf\u524d\u4e00\u4e2a\u7ae0\u8282\u63d0\u5230\u7684\uff0c\u6211\u4eec\u4e0d\u80fd\u89e6\u78b0\u6b63\u5728\u4f7f\u7528\u4e2d\u7684\u8d44\u6e90\u3002\u5f88\u660e\u663e\uff0c\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u672c\u8eab\u3002\u56fe\u50cf\u89c6\u56fe\u4e5f\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4eec\u76f4\u63a5\u5efa\u7acb\u5728\u4ea4\u6362\u94fe\u56fe\u50cf\u57fa\u7840\u4e0a\u3002\u6e32\u67d3\u901a\u9053\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4f9d\u8d56\u4ea4\u6362\u94fe\u56fe\u50cf\u7684\u683c\u5f0f\u3002\u5728\u7a97\u4f53\u8c03\u6574\u5927\u5c0f\u7684\u64cd\u4f5c\u671f\u95f4\uff0c\u4ea4\u6362\u94fe\u56fe\u50cf\u683c\u5f0f\u5f88\u5c11\u53d1\u751f\u53d8\u5316\uff0c\u4f46\u4ecd\u5e94\u8be5\u88ab\u5904\u7406\u3002\u5728\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u671f\u95f4\u6307\u5b9a Viewport \u548c scissor \u77e9\u5f62\u5927\u5c0f\uff0c\u6240\u4ee5\u7ba1\u7ebf\u9700\u8981\u91cd\u65b0\u6784\u5efa\u3002\u53ef\u4ee5\u4f7f\u7528\u52a8\u6001\u72b6\u6001\u6539\u53d8 viewports \u548c scissor rectangles \uff0c\u907f\u514d\u91cd\u65b0\u521b\u5efa\u3002\u6700\u540e\u5e27\u7f13\u51b2\u533a\u548c\u547d\u4ee4\u7f13\u51b2\u533a\u4e5f\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4eec\u4e5f\u4f9d\u8d56\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u3002 \u4e3a\u4e86\u786e\u4fdd\u91cd\u65b0\u521b\u5efa\u76f8\u5173\u7684\u5bf9\u8c61\u4e4b\u524d\uff0c\u8001\u7248\u672c\u7684\u5bf9\u8c61\u88ab\u7cfb\u7edf\u6b63\u786e\u56de\u6536\u6e05\u7406\uff0c\u6211\u4eec\u9700\u8981\u79fb\u52a8\u4e00\u4e9bcleanup\u4ee3\u7801\u5230\u4e0d\u540c\u7684\u51fd\u6570\u4e2d\uff0c\u8fd9\u6837\u53ef\u4ee5\u5728 recreateSwapChain \u51fd\u6570\u8c03\u7528\u3002\u8be5\u51fd\u6570\u5b9a\u4e49\u4e3a cleanupSwapChain : void cleanupSwapChain() { } void recreateSwapChain() { vkDeviceWaitIdle(device); cleanupSwapChain() createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers(); } \u6211\u4eec\u4ece cleanup \u4e2d\u5c06\u9700\u8981\u88ab\u91cd\u65b0\u521b\u5efa\u7684\u5bf9\u8c61\u6240\u5bf9\u5e94\u7684\u6e05\u7406\u4ee3\u7801\u79fb\u52a8\u5230 cleanupSwapChain \u4e2d: void cleanupSwapChain() { for (size_t i = 0; i < swapChainFramebuffers.size(); i++) { vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); } vkFreeCommandBuffers(device, commandPool, static_cast<uint32_t>(commandBuffers.size()), commandBuffers.data()); vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); for (size_t i = 0; i < swapChainImageViews.size(); i++) { vkDestroyImageView(device, swapChainImageViews[i], nullptr); } vkDestroySwapchainKHR(device, swapChain, nullptr); } void cleanup() { cleanupSwapChain(); vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); vkDestroyCommandPool(device, commandPool, nullptr); vkDestroyDevice(device, nullptr); DestroyDebugReportCallbackEXT(instance, callback, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate(); } \u6211\u4eec\u91cd\u5934\u521b\u5efa\u547d\u4ee4\u5bf9\u8c61\u6c60 command pool \uff0c\u4f46\u662f\u6bd4\u8f83\u6d6a\u8d39\u770b\u8d77\u6765\u3002\u76f8\u53cd\u7684\uff0c\u6211\u4eec\u9009\u62e9\u501f\u52a9 vkFreeCommandBuffers \u51fd\u6570\u6e05\u7406\u5df2\u7ecf\u5b58\u5728\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u8fd9\u79cd\u65b9\u5f0f\u53ef\u4ee5\u91cd\u7528\u5bf9\u8c61\u6c60\u4e2d\u5df2\u7ecf\u5206\u914d\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002 \u4ee5\u4e0a\u90e8\u5206\u5c31\u662f\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u7684\u5de5\u4f5c\uff01\u7136\u800c\u8fd9\u6837\u505a\u7684\u7f3a\u70b9\u5c31\u662f\u5728\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u5b8c\u6bd5\u4e4b\u524d\uff0c\u4f1a\u9020\u6210\u6e32\u67d3\u505c\u6b62\u3002\u521b\u5efa\u65b0\u4ea4\u6362\u94fe\u7684\u540c\u65f6\u5141\u8bb8\u5728\u65e7\u7684\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u4e0a\u7ee7\u7eed\u7ed8\u5236\u547d\u4ee4\u3002\u9700\u8981\u5c06\u4e4b\u524d\u7684\u4ea4\u6362\u94fe\u4f20\u9012\u5230 VkSwapchainCreateInfoKHR \u7ed3\u6784\u4f53\u4e2d\u7684 oldSwapChain \u5b57\u6bb5\uff0c\u5e76\u5728\u4f7f\u7528\u4e4b\u540e\u7acb\u5373\u9500\u6bc1\u3002 \u7a97\u53e3\u5927\u5c0f\u8c03\u6574 \u73b0\u5728\u6211\u4eec\u9700\u8981\u641e\u6e05\u695a\u54ea\u4e9b\u60c5\u51b5\u4e0b\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u662f\u5fc5\u8981\u7684\uff0c\u5e76\u8c03\u7528 recreateSwapChain \u51fd\u6570\u3002\u4e00\u4e2a\u901a\u5e38\u7684\u6761\u4ef6\u662f\u7a97\u4f53\u7684\u5927\u5c0f\u53d8\u5316\u3002\u8ba9\u6211\u4eec\u8c03\u6574\u7a97\u4f53\u7684\u5927\u5c0f\uff0c\u5e76\u89c2\u5bdf\u6355\u6349\u5230\u7684\u4e8b\u4ef6\u3002\u4fee\u6539 initWindow \u51fd\u6570\u4e0d\u518d\u5305\u542b GLFW_RESIZABLE \u884c\uff0c\u6216\u8005\u5c06\u5176\u53c2\u6570\u4ece GLFW_FALSE \u4fee\u6539\u4e3a GLFW_TRUE \u3002 void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); glfwSetWindowUserPointer(window, this); glfwSetWindowSizeCallback(window, HelloTriangleApplication::onWindowResized); } ... static void onWindowResized(GLFWwindow* window, int width, int height) { if (width == 0 || height == 0) return; HelloTriangleApplication* app = reinterpret_cast<HelloTriangleApplication*>(glfwGetWindowUserPointer(window)); app->recreateSwapChain(); } C++ glfwSetWindowSizeCallback \u51fd\u6570\u4f1a\u5728\u7a97\u4f53\u53d1\u751f\u5927\u5c0f\u53d8\u5316\u7684\u65f6\u5019\u88ab\u4e8b\u4ef6\u56de\u8c03\u3002\u9057\u61be\u7684\u662f\uff0c\u5b83\u53ea\u80fd\u63a5\u53d7\u4e00\u4e2a\u6307\u9488\u4f5c\u4e3a\u53c2\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u76f4\u63a5\u4f7f\u7528\u6210\u5458\u51fd\u6570\u3002\u4f46\u5e78\u8fd0\u7684\u662f\uff0cGLFW\u5141\u8bb8\u6211\u4eec\u4f7f\u7528 glfwSetWindowUserPointer \u5c06\u4efb\u610f\u6307\u9488\u5b58\u50a8\u5728\u7a97\u4f53\u5bf9\u8c61\u4e2d\uff0c\u56e0\u6b64\u53ef\u4ee5\u6307\u5b9a\u9759\u6001\u7c7b\u6210\u5458\u8c03\u7528 glfwGetWindowUserPointer \u8fd4\u56de\u539f\u59cb\u7684\u5b9e\u4f8b\u5bf9\u8c61\u3002\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528 recreateSwapChain \uff0c\u8fd9\u79cd\u60c5\u51b5\u901a\u5e38\u53d1\u751f\u5728\uff0c\u7a97\u4f53\u6700\u5c0f\u5316\u5e76\u4e14\u5bfc\u81f4\u4ea4\u6362\u94fe\u521b\u5efa\u5931\u8d25\u65f6. chooseSwapExtent \u51fd\u6570\u5e94\u8be5\u589e\u52a0\u66f4\u65b0\u903b\u8f91\uff0c\u4f7f\u7528\u7a97\u4f53\u6700\u65b0\u7684 width \u548c height \u4ee3\u66ff\u6700\u521d\u7684 WIDTH \u548c HEIGHT : int width, height; glfwGetWindowSize(window, &width, &height); VkExtent2D actualExtent = {width, height}; C++ \u6b21\u4f18\u6216\u8fc7\u671f\u7684\u4ea4\u6362\u94fe \u6709\u4e9b\u65f6\u5019 Vulkan \u53ef\u80fd\u544a\u8bc9\u6211\u4eec\u5f53\u524d\u7684\u4ea4\u6362\u94fe\u5728 presentation \u65f6\u4e0d\u518d\u517c\u5bb9\u3002 vkAcquireNextImageKHR \u548c vkQueuePresentKHR \u51fd\u6570\u53ef\u4ee5\u8fd4\u56de\u5177\u4f53\u7684\u503c\u660e\u786e\u3002 VK_ERROR_OUT_DATE_KHR : \u4ea4\u6362\u94fe\u4e0esurface\u4e0d\u518d\u517c\u5bb9\uff0c\u4e0d\u53ef\u8fdb\u884c\u6e32\u67d3 VK_SUBOPTIMAL_KHR : \u4ea4\u6362\u94fe\u4ecd\u7136\u53ef\u4ee5\u5411surface\u63d0\u4ea4\u56fe\u50cf\uff0c\u4f46\u662fsurface\u7684\u5c5e\u6027\u4e0d\u518d\u5339\u914d\u51c6\u786e\u3002\u6bd4\u5982\u5e73\u53f0\u53ef\u80fd\u91cd\u65b0\u8c03\u6574\u56fe\u50cf\u7684\u5c3a\u5bf8\u9002\u5e94\u7a97\u4f53\u5927\u5c0f\u3002 VkResult result = vkAcquireNextImageKHR(device, swapChain, std::numeric_limits<uint64_t>::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex); if (result == VK_ERROR_OUT_OF_DATE_KHR) { recreateSwapChain(); return; } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) { throw std::runtime_error(\"failed to acquire swap chain image!\"); } C++ \u5982\u679c\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf timeout \uff0c\u8868\u660e\u4e0d\u518d\u53ef\u7528\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u7acb\u5373\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\uff0c\u5e76\u5728\u4e0b\u4e00\u6b21 drawFrame \u8c03\u7528\u4e2d\u5c1d\u8bd5\u83b7\u53d6\u3002 \u4f60\u4e5f\u53ef\u4ee5\u9009\u62e9\u5728\u4ea4\u6362\u94fe\u4e0d\u662f\u6700\u4f73\u72b6\u6001\u7684\u65f6\u5019\uff0c\u9009\u62e9\u91cd\u65b0\u521b\u5efa\uff0c\u6bd4\u5982\u521a\u624d\u8bf4\u7684\u5927\u5c0f\u4e0d\u5339\u914d\u95ee\u9898\u3002\u5728\u8fd9\u91cc\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u83b7\u5f97\u4e86\u4e00\u4e2a\u56fe\u50cf\uff0c\u6240\u4ee5\u7ee7\u7eed\u8fdb\u884c\u3002 VK_SUCCESS \u548c VK_SUBOPTIMAL_KHR \u90fd\u88ab\u8ba4\u4e3a\u662f\u201c\u6210\u529f\u201d\u8fd4\u56de\u7801\u3002 result = vkQueuePresentKHR(presentQueue, &presentInfo); if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) { recreateSwapChain(); } else if (result != VK_SUCCESS) { throw std::runtime_error(\"failed to present swap chain image!\"); } vkQueueWaitIdle(presentQueue); vkQueuePresentKHR \u51fd\u6570\u8fd4\u56de\u540c\u6837\u7684\u503c\u3002\u5728\u6211\u4eec\u7684\u6848\u4f8b\u4e2d\u6211\u4eec\uff0c\u5982\u679c\u662f\u975e\u6700\u4f73\u72b6\u6001\uff0c\u4e5f\u9009\u62e9\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u3002\u56e0\u4e3a\u6211\u4eec\u9700\u8981\u6700\u597d\u7684\u6548\u679c\u3002\u5c1d\u8bd5\u8c03\u6574\u7a97\u4f53\u7684\u5927\u5c0f\uff0c\u5e27\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u53d8\u5316\u4e0e\u7a97\u4f53\u5339\u914d\u3002 Congratulations \uff0c\u6211\u4eec\u5b8c\u7ed3\u4e86\u7b2c\u4e00\u4e2a\u8fd0\u884c\u6bd4\u8f83\u5b8c\u6574\u7684 Vulkan \u7a0b\u5e8f\uff0c\u5728\u4e0b\u9762\u7684\u7ae0\u8282\u4e2d\u6211\u4eec\u5c1d\u8bd5\u6446\u8131\u4e4b\u524d\u7684\u786c\u7f16\u7801\uff0c\u4f7f\u7528\u9876\u70b9\u7f13\u51b2\u533a\u4ee3\u66ff vertex shader \u4e2d\u5199\u6b7b\u9876\u70b9\u6570\u636e\u3002 \u7b2c\u4e8c\u7ae0 Vulkan \u9876\u70b9\u8f93\u5165 Vulkan \u521b\u5efa\u9876\u70b9\u7f13\u51b2\u533a Vulkan \u4e34\u65f6\u7f13\u51b2\u533a Vulkan \u7d22\u5f15\u7f13\u51b2\u533a Vulkan \u63cf\u8ff0\u7b26\u5e03\u5c40\u548c\u7f13\u51b2\u533a Vulkan \u63cf\u8ff0\u7b26\u6c60\u548c\u96c6\u5408 Vulkan \u56fe\u50cf(Images) Vulkan \u56fe\u50cf\u89c6\u56fe\u548c\u91c7\u6837\u5668 Vulkan \u7ec4\u5408\u56fe\u50cf\u53d6\u6837\u5668 Vulkan \u6df1\u5ea6\u7f13\u51b2\u533a Vulkan \u52a0\u8f7d\u6a21\u578b Vulkan \u751f\u6210\u8d34\u56fe(mipmap)","title":"Vulkan\u6559\u7a0b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_1","text":"","title":"\u7b2c\u4e00\u7ae0"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan-vulkan","text":"\u521b\u5efaVulkan\u5b9e\u4f8b \uff0c\u4e0e Vulkan \u6253\u4ea4\u9053\uff0c\u901a\u5e38\u7684\u6b65\u9aa4\u662f\u521b\u5efa\u4e00\u4e2a intance \u53bb\u521d\u59cb\u5316 Vulkan library \u3002\u8fd9\u4e2a instance \u662f\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u4e0e Vulkan \u5e93\u4e4b\u95f4\u7684\u8fde\u63a5\u6865\u6881,\u901a\u5e38\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u9700\u8981\u5411\u9a71\u52a8\u7a0b\u5e8f\u63d0\u4f9b\u4e00\u4e9b\u5e94\u7528\u5c42\u7684\u4fe1\u606f\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b 2 \u68c0\u67e5\u53ef\u9009\u529f\u80fd 3 \u9000\u51fa 4 \u6e90\u4ee3\u7801","title":"Vulkan \u521b\u5efaVulkan\u5b9e\u4f8b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_2","text":"Vulkan API \u4f7f\u7528 vkInstance \u5bf9\u8c61\u6765\u5b58\u50a8\u6240\u6709\u6bcf\u4e2a\u5e94\u7528\u7684\u72b6\u6001\u3002\u5e94\u7528\u7a0b\u5e8f\u5fc5\u987b\u5728\u6267\u884c\u4efb\u4f55\u5176\u4ed6 Vulkan \u64cd\u4f5c\u4e4b\u524d\u521b\u5efa\u4e00\u4e2a Vulkan \u5b9e\u4f8b\uff0c\u57fa\u672c\u7684 Vulkan \u67b6\u6784\u770b\u8d77\u6765\u662f\u8fd9\u6837\u7684\uff1a \u8bf7\u6ce8\u610f\uff0c\u56fe\u4e2d\u6709\u4e00\u4e9b\u5c42\uff08 Layer )\uff0c\u8fd9\u4e9b\u5c42\u4e5f\u88ab\u52a0\u8f7d\u5668\u52a0\u8f7d\u3002\u5c42\u901a\u5e38\u7528\u4e8e\u9a8c\u8bc1\uff0c\u901a\u5e38\u662f\u7531\u9a71\u52a8\u6267\u884c\u7684\u9519\u8bef\u68c0\u67e5\u3002\u5728 Vulkan \u4e2d\uff0c\u9a71\u52a8\u7a0b\u5e8f\u6bd4 OpenGL \u7b49\u5176\u4ed6 API \u8981\u8f7b\u91cf\u5f97\u591a\uff0c\u90e8\u5206\u539f\u56e0\u662f\u5b83\u5c06\u529f\u80fd\u9a8c\u8bc1\u59d4\u6258\u7ed9\u9a8c\u8bc1\u5c42\u3002\u5c42\u662f\u53ef\u9009\u7684\uff0c\u6bcf\u6b21\u5e94\u7528\u7a0b\u5e8f\u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u65f6\u90fd\u53ef\u4ee5\u9009\u62e9\u6027\u5730\u88c5\u8f7d\u3002 Vulkan Layer \u8d85\u51fa\u4e86\u672c\u7ae0\u7684\u8303\u56f4\uff0c\u4e0b\u9762\u5f00\u59cb\u521b\u5efavulkan\u5b9e\u4f8b\uff0c\u9996\u5148\u6dfb\u52a0\u4e00\u4e2a createInstance \u51fd\u6570\uff0c\u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\u3002 void initVulkan() { createInstance(); } C++ \u53e6\u5916\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u6765\u4fdd\u5b58 instance \u53e5\u67c4: private: VkInstance instance; C++ \u73b0\u5728\u6211\u4eec\u521b\u5efa\u4e00\u4e2a instance \uff0c\u5e76\u4e14\u4e3a\u8be5\u6570\u636e\u7ed3\u6784\u8d4b\u4e88\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u4fe1\u606f\u3002\u8fd9\u4e9b\u6570\u636e\u4ece\u6280\u672f\u89d2\u5ea6\u662f\u53ef\u9009\u62e9\u7684\uff0c\u4f46\u662f\u5b83\u53ef\u4ee5\u4e3a\u9a71\u52a8\u7a0b\u5e8f\u63d0\u4f9b\u4e00\u4e9b\u6709\u7528\u7684\u4fe1\u606f\u6765\u4f18\u5316\u7a0b\u5e8f\u7279\u6b8a\u7684\u4f7f\u7528\u60c5\u666f\uff0c\u6bd4\u5982\u9a71\u52a8\u7a0b\u5e8f\u4f7f\u7528\u4e00\u4e9b\u56fe\u5f62\u5f15\u64ce\u7684\u7279\u6b8a\u884c\u4e3a\u3002\u8fd9\u4e2a\u6570\u636e\u7ed3\u6784\u79f0\u4e3a VkApplicationInfo : VkApplicationInfo appInfo = {}; appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;appInfo.pNext = nullptr; appInfo.pApplicationName = \"Hello Triangle\"; appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.pEngineName = \"No Engine\"; appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.apiVersion = VK_API_VERSION_1_0; C++ \u5982\u524d\u6240\u8ff0\uff0c Vulkan \u4e2d\u7684\u8bb8\u591a\u6570\u636e\u7ed3\u6784\u8981\u6c42\u5728 sType \u6210\u5458\u4e2d\u660e\u786e\u7684\u6307\u5b9a\u7c7b\u578b\u3002 pNext \u6210\u5458\u53ef\u7528\u4e8e\u6307\u5411\u7279\u5b9a\u7684\u6269\u5c55\u7ed3\u6784\u3002\u6211\u4eec\u5728\u8fd9\u91cc\u4f7f\u7528\u9ed8\u8ba4\u521d\u59cb\u5316\uff0c\u5c06\u5176\u8bbe\u7f6e\u4e3a nullptr \u3002 Vulkan \u4e2d\u7684\u5927\u91cf\u4fe1\u606f\u901a\u8fc7\u7ed3\u6784\u4f53\u800c\u4e0d\u662f\u51fd\u6570\u53c2\u6570\u4f20\u9012\uff0c\u6211\u4eec\u5c06\u586b\u5145\u4e00\u4e2a\u7ed3\u6784\u4f53\u4ee5\u63d0\u4f9b\u8db3\u591f\u7684\u4fe1\u606f\u521b\u5efa instance \u3002\u4e0b\u4e00\u4e2a\u7ed3\u6784\u4f53\u4e0d\u662f\u53ef\u9009\u7684\uff0c\u5b83\u9700\u8981\u544a\u77e5 Vulkan \u9a71\u52a8\u7a0b\u5e8f\u6211\u4eec\u9700\u8981\u4f7f\u7528\u54ea\u4e9b\u5168\u5c40\u7684 extensions \u548c validation layers \u3002\u8fd9\u91cc\u7684\u5168\u5c40\u610f\u5473\u7740\u5b83\u9002\u7528\u4e8e\u6574\u4e2a\u7a0b\u5e8f\uff0c\u800c\u4e0d\u662f\u7279\u5b9a\u7684\u8bbe\u5907\uff0c\u8fd9\u4e9b\u5185\u5bb9\u5c06\u5728\u63a5\u4e0b\u6765\u7684\u5c0f\u8282\u4e2d\u8bf4\u660e\u3002 VkInstanceCreateInfo \u7ed3\u6784\u4f53\u4fe1\u606f\u5982\u4e0b\uff1a VkInstanceCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pApplicationInfo = &appInfo; C++ \u524d\u51e0\u4e2a\u53c2\u6570\u6bd4\u8f83\u7b80\u5355\u3002\u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u6307\u5b9a\u9700\u8981\u7684\u5168\u5c40\u6269\u5c55\uff0c Vulakn \u5bf9\u4e8e\u5e73\u53f0\u7279\u6027\u662f\u96f6 API \u652f\u6301\u7684(\u81f3\u5c11\u6682\u65f6\u8fd9\u6837)\uff0c\u8fd9\u610f\u5473\u7740\u9700\u8981\u4e00\u4e2a\u6269\u5c55\u624d\u80fd\u4e0e\u4e0d\u540c\u5e73\u53f0\u7684\u7a97\u4f53\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002 GLFW \u6709\u4e00\u4e2a\u65b9\u4fbf\u7684\u5185\u7f6e\u51fd\u6570\uff0c\u8fd4\u56de\u5b83\u6709\u5173\u7684\u6269\u5c55\u4fe1\u606f\uff0c\u6211\u4eec\u53ef\u4ee5\u4f20\u9012\u7ed9 struct : unsigned int glfwExtensionCount = 0; const char** glfwExtensions; glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount); createInfo.enabledExtensionCount = glfwExtensionCount; createInfo.ppEnabledExtensionNames = glfwExtensions; C++ \u7ed3\u6784\u4f53\u7684\u6700\u540e\u4e24\u4e2a\u6210\u5458\u786e\u5b9a\u9700\u8981\u5f00\u542f\u7684\u5168\u5c40\u7684 validation layers \u3002\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u4e00\u8282\u4e2d\u6df1\u5165\u63a2\u8ba8\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u5728\u8fd9\u4e00\u8282\u8bbe\u7f6e\u4e3a\u7a7a\u3002 createInfo.enabledLayerCount = 0; C++ \u6211\u4eec\u73b0\u5728\u5df2\u7ecf\u6307\u5b9a\u4e86 Vulkan \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u9700\u8981\u7684\u4e00\u5207\u4fe1\u606f\uff0c\u8c03\u7528 vkCreateInstance \u521b\u5efa\u5c5e\u4e8e\u6211\u4eec\u7684\u7b2c\u4e00\u4e2a instance : VkResult result = vkCreateInstance(&createInfo, nullptr, &instance); C++ \u5982\u4f60\u6240\u89c1\uff0c Vulkan \u4e2d\u521b\u5efa\u3001\u5b9e\u4f8b\u5316\u76f8\u5173\u7684\u51fd\u6570\u53c2\u6570\u4e00\u822c\u9075\u5faa\u5982\u4e0b\u539f\u5219\u5b9a\u4e49: \u4f7f\u7528\u6709\u5173creation info \u7684\u7ed3\u6784\u4f53\u6307\u9488 \u4f7f\u7528\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u56de\u8c03\u7684\u6307\u9488 \u4f7f\u7528\u4fdd\u5b58\u65b0\u5bf9\u8c61\u53e5\u67c4\u7684\u6307\u9488 \u5982\u679c\u4e00\u5207\u987a\u5229\uff0c\u6b64\u523binstance\u7684\u53e5\u67c4\u5e94\u8be5\u5b58\u50a8\u5728 VkInstance \u7c7b\u6210\u5458\u4e2d\u4e86\u3002\u51e0\u4e4e\u6240\u6709\u7684Vulkan\u51fd\u6570\u90fd\u8fd4\u56de\u4e00\u4e2a\u503c\u4e3a VK_SUCCESS \u6216\u9519\u8bef\u4ee3\u7801\u7684 VkResult \u7c7b\u578b\u7684\u503c\u3002\u8981\u68c0\u67e5 instance \u662f\u5426\u5df2\u7ecf\u6210\u529f\u521b\u5efa\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u4fdd\u5b58\u7ed3\u679c\uff0c\u4ec5\u4ec5\u4f7f\u7528 VK_SUCCESS \u503c\u6765\u68c0\u6d4b\u5373\u53ef\uff1a if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) { throw std::runtime_error(\"failed to create instance!\"); } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\uff0c\u786e\u8ba4\u6211\u4eec\u7684 instance \u521b\u5efa\u6210\u529f\u3002","title":"\u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_3","text":"\u5982\u679c\u4f60\u67e5\u770b vkCreateInstance \u7684\u6587\u6863\uff0c\u4f60\u4f1a\u770b\u5230\u4e00\u4e2a\u53ef\u80fd\u51fa\u73b0\u7684\u9519\u8bef\u4ee3\u7801\u662f VK_ERROR_EXTENSION_NOT_PRESENT \u3002\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u5730\u6307\u5b9a\u6211\u4eec\u9700\u8981\u7684\u6269\u5c55\uff0c\u5982\u679c\u8be5\u9519\u8bef\u4ee3\u7801\u8fd4\u56de\uff0c\u5219\u7ec8\u6b62\u5b83\u4eec\u3002\u8fd9\u5bf9\u4e8e\u7a97\u4f53\u7cfb\u7edf\u6216\u8005\u8bf8\u5982\u6b64\u7c7b\u7684\u6269\u5c55\u662f\u6709\u610f\u4e49\u7684\uff0c\u90a3\u4e48\u5982\u4f55\u68c0\u67e5\u53ef\u9009\u529f\u80fd\u5462\uff1f \u5728\u521b\u5efa instance \u4e4b\u524d\u68c0\u7d22\u652f\u6301\u7684\u6269\u5c55\u5217\u8868\uff0c\u901a\u8fc7 vkEnumerateInstanceExtensionProperties \u51fd\u6570\u3002\u5b83\u6307\u5411\u4e00\u4e2a\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u5b58\u50a8\u6269\u5c55\u6570\u91cf\u548c\u4e00\u4e2a VkExtensionProperties \u6570\u7ec4\u6765\u5b58\u50a8\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f\u3002\u5b83\u4e5f\u63a5\u53d7\u4e00\u4e2a\u53ef\u9009\u62e9\u7684\u53c2\u6570\uff0c\u5141\u8bb8\u6211\u4eec\u901a\u8fc7\u7279\u5b9a\u7684 validation layers \u8fc7\u6ee4\u6269\u5c55\uff0c\u73b0\u5728\u6211\u4eec\u6682\u65f6\u5ffd\u7565\u8fd9\u4e9b\u3002 \u8981\u5206\u914d\u4e00\u4e2a\u6570\u7ec4\u6765\u4fdd\u5b58\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u77e5\u9053\u6709\u591a\u5c11\u4e2a\u6269\u5c55\u5b58\u5728\u3002\u53ef\u4ee5\u901a\u8fc7\u5c06\u540e\u4e00\u4e2a\u53c2\u6570\u7f6e\u7a7a\u6765\u83b7\u53d6\u6269\u5c55\u6570\u91cf: uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr); C++ \u73b0\u5728\u6211\u4eec\u5206\u914d\u4e00\u4e2a\u96c6\u5408\u53bb\u6301\u6709\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f( include ) std::vector<VkExtensionProperties> extensions(extensionCount); C++ \u6700\u540e\u6211\u4eec\u53ef\u4ee5\u904d\u5386\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f: vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data()); C++ \u6bcf\u4e2a VkExtensionProperties \u7ed3\u6784\u4f53\u5305\u542b\u6269\u5c55\u7684\u540d\u79f0\u548c\u7248\u672c\u3002\u6211\u4eec\u53ef\u4ee5\u7528\u7b80\u5355\u7684for\u5faa\u73af\u6253\u5370\u4ed6\u4eec(\\t\u662f\u7f29\u8fdb) std::cout << \"available extensions:\" << std::endl; for (const auto& extension : extensions) { std::cout << \"\\t\" << extension.extensionName << std::endl; } C++ \u5982\u679c\u9700\u8981\u83b7\u53d6\u6709\u5173 Vulkan \u652f\u6301\u7684\u4e00\u4e9b\u8be6\u7ec6\u4fe1\u606f\uff0c\u53ef\u4ee5\u5c06\u6b64\u4ee3\u7801\u6dfb\u52a0\u5230 createInstance \u51fd\u6570\u3002\u4f5c\u4e3a\u4e00\u4e2a\u5c1d\u8bd5\uff0c\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\uff0c\u68c0\u67e5 glfwGetRequiredInstanceExtensions \u8fd4\u56de\u7684\u6240\u6709\u6269\u5c55\u662f\u5426\u90fd\u5305\u542b\u5728\u53d7\u652f\u6301\u7684\u6269\u5c55\u5217\u8868\u4e2d\u3002","title":"\u68c0\u67e5\u53ef\u9009\u529f\u80fd"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_4","text":"\u5728\u7a0b\u5e8f\u9000\u51fa\u524d\uff0c\u8bf7\u6b63\u786e\u9500\u6bc1 VkInstance \u3002\u8fd9\u90e8\u5206\u53ef\u4ee5\u5b9a\u4e49\u5728cleanup\u51fd\u6570\u4e2d\uff0c\u8c03\u7528 vkDestroyInstance \u51fd\u6570\u5b8c\u6210\u3002 void cleanup() { vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate(); } C++ vkDestroyInstance \u51fd\u6570\u7684\u53c2\u6570\u5f88\u7b80\u5355\u3002\u50cf\u4e4b\u524d\u5c0f\u8282\u63d0\u5230\u7684\uff0cVulkan\u4e2d\u7684\u5206\u914d\u548c\u91ca\u653e\u529f\u80fd\u6709\u4e00\u4e2a\u53ef\u9009\u7684\u5206\u914d\u5668\u56de\u8c03\uff0c\u6211\u4eec\u901a\u8fc7\u5c06 nullptr \u8bbe\u7f6e\u5ffd\u7565\u3002\u540e\u7eed\u5c0f\u8282\u4e2d\u521b\u5efa\u7684\u6240\u6709Vulkan\u76f8\u5173\u8d44\u6e90\uff0c\u96c6\u4e2d\u5728cleanup\u51fd\u6570\u4e2d\u8fdb\u884c\u6e05\u7406\uff0c\u4e14\u786e\u4fdd\u5728\u9500\u6bc1 instance \u4e4b\u524d\u9500\u6bc1\u3002 \u5728\u8fdb\u884c\u66f4\u590d\u6742\u7684\u5185\u5bb9\u4e4b\u524d\uff0c\u662f\u65f6\u5019\u4e86\u89e3 validation layers \u4e86\u3002","title":"\u9000\u51fa"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan","text":"Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217 \uff0c\u901a\u8fc7 VkInstance \u521d\u59cb\u5316 Vulkan \u540e\uff0c\u6211\u4eec\u9700\u8981\u5728\u7cfb\u7edf\u4e2d\u67e5\u627e\u5e76\u9009\u62e9\u4e00\u4e2a\u652f\u6301\u6211\u4eec\u6240\u9700\u529f\u80fd\u7684\u663e\u5361\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u6570\u91cf\u7684\u663e\u5361\u5e76\u540c\u65f6\u4f7f\u7528\u4ed6\u4eec\uff0c\u4f46\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u5355\u7684\u8bbe\u5b9a\u9009\u62e9\u89c4\u5219\uff0c\u5373\u5c06\u67e5\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u56fe\u5f62\u5361\u4f5c\u4e3a\u6211\u4eec\u9002\u5408\u7684\u7269\u7406\u8bbe\u5907\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9009\u62e9\u7269\u7406\u8bbe\u5907 2 \u8bbe\u5907\u9700\u6c42\u68c0\u6d4b 3 \u961f\u5217\u65cf 4 \u6e90\u4ee3\u7801","title":"Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217\u7c07"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_5","text":"\u901a\u8fc7 VkInstance \u521d\u59cb\u5316Vulkan\u540e\uff0c\u6211\u4eec\u9700\u8981\u5728\u7cfb\u7edf\u4e2d\u67e5\u627e\u5e76\u9009\u62e9\u4e00\u4e2a\u652f\u6301\u6211\u4eec\u6240\u9700\u529f\u80fd\u7684\u663e\u5361\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u6570\u91cf\u7684\u663e\u5361\u5e76\u540c\u65f6\u4f7f\u7528\u4ed6\u4eec\uff0c\u4f46\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u5355\u7684\u8bbe\u5b9a\u9009\u62e9\u89c4\u5219\uff0c\u5373\u5c06\u67e5\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u56fe\u5f62\u5361\u4f5c\u4e3a\u6211\u4eec\u9002\u5408\u7684\u7269\u7406\u8bbe\u5907\u3002 \u6211\u4eec\u6dfb\u52a0\u51fd\u6570 pickPhysicalDevice \u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); pickPhysicalDevice(); } void pickPhysicalDevice() { } C++ \u6700\u7ec8\u6211\u4eec\u9009\u62e9\u7684\u56fe\u5f62\u663e\u5361\u5b58\u50a8\u5728\u7c7b\u6210\u5458 VkPhysicalDevice \u53e5\u67c4\u4e2d\u3002\u5f53 VkInstance \u9500\u6bc1\u65f6\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u5c06\u4f1a\u88ab\u9690\u5f0f\u9500\u6bc1\uff0c\u6240\u4ee5\u6211\u4eec\u5e76\u4e0d\u9700\u8981\u5728 cleanup \u51fd\u6570\u4e2d\u505a\u4efb\u4f55\u64cd\u4f5c\u3002 VkPhysicalDevice physicalDevice = VK_NULL_HANDLE; C++ \u5173\u4e8e\u83b7\u53d6\u56fe\u5f62\u5361\u5217\u8868\u7684\u65b9\u5f0f\u4e0e\u83b7\u5f97\u6269\u5c55\u5217\u8868\u7684\u65b9\u5f0f\u7c7b\u4f3c\u3002 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); C++ \u5982\u679c Vulkan \u652f\u6301\u7684\u8bbe\u5907\u6570\u4e3a0\uff0c\u90a3\u4e48\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u8fdb\u884c\u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u9009\u62e9\u629b\u51fa\u5f02\u5e38\u3002 if (deviceCount == 0) { throw std::runtime_error(\"failed to find GPUs with Vulkan support!\"); } C++ \u5426\u5219\u6211\u4eec\u5206\u914d\u6570\u7ec4\u5b58\u50a8\u6240\u6709 VkPhysicalDevice \u7684\u53e5\u67c4\u3002 std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); C++ \u73b0\u5728\u6211\u4eec\u9700\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u8bc4\u4f30\uff0c\u68c0\u67e5\u5b83\u4eec\u662f\u5426\u9002\u5408\u6211\u4eec\u8981\u6267\u884c\u7684\u64cd\u4f5c\uff0c\u56e0\u4e3a\u5e76\u4e0d\u662f\u6240\u6709\u7684\u663e\u5361\u529f\u80fd\u4e00\u81f4\u3002\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u51fd\u6570: bool isDeviceSuitable(VkPhysicalDevice device) { return true; } C++ \u6211\u4eec\u5c06\u68c0\u67e5\u662f\u5426\u6709\u4efb\u4f55\u7269\u7406\u8bbe\u5907\u7b26\u5408\u6211\u4eec\u7684\u529f\u80fd\u9700\u6c42\u3002 for (const auto& device : devices) { if (isDeviceSuitable(device)) { physicalDevice = device; break; } } if (physicalDevice == VK_NULL_HANDLE) { throw std::runtime_error(\"failed to find a suitable GPU!\"); } C++ \u4e0b\u4e00\u8282\u6211\u4eec\u4ecb\u7ecd isDeviceSuitable \u51fd\u6570\uff0c\u5e76\u68c0\u67e5\u7b2c\u4e00\u4e2a\u9700\u8981\u6ee1\u8db3\u7684\u529f\u80fd\u3002\u5728\u540e\u7eed\u7684\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u5f00\u59cb\u4f7f\u7528\u66f4\u591a\u7684 Vulkan \u529f\u80fd\uff0c\u6211\u4eec\u4f1a\u6269\u5c55\u6b64\u529f\u80fd\u51fd\u6570\u4ee5\u6ee1\u8db3\u66f4\u591a\u7684\u68c0\u67e5\u6761\u4ef6\u3002","title":"\u9009\u62e9\u7269\u7406\u8bbe\u5907"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_6","text":"\u8bc4\u4f30\u5408\u9002\u7684\u8bbe\u5907\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u904d\u5386\u4e00\u4e9b\u7ec6\u8282\u6765\u5b8c\u6210\u3002\u57fa\u672c\u7684\u8bbe\u5907\u5c5e\u6027\u50cfname, type\u4ee5\u53ca Vulkan \u7248\u672c\u90fd\u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceProperties \u6765\u904d\u5386\u5f97\u5230\u3002 VkPhysicalDeviceProperties deviceProperties; vkGetPhysicalDeviceProperties(device, &deviceProperties); C++ \u53ef\u4ee5\u4f7f\u7528 vkGetPhysicalDeviceFeatures \u67e5\u8be2\u5bf9\u7eb9\u7406\u538b\u7f29\uff0c64\u4f4d\u6d6e\u70b9\u6570\u548c\u591a\u89c6\u56fe\u6e32\u67d3(VR\u975e\u5e38\u6709\u7528)\u7b49\u53ef\u9009\u529f\u80fd\u7684\u652f\u6301: VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceFeatures(device, &deviceFeatures); C++ \u66f4\u591a\u904d\u5386\u7269\u7406\u8bbe\u5907\u7ec6\u8282\u7684\u4fe1\u606f\uff0c\u8bf8\u5982\u8bbe\u5907\u5185\u5b58\u3001\u961f\u5217\u7c07\u6211\u4eec\u5c06\u4f1a\u5728\u540e\u7eed\u5c0f\u8282\u8ba8\u8bba\u3002 \u4f8b\u5982\uff0c\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u4ec5\u9002\u7528\u4e8e\u652f\u6301 geometry shaders \u7684\u4e13\u7528\u663e\u5361\u3002\u90a3\u4e48 isDeviceSuitable \u51fd\u6570\u5c06\u5982\u4e0b\u6240\u793a: bool isDeviceSuitable(VkPhysicalDevice device) { VkPhysicalDeviceProperties deviceProperties; VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceProperties(device, &deviceProperties); vkGetPhysicalDeviceFeatures(device, &deviceFeatures); return deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU && deviceFeatures.geometryShader; } C++ \u4e3a\u4e86\u907f\u514d\u7eaf\u7cb9\u7684\u5355\u4e00\u7684\u5224\u65ad\u4e00\u4e2a\u8bbe\u5907\u662f\u5426\u5408\u9002\uff0c\u5c24\u5176\u662f\u5f53\u4f60\u53d1\u73b0\u591a\u4e2a\u8bbe\u5907\u90fd\u5408\u9002\u7684\u6761\u4ef6\u4e0b\uff0c\u4f60\u4e5f\u53ef\u4ee5\u7ed9\u6bcf\u4e00\u4e2a\u8bbe\u5907\u505a\u6743\u503c\uff0c\u9009\u62e9\u6700\u9ad8\u7684\u4e00\u4e2a\u3002\u8fd9\u6837\uff0c\u53ef\u4ee5\u901a\u8fc7\u7ed9\u4e88\u66f4\u9ad8\u6743\u503c\u83b7\u53d6\u5b9a\u5236\u5316\u7684\u56fe\u5f62\u8bbe\u5907\uff0c\u4f46\u5982\u679c\u6ca1\u6709\u4e00\u4e2a\u53ef\u7528\u7684\u8bbe\u5907\uff0c\u53ef\u4ee5\u56de\u6eda\u5230\u96c6\u6210\u56fe\u5f62\u8bbe\u5907\u3002\u4f60\u53ef\u4ee5\u6309\u7167\u5982\u4e0b\u65b9\u5f0f\u5b9e\u73b0: #include <map> ... void pickPhysicalDevice() { ... // Use an ordered map to automatically sort candidates by increasing score std::multimap<int, VkPhysicalDevice> candidates; for (const auto& device : devices) { int score = rateDeviceSuitability(device); candidates.insert(std::make_pair(score, device)); } // Check if the best candidate is suitable at all if (candidates.rbegin()->first > 0) { physicalDevice = candidates.rbegin()->second; } else { throw std::runtime_error(\"failed to find a suitable GPU!\"); } } int rateDeviceSuitability(VkPhysicalDevice device) { ... int score = 0; // Discrete GPUs have a significant performance advantage if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) { score += 1000; } // Maximum possible size of textures affects graphics quality score += deviceProperties.limits.maxImageDimension2D; // Application can't function without geometry shaders if (!deviceFeatures.geometryShader) { return 0; } return score; } C++ \u6211\u4eec\u4e0d\u9700\u8981\u5728\u5c0f\u8282\u5185\u5b9e\u73b0\u6240\u6709\u5185\u5bb9\uff0c\u4f46\u6211\u4eec\u53ef\u4ee5\u4e86\u89e3\u5982\u4f55\u9009\u62e9\u56fe\u5f62\u8bbe\u5907\u7684\u8fc7\u7a0b\u3002\u5f53\u7136\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u793a\u56fe\u5f62\u8bbe\u5907\u7684\u540d\u79f0\u5217\u8868\uff0c\u8ba9\u7528\u6237\u9009\u62e9\u3002 \u56e0\u4e3a\u6211\u4eec\u521a\u521a\u5f00\u59cb\uff0c Vulkan \u7684\u652f\u6301\u662f\u6211\u4eec\u552f\u4e00\u9700\u8981\u7684\uff0c\u5728\u8fd9\u91cc\u5047\u8bbe\u4efb\u4f55GPU\u90fd\u53ef\u4ee5: bool isDeviceSuitable(VkPhysicalDevice device) { return true; } C++ \u5728\u4e0b\u4e00\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u8ba8\u8bba\u7b2c\u4e00\u4e2a\u771f\u6b63\u9700\u8981\u68c0\u67e5\u7684\u8bbe\u5907\u529f\u80fd\u3002","title":"\u8bbe\u5907\u9700\u6c42\u68c0\u6d4b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_7","text":"\u4e4b\u524d\u5df2\u7ecf\u7b80\u8981\u7684\u4ecb\u7ecd\u8fc7\uff0c\u51e0\u4e4e\u6240\u6709\u7684 Vulkan \u64cd\u4f5c\uff0c\u4ece\u7ed8\u56fe\u5230\u4e0a\u4f20\u7eb9\u7406\uff0c\u90fd\u9700\u8981\u5c06\u547d\u4ee4\u63d0\u4ea4\u5230\u961f\u5217\u4e2d\u3002\u6709\u4e0d\u540c\u7c7b\u578b\u7684\u961f\u5217\u6765\u6e90\u4e8e\u4e0d\u540c\u7684\u961f\u5217\u7c07\uff0c\u6bcf\u4e2a\u961f\u5217\u7c07\u53ea\u5141\u8bb8\u90e8\u5206 commands \u3002\u4f8b\u5982\uff0c\u53ef\u4ee5\u6709\u4e00\u4e2a\u961f\u5217\u7c07\uff0c\u53ea\u5141\u8bb8\u5904\u7406\u8ba1\u7b97 commands \u6216\u8005\u53ea\u5141\u8bb8\u5185\u5b58\u4f20\u8f93 commands : \u6211\u4eec\u9700\u8981\u68c0\u6d4b\u8bbe\u5907\u4e2d\u652f\u6301\u7684\u961f\u5217\u7c07\uff0c\u5176\u4e2d\u54ea\u4e00\u4e2a\u961f\u5217\u7c07\u652f\u6301\u6211\u4eec\u60f3\u8981\u7684 commands \u3002\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u51fd\u6570 findQueueFamilies \u6765\u67e5\u627e\u6211\u4eec\u9700\u8981\u7684\u961f\u5217\u7c07\u3002\u73b0\u5728\u6211\u4eec\u53ea\u4f1a\u5bfb\u627e\u4e00\u4e2a\u652f\u6301\u56fe\u5f62 commands \u961f\u5217\u7c07\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u5728\u7a0d\u540e\u7684\u5c0f\u8282\u4e2d\u6269\u5c55\u66f4\u591a\u7684\u5185\u5bb9\u3002 \u6b64\u51fd\u6570\u8fd4\u56de\u6ee1\u8db3\u67d0\u4e2a\u5c5e\u6027\u7684\u961f\u5217\u7c07\u7d22\u5f15\u3002\u5b9a\u4e49\u7ed3\u6784\u4f53\uff0c\u5176\u4e2d\u7d22\u5f15 -1 \u8868\u793a\u201d\u672a\u627e\u5230\u201d: struct QueueFamilyIndices { int graphicsFamily = -1; bool isComplete() { return graphicsFamily >= 0; } }; C++ \u73b0\u5728\u6211\u4eec\u5b9e\u73b0 findQueueFamilies \u51fd\u6570: QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) { QueueFamilyIndices indices; ... return indices; } C++ \u83b7\u53d6\u961f\u5217\u7c07\u7684\u5217\u8868\u51fd\u6570\u4e3a vkGetPhysicalDeviceQueueFamilyProperties : uint32_t queueFamilyCount = 0; vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr); std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount); vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data()); C++ \u6709\u5173\u961f\u5217\u7c07\uff0c\u7ed3\u6784\u4f53 VkQueueFamilyProperties \u5305\u542b\u4e86\u5177\u4f53\u4fe1\u606f\uff0c\u5305\u62ec\u652f\u6301\u7684\u64cd\u4f5c\u7c7b\u578b\u548c\u57fa\u4e8e\u5f53\u524d\u961f\u5217\u7c07\u53ef\u4ee5\u521b\u5efa\u7684\u6709\u6548\u961f\u5217\u6570\u3002\u6211\u4eec\u81f3\u5c11\u9700\u8981\u627e\u5230\u4e00\u4e2a\u652f\u6301 VK_QUEUE_GRAPHICS_BIT \u7684\u961f\u5217\u7c07\u3002 int i = 0; for (const auto& queueFamily : queueFamilies) { if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) { indices.graphicsFamily = i; } if (indices.isComplete()) { break; } i++; } C++ \u73b0\u5728\u6211\u4eec\u6709\u4e86\u6bd4\u8f83\u7406\u60f3\u7684\u961f\u5217\u7c07\u67e5\u8be2\u529f\u80fd\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 isDeviceSuitable \u51fd\u6570\u4e2d\u4f7f\u7528\uff0c\u786e\u4fdd\u7269\u7406\u8bbe\u5907\u53ef\u4ee5\u5904\u7406\u6211\u4eec\u9700\u8981\u7684\u547d\u4ee4: bool isDeviceSuitable(VkPhysicalDevice device) { QueueFamilyIndices indices = findQueueFamilies(device); return indices.isComplete(); } C++ \u5f88\u597d\uff0c\u6211\u4eec\u5df2\u7ecf\u627e\u5230\u4e86\u6211\u4eec\u9700\u8981\u7684\u7269\u7406\u8bbe\u5907\uff0c\u5728 \u4e0b\u4e00\u4e2a\u5c0f\u8282 \u6211\u4eec\u4f1a\u8ba8\u8bba\u903b\u8f91\u8bbe\u5907\u3002","title":"\u961f\u5217\u65cf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_1","text":"Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b \uff0c \u4e0a\u4e00\u8282 \u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6b63\u786e\u914d\u7f6e\u3001\u53ef\u8fd0\u884c\u7684\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u4f7f\u7528\u6d4b\u8bd5\u4ee3\u7801\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u672c\u8282\u4e2d\u6211\u4eec\u4ece\u5934\u5f00\u59cb\uff0c\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u6784\u5efa\u4e00\u4e2a\u57fa\u4e8e GLFW \u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\u539f\u578b\u6846\u67b6\u7684\u96cf\u5f62\u3002 \u64cd\u4f5c\u7cfb\u7edf: Windows8.1 \u663e\u5361:Nivida GTX965M \u5f00\u53d1\u5de5\u5177\uff1aVisual Studio 2017 \u6587\u7ae0\u76ee\u5f55 1 \u603b\u4f53\u7ed3\u6784 2 \u8d44\u6e90\u7ba1\u7406 3 \u6574\u5408GLFW","title":"Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_8","text":"\u5728\u4e0a\u4e00\u8282\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6b63\u786e\u914d\u7f6e\u3001\u53ef\u8fd0\u884c\u7684\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u4f7f\u7528\u6d4b\u8bd5\u4ee3\u7801\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u672c\u8282\u4e2d\u6211\u4eec\u4ece\u5934\u5f00\u59cb\uff0c\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u6784\u5efa\u4e00\u4e2a\u57fa\u4e8eGLFW\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\u539f\u578b\u6846\u67b6\u7684\u96cf\u5f62\u3002 #include <vulkan/vulkan.h> #include <iostream> #include <stdexcept> #include <functional> class HelloTriangleApplication { public: void run() { initVulkan(); mainLoop(); cleanup(); } private: void initVulkan() { } void mainLoop() { } void cleanup() { } }; int main() { HelloTriangleApplication app; try { app.run(); } catch (const std::runtime_error& e) { std::cerr << e.what() << std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; } C++ \u9996\u5148\u4ece LunarG SDK \u4e2d\u6dfb\u52a0 Vulkan \u5934\u6587\u4ef6\uff0c\u5b83\u63d0\u4f9b\u4e86\u8d2d\u673a\u7231\u4f60 Vulkan \u5e94\u7528\u7a0b\u5e8f\u9700\u8981\u7684\u51fd\u6570\u3001\u7ed3\u6784\u4f53\u3001\u548c\u679a\u4e3e\u3002\u6211\u4eec\u5305\u542b stdexcept \u548c iostream \u5934\u6587\u4ef6\u7528\u4e8e\u629b\u51fa\u5f02\u5e38\u4fe1\u606f\uff0c\u800c functional \u5934\u6587\u4ef6\u7528\u4e8e\u8d44\u6e90\u7ba1\u7406\u90e8\u5206\u652f\u6301 lambda \u8868\u8fbe\u5f0f\u3002 \u7a0b\u5e8f\u88ab\u5c01\u88c5\u5230\u4e00\u4e2a\u7c7b\u4e2d\uff0c\u8be5\u7c7b\u7ed3\u6784\u5c06\u4f1a\u5b58\u50a8Vulkan\u79c1\u6709\u6210\u5458\u5bf9\u8c61\uff0c\u5e76\u6dfb\u52a0\u57fa\u672c\u7684\u51fd\u6570\u6765\u521d\u59cb\u5316\u4ed6\u4eec\u3002\u9996\u5148\u4f1a\u4ece initVulkan \u51fd\u6570\u5f00\u59cb\u8c03\u7528\u3002\u5f53\u4e00\u5207\u51c6\u5907\u597d\uff0c\u6211\u4eec\u8fdb\u5165\u4e3b\u5faa\u73af\u5f00\u59cb\u6e32\u67d3\u5e27\u3002\u6211\u4eec\u5c06\u4f1a\u52a0\u5165 mainLoop \u51fd\u6570\u5305\u542bloop\u5faa\u73af\u8c03\u7528\uff0c\u8be5\u5faa\u73af\u8c03\u7528\u76f4\u5230GLFW\u7a97\u4f53\u7ba1\u7406\u624d\u4f1a\u505c\u6b62\u3002\u5f53\u7a97\u4f53\u5173\u95ed\u5e76\u4e14 mainLoop \u8fd4\u56de\u65f6\uff0c\u6211\u4eec\u9700\u8981\u91ca\u653e\u6211\u4eec\u5df2\u7ecf\u7533\u8bf7\u8fc7\u7684\u4efb\u4f55\u8d44\u6e90\uff0c\u8be5\u6e05\u7406\u903b\u8f91\u5728 cleanup \u51fd\u6570\u4e2d\u53bb\u5b9a\u4e49\u3002 \u7a0b\u5e8f\u8fd0\u884c\u671f\u95f4\uff0c\u5982\u679c\u53d1\u751f\u4e86\u4efb\u4f55\u4e25\u91cd\u7684\u9519\u8bef\u5f02\u5e38\uff0c\u6211\u4eec\u4f1a\u629b\u51fa std::runtime_error \u5e76\u6ce8\u660e\u5f02\u5e38\u63cf\u8ff0\u4fe1\u606f,\u8fd9\u4e2a\u5f02\u5e38\u4fe1\u606f\u4f1a\u88ab main \u51fd\u6570\u6355\u83b7\u53ca\u6253\u5370\u63d0\u793a\u3002\u5f88\u5feb\u4f60\u5c06\u4f1a\u9047\u5230\u4e00\u4e2a\u629b\u51faerror\u7684\u4f8b\u5b50\uff0c\u662f\u5173\u4e8e Vulkan \u5e94\u7528\u7a0b\u5e8f\u4e0d\u652f\u6301\u67d0\u4e2a\u5fc5\u8981\u7684\u6269\u5c55\u529f\u80fd\u3002 \u57fa\u672c\u4e0a\u5728\u4e4b\u540e\u7684\u6bcf\u4e00\u4e2a\u5c0f\u8282\u4e2d\u90fd\u4f1a\u4ece initVulkan \u51fd\u6570\u4e2d\u589e\u52a0\u4e00\u4e2a\u65b0\u7684 Vulkan \u51fd\u6570\u8c03\u7528,\u589e\u52a0\u7684\u51fd\u6570\u4f1a\u4ea7\u751f Vulkan objects \u5e76\u4fdd\u5b58\u4e3a\u7c7b\u7684\u79c1\u6709\u6210\u5458\uff0c\u8bf7\u8bb0\u5f97\u5728 cleanup \u4e2d\u8fdb\u884c\u8d44\u6e90\u7684\u6e05\u7406\u548c\u91ca\u653e\u3002","title":"\u603b\u4f53\u7ed3\u6784"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_9","text":"\u6211\u4eec\u77e5\u9053\u901a\u8fc7 malloc \u5206\u914d\u7684\u6bcf\u4e00\u4e2a\u5185\u5b58\u5feb\u5728\u4f7f\u7528\u5b8c\u4e4b\u540e\u90fd\u9700\u8981 free \u5185\u5b58\u8d44\u6e90\uff0c\u6bcf\u4e00\u4e2a\u6211\u4eec\u521b\u5efa\u7684 Vulkan object \u4e0d\u5728\u4f7f\u7528\u65f6\u90fd\u9700\u8981\u660e\u786e\u7684\u9500\u6bc1\u3002\u5728 C++ \u4e2d\u53ef\u4ee5\u5229\u7528 \u5b8c\u6210auto\u8d44\u6e90\u7ba1\u7406\uff0c\u4f46\u662f\u5728\u672c\u8282\u4e2d\uff0c\u9009\u62e9\u660e\u786e\u7f16\u5199\u6240\u6709\u7684\u5185\u5b58\u7684\u5206\u914d\u548c\u91ca\u653e\u64cd\u4f5c\uff0c\u5176\u4e3b\u8981\u539f\u56e0\u662f`\u7684\u8bbe\u8ba1\u7406\u5ff5\u5c31\u662f\u660e\u786e\u6bcf\u4e00\u6b65\u64cd\u4f5c\uff0c\u6e05\u695a\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f\uff0c\u907f\u514d\u53ef\u80fd\u5b58\u5728\u7684\u672a\u77e5\u4ee3\u7801\u9020\u6210\u7684\u5f02\u5e38\u3002 \u5f53\u7136\u5728\u672c\u8282\u4e4b\u540e,\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u91cd\u8f7d std::shared_ptr \u6765\u5b9e\u73b0auto \u8d44\u6e90\u7ba1\u7406\u3002\u5bf9\u4e8e\u66f4\u5927\u4f53\u91cf\u7684Vulkan\u7a0b\u5e8f,\u5efa\u8bae\u9075\u5faa RAII \u7684\u539f\u5219\u7ef4\u62a4\u8d44\u6e90\u7684\u7ba1\u7406\u3002 Vulkan \u5bf9\u8c61\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 vkCreateXXX \u7cfb\u51fd\u6570\u521b\u5efa\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u5177\u6709 vkAllocateXXX \u7b49\u529f\u80fd\u7684\u4e00\u4e2a\u5bf9\u8c61\u8fdb\u884c\u5206\u914d\u3002\u786e\u4fdd\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u5728\u4e0d\u4f7f\u7528\u7684\u65f6\u5019\u8c03\u7528 vkDestroyXXX \u548c vkFreeXXX \u9500\u6bc1\u3001\u91ca\u653e\u5bf9\u5e94\u7684\u8d44\u6e90\u3002\u8fd9\u4e9b\u51fd\u6570\u7684\u53c2\u6570\u901a\u5e38\u56e0\u4e0d\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u800c\u4e0d\u540c\uff0c\u4f46\u662f\u4ed6\u4eec\u5171\u4eab\u4e00\u4e2a\u53c2\u6570:pAllocator\u3002\u8fd9\u662f\u4e00\u4e2a\u53ef\u9009\u7684\u53c2\u6570\uff0c Vulkan \u5141\u8bb8\u6211\u4eec\u81ea\u5b9a\u4e49\u5185\u5b58\u5206\u914d\u5668\u3002\u6211\u4eec\u5c06\u5728\u672c\u6559\u7a0b\u5ffd\u7565\u6b64\u53c2\u6570\uff0c\u59cb\u7ec8\u4ee5 nullptr \u4f5c\u4e3a\u53c2\u6570\u3002","title":"\u8d44\u6e90\u7ba1\u7406"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#glfw","text":"\u5982\u679c\u6211\u4eec\u5f00\u53d1\u4e00\u4e9b\u4e0d\u9700\u8981\u57fa\u4e8e\u5c4f\u5e55\u663e\u793a\u7684\u7a0b\u5e8f\uff0c\u90a3\u4e48\u7eaf\u7cb9\u7684 Vulkan \u672c\u8eab\u53ef\u4ee5\u5b8c\u7f8e\u7684\u652f\u6301\u5f00\u53d1\u3002\u4f46\u662f\u5982\u679c\u521b\u5efa\u4e00\u4e9b\u8ba9\u4eba\u5174\u594b\u7684\u53ef\u89c6\u5316\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u5c31\u9700\u8981\u5f15\u5165\u7a97\u4f53\u7cfb\u7edf GLFW \uff0c\u5e76\u5c06 #include \u8fdb\u884c\u76f8\u5e94\u7684\u66ff\u6362\u3002 #define GLFW_INCLUDE_VULKAN #include <GLFW/glfw3.h> C++ \u5728\u65b0\u7248\u672c\u7684 GLFW \u4e2d\u5df2\u7ecf\u63d0\u4f9b\u4e86 Vulkan \u76f8\u5173\u7684\u652f\u6301\uff0c\u8be6\u7ec6\u7684\u4f7f\u7528\u5efa\u8bae\u53c2\u9605\u5b98\u65b9\u8d44\u6599\u3002 \u901a\u8fc7\u66ff\u6362\uff0c\u5c06\u4f1a\u4f7f\u7528 GLFW \u5bf9 Vulkan \u7684\u652f\u6301\uff0c\u5e76\u81ea\u52a8\u52a0\u8f7d Vulkan \u7684\u5934\u6587\u4ef6\u3002\u5728 run \u51fd\u6570\u4e2d\u6dfb\u52a0\u4e00\u4e2a initWindow \u51fd\u6570\u8c03\u7528\uff0c\u5e76\u786e\u4fdd\u5728\u5176\u4ed6\u51fd\u6570\u8c03\u7528\u524d\u4f18\u5148\u8c03\u7528\u3002\u6211\u4eec\u5c06\u4f1a\u901a\u8fc7\u8be5\u51fd\u6570\u5b8c\u6210 GLFW \u7684\u7a97\u4f53\u521d\u59cb\u5316\u5de5\u4f5c\u3002 void run() { initWindow(); initVulkan(); mainLoop(); cleanup(); } private: void initWindow() { } C++ initWindow \u4e2d\u7684\u7b2c\u4e00\u4e2a\u8c03\u7528\u662f glfwInit() ,\u5b83\u4f1a\u521d\u59cb\u5316 GLFW \u5e93\u3002\u56e0\u4e3a\u6700\u521d GLFW \u662f\u4e3a OpenGL \u521b\u5efa\u4e0a\u4e0b\u6587\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u4eec\u9700\u8981\u544a\u8bc9\u5b83\u4e0d\u8981\u8c03\u7528 OpenGL \u76f8\u5173\u7684\u521d\u59cb\u5316\u64cd\u4f5c\u3002 glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); C++ \u7279\u522b\u6ce8\u610f\u7a97\u53e3\u5927\u5c0f\u7684\u8bbe\u7f6e\uff0c\u7a0d\u540e\u6211\u4eec\u4f1a\u8c03\u7528\uff0c\u73b0\u5728\u4f7f\u7528\u53e6\u4e00\u4e2a\u7a97\u53e3\u63d0\u793a\u6765\u4ec5\u7528\u5b83\u3002 glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); C++ \u73b0\u5728\u5269\u4e0b\u7684\u5c31\u662f\u521b\u5efa\u5b9e\u9645\u7684\u7a97\u4f53\u3002\u6dfb\u52a0\u4e00\u4e2a GLFWwindow* \u7a97\u4f53\uff0c\u79c1\u6709\u7c7b\u6210\u5458\u5b58\u50a8\u5176\u5f15\u7528\u5e76\u521d\u59cb\u5316\u7a97\u4f53: window = glfwCreateWindow(800, 600, \"Vulkan\", nullptr, nullptr); C++ \u524d\u4e09\u4e2a\u53c2\u6570\u5b9a\u4e49\u7a97\u4f53\u7684\u5bbd\u5ea6\u3001\u9ad8\u5ea6\u548c Title \u3002\u7b2c\u56db\u4e2a\u53c2\u6570\u5141\u8bb8\u5236\u5b9a\u4e00\u4e2a\u76d1\u542c\u5668\u6765\u6253\u5f00\u7a97\u4f53\uff0c\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u4e0e OpenGL \u6709\u5173\uff0c\u6211\u4eec\u9009\u62e9 nullptr \u3002 \u4f7f\u7528\u5e38\u91cf\u4ee3\u66ff\u786c\u7f16\u7801\u5bbd\u5ea6\u548c\u9ad8\u5ea6\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u540e\u7eed\u7684\u5185\u5bb9\u4e2d\u4f1a\u5f15\u7528\u8be5\u6570\u503c\u591a\u6b21\u3002\u5728 HelloTriangleApplication \u7c7b\u5b9a\u4e49\u4e4b\u4e0a\u6dfb\u52a0\u4ee5\u4e0b\u51e0\u884c: const int WIDTH = 800; const int HEIGHT = 600; C++ \u5e76\u66ff\u6362\u7a97\u4f53\u521b\u5efa\u7684\u4ee3\u7801\u8bed\u53e5\u4e3a: window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); C++ \u4f60\u73b0\u5728\u5e94\u8be5\u6709\u4e00\u4e2a\u5982\u4e0b\u6240\u793a\u7684initWindow\u51fd\u6570: void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); } C++ \u4fdd\u6301\u7a0b\u5e8f\u8fd0\u884c\uff0c\u76f4\u5230\u53d1\u751f\u9519\u8bef\u6216\u8005\u7a97\u4f53\u5173\u95ed\uff0c\u6211\u4eec\u9700\u8981\u5411 mainLoop \u51fd\u6570\u6dfb\u52a0\u4e8b\u4ef6\u5faa\u73af\uff0c\u5982\u4e0b\u6240\u793a: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); } } C++ \u8fd9\u6bb5\u4ee3\u7801\u5e94\u8be5\u5f88\u5bb9\u6613\u770b\u61c2\u3002\u5b83\u5faa\u73af\u5e76\u68c0\u67e5 GLFW \u4e8b\u4ef6\uff0c\u76f4\u5230\u6309\u4e0b X \u6309\u94ae\uff0c\u6216\u8005\u5173\u95ed\u7a97\u4f53\u3002\u8be5\u5faa\u73af\u7ed3\u6784\u7a0d\u540e\u4f1a\u8c03\u7528\u6e32\u67d3\u51fd\u6570\u3002 \u4e00\u65e6\u7a97\u4f53\u5173\u95ed\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7 cleanup \u51fd\u6570\u6e05\u7406\u8d44\u6e90\u3001\u7ed3\u675f GLFW \u672c\u8eab\u3002 void cleanup() { glfwDestroyWindow(window); glfwTerminate(); } C++ \u8fd0\u884c\u7a0b\u5e8f\uff0c\u6211\u4eec\u5e94\u8be5\u4f1a\u770b\u5230\u4e00\u4e2a\u540d\u4e3a Vulkan \u7684\u767d\u8272\u7a97\u4f53\uff0c\u76f4\u5230\u5173\u95ed\u7a97\u4f53\u7ec8\u6b62\u5e94\u7528\u7a0b\u5e8f\u3002 ok\uff0c\u5230\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86\u4e00\u4e2a Vulkan \u7a0b\u5e8f\u7684\u9aa8\u67b6\u539f\u578b\uff0c\u5728 \u4e0b\u4e00\u8282 \u6211\u4eec\u4f1a\u521b\u5efa\u7b2c\u4e00\u4e2a Vulkan Object !","title":"\u6574\u5408GLFW"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_2","text":"PASS","title":"[Vulkan \u9a8c\u8bc1\u5c42]"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_3","text":"Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217 \uff0c\u5728\u9009\u62e9\u8981\u4f7f\u7528\u7684\u7269\u7406\u8bbe\u5907\u4e4b\u540e\uff0c\u6211\u4eec\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u903b\u8f91\u8bbe\u5907\u7528\u4e8e\u4ea4\u4e92\u3002\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u8fc7\u7a0b\u4e0einstance\u521b\u5efa\u8fc7\u7a0b\u7c7b\u4f3c\uff0c\u4e5f\u9700\u8981\u63cf\u8ff0\u6211\u4eec\u9700\u8981\u4f7f\u7528\u7684\u529f\u80fd\u3002\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u67e5\u8be2\u8fc7\u54ea\u4e9b\u961f\u5217\u7c07\u53ef\u7528\uff0c\u5728\u8fd9\u91cc\u9700\u8981\u8fdb\u4e00\u6b65\u4e3a\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u5177\u4f53\u7c7b\u578b\u7684\u547d\u4ee4\u961f\u5217\u3002\u5982\u679c\u6709\u4e0d\u540c\u7684\u9700\u6c42\uff0c\u4e5f\u53ef\u4ee5\u57fa\u4e8e\u540c\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u521b\u5efa\u591a\u4e2a\u903b\u8f91\u8bbe\u5907\u3002 \u9996\u5148\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u7c7b\u6210\u5458\u6765\u5b58\u50a8\u903b\u8f91\u8bbe\u5907\u53e5\u67c4\u3002 VkDevice device; C++ \u63a5\u4e0b\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u51fd\u6570 createLogicalDevice \uff0c\u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\uff0c\u4ee5\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u3002 void initVulkan() { createInstance(); setupDebugCallback(); pickPhysicalDevice(); createLogicalDevice(); } void createLogicalDevice() { } C++ https://geek-docs.com/vulkan/vulkan-tutorial/vulkan-logical-devices-and-queues.html#i-5)","title":"Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_10","text":"\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u9700\u8981\u5728\u7ed3\u6784\u4f53\u4e2d\u660e\u786e\u5177\u4f53\u7684\u4fe1\u606f\uff0c\u9996\u5148\u7b2c\u4e00\u4e2a\u7ed3\u6784\u4f53 VkDeviceQueueCreateInfo \u3002\u8fd9\u4e2a\u7ed3\u6784\u4f53\u63cf\u8ff0\u961f\u5217\u7c07\u4e2d\u9884\u8981\u7533\u8bf7\u4f7f\u7528\u7684\u961f\u5217\u6570\u91cf\u3002\u73b0\u5728\u6211\u4eec\u4ec5\u5173\u5fc3\u5177\u5907\u56fe\u5f62\u80fd\u529b\u7684\u961f\u5217\u3002 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); VkDeviceQueueCreateInfo queueCreateInfo = {}; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = indices.graphicsFamily; queueCreateInfo.queueCount = 1; C++ \u5f53\u524d\u53ef\u7528\u7684\u9a71\u52a8\u7a0b\u5e8f\u6240\u63d0\u4f9b\u7684\u961f\u5217\u7c07\u53ea\u5141\u8bb8\u521b\u5efa\u5c11\u91cf\u7684\u961f\u5217\uff0c\u5e76\u4e14\u5f88\u591a\u65f6\u5019\u6ca1\u6709\u5fc5\u8981\u521b\u5efa\u591a\u4e2a\u961f\u5217\u3002\u8fd9\u662f\u56e0\u4e3a\u53ef\u4ee5\u5728\u591a\u4e2a\u7ebf\u7a0b\u4e0a\u521b\u5efa\u6240\u6709\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u7136\u540e\u5728\u4e3b\u7ebf\u7a0b\u4e00\u6b21\u6027\u7684\u4ee5\u8f83\u4f4e\u5f00\u9500\u7684\u8c03\u7528\u63d0\u4ea4\u961f\u5217\u3002 Vulkan \u5141\u8bb8\u4f7f\u75280.0\u52301.0\u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u5206\u914d\u961f\u5217\u4f18\u5148\u7ea7\u6765\u5f71\u54cd\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u7684\u8c03\u7528\u3002\u5373\u4f7f\u53ea\u6709\u4e00\u4e2a\u961f\u5217\u4e5f\u662f\u5fc5\u987b\u7684: float queuePriority = 1.0f; queueCreateInfo.pQueuePriorities = &queuePriority; C++","title":"\u6307\u5b9a\u521b\u5efa\u7684\u961f\u5217"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_11","text":"\u4e0b\u4e00\u4e2a\u8981\u660e\u786e\u7684\u4fe1\u606f\u6709\u5173\u8bbe\u5907\u8981\u4f7f\u7528\u7684\u529f\u80fd\u7279\u6027\u3002\u8fd9\u4e9b\u662f\u6211\u4eec\u5728\u4e0a\u4e00\u8282\u4e2d\u7528 vkGetPhysicalDeviceFeatures \u67e5\u8be2\u652f\u6301\u7684\u529f\u80fd\uff0c\u6bd4\u5982geometry shaders\u3002\u73b0\u5728\u6211\u4eec\u4e0d\u9700\u8981\u4efb\u4f55\u7279\u6b8a\u7684\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7684\u5b9a\u4e49\u5b83\u5e76\u5c06\u6240\u6709\u5185\u5bb9\u4fdd\u7559\u5230 VK_FALSE \u3002\u4e00\u65e6\u6211\u4eec\u8981\u5f00\u59cb\u7528Vulkan\u505a\u66f4\u591a\u7684\u4e8b\u60c5\uff0c\u6211\u4eec\u4f1a\u56de\u5230\u8fd9\u4e2a\u7ed3\u6784\u4f53\uff0c\u8fdb\u4e00\u6b65\u8bbe\u7f6e\u3002 VkPhysicalDeviceFeatures deviceFeatures = {}; C++","title":"\u6307\u5b9a\u4f7f\u7528\u7684\u8bbe\u5907\u7279\u6027"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_12","text":"\u4f7f\u7528\u524d\u9762\u7684\u4e24\u4e2a\u7ed3\u6784\u4f53\uff0c\u6211\u4eec\u53ef\u4ee5\u586b\u5145 VkDeviceCreateInfo \u7ed3\u6784\u3002 VkDeviceCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; C++ \u9996\u5148\u6dfb\u52a0\u6307\u5411\u961f\u5217\u521b\u5efa\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\u548c\u8bbe\u5907\u529f\u80fd\u7ed3\u6784\u4f53: createInfo.pQueueCreateInfos = &queueCreateInfo; createInfo.queueCreateInfoCount = 1; createInfo.pEnabledFeatures = &deviceFeatures; C++ \u7ed3\u6784\u4f53\u5176\u4f59\u7684\u90e8\u5206\u4e0e VkInstanceCreateInfo \u76f8\u4f3c\uff0c\u9700\u8981\u6307\u5b9a\u6269\u5c55\u548c validation layers \uff0c\u603b\u800c\u8a00\u4e4b\u8fd9\u6b21\u4e0d\u540c\u4e4b\u5904\u662f\u4e3a\u5177\u4f53\u7684\u8bbe\u5907\u8bbe\u7f6e\u4fe1\u606f\u3002 \u8bbe\u7f6e\u5177\u4f53\u6269\u5c55\u7684\u4e00\u4e2a\u6848\u4f8b\u662f VK_KHR_swapchain \uff0c\u5b83\u5141\u8bb8\u5c06\u6765\u81ea\u8bbe\u5907\u7684\u6e32\u67d3\u56fe\u5f62\u5448\u73b0\u5230 Windows \u3002\u7cfb\u7edf\u4e2d\u7684 Vulkan \u8bbe\u5907\u53ef\u80fd\u7f3a\u5c11\u8be5\u529f\u80fd\uff0c\u4f8b\u5982\u4ec5\u4ec5\u652f\u6301\u8ba1\u7b97\u64cd\u4f5c\u3002\u6211\u4eec\u5c06\u5728\u4ea4\u6362\u94fe\u7ae0\u8282\u4e2d\u5c55\u5f00\u8fd9\u4e2a\u6269\u5c55\u3002 \u5c31\u50cf\u4e4b\u524d validation layers \u5c0f\u8282\u4e2d\u63d0\u5230\u7684\uff0c\u5141\u8bb8\u4e3a instance \u5f00\u542f validation layers \uff0c\u73b0\u5728\u6211\u4eec\u5c06\u4e3a\u8bbe\u5907\u5f00\u542f validation layers \uff0c\u800c\u4e0d\u9700\u8981\u4e3a\u8bbe\u5907\u6307\u5b9a\u4efb\u4f55\u6269\u5c55\u3002 createInfo.enabledExtensionCount = 0; if (enableValidationLayers) { createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size()); createInfo.ppEnabledLayerNames = validationLayers.data(); } else { createInfo.enabledLayerCount = 0; } C++ \u5c31\u8fd9\u6837\uff0c\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 vkCreateDevice \u51fd\u6570\u6765\u521b\u5efa\u5b9e\u4f8b\u5316\u903b\u8f91\u8bbe\u5907\u3002 if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) { throw std::runtime_error(\"failed to create logical device!\"); } C++ \u8fd9\u4e9b\u53c2\u6570\u5206\u522b\u662f\u5305\u542b\u5177\u4f53\u961f\u5217\u4f7f\u7528\u4fe1\u606f\u7684\u7269\u7406\u8bbe\u5907\uff0c\u53ef\u9009\u7684\u5206\u914d\u5668\u56de\u8c03\u6307\u9488\u4ee5\u53ca\u7528\u4e8e\u5b58\u50a8\u903b\u8f91\u8bbe\u5907\u7684\u53e5\u67c4\u3002\u4e0e instance \u521b\u5efa\u7c7b\u4f3c\uff0c\u6b64\u8c03\u7528\u53ef\u80fd\u7531\u4e8e\u542f\u7528\u4e0d\u5b58\u5728\u7684\u6269\u5c55\u6216\u8005\u6307\u5b9a\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5bfc\u81f4\u8fd4\u56de\u9519\u8bef\u3002 \u5728 cleanup \u51fd\u6570\u4e2d\u903b\u8f91\u8bbe\u5907\u9700\u8981\u8c03\u7528 vkDestroyDevice \u9500\u6bc1: void cleanup() { vkDestroyDevice(device, nullptr); ... } C++ \u903b\u8f91\u8bbe\u5907\u4e0d\u4e0e instance \u4ea4\u4e92\uff0c\u6240\u4ee5\u53c2\u6570\u4e2d\u4e0d\u5305\u542b instance \u3002","title":"\u521b\u5efa\u903b\u8f91\u8bbe\u5907"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_13","text":"\u8fd9\u4e9b\u961f\u5217\u4e0e\u903b\u8f91\u8bbe\u5907\u81ea\u52a8\u7684\u4e00\u540c\u521b\u5efa\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u4e00\u4e2a\u4e0e\u5b83\u4eec\u8fdb\u884c\u4ea4\u4e92\u7684\u53e5\u67c4\u3002\u5728\u8fd9\u91cc\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u7c7b\u6210\u5458\u6765\u5b58\u50a8\u56fe\u5f62\u961f\u5217\u53e5\u67c4: VkQueue graphicsQueue; C++ \u8bbe\u5907\u961f\u5217\u5728\u8bbe\u5907\u88ab\u9500\u6bc1\u7684\u65f6\u5019\u9690\u5f0f\u6e05\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u5728 cleanup \u51fd\u6570\u4e2d\u505a\u4efb\u4f55\u64cd\u4f5c\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 vkGetDeviceQueue \u51fd\u6570\u6765\u68c0\u6d4b\u6bcf\u4e2a\u961f\u5217\u7c07\u4e2d\u961f\u5217\u7684\u53e5\u67c4\u3002\u53c2\u6570\u662f\u903b\u8f91\u8bbe\u5907\uff0c\u961f\u5217\u7c07\uff0c\u961f\u5217\u7d22\u5f15\u548c\u5b58\u50a8\u83b7\u53d6\u961f\u5217\u53d8\u91cf\u53e5\u67c4\u7684\u6307\u9488\u3002\u56e0\u4e3a\u6211\u4eec\u53ea\u662f\u4ece\u8fd9\u4e2a\u961f\u5217\u7c07\u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u6240\u4ee5\u9700\u8981\u4f7f\u7528\u7d22\u5f15 0 \u3002 vkGetDeviceQueue(device, indices.graphicsFamily, 0, &graphicsQueue); C++ \u5728\u6210\u529f\u83b7\u53d6\u903b\u8f91\u8bbe\u5907\u548c\u961f\u5217\u53e5\u67c4\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u663e\u5361\u505a\u4e00\u4e9b\u5b9e\u9645\u7684\u4e8b\u60c5\u4e86\uff0c\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u4f1a\u8bbe\u7f6e\u8d44\u6e90\u5e76\u5c06\u76f8\u5e94\u7684\u7ed3\u679c\u63d0\u4ea4\u5230\u7a97\u4f53\u7cfb\u7edf\u3002","title":"\u68c0\u7d22\u961f\u5217\u5904\u7406"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_4","text":"Vulkan \u4ea4\u6362\u94fe \uff0c\u5728\u8fd9\u4e00\u7ae0\u8282\uff0c\u6211\u4eec\u4e86\u89e3\u4e00\u4e0b\u5c06\u6e32\u67d3\u56fe\u50cf\u63d0\u4ea4\u5230\u5c4f\u5e55\u7684\u57fa\u672c\u673a\u5236\u3002\u8fd9\u79cd\u673a\u5236\u79f0\u4e3a\u4ea4\u6362\u94fe\uff0c\u5e76\u4e14\u9700\u8981\u5728 Vulkan \u4e0a\u4e0b\u6587\u4e2d\u88ab\u660e\u786e\u521b\u5efa\u3002\u4ece\u5c4f\u5e55\u7684\u89d2\u5ea6\u89c2\u5bdf\uff0c\u4ea4\u6362\u94fe\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u56fe\u50cf\u961f\u5217\u3002\u5e94\u7528\u7a0b\u5e8f\u4f5c\u4e3a\u751f\u4ea7\u8005\u4f1a\u83b7\u53d6\u56fe\u50cf\u8fdb\u884c\u7ed8\u5236\uff0c\u7136\u540e\u5c06\u5176\u8fd4\u8fd8\u7ed9\u4ea4\u6362\u94fe\u56fe\u50cf\u961f\u5217\uff0c\u7b49\u5f85\u5c4f\u5e55\u6d88\u8d39\u3002\u4ea4\u6362\u94fe\u7684\u5177\u4f53\u914d\u7f6e\u4fe1\u606f\u51b3\u5b9a\u4e86\u5e94\u7528\u7a0b\u5e8f\u63d0\u4ea4\u7ed8\u5236\u56fe\u50cf\u5230\u961f\u5217\u7684\u6761\u4ef6\u4ee5\u53ca\u56fe\u50cf\u961f\u5217\u8868\u73b0\u7684\u6548\u679c\uff0c\u4f46\u4ea4\u6362\u94fe\u7684\u901a\u5e38\u4f7f\u7528\u76ee\u7684\u662f\u4f7f\u7ed8\u5236\u56fe\u50cf\u7684\u6700\u7ec8\u5448\u73b0\u4e0e\u5c4f\u5e55\u7684\u5237\u65b0\u9891\u7387\u540c\u6b65\u3002\u53ef\u4ee5\u7b80\u5355\u5c06\u4ea4\u6362\u94fe\u7406\u89e3\u4e3a\u4e00\u4e2a\u961f\u5217\uff0c\u540c\u6b65\u4ece\u751f\u4ea7\u8005\uff0c\u5373\u5e94\u7528\u7a0b\u5e8f\u7ed8\u5236\u56fe\u50cf\uff0c\u5230\u6d88\u8d39\u8005\uff0c\u5c4f\u5e55\u5237\u65b0\u7684 Produce-Consume \u5173\u7cfb\u3002\u5728\u6df1\u5165\u5185\u5bb9\u524d\u770b\u4e00\u4e0b\u5b98\u65b9\u7ed9\u51fa\u7684\u6574\u4f53\u4ea4\u6362\u94fe\u793a\u4f8b\u56fe\u3002 \u5f53\u7136\u56fe\u793a\u4e0a\u6709\u4e00\u4e9b\u964c\u751f\u7684\u5173\u952e\u5b57\u4f1a\u5728\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\u4e2d\u9010\u4e00\u4ecb\u7ecd\uff0c\u5728\u6b64\u6709\u4e00\u4e2a\u6574\u4f53\u6982\u5ff5\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u68c0\u67e5\u4ea4\u6362\u94fe\u652f\u6301 2 \u67e5\u8be2\u4ea4\u6362\u94fe\u652f\u6301\u7684\u8be6\u60c5 3 \u4e3a\u4ea4\u6362\u94fe\u9009\u62e9\u6b63\u786e\u7684\u8bbe\u7f6e 4 Surface \u683c\u5f0f 5 \u6f14\u793a\u6a21\u5f0f 6 \u4ea4\u6362\u8303\u56f4 7 \u521b\u5efa\u4ea4\u6362\u94fe 8 \u83b7\u53d6\u4ea4\u6362\u94fe\u56fe\u50cf","title":"Vulkan \u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_14","text":"\u5e76\u4e0d\u662f\u6240\u6709\u7684\u56fe\u5f62\u5361\u5177\u5907\u80fd\u529b\u5c06\u7ed8\u5236\u7684\u56fe\u50cf\u76f4\u63a5\u663e\u793a\u5230\u5c4f\u5e55\u4e0a\u3002\u6bd4\u5982\u4e00\u4e2aGPU\u5361\u662f\u4e3a\u670d\u52a1\u5668\u8bbe\u8ba1\u7684\uff0c\u90a3\u5c31\u4e0d\u4f1a\u5177\u5907\u4efb\u4f55\u6709\u5173\u663e\u793a\u7684\u8f93\u51fa\u3002\u5176\u6b21\uff0c\u56fe\u50cf\u5448\u73b0\u662f\u4e0e surface \u6253\u4ea4\u9053\uff0c\u800c surface \u53c8\u4e0e\u5177\u4f53\u7684\u7a97\u4f53\u7cfb\u7edf\u5f3a\u5173\u8054\uff0c\u4ece\u8fd9\u4e2a\u89d2\u5ea6\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u5b83\u4e0d\u662f Vulkan \u6838\u5fc3\u7684\u90e8\u5206\u3002\u5728\u67e5\u8be2\u56fe\u5f62\u5361\u662f\u5426\u652f\u6301\u540e\uff0c\u9700\u8981\u542f\u7528 VK_KHR_swapchain \u8bbe\u5907\u7ea7\u522b\u7684\u6269\u5c55\u3002 \u6240\u4ee5\u5462\uff0c\u6211\u4eec\u9996\u5148\u6269\u5c55\u4e4b\u524d\u7684 isDeviceSuitable \u51fd\u6570\uff0c\u786e\u8ba4\u8bbe\u5907\u662f\u5426\u652f\u6301\u3002\u4e4b\u524d\u6211\u4eec\u5df2\u7ecf\u4e86\u89e3\u5982\u4f55\u5217\u51fa VkPhysicalDevice \u652f\u6301\u7684\u6269\u5c55\u5217\u8868\uff0c\u5728\u6b64\u5c31\u4e0d\u5c55\u5f00\u5177\u4f53\u7ec6\u8282\u4e86\u3002\u8bf7\u6ce8\u610f\u7684\u662f\uff0cVulkan\u5934\u6587\u4ef6\u63d0\u4f9b\u7ed9\u4e86\u4e00\u4e2a\u65b9\u4fbf\u7684\u5b8f VK_KHR_SWAPCHAIN_EXTENSION_NAME \uff0c\u8be5\u5b8f\u5b9a\u4e49\u4e3a VK_KHR_swapchain \u3002\u4f7f\u7528\u5b8f\u7684\u4f18\u70b9\u5c31\u662f\u907f\u514d\u62fc\u5199\u9519\u8bef\u3002 \u9996\u5148\u58f0\u660e\u9700\u8981\u7684\u8bbe\u5907\u6269\u5c55\u6e05\u5355\uff0c\u4e0e\u4e4b\u524d\u5f00\u542f validation layers \u7684\u5217\u8868\u662f\u76f8\u4f3c\u7684\u3002 const std::vector<const char*> deviceExtensions = { VK_KHR_SWAPCHAIN_EXTENSION_NAME }; C++ \u63a5\u4e0b\u6765\uff0c\u521b\u5efa\u4e00\u4e2a\u4ece isDeviceSuitable \u8c03\u7528\u7684\u65b0\u51fd\u6570 checkDeviceExtensionSupport \u4f5c\u4e3a\u989d\u5916\u7684\u68c0\u67e5\u903b\u8f91: bool isDeviceSuitable(VkPhysicalDevice device) { QueueFamilyIndices indices = findQueueFamilies(device); bool extensionsSupported = checkDeviceExtensionSupport(device); return indices.isComplete() && extensionsSupported; } bool checkDeviceExtensionSupport(VkPhysicalDevice device) { return true; } C++ \u4fee\u6539\u51fd\u6570\u4f53\u4ee5\u4fbf\u4e8e\u679a\u4e3e\u8bbe\u5907\u6240\u6709\u96c6\u5408\uff0c\u5e76\u68c0\u6d4b\u662f\u5426\u6240\u6709\u9700\u8981\u7684\u6269\u5c55\u5728\u5176\u4e2d\u3002 bool checkDeviceExtensionSupport(VkPhysicalDevice device) { uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availableExtensions.data()); std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end()); for (const auto& extension : availableExtensions) { requiredExtensions.erase(extension.extensionName); } return requiredExtensions.empty(); } C++ \u9009\u62e9\u4e00\u7ec4\u5b57\u7b26\u4e32\u6765\u8868\u793a\u672a\u7ecf\u786e\u8ba4\u8fc7\u7684\u6269\u5c55\u540d\u3002\u8fd9\u6837\u505a\u53ef\u4ee5\u6bd4\u8f83\u5bb9\u6613\u7684\u8fdb\u884c\u589e\u5220\u53ca\u904d\u5386\u7684\u6b21\u5e8f\u3002\u5f53\u7136\u4e5f\u53ef\u4ee5\u50cf CheckValidationLayerSupport \u51fd\u6570\u90a3\u6837\u505a\u5d4c\u5957\u7684\u5faa\u73af\u3002\u6027\u80fd\u7684\u5dee\u5f02\u5728\u8fd9\u91cc\u662f\u4e0d\u5173\u7d27\u8981\u7684\u3002\u73b0\u5728\u8fd0\u884c\u4ee3\u7801\u9a8c\u8bc1\u56fe\u5f62\u5361\u662f\u5426\u80fd\u591f\u987a\u5229\u521b\u5efa\u4e00\u4e2a\u4ea4\u6362\u94fe\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u524d\u4e00\u4e2a\u7ae0\u8282\u4e2d\u9a8c\u8bc1\u8fc7\u7684 presentation \u961f\u5217\u6709\u6548\u6027\uff0c\u5e76\u6ca1\u6709\u660e\u786e\u6307\u51fa\u4ea4\u6362\u94fe\u6269\u5c55\u4e5f\u5fc5\u987b\u6709\u6548\u652f\u6301\u3002\u597d\u5728\u6269\u5c55\u5fc5\u987b\u660e\u786e\u7684\u5f00\u542f\u3002 \u542f\u7528\u6269\u5c55\u9700\u8981\u5bf9\u903b\u8f91\u8bbe\u5907\u7684\u521b\u5efa\u7ed3\u6784\u4f53\u505a\u4e00\u4e9b\u5c0f\u7684\u6539\u52a8: createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size()); createInfo.ppEnabledExtensionNames = deviceExtensions.data(); C++","title":"\u68c0\u67e5\u4ea4\u6362\u94fe\u652f\u6301"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_15","text":"\u5982\u679c\u4ec5\u4ec5\u662f\u4e3a\u4e86\u6d4b\u8bd5\u4ea4\u6362\u94fe\u7684\u6709\u6548\u6027\u662f\u8fdc\u8fdc\u4e0d\u591f\u7684\uff0c\u56e0\u4e3a\u5b83\u8fd8\u4e0d\u80fd\u5f88\u597d\u7684\u4e0e\u7a97\u4f53 surface \u517c\u5bb9\u3002\u521b\u5efa\u4ea4\u6362\u94fe\u540c\u6837\u4e5f\u9700\u8981\u5f88\u591a\u8bbe\u7f6e\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4e86\u89e3\u4e00\u4e9b\u6709\u5173\u8bbe\u7f6e\u7684\u7ec6\u8282\u3002 \u57fa\u672c\u4e0a\u6709\u4e09\u5927\u7c7b\u5c5e\u6027\u9700\u8981\u8bbe\u7f6e: \u57fa\u672c\u7684surface\u529f\u80fd\u5c5e\u6027(min/max number of images in swap chain, min/max width and height of images) Surface\u683c\u5f0f(pixel format, color space) \u6709\u6548\u7684presentation\u6a21\u5f0f \u4e0e findQueueFamilies \u7c7b\u4f3c\uff0c\u6211\u4eec\u4f7f\u7528\u7ed3\u6784\u4f53\u4e00\u6b21\u6027\u7684\u4f20\u9012\u8be6\u7ec6\u7684\u4fe1\u606f\u3002\u4e09\u7c7b\u5c5e\u6027\u5c01\u88c5\u5728\u5982\u4e0b\u7ed3\u6784\u4f53\u4e2d\uff1a struct SwapChainSupportDetails { VkSurfaceCapabilitiesKHR capabilities; std::vector<VkSurfaceFormatKHR> formats; std::vector<VkPresentModeKHR> presentModes; }; C++ \u73b0\u5728\u521b\u5efa\u65b0\u7684\u51fd\u6570 querySwapChainSupport \u586b\u5145\u8be5\u7ed3\u6784\u4f53\u3002 SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) { SwapChainSupportDetails details; return details; } C++ \u672c\u5c0f\u8282\u6d89\u53ca\u5982\u4f55\u67e5\u8be2\u5305\u542b\u6b64\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\uff0c\u8fd9\u4e9b\u7ed3\u6784\u4f53\u7684\u542b\u4e49\u53ca\u5305\u542b\u7684\u6570\u636e\u5c06\u5728\u4e0b\u4e00\u8282\u8ba8\u8bba\u3002 \u6211\u4eec\u73b0\u5728\u5f00\u59cb\u57fa\u672c\u7684 surface \u529f\u80fd\u8bbe\u7f6e\u90e8\u5206\u3002\u8fd9\u4e9b\u5c5e\u6027\u53ef\u4ee5\u901a\u8fc7\u7b80\u5355\u7684\u51fd\u6570\u8c03\u7528\u67e5\u8be2\uff0c\u5e76\u8fd4\u56de\u5230\u5355\u4e2a VkSurfaceCapabilitiesKHR \u7ed3\u6784\u4f53\u4e2d\u3002 vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &details.capabilities); C++ \u8fd9\u4e2a\u51fd\u6570\u9700\u8981 VkPhysicalDevice \u548c VkSurfaceKHR \u7a97\u4f53 surface \u51b3\u5b9a\u652f\u6301\u54ea\u4e9b\u5177\u4f53\u529f\u80fd\u3002\u6240\u6709\u7528\u4e8e\u67e5\u770b\u652f\u6301\u529f\u80fd\u7684\u51fd\u6570\u90fd\u9700\u8981\u8fd9\u4e24\u4e2a\u53c2\u6570\uff0c\u56e0\u4e3a\u5b83\u4eec\u662f\u4ea4\u6362\u94fe\u7684\u6838\u5fc3\u7ec4\u4ef6\u3002 \u4e0b\u4e00\u6b65\u67e5\u8be2\u652f\u6301\u7684 surface \u683c\u5f0f\u3002\u56e0\u4e3a\u83b7\u53d6\u5230\u7684\u662f\u4e00\u4e2a\u7ed3\u6784\u4f53\u5217\u8868\uff0c\u5177\u4f53\u5e94\u7528\u5f62\u5f0f\u5982\u4e0b: uint32_t formatCount; vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, nullptr); if (formatCount != 0) { details.formats.resize(formatCount); vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, details.formats.data()); } C++ \u786e\u4fdd\u96c6\u5408\u5bf9\u4e8e\u6240\u6709\u6709\u6548\u7684\u683c\u5f0f\u53ef\u6269\u5145\u3002\u6700\u540e\u67e5\u8be2\u652f\u6301\u7684 presentation \u6a21\u5f0f\uff0c\u540c\u6837\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528 vkGetPhysicalDeviceSurfacePresentModesKHR : uint32_t presentModeCount; vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, nullptr); if (presentModeCount != 0) { details.presentModes.resize(presentModeCount); vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, details.presentModes.data()); } C++ \u73b0\u5728\u7ed3\u6784\u4f53\u7684\u76f8\u5173\u7ec6\u8282\u4ecb\u7ecd\u5b8c\u6bd5\uff0c\u8ba9\u6211\u4eec\u6269\u5145 isDeviceSuitable \u51fd\u6570\uff0c\u4ece\u800c\u5229\u7528\u8be5\u51fd\u6570\u9a8c\u8bc1\u4ea4\u6362\u94fe\u8db3\u591f\u7684\u652f\u6301\u3002\u5728\u672c\u7ae0\u8282\u4e2d\u4ea4\u6362\u94fe\u7684\u652f\u6301\u662f\u8db3\u591f\u7684\uff0c\u56e0\u4e3a\u5bf9\u4e8e\u7ed9\u5b9a\u7684\u7a97\u4f53 surface \uff0c\u5b83\u81f3\u5c11\u652f\u6301\u4e00\u4e2a\u56fe\u50cf\u683c\u5f0f\uff0c\u4e00\u4e2a presentaion \u6a21\u5f0f\u3002 bool swapChainAdequate = false; if (extensionsSupported) { SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device); swapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty(); } C++ \u6bd4\u8f83\u91cd\u8981\u7684\u662f\u5c1d\u8bd5\u67e5\u8be2\u4ea4\u6362\u94fe\u7684\u652f\u6301\u662f\u5728\u9a8c\u8bc1\u5b8c\u6269\u5c55\u6709\u6548\u6027\u4e4b\u540e\u8fdb\u884c\u3002\u51fd\u6570\u7684\u6700\u540e\u4e00\u884c\u4ee3\u7801\u4fee\u6539\u4e3a: return indices.isComplete() && extensionsSupported && swapChainAdequate; C++","title":"\u67e5\u8be2\u4ea4\u6362\u94fe\u652f\u6301\u7684\u8be6\u60c5"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_16","text":"\u5982\u679c swapChainAdequate \u6761\u4ef6\u8db3\u591f\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u652f\u6301\u7684\u8db3\u591f\u7684\uff0c\u4f46\u662f\u6839\u636e\u4e0d\u540c\u7684\u6a21\u5f0f\u4ecd\u7136\u6709\u4e0d\u540c\u7684\u6700\u4f73\u9009\u62e9\u3002\u6211\u4eec\u7f16\u5199\u4e00\u7ec4\u51fd\u6570\uff0c\u901a\u8fc7\u8fdb\u4e00\u6b65\u7684\u8bbe\u7f6e\u67e5\u627e\u6700\u5339\u914d\u7684\u4ea4\u6362\u94fe\u3002\u8fd9\u91cc\u6709\u4e09\u79cd\u7c7b\u578b\u7684\u8bbe\u7f6e\u53bb\u786e\u5b9a: Surface\u683c\u5f0f (color depth) Presentation mode (conditions for \u201cswapping\u201d image to the screen) Swap extent (resolution of images in swap chain) \u9996\u5148\u5728\u8111\u6d77\u4e2d\u5bf9\u6bcf\u4e00\u4e2a\u8bbe\u7f6e\u90fd\u6709\u4e00\u4e2a\u7406\u60f3\u7684\u6570\u503c\uff0c\u5982\u679c\u8fbe\u6210\u4e00\u81f4\u6211\u4eec\u5c31\u4f7f\u7528\uff0c\u5426\u5219\u6211\u4eec\u4e00\u8d77\u521b\u5efa\u4e00\u4e9b\u903b\u8f91\u53bb\u627e\u5230\u66f4\u597d\u7684\u89c4\u5219\u3001\u6570\u503c\u3002","title":"\u4e3a\u4ea4\u6362\u94fe\u9009\u62e9\u6b63\u786e\u7684\u8bbe\u7f6e"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#surface","text":"\u8fd9\u4e2a\u51fd\u6570\u7528\u6765\u8bbe\u7f6esurface\u683c\u5f0f\u3002\u6211\u4eec\u4f20\u9012 formats \u4f5c\u4e3a\u51fd\u6570\u7684\u53c2\u6570\uff0c\u7c7b\u578b\u4e3a SwapChainSupportDetails \u3002 VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) { } C++ \u6bcf\u4e2a VkSurfaceFormatKHR \u7ed3\u6784\u90fd\u5305\u542b\u4e00\u4e2a format \u548c\u4e00\u4e2a colorSpace \u6210\u5458\u3002 format \u6210\u5458\u53d8\u91cf\u6307\u5b9a\u8272\u5f69\u901a\u9053\u548c\u7c7b\u578b\u3002\u6bd4\u5982\uff0c VK_FORMAT_B8G8R8A8_UNORM \u4ee3\u8868\u4e86\u6211\u4eec\u4f7f\u7528B,G,R\u548calpha\u6b21\u5e8f\u7684\u901a\u9053\uff0c\u4e14\u6bcf\u4e00\u4e2a\u901a\u9053\u4e3a\u65e0\u7b26\u53f78bit\u6574\u6570\uff0c\u6bcf\u4e2a\u50cf\u7d20\u603b\u8ba132bits\u3002 colorSpace \u6210\u5458\u63cf\u8ff0 SRGB \u989c\u8272\u7a7a\u95f4\u662f\u5426\u901a\u8fc7 VK_COLOR_SPACE_SRGB_NONLINEAR_KHR \u6807\u5fd7\u652f\u6301\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u5728\u8f83\u65e9\u7248\u672c\u7684\u89c4\u8303\u4e2d\uff0c\u8fd9\u4e2a\u6807\u5fd7\u540d\u4e3a VK_COLORSPACE_SRGB_NONLINEAR_KHR \u3002 \u5982\u679c\u53ef\u4ee5\u6211\u4eec\u5c3d\u53ef\u80fd\u4f7f\u7528SRGB(\u5f69\u8272\u8bed\u8a00\u534f\u8bae)\uff0c \u56e0\u4e3a\u5b83\u4f1a\u5f97\u5230\u66f4\u5bb9\u6613\u611f\u77e5\u7684\u3001\u7cbe\u786e\u7684\u8272\u5f69 \u3002\u76f4\u63a5\u4e0e SRGB \u989c\u8272\u6253\u4ea4\u9053\u662f\u6bd4\u8f83\u6709\u6311\u6218\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u4f7f\u7528\u6807\u51c6\u7684RGB\u4f5c\u4e3a\u989c\u8272\u683c\u5f0f\uff0c\u8fd9\u4e5f\u662f\u901a\u5e38\u4f7f\u7528\u7684\u4e00\u4e2a\u683c\u5f0f VK_FORMAT_B8G8R8A8_UNORM \u3002 \u6700\u7406\u60f3\u7684\u60c5\u51b5\u662fsurface\u6ca1\u6709\u8bbe\u7f6e\u4efb\u4f55\u504f\u5411\u6027\u7684\u683c\u5f0f\uff0c\u8fd9\u4e2a\u65f6\u5019Vulkan\u4f1a\u901a\u8fc7\u4ec5\u8fd4\u56de\u4e00\u4e2a VkSurfaceFormatKHR \u7ed3\u6784\u8868\u793a\uff0c\u4e14\u8be5\u7ed3\u6784\u7684 format \u6210\u5458\u8bbe\u7f6e\u4e3a VK_FORMAT_UNDEFINED \u3002 if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) { return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; } C++ \u5982\u679c\u4e0d\u80fd\u81ea\u7531\u7684\u8bbe\u7f6e\u683c\u5f0f\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u904d\u5386\u5217\u8868\u8bbe\u7f6e\u5177\u6709\u504f\u5411\u6027\u7684\u7ec4\u5408: for (const auto& availableFormat : availableFormats) { if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { return availableFormat; } } C++ \u5982\u679c\u4ee5\u4e0a\u4e24\u79cd\u65b9\u5f0f\u90fd\u5931\u6548\u4e86\uff0c\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u201c\u4f18\u826f\u201d\u8fdb\u884c\u6253\u5206\u6392\u5e8f\uff0c\u4f46\u662f\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4f1a\u9009\u62e9\u7b2c\u4e00\u4e2a\u683c\u5f0f\u4f5c\u4e3a\u7406\u60f3\u7684\u9009\u62e9\u3002 VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) { if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) { return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; } for (const auto& availableFormat : availableFormats) { if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { return availableFormat; } } return availableFormats[0]; } C++","title":"Surface \u683c\u5f0f"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_17","text":"presentation \u6a21\u5f0f\u5bf9\u4e8e\u4ea4\u6362\u94fe\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u56e0\u4e3a\u5b83\u4ee3\u8868\u4e86\u5728\u5c4f\u5e55\u5448\u73b0\u56fe\u50cf\u7684\u6761\u4ef6\u3002\u5728 Vulkan \u4e2d\u6709\u56db\u4e2a\u6a21\u5f0f\u53ef\u4ee5\u4f7f\u7528: VK_PRESENT_MODE_IMMEDIATE_KHR : \u5e94\u7528\u7a0b\u5e8f\u63d0\u4ea4\u7684\u56fe\u50cf\u88ab\u7acb\u5373\u4f20\u8f93\u5230\u5c4f\u5e55\u5448\u73b0\uff0c\u8fd9\u79cd\u6a21\u5f0f\u53ef\u80fd\u4f1a\u9020\u6210\u6495\u88c2\u6548\u679c\u3002 VK_PRESENT_MODE_FIFO_KHR : \u4ea4\u6362\u94fe\u88ab\u770b\u4f5c\u4e00\u4e2a\u961f\u5217\uff0c\u5f53\u663e\u793a\u5185\u5bb9\u9700\u8981\u5237\u65b0\u7684\u65f6\u5019\uff0c\u663e\u793a\u8bbe\u5907\u4ece\u961f\u5217\u7684\u524d\u9762\u83b7\u53d6\u56fe\u50cf\uff0c\u5e76\u4e14\u7a0b\u5e8f\u5c06\u6e32\u67d3\u5b8c\u6210\u7684\u56fe\u50cf\u63d2\u5165\u961f\u5217\u7684\u540e\u9762\u3002\u5982\u679c\u961f\u5217\u662f\u6ee1\u7684\u7a0b\u5e8f\u4f1a\u7b49\u5f85\u3002\u8fd9\u79cd\u89c4\u6a21\u4e0e\u89c6\u9891\u6e38\u620f\u7684\u5782\u76f4\u540c\u6b65\u5f88\u7c7b\u4f3c\u3002\u663e\u793a\u8bbe\u5907\u7684\u5237\u65b0\u65f6\u523b\u88ab\u6210\u4e3a\u201c\u5782\u76f4\u4e2d\u65ad\u201d\u3002 VK_PRESENT_MODE_FIFO_RELAXED_KHR : \u8be5\u6a21\u5f0f\u4e0e\u4e0a\u4e00\u4e2a\u6a21\u5f0f\u7565\u6709\u4e0d\u540c\u7684\u5730\u65b9\u4e3a\uff0c\u5982\u679c\u5e94\u7528\u7a0b\u5e8f\u5b58\u5728\u5ef6\u8fdf\uff0c\u5373\u63a5\u53d7\u6700\u540e\u4e00\u4e2a\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\u65f6\u961f\u5217\u7a7a\u4e86\uff0c\u5c06\u4e0d\u4f1a\u7b49\u5f85\u4e0b\u4e00\u4e2a\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\uff0c\u800c\u662f\u5c06\u56fe\u50cf\u76f4\u63a5\u4f20\u9001\u3002\u8fd9\u6837\u505a\u53ef\u80fd\u5bfc\u81f4\u53ef\u89c1\u7684\u6495\u88c2\u6548\u679c\u3002 VK_PRESENT_MODE_MAILBOX_KHR : \u8fd9\u662f\u7b2c\u4e8c\u79cd\u6a21\u5f0f\u7684\u53d8\u79cd\u3002\u5f53\u4ea4\u6362\u94fe\u961f\u5217\u6ee1\u7684\u65f6\u5019\uff0c\u9009\u62e9\u65b0\u7684\u66ff\u6362\u65e7\u7684\u56fe\u50cf\uff0c\u4ece\u800c\u66ff\u4ee3\u963b\u585e\u5e94\u7528\u7a0b\u5e8f\u7684\u60c5\u5f62\u3002\u8fd9\u79cd\u6a21\u5f0f\u901a\u5e38\u7528\u6765\u5b9e\u73b0\u4e09\u91cd\u7f13\u51b2\u533a\uff0c\u4e0e\u6807\u51c6\u7684\u5782\u76f4\u540c\u6b65\u53cc\u7f13\u51b2\u76f8\u6bd4\uff0c\u5b83\u53ef\u4ee5\u6709\u6548\u907f\u514d\u5ef6\u8fdf\u5e26\u6765\u7684\u6495\u88c2\u6548\u679c\u3002 \u903b\u8f91\u4e0a\u770b\u4ec5\u4ec5 VR_PRESENT_MODE_FIFO_KHR \u6a21\u5f0f\u4fdd\u8bc1\u53ef\u7528\u6027\uff0c\u6240\u4ee5\u6211\u4eec\u518d\u6b21\u589e\u52a0\u4e00\u4e2a\u51fd\u6570\u67e5\u627e\u6700\u4f73\u7684\u6a21\u5f0f: VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { return VK_PRESENT_MODE_FIFO_KHR; } C++ \u6211\u4e2a\u4eba\u8ba4\u4e3a\u4e09\u7ea7\u7f13\u51b2\u662f\u4e00\u4e2a\u975e\u5e38\u597d\u7684\u7b56\u7565\u3002\u5b83\u5141\u8bb8\u6211\u4eec\u907f\u514d\u6495\u88c2\uff0c\u540c\u65f6\u4ecd\u7136\u4fdd\u6301\u76f8\u5bf9\u4f4e\u7684\u5ef6\u8fdf\uff0c\u901a\u8fc7\u6e32\u67d3\u5c3d\u53ef\u80fd\u65b0\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u63a5\u53d7\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\u3002\u6240\u4ee5\u6211\u4eec\u770b\u4e00\u4e0b\u5217\u8868\uff0c\u5b83\u662f\u5426\u53ef\u7528: VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { for (const auto& availablePresentMode : availablePresentModes) { if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { return availablePresentMode; } } return VK_PRESENT_MODE_FIFO_KHR; } C++ \u9057\u61be\u7684\u662f\uff0c\u4e00\u4e9b\u9a71\u52a8\u7a0b\u5e8f\u76ee\u524d\u5e76\u4e0d\u652f\u6301 VK_PRESENT_MODE_FIFO_KHR ,\u9664\u6b64\u4e4b\u5916\u5982\u679c VK_PRESENT_MODE_MAILBOX_KHR \u4e5f\u4e0d\u53ef\u7528\uff0c\u6211\u4eec\u66f4\u503e\u5411\u4f7f\u7528 VK_PRESENT_MODE_IMMEDIATE_KHR : VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { VkPresentModeKHR bestMode = VK_PRESENT_MODE_FIFO_KHR; for (const auto& availablePresentMode : availablePresentModes) { if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { return availablePresentMode; } else if (availablePresentMode == VK_PRESENT_MODE_IMMEDIATE_KHR) { bestMode = availablePresentMode; } } return bestMode; } C++","title":"\u6f14\u793a\u6a21\u5f0f"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_18","text":"\u8fd8\u5269\u4e0b\u4e00\u4e2a\u5c5e\u6027\uff0c\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u51fd\u6570: VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) { } C++ \u4ea4\u6362\u8303\u56f4\u662f\u6307\u4ea4\u6362\u94fe\u56fe\u50cf\u7684\u5206\u8fa8\u7387\uff0c\u5b83\u51e0\u4e4e\u603b\u662f\u7b49\u4e8e\u6211\u4eec\u7ed8\u5236\u7a97\u4f53\u7684\u5206\u8fa8\u7387\u3002\u5206\u8fa8\u7387\u7684\u8303\u56f4\u88ab\u5b9a\u4e49\u5728 VkSurfaceCapabilitiesKHR \u7ed3\u6784\u4f53\u4e2d\u3002 Vulkan \u544a\u8bc9\u6211\u4eec\u901a\u8fc7\u8bbe\u7f6e currentExtent \u6210\u5458\u7684 width \u548c height \u6765\u5339\u914d\u7a97\u4f53\u7684\u5206\u8fa8\u7387\u3002\u7136\u800c\uff0c\u4e00\u4e9b\u7a97\u4f53\u7ba1\u7406\u5668\u5141\u8bb8\u4e0d\u540c\u7684\u8bbe\u7f6e\uff0c\u610f\u5473\u7740\u5c06 currentExtent \u7684width\u548cheight\u8bbe\u7f6e\u4e3a\u7279\u6b8a\u7684\u6570\u503c\u8868\u793a: uint32_t \u7684\u6700\u5927\u503c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53c2\u8003\u7a97\u4f53 minImageExtent \u548c maxImageExtent \u9009\u62e9\u6700\u5339\u914d\u7684\u5206\u8fa8\u7387\u3002 VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) { if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) { return capabilities.currentExtent; } else { VkExtent2D actualExtent = {WIDTH, HEIGHT}; actualExtent.width = std::max(capabilities.minImageExtent.width, std::min(capabilities.maxImageExtent.width, actualExtent.width)); actualExtent.height = std::max(capabilities.minImageExtent.height, std::min(capabilities.maxImageExtent.height, actualExtent.height)); return actualExtent; } } C++ max \u548c min \u51fd\u6570\u7528\u4e8e\u5c06 WIDTH \u548c HEIGHT \u6536\u655b\u5728\u5b9e\u9645\u652f\u6301\u7684 minimum \u548c maximum \u8303\u56f4\u4e2d\u3002\u5728\u8fd9\u91cc\u786e\u8ba4\u5305\u542b <algorithm> \u5934\u6587\u4ef6\u3002","title":"\u4ea4\u6362\u8303\u56f4"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_19","text":"\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6709\u4e86\u8fd9\u4e9b\u8f85\u52a9\u51fd\u6570\uff0c\u7528\u4ee5\u5728\u8fd0\u884c\u65f6\u5e2e\u52a9\u6211\u4eec\u505a\u51fa\u660e\u667a\u7684\u9009\u62e9\uff0c\u6700\u7ec8\u83b7\u5f97\u6709\u4e86\u521b\u5efa\u4ea4\u6362\u94fe\u6240\u9700\u8981\u7684\u6240\u6709\u4fe1\u606f\u3002 \u521b\u5efa\u4e00\u4e2a\u51fd\u6570 createSwapChain \uff0c\u5728 initVulkan \u51fd\u6570\u4e2d\uff0c\u8be5\u51fd\u6570\u4f1a\u5728\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u4e4b\u540e\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); } void createSwapChain() { SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice); VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats); VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes); VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities); } C++ \u5b9e\u9645\u4e0a\u8fd8\u6709\u4e00\u4e9b\u5c0f\u4e8b\u60c5\u9700\u8981\u786e\u5b9a\uff0c\u4f46\u662f\u6bd4\u8f83\u7b80\u5355\uff0c\u6240\u4ee5\u6ca1\u6709\u5355\u72ec\u521b\u5efa\u51fd\u6570\u3002\u7b2c\u4e00\u4e2a\u662f\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u53ef\u4ee5\u7406\u89e3\u4e3a\u961f\u5217\u7684\u957f\u5ea6\u3002\u5b83\u6307\u5b9a\u8fd0\u884c\u65f6\u56fe\u50cf\u7684\u6700\u5c0f\u6570\u91cf\uff0c\u6211\u4eec\u5c06\u5c1d\u8bd5\u5927\u4e8e1\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u4ee5\u5b9e\u73b0\u4e09\u91cd\u7f13\u51b2\u3002 uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1; if (swapChainSupport.capabilities.maxImageCount > 0 && imageCount > swapChainSupport.capabilities.maxImageCount) { imageCount = swapChainSupport.capabilities.maxImageCount; } C++ \u5bf9\u4e8e maxImageCount \u6570\u503c\u4e3a 0 \u4ee3\u8868\u9664\u4e86\u5185\u5b58\u4e4b\u5916\u6ca1\u6709\u9650\u5236\uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u9700\u8981\u68c0\u67e5\u3002 \u4e0eVulkan\u5176\u4ed6\u5bf9\u8c61\u7684\u521b\u5efa\u8fc7\u7a0b\u4e00\u6837\uff0c\u521b\u5efa\u4ea4\u6362\u94fe\u4e5f\u9700\u8981\u586b\u5145\u5927\u91cf\u7684\u7ed3\u6784\u4f53: VkSwapchainCreateInfoKHR createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; createInfo.surface = surface; C++ \u5728\u6307\u5b9a\u4ea4\u6362\u94fe\u7ed1\u5b9a\u5230\u5177\u4f53\u7684 surface \u4e4b\u540e\uff0c\u9700\u8981\u6307\u5b9a\u4ea4\u6362\u94fe\u56fe\u50cf\u6709\u5173\u7684\u8be6\u7ec6\u4fe1\u606f: createInfo.minImageCount = imageCount; createInfo.imageFormat = surfaceFormat.format; createInfo.imageColorSpace = surfaceFormat.colorSpace; createInfo.imageExtent = extent; createInfo.imageArrayLayers = 1; createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; C++ imageArrayLayers \u6307\u5b9a\u6bcf\u4e2a\u56fe\u50cf\u7ec4\u6210\u7684\u5c42\u6570\u3002\u9664\u975e\u6211\u4eec\u5f00\u53d13D\u5e94\u7528\u7a0b\u5e8f\uff0c\u5426\u5219\u59cb\u7ec8\u4e3a1\u3002 imageUsage \u4f4d\u5b57\u6bb5\u6307\u5b9a\u5728\u4ea4\u6362\u94fe\u4e2d\u5bf9\u56fe\u50cf\u8fdb\u884c\u7684\u5177\u4f53\u64cd\u4f5c\u3002\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u76f4\u63a5\u5bf9\u5b83\u4eec\u8fdb\u884c\u6e32\u67d3\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u4eec\u4f5c\u4e3a\u989c\u8272\u9644\u4ef6\u3002\u4e5f\u53ef\u4ee5\u9996\u5148\u5c06\u56fe\u50cf\u6e32\u67d3\u4e3a\u5355\u72ec\u7684\u56fe\u50cf\uff0c\u8fdb\u884c\u540e\u5904\u7406\u64cd\u4f5c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u53ef\u4ee5\u4f7f\u7528\u50cf VK_IMAGE_USAGE_TRANSFER_DST_BIT \u8fd9\u6837\u7684\u503c\uff0c\u5e76\u4f7f\u7528\u5185\u5b58\u64cd\u4f5c\u5c06\u6e32\u67d3\u7684\u56fe\u50cf\u4f20\u8f93\u5230\u4ea4\u6362\u94fe\u56fe\u50cf\u961f\u5217\u3002 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); uint32_t queueFamilyIndices[] = {(uint32_t) indices.graphicsFamily, (uint32_t) indices.presentFamily}; if (indices.graphicsFamily != indices.presentFamily) { createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT; createInfo.queueFamilyIndexCount = 2; createInfo.pQueueFamilyIndices = queueFamilyIndices; } else { createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; createInfo.queueFamilyIndexCount = 0; // Optional createInfo.pQueueFamilyIndices = nullptr; // Optional } C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u6307\u5b9a\u5982\u4f55\u5904\u7406\u8de8\u591a\u4e2a\u961f\u5217\u7c07\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u3002\u5982\u679cgraphics\u961f\u5217\u7c07\u4e0epresentation\u961f\u5217\u7c07\u4e0d\u540c\uff0c\u4f1a\u51fa\u73b0\u5982\u4e0b\u60c5\u5f62\u3002\u6211\u4eec\u5c06\u4ecegraphics\u961f\u5217\u4e2d\u7ed8\u5236\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\uff0c\u7136\u540e\u5728\u53e6\u4e00\u4e2apresentation\u961f\u5217\u4e2d\u63d0\u4ea4\u4ed6\u4eec\u3002\u591a\u961f\u5217\u5904\u7406\u56fe\u50cf\u6709\u4e24\u79cd\u65b9\u6cd5: VK_SHARING_MODE_EXCLUSIVE : \u540c\u4e00\u65f6\u95f4\u56fe\u50cf\u53ea\u80fd\u88ab\u4e00\u4e2a\u961f\u5217\u7c07\u5360\u7528\uff0c\u5982\u679c\u5176\u4ed6\u961f\u5217\u7c07\u9700\u8981\u5176\u6240\u6709\u6743\u9700\u8981\u660e\u786e\u6307\u5b9a\u3002\u8fd9\u79cd\u65b9\u5f0f\u63d0\u4f9b\u4e86\u6700\u597d\u7684\u6027\u80fd\u3002 VK_SHARING_MODE_CONCURRENT : \u56fe\u50cf\u53ef\u4ee5\u88ab\u591a\u4e2a\u961f\u5217\u7c07\u8bbf\u95ee\uff0c\u4e0d\u9700\u8981\u660e\u786e\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\u3002 \u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u5982\u679c\u961f\u5217\u7c07\u4e0d\u540c\uff0c\u5c06\u4f1a\u4f7f\u7528 concurrent \u6a21\u5f0f\uff0c\u907f\u514d\u5904\u7406\u56fe\u50cf\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\u7684\u5185\u5bb9\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u4f1a\u6d89\u53ca\u4e0d\u5c11\u6982\u5ff5\uff0c\u5efa\u8bae\u540e\u7eed\u7684\u7ae0\u8282\u8ba8\u8bba\u3002 Concurrent \u6a21\u5f0f\u9700\u8981\u9884\u5148\u6307\u5b9a\u961f\u5217\u7c07\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\uff0c\u901a\u8fc7 queueFamilyIndexCount \u548c pQueueFamilyIndices \u53c2\u6570\u8fdb\u884c\u5171\u4eab\u3002\u5982\u679c graphics \u961f\u5217\u7c07\u548cpresentation\u961f\u5217\u7c07\u76f8\u540c\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 exclusive \u6a21\u5f0f\uff0c\u56e0\u4e3a concurrent \u6a21\u5f0f\u9700\u8981\u81f3\u5c11\u4e24\u4e2a\u4e0d\u540c\u7684\u961f\u5217\u7c07\u3002 createInfo.preTransform = swapChainSupport.capabilities.currentTransform; C++ \u5982\u679c\u4ea4\u6362\u94fe\u652f\u6301( supportedTransforms in capabilities ),\u6211\u4eec\u53ef\u4ee5\u4e3a\u4ea4\u6362\u94fe\u56fe\u50cf\u6307\u5b9a\u67d0\u4e9b\u8f6c\u6362\u903b\u8f91\uff0c\u6bd4\u598290\u5ea6\u987a\u65f6\u9488\u65cb\u8f6c\u6216\u8005\u6c34\u5e73\u53cd\u8f6c\u3002\u5982\u679c\u4e0d\u9700\u8981\u4efb\u4f55 transoform \u64cd\u4f5c\uff0c\u53ef\u4ee5\u7b80\u5355\u7684\u8bbe\u7f6e\u4e3a currentTransoform \u3002 createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR; C++ \u6df7\u5408Alpha\u5b57\u6bb5\u6307\u5b9aalpha\u901a\u9053\u662f\u5426\u5e94\u7528\u4e0e\u4e0e\u5176\u4ed6\u7684\u7a97\u4f53\u7cfb\u7edf\u8fdb\u884c\u6df7\u5408\u64cd\u4f5c\u3002\u5982\u679c\u5ffd\u7565\u8be5\u529f\u80fd\uff0c\u7b80\u5355\u7684\u586b VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR \u3002 createInfo.presentMode = presentMode; createInfo.clipped = VK_TRUE; C++ presentMode \u6307\u5411\u81ea\u5df1\u3002\u5982\u679c clipped \u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u610f\u5473\u7740\u6211\u4eec\u4e0d\u5173\u5fc3\u88ab\u906e\u853d\u7684\u50cf\u7d20\u6570\u636e\uff0c\u6bd4\u5982\u7531\u4e8e\u5176\u4ed6\u7684\u7a97\u4f53\u7f6e\u4e8e\u524d\u65b9\u65f6\u6216\u8005\u6e32\u67d3\u7684\u90e8\u5206\u5185\u5bb9\u5b58\u5728\u4e8e\u53ef\u662f\u533a\u57df\u4e4b\u5916\uff0c\u9664\u975e\u771f\u7684\u9700\u8981\u8bfb\u53d6\u8fd9\u4e9b\u50cf\u7d20\u83b7\u6570\u636e\u8fdb\u884c\u5904\u7406\uff0c\u5426\u5219\u53ef\u4ee5\u5f00\u542f\u88c1\u526a\u83b7\u5f97\u6700\u4f73\u6027\u80fd\u3002 createInfo.oldSwapchain = VK_NULL_HANDLE; C++ \u6700\u540e\u4e00\u4e2a\u5b57\u6bb5 oldSwapChain \u3002Vulkan\u8fd0\u884c\u65f6\uff0c\u4ea4\u6362\u94fe\u53ef\u80fd\u5728\u67d0\u4e9b\u6761\u4ef6\u4e0b\u88ab\u66ff\u6362\uff0c\u6bd4\u5982\u7a97\u53e3\u8c03\u6574\u5927\u5c0f\u6216\u8005\u4ea4\u6362\u94fe\u9700\u8981\u91cd\u65b0\u5206\u914d\u66f4\u5927\u7684\u56fe\u50cf\u961f\u5217\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4ea4\u6362\u94fe\u5b9e\u9645\u4e0a\u9700\u8981\u91cd\u65b0\u5206\u914d\u521b\u5efa\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u6b64\u5b57\u6bb5\u4e2d\u6307\u5b9a\u5bf9\u65e7\u7684\u5f15\u7528\uff0c\u7528\u4ee5\u56de\u6536\u8d44\u6e90\u3002\u8fd9\u662f\u4e00\u4e2a\u6bd4\u8f83\u590d\u6742\u7684\u8bdd\u9898\uff0c\u6211\u4eec\u4f1a\u5728\u540e\u9762\u7684\u7ae0\u8282\u4e2d\u8be6\u7ec6\u4ecb\u7ecd\u3002\u73b0\u5728\u5047\u8bbe\u6211\u4eec\u53ea\u4f1a\u521b\u5efa\u4e00\u4e2a\u4ea4\u6362\u94fe\u3002 \u73b0\u5728\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u53d8\u91cf\u5b58\u50a8 VkSwapchainKHR \u5bf9\u8c61: VkSwapchainKHR swapChain; C++ \u521b\u5efa\u4ea4\u6362\u94fe\u53ea\u9700\u8981\u7b80\u5355\u7684\u8c03\u7528\u51fd\u6570: vkCreateSwapchainKHR : if (vkCreateSwapchainKHR(device, &createInfo, nullptr, &swapChain) != VK_SUCCESS) { throw std::runtime_error(\"failed to create swap chain!\"); } C++ \u53c2\u6570\u662f\u903b\u8f91\u8bbe\u5907\uff0c\u4ea4\u6362\u94fe\u521b\u5efa\u7684\u4fe1\u606f\uff0c\u53ef\u9009\u62e9\u7684\u5206\u914d\u5668\u548c\u4e00\u4e2a\u5b58\u50a8\u4ea4\u6362\u540e\u7684\u53e5\u67c4\u6307\u9488\u3002\u5b83\u4e5f\u9700\u8981\u5728\u8bbe\u5907\u88ab\u6e05\u7406\u524d\uff0c\u8fdb\u884c\u9500\u6bc1\u64cd\u4f5c\uff0c\u901a\u8fc7\u8c03\u7528 vkDestroySwapchainKHR \u3002 void cleanup() { vkDestroySwapchainKHR(device, swapChain, nullptr); ... } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\u786e\u4fdd\u4ea4\u6362\u94fe\u521b\u5efa\u6210\u529f\uff01 \u5c1d\u8bd5\u79fb\u9664 createInfo.imageExtent = extent; \u5e76\u5728validation layers\u5f00\u542f\u7684\u6761\u4ef6\u4e0b\uff0cvalidation layers\u4f1a\u7acb\u523b\u6355\u83b7\u5230\u6709\u5e2e\u52a9\u7684\u5f02\u5e38\u4fe1\u606f:","title":"\u521b\u5efa\u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_20","text":"\u4ea4\u6362\u94fe\u521b\u5efa\u540e\uff0c\u9700\u8981\u83b7\u53d6 VkImage \u76f8\u5173\u7684\u53e5\u67c4\u3002\u5b83\u4f1a\u5728\u540e\u7eed\u6e32\u67d3\u7684\u7ae0\u8282\u4e2d\u5f15\u7528\u3002\u6dfb\u52a0\u7c7b\u6210\u5458\u53d8\u91cf\u5b58\u50a8\u8be5\u53e5\u67c4: std::vector<VkImage> swapChainImages; C++ \u56fe\u50cf\u88ab\u4ea4\u6362\u94fe\u521b\u5efa\uff0c\u4e5f\u4f1a\u5728\u4ea4\u6362\u94fe\u9500\u6bc1\u7684\u540c\u65f6\u81ea\u52a8\u6e05\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u6dfb\u52a0\u4efb\u4f55\u6e05\u7406\u4ee3\u7801\u3002 \u6211\u4eec\u5728 createSwapChain \u51fd\u6570\u4e0b\u9762\u6dfb\u52a0\u4ee3\u7801\u83b7\u53d6\u53e5\u67c4\uff0c\u5728 vkCreateSwapchainKHR \u540e\u8c03\u7528\u3002\u83b7\u53d6\u53e5\u67c4\u7684\u64cd\u4f5c\u540c\u4e4b\u524d\u83b7\u53d6\u6570\u7ec4\u96c6\u5408\u7684\u64cd\u4f5c\u975e\u5e38\u7c7b\u4f3c\u3002\u9996\u5148\u901a\u8fc7\u8c03\u7528 vkGetSwapchainImagesKHR \u83b7\u53d6\u4ea4\u6362\u94fe\u4e2d\u56fe\u50cf\u7684\u6570\u91cf\uff0c\u5e76\u6839\u636e\u6570\u91cf\u8bbe\u7f6e\u5408\u9002\u7684\u5bb9\u5668\u5927\u5c0f\u4fdd\u5b58\u83b7\u53d6\u5230\u7684\u53e5\u67c4\u96c6\u5408\u3002 vkGetSwapchainImagesKHR(device, swapChain, &imageCount, nullptr); swapChainImages.resize(imageCount); vkGetSwapchainImagesKHR(device, swapChain, &imageCount, swapChainImages.data()); C++ \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e4b\u524d\u521b\u5efa\u4ea4\u6362\u94fe\u6b65\u9aa4\u4e2d\u6211\u4eec\u4f20\u9012\u4e86\u671f\u671b\u7684\u56fe\u50cf\u5927\u5c0f\u5230\u5b57\u6bb5 minImageCount \u3002\u800c\u5b9e\u9645\u7684\u8fd0\u884c\uff0c\u5141\u8bb8\u6211\u4eec\u521b\u5efa\u66f4\u591a\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u9700\u8981\u518d\u4e00\u6b21\u83b7\u53d6\u6570\u91cf\u3002 \u6700\u540e\uff0c\u5b58\u50a8\u4ea4\u6362\u94fe\u683c\u5f0f\u548c\u8303\u56f4\u5230\u6210\u5458\u53d8\u91cf\u4e2d\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7ae0\u8282\u4f7f\u7528\u3002 VkSwapchainKHR swapChain; std::vector<VkImage> swapChainImages; VkFormat swapChainImageFormat; VkExtent2D swapChainExtent; ... swapChainImageFormat = surfaceFormat.format; swapChainExtent = extent; C++ \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u56fe\u50cf\uff0c\u8fd9\u4e9b\u56fe\u50cf\u53ef\u4ee5\u88ab\u7ed8\u5236\uff0c\u5e76\u5448\u73b0\u5230\u7a97\u4f53\u3002 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u5f00\u59cb\u8ba8\u8bba\u5982\u4f55\u4e3a\u56fe\u50cf\u8bbe\u7f6e\u6e32\u67d3\u76ee\u6807\uff0c\u5e76\u4e86\u89e3\u5b9e\u9645\u7684\u56fe\u50cf\u7ba1\u7ebf\u548c\u7ed8\u5236\u547d\u4ee4\u3002","title":"\u83b7\u53d6\u4ea4\u6362\u94fe\u56fe\u50cf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan-window-surface","text":"Vulkan Window Surface \uff0c\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u4e86\u89e3\u5230 Vulkan \u662f\u4e00\u4e2a\u4e0e\u5e73\u53f0\u7279\u6027\u65e0\u5173\u8054\u7684 API \u96c6\u5408\u3002\u5b83\u4e0d\u80fd\u76f4\u63a5\u4e0e\u7a97\u53e3\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002\u4e3a\u4e86\u5c06\u6e32\u67d3\u7ed3\u679c\u5448\u73b0\u5230\u5c4f\u5e55\uff0c\u9700\u8981\u5efa\u7acb Vulkan \u4e0e\u7a97\u4f53\u7cfb\u7edf\u4e4b\u95f4\u7684\u8fde\u63a5\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 WSI (\u7a97\u4f53\u7cfb\u7edf\u96c6\u6210)\u6269\u5c55\u3002\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u8ba8\u8bba\u7b2c\u4e00\u4e2a\uff0c\u5373 VK_KHR_surface \u3002\u5b83\u66b4\u9732\u4e86 VkSurfaceKHR \uff0c\u5b83\u4ee3\u8868 surface \u7684\u4e00\u4e2a\u62bd\u8c61\u7c7b\u578b\uff0c\u7528\u4ee5\u5448\u73b0\u6e32\u67d3\u56fe\u50cf\u4f7f\u7528\u3002\u6211\u4eec\u7a0b\u5e8f\u4e2d\u5c06\u8981\u4f7f\u7528\u5230\u7684 surface \u662f\u7531\u6211\u4eec\u5df2\u7ecf\u5f15\u5165\u7684 GLFW \u6269\u5c55\u53ca\u5176\u6253\u5f00\u7684\u76f8\u5173\u7a97\u4f53\u652f\u6301\u7684\u3002\u7b80\u5355\u6765\u8bf4surface\u5c31\u662fVulkan\u4e0e\u7a97\u4f53\u7cfb\u7edf\u7684\u8fde\u63a5\u6865\u6881\u3002 VK_KHR_surface \u6269\u5c55\u662f\u4e00\u4e2ainstance\u7ea7\u6269\u5c55\uff0c\u6211\u4eec\u76ee\u524d\u4e3a\u6b62\u5df2\u7ecf\u542f\u7528\u8fc7\u5b83\uff0c\u5b83\u5305\u542b\u5728 glfwGetRequiredInstanceExtensions \u8fd4\u56de\u7684\u5217\u8868\u4e2d\u3002\u8be5\u5217\u8868\u8fd8\u5305\u62ec\u5c06\u5728\u63a5\u4e0b\u6765\u51e0\u5c0f\u8282\u4e2d\u4f7f\u7528\u7684\u4e00\u4e9b\u5176\u4ed6WSI\u6269\u5c55\u3002 \u9700\u8981\u5728 instance \u521b\u5efa\u4e4b\u540e\u7acb\u5373\u521b\u5efa\u7a97\u4f53 surface \uff0c\u56e0\u4e3a\u5b83\u4f1a\u5f71\u54cd\u7269\u7406\u8bbe\u5907\u7684\u9009\u62e9\u3002\u4e4b\u6240\u4ee5\u5728\u672c\u5c0f\u8282\u5c06 surface \u521b\u5efa\u903b\u8f91\u7eb3\u5165\u8ba8\u8bba\u8303\u56f4\uff0c\u662f\u56e0\u4e3a\u7a97\u4f53 surface \u5bf9\u4e8e\u6e32\u67d3\u3001\u5448\u73b0\u65b9\u5f0f\u662f\u4e00\u4e2a\u6bd4\u8f83\u5927\u7684\u8bfe\u9898\uff0c\u5982\u679c\u8fc7\u65e9\u7684\u5728\u521b\u5efa\u7269\u7406\u8bbe\u5907\u52a0\u5165\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u4f1a\u6df7\u6dc6\u57fa\u672c\u7684\u7269\u7406\u8bbe\u5907\u8bbe\u7f6e\u5de5\u4f5c\u3002\u53e6\u5916\u7a97\u4f53 surface \u672c\u8eab\u5bf9\u4e8e Vulkan \u4e5f\u662f\u975e\u5f3a\u5236\u7684\u3002 Vulkan \u5141\u8bb8\u8fd9\u6837\u505a\uff0c\u4e0d\u9700\u8981\u540c OpenGL \u4e00\u6837\u5fc5\u987b\u8981\u521b\u5efa\u7a97\u4f53 surface \u3002 \u6587\u7ae0\u76ee\u5f55 1 \u521b\u5efa Window Surface 2 \u67e5\u8be2\u6f14\u793a\u652f\u6301 3 \u521b\u5efa\u6f14\u793a\u961f\u5217","title":"Vulkan Window Surface"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#window-surface","text":"\u73b0\u5728\u5f00\u59cb\u7740\u624b\u521b\u5efa\u7a97\u4f53 surface \uff0c\u5728\u7c7b\u6210\u5458 debugCallback \u4e0b\u52a0\u5165\u6210\u5458\u53d8\u91cf surface \u3002 VkSurfaceKHR surface; C++ \u867d\u7136 VkSurfaceKHR \u5bf9\u8c61\u53ca\u5176\u7528\u6cd5\u4e0e\u5e73\u53f0\u65e0\u5173\u8054\uff0c\u4f46\u521b\u5efa\u8fc7\u7a0b\u9700\u8981\u4f9d\u8d56\u5177\u4f53\u7684\u7a97\u4f53\u7cfb\u7edf\u7684\u7ec6\u8282\u3002\u6bd4\u5982\uff0c\u5728 Windows \u5e73\u53f0\u4e2d\uff0c\u5b83\u9700\u8981 WIndows \u4e0a\u7684 HWND \u548c HMODULE \u53e5\u67c4\u3002\u56e0\u6b64\u9488\u5bf9\u7279\u5b9a\u5e73\u53f0\u63d0\u4f9b\u76f8\u5e94\u7684\u6269\u5c55\uff0c\u5728 Windows \u4e0a\u4e3a VK_KHR_win32_surface \uff0c\u5b83\u81ea\u52a8\u5305\u542b\u5728 glfwGetRequiredInstanceExtensions \u5217\u8868\u4e2d\u3002 \u6211\u4eec\u5c06\u4f1a\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u7279\u5b9a\u5e73\u53f0\u7684\u6269\u5c55\u6765\u521b\u5efa Windows \u4e0a\u7684 surface \u6865\uff0c\u4f46\u662f\u4e0d\u4f1a\u5728\u6559\u7a0b\u4e2d\u5b9e\u9645\u4f7f\u7528\u5b83\u3002\u4f7f\u7528GLFW\u8fd9\u6837\u7684\u5e93\u907f\u514d\u4e86\u7f16\u5199\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u7684\u8de8\u5e73\u53f0\u76f8\u5173\u4ee3\u7801\u3002 GLFW \u5b9e\u9645\u4e0a\u901a\u8fc7 glfwCreateWindowSurface \u5f88\u597d\u7684\u5904\u7406\u4e86\u5e73\u53f0\u5dee\u5f02\u6027\u3002\u5f53\u7136\u4e86\uff0c\u6bd4\u8f83\u7406\u60f3\u662f\u5728\u4f9d\u8d56\u5b83\u4eec\u5e2e\u52a9\u6211\u4eec\u5b8c\u6210\u5177\u4f53\u5de5\u4f5c\u4e4b\u524d\uff0c\u4e86\u89e3\u4e00\u4e0b\u80cc\u540e\u7684\u5b9e\u73b0\u662f\u6709\u5e2e\u52a9\u7684\u3002 \u56e0\u4e3a\u4e00\u4e2a\u7a97\u4f53 surface \u662f\u4e00\u4e2a Vulkan \u5bf9\u8c61\uff0c\u5b83\u9700\u8981\u586b\u5145 VkWin32SurfaceCreateInfoKHR \u7ed3\u6784\u4f53\uff0c\u8fd9\u91cc\u6709\u4e24\u4e2a\u6bd4\u8f83\u91cd\u8981\u7684\u53c2\u6570: hwnd \u548c hinstance \u3002\u5982\u679c\u719f\u6089 windows \u4e0b\u5f00\u53d1\u5e94\u8be5\u77e5\u9053\uff0c\u8fd9\u4e9b\u662f\u7a97\u53e3\u548c\u8fdb\u7a0b\u7684\u53e5\u67c4\u3002 VkWin32SurfaceCreateInfoKHR createInfo; createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR; createInfo.hwnd = glfwGetWin32Window(window); createInfo.hinstance = GetModuleHandle(nullptr); C++ glfwGetWin32Window \u51fd\u6570\u7528\u4e8e\u4eceGLFW\u7a97\u4f53\u5bf9\u8c61\u83b7\u53d6\u539f\u59cb\u7684 HWND \u3002 GetModuleHandle \u51fd\u6570\u8fd4\u56de\u5f53\u524d\u8fdb\u7a0b\u7684 HINSTANCE \u53e5\u67c4\u3002 \u586b\u5145\u5b8c\u7ed3\u6784\u4f53\u4e4b\u540e\uff0c\u53ef\u4ee5\u5229\u7528 vkCreateWin32SurfaceKHR \u521b\u5efasurface\u6865\uff0c\u548c\u4e4b\u524d\u83b7\u53d6\u521b\u5efa\u3001\u9500\u6bc1 DebugReportCallEXT \u4e00\u6837\uff0c\u8fd9\u91cc\u540c\u6837\u9700\u8981\u901a\u8fc7 instance \u83b7\u53d6\u521b\u5efa surface \u7528\u5230\u7684\u51fd\u6570\u3002\u8fd9\u91cc\u6d89\u53ca\u5230\u7684\u53c2\u6570\u5206\u522b\u4e3a instance , surface \u521b\u5efa\u7684\u4fe1\u606f\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u6700\u7ec8\u4fdd\u5b58 surface \u7684\u53e5\u67c4\u53d8\u91cf\u3002 auto CreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) vkGetInstanceProcAddr(instance, \"vkCreateWin32SurfaceKHR\"); if (!CreateWin32SurfaceKHR || CreateWin32SurfaceKHR(instance, &createInfo, nullptr, &surface) != VK_SUCCESS) { throw std::runtime_error(\"failed to create window surface!\"); } C++ \u8be5\u8fc7\u7a0b\u4e0e\u5176\u4ed6\u5e73\u53f0\u7c7b\u4f3c\uff0c\u6bd4\u5982 Linux \uff0c\u4f7f\u7528X11\u754c\u9762\u7a97\u4f53\u7cfb\u7edf\uff0c\u53ef\u4ee5\u901a\u8fc7 vkCreateXcbSurfaceKHR \u51fd\u6570\u5efa\u7acb\u8fde\u63a5\u3002 glfwCreateWindowSurface \u51fd\u6570\u6839\u636e\u4e0d\u540c\u5e73\u53f0\u7684\u5dee\u5f02\u6027\uff0c\u5728\u5b9e\u73b0\u7ec6\u8282\u4e0a\u4f1a\u6709\u6240\u4e0d\u540c\u3002\u6211\u4eec\u73b0\u5728\u5c06\u5176\u6574\u5408\u5230\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\u3002\u4ece initVulkan \u4e2d\u6dfb\u52a0\u4e00\u4e2a\u51fd\u6570 createSurface ,\u5b89\u6392\u5728 createInstnace \u548c setupDebugCallback \u51fd\u6570\u4e4b\u540e\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); } void createSurface() { } C++ GLFW \u6ca1\u6709\u4f7f\u7528\u7ed3\u6784\u4f53\uff0c\u800c\u662f\u9009\u62e9\u975e\u5e38\u76f4\u63a5\u7684\u53c2\u6570\u4f20\u9012\u6765\u8c03\u7528\u51fd\u6570\u3002 void createSurface() { if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) { throw std::runtime_error(\"failed to create window surface!\"); } } C++ \u53c2\u6570\u662f VkInstance , GLFW \u7a97\u4f53\u7684\u6307\u9488\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u7528\u4e8e\u5b58\u50a8 VkSurfaceKHR \u53d8\u91cf\u7684\u6307\u9488\u3002\u5bf9\u4e8e\u4e0d\u540c\u5e73\u53f0\u7edf\u4e00\u8fd4\u56de VkResult \u3002 GLFW \u6ca1\u6709\u63d0\u4f9b\u4e13\u7528\u7684\u51fd\u6570\u9500\u6bc1 surface ,\u4f46\u662f\u53ef\u4ee5\u7b80\u5355\u7684\u901a\u8fc7 Vulkan \u539f\u59cb\u7684 API \u5b8c\u6210: void cleanup() { ... vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); ... } C++ \u6700\u540e\u8bf7\u786e\u4fddsurface\u7684\u6e05\u7406\u662f\u5728instance\u9500\u6bc1\u4e4b\u524d\u5b8c\u6210\u3002","title":"\u521b\u5efa Window Surface"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_21","text":"\u867d\u7136 Vulkan \u7684\u5b9e\u73b0\u652f\u6301\u7a97\u4f53\u96c6\u6210\u529f\u80fd\uff0c\u4f46\u662f\u5e76\u4e0d\u610f\u5473\u7740\u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u90fd\u652f\u6301\u5b83\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u6269\u5c55 isDeviceSuitable \u51fd\u6570\uff0c\u786e\u4fdd\u8bbe\u5907\u53ef\u4ee5\u5c06\u56fe\u50cf\u5448\u73b0\u5230\u6211\u4eec\u521b\u5efa\u7684 surface \u3002\u7531\u4e8e presentation \u662f\u4e00\u4e2a\u961f\u5217\u7684\u7279\u6027\u529f\u80fd\uff0c\u56e0\u6b64\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6cd5\u5c31\u662f\u627e\u5230\u652f\u6301 presentation \u7684\u961f\u5217\u7c07\uff0c\u6700\u7ec8\u83b7\u53d6\u961f\u5217\u6ee1\u8db3 surface \u521b\u5efa\u7684\u9700\u8981\u3002 \u5b9e\u9645\u60c5\u51b5\u662f\uff0c\u652f\u6301 graphics \u547d\u4ee4\u7684\u7684\u961f\u5217\u7c07\u548c\u652f\u6301 presentation \u547d\u4ee4\u7684\u961f\u5217\u7c07\u53ef\u80fd\u4e0d\u662f\u540c\u4e00\u4e2a\u7c07\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u4fee\u6539 QueueFamilyIndices \u7ed3\u6784\u4f53\uff0c\u4ee5\u652f\u6301\u5dee\u5f02\u5316\u7684\u5b58\u50a8\u3002 struct QueueFamilyIndices { int graphicsFamily = -1; int presentFamily = -1; bool isComplete() { return graphicsFamily >= 0 && presentFamily >= 0; } }; C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4fee\u6539 findQueueFamilies \u51fd\u6570\u6765\u67e5\u627e\u5177\u5907 presentation \u529f\u80fd\u7684\u961f\u5217\u7c07\u3002\u51fd\u6570\u4e2d\u7528\u4e8e\u68c0\u67e5\u7684\u6838\u5fc3\u4ee3\u7801\u662f vkGetPhysicalDeviceSurfaceSupportKHR ,\u5b83\u5c06\u7269\u7406\u8bbe\u5907\u3001\u961f\u5217\u7c07\u7d22\u5f15\u548c surface \u4f5c\u4e3a\u53c2\u6570\u3002\u5728 VK_QUEUE_GRAPHICS_BIT \u76f8\u540c\u7684\u5faa\u73af\u4f53\u4e2d\u6dfb\u52a0\u51fd\u6570\u7684\u8c03\u7528: VkBool32 presentSupport = false; vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport); C++ \u7136\u540e\u4e4b\u9700\u8981\u68c0\u67e5\u5e03\u5c14\u503c\u5e76\u5b58\u50a8 presentation \u961f\u5217\u7c07\u7684\u7d22\u5f15: if (queueFamily.queueCount > 0 && presentSupport) { indices.presentFamily = i; } C++ \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e3a\u4e86\u652f\u6301 graphics \u548c presentation \u529f\u80fd\uff0c\u6211\u4eec\u5b9e\u9645\u73af\u5883\u4e2d\u5f97\u5230\u7684\u53ef\u80fd\u662f\u540c\u4e00\u4e2a\u961f\u5217\u7c07\uff0c\u4e5f\u53ef\u80fd\u4e0d\u540c\uff0c\u4e3a\u6b64\u5728\u6211\u4eec\u7684\u7a0b\u5e8f\u6570\u636e\u7ed3\u6784\u53ca\u9009\u62e9\u903b\u8f91\u4e2d\uff0c\u5c06\u6309\u7167\u5747\u6765\u81ea\u4e0d\u540c\u7684\u961f\u5217\u7c07\u5206\u522b\u5904\u7406\uff0c\u8fd9\u6837\u4fbf\u53ef\u4ee5\u7edf\u4e00\u5904\u7406\u4ee5\u4e0a\u4e24\u79cd\u60c5\u51b5\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u51fa\u4e8e\u6027\u80fd\u7684\u8003\u8651\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u903b\u8f91\u660e\u786e\u7684\u6307\u5b9a\u7269\u7406\u8bbe\u5907\u6240\u4f7f\u7528\u7684 graphics \u548c presentation \u529f\u80fd\u6765\u81ea\u540c\u4e00\u4e2a\u961f\u5217\u7c07\u3002","title":"\u67e5\u8be2\u6f14\u793a\u652f\u6301"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_22","text":"\u5269\u4e0b\u7684\u4e8b\u60c5\u662f\u4fee\u6539\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u8fc7\u7a0b\uff0c\u5728\u4e8e\u521b\u5efa presentation \u961f\u5217\u5e76\u83b7\u53d6 VkQueue \u7684\u53e5\u67c4\u3002\u6dfb\u52a0\u4fdd\u5b58\u961f\u5217\u53e5\u67c4\u7684\u6210\u5458\u53d8\u91cf: VkQueue presentQueue; C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u591a\u4e2a VkDeviceQueueCreateInfo \u7ed3\u6784\u6765\u521b\u5efa\u4e0d\u540c\u529f\u80fd\u7684\u961f\u5217\u3002\u4e00\u4e2a\u4f18\u96c5\u7684\u65b9\u5f0f\u662f\u9488\u5bf9\u4e0d\u540c\u529f\u80fd\u7684\u961f\u5217\u7c07\u521b\u5efa\u4e00\u4e2aset\u96c6\u5408\u786e\u4fdd\u961f\u5217\u7c07\u7684\u552f\u4e00\u6027: #include <set> ... QueueFamilyIndices indices = findQueueFamilies(physicalDevice); std::vector<VkDeviceQueueCreateInfo> queueCreateInfos; std::set<int> uniqueQueueFamilies = {indices.graphicsFamily, indices.presentFamily}; float queuePriority = 1.0f; for (int queueFamily : uniqueQueueFamilies) { VkDeviceQueueCreateInfo queueCreateInfo = {}; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = queueFamily; queueCreateInfo.queueCount = 1; queueCreateInfo.pQueuePriorities = &queuePriority; queueCreateInfos.push_back(queueCreateInfo); } C++ \u540c\u65f6\u8fd8\u8981\u4fee\u6539 VkDeviceCreateInfo \u6307\u5411\u961f\u5217\u96c6\u5408: createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size()); createInfo.pQueueCreateInfos = queueCreateInfos.data(); C++ \u5982\u679c\u961f\u5217\u7c07\u76f8\u540c\uff0c\u90a3\u4e48\u6211\u4eec\u4e4b\u9700\u8981\u4f20\u9012\u4e00\u6b21\u7d22\u5f15\u3002\u6700\u540e\uff0c\u6dfb\u52a0\u4e00\u4e2a\u8c03\u7528\u68c0\u7d22\u961f\u5217\u53e5\u67c4: vkGetDeviceQueue(device, indices.presentFamily, 0, &presentQueue); C++ \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u961f\u5217\u7c07\u662f\u76f8\u540c\u7684\uff0c\u4e24\u4e2a\u53e5\u67c4\u53ef\u80fd\u4f1a\u6709\u76f8\u540c\u7684\u503c\u3002\u5728 \u4e0b\u4e00\u4e2a\u7ae0\u8282 \u4e2d\u6211\u4eec\u4f1a\u770b\u770b\u4ea4\u6362\u94fe\uff0c\u4ee5\u53ca\u5b83\u4eec\u5982\u4f55\u4f7f\u6211\u4eec\u80fd\u591f\u5c06\u56fe\u50cf\u5448\u73b0\u7ed9 surface \u3002","title":"\u521b\u5efa\u6f14\u793a\u961f\u5217"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_5","text":"Vulkan \u56fe\u5f62\u7ba1\u7ebf \uff0c\u901a\u8fc7\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\uff0c\u6211\u4eec\u5c06\u4f1a\u5f00\u542f\u6709\u5173\u56fe\u5f62\u7ba1\u7ebf\u7684\u8bdd\u9898\uff0c\u901a\u8fc7\u5bf9\u56fe\u5f62\u6e32\u67d3\u7ba1\u7ebf\u7684\u914d\u7f6e\u5b8c\u6210\u6700\u540e\u7684\u4e09\u89d2\u5f62\u7ed8\u753b\u3002\u6240\u8c13\u56fe\u5f62\u7ba1\u7ebf\u5c31\u662f\u5c06 mesh \u4f7f\u7528\u5230\u7684 vertices \u5b9a\u70b9\u6570\u636e\u548c\u8d34\u56fe\u6570\u636e\uff0c\u8f6c\u5316\u4e3a\u6e32\u67d3 targets \u50cf\u7d20\u7684\u64cd\u4f5c\u5e8f\u5217\u3002\u7b80\u8981\u7684\u6982\u8ff0\u5982\u4e0b\u56fe\u6240\u793a: Input assembler \u6536\u96c6\u6700\u539f\u59cb\u7684\u9876\u70b9\u6570\u636e\uff0c\u5e76\u4e14\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7d22\u5f15\u7f13\u51b2\u533a\u590d\u7528\u8fd9\u4e9b\u6570\u636e\u5143\u7d20\uff0c\u800c\u4e0d\u5fc5\u590d\u5236\u5197\u4f59\u7684\u9876\u70b9\u6570\u636e\u526f\u672c\u3002 vertex shader \u4f1a\u5e94\u7528\u5728\u6bcf\u4e00\u4e2a\u9876\u70b9\u6570\u636e\uff0c\u901a\u5e38\u5e94\u7528\u53d8\u6362\u64cd\u4f5c\uff0c\u4ece\u800c\u5c06\u9876\u70b9\u7684\u4f4d\u7f6e\u5750\u6807\u6570\u636e\u4ece\u6a21\u578b\u7a7a\u95f4\u8f6c\u6362\u4e3a\u5c4f\u5e55\u7a7a\u95f4\u3002\u5728\u5904\u7406\u5b8c\u6bd5\u4e4b\u540e\u4f1a\u5c06\u6570\u636e\u7ee7\u7eed\u5728\u7ba1\u7ebf\u4f20\u9012\u4e0b\u53bb\u3002 tessellation shader \u66f2\u9762\u7740\u8272\u5668\u5141\u8bb8\u57fa\u4e8e\u67d0\u4e9b\u89c4\u5219\u8fdb\u4e00\u6b65\u7ec6\u5206\u51e0\u4f55\u6570\u636e\u589e\u52a0\u7f51\u683c\u7684\u8d28\u91cf\u3002\u7ecf\u5e38\u5e94\u7528\u4e0e\u5899\u9762\u548c\u697c\u68af\u8868\u9762\uff0c\u4f7f\u9644\u8fd1\u770b\u8d77\u6765\u4e0d\u662f\u90a3\u4e48\u5e73\u5766\u3002 geometry shader \u96c6\u5408\u7740\u8272\u5668\u5e94\u7528\u5728\u6bcf\u4e00\u4e2a\u56fe\u5143\u4e0a\uff0c\u53ef\u7528\u4e8e\u589e\u51cf\u56fe\u5143\uff0c\u5b83\u4e0e\u66f2\u9762\u7740\u8272\u5668\u7c7b\u4f3c\uff0c\u4f46\u66f4\u52a0\u7075\u6d3b\u3002\u7136\u800c\uff0c\u5b83\u5728\u4eca\u5929\u7684\u5e94\u7528\u4e2d\u5e76\u6ca1\u6709\u592a\u591a\u7684\u5e94\u7528\u60c5\u666f\uff0c\u56e0\u4e3a\u9664\u4e86 Intel \u7684\u96c6\u6210\u663e\u5361\u5916\uff0c\u5927\u591a\u6570\u663e\u5361\u6027\u80fd\u652f\u6301\u90fd\u4e0d\u7406\u60f3\u3002 \u5149\u6805\u5316\u9636\u6bb5\u5c06\u56fe\u5143\u5206\u89e3\u4e3a\u7247\u5143\u3002\u8fd9\u4e9b\u662f\u586b\u5145\u5728\u5e27\u7f13\u51b2\u533a\u4e0a\u7684\u50cf\u7d20\u5143\u7d20\u3002\u5c4f\u5e55\u5916\u533a\u57df\u7684\u7247\u5143\u4f1a\u88ab\u4e22\u5f03\uff0c\u9876\u70b9\u7740\u8272\u5668\u8f93\u51fa\u7684\u6570\u636e\u5728\u4f20\u9012\u5230\u7247\u5143\u7740\u8272\u5668\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u5982\u56fe\u6240\u793a\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u6839\u636e\u6df1\u5ea6\u6d4b\u8bd5\u7684\u7ed3\u679c\u4e5f\u4f1a\u5bf9\u7247\u5143\u8fdb\u884c\u4e22\u5f03\u3002 fragment shader \u5e94\u7528\u4e8e\u6bcf\u4e2a\u7247\u5143\uff0c\u786e\u5b9a\u6bcf\u4e2a\u5e27\u7f13\u51b2\u533a\u4e2d\u5199\u5165\u7684\u7247\u5143\u6570\u636e\u7684\u989c\u8272\u548c\u6df1\u5ea6\u503c\u3002\u7247\u5143\u7740\u8272\u5668\u53ef\u4ee5\u4f7f\u7528\u9876\u70b9\u7740\u8272\u5668\u7684\u63d2\u503c\u6570\u636e\uff0c\u8d34\u56fe\u7684UV\u5750\u6807\u548c\u5149\u6e90\u6cd5\u7ebf\u6570\u636e\u3002 \u6df7\u8272\u64cd\u4f5c\u9636\u6bb5\u4f1a\u5bf9\u4e0d\u540c\u7247\u5143\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\uff0c\u6700\u7ec8\u6620\u5c04\u5230\u5e27\u7f13\u51b2\u533a\u7684\u540c\u4e00\u4e2a\u50cf\u7d20\u4e0a\u3002\u7247\u5143\u4e5f\u53ef\u4ee5\u7b80\u5355\u7684\u4e92\u76f8\u91cd\u5199\uff0c\u53e0\u52a0\u6216\u8005\u6839\u636e\u900f\u660e\u5ea6\u6df7\u5408\u3002 \u7eff\u8272\u7684\u9636\u6bb5\u88ab\u79f0\u4e3a\u56fa\u5b9a\u6d41\u6c34\u7ebf\u3002\u8fd9\u4e2a\u9636\u6bb5\u5141\u8bb8\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684\u53c2\u6570\u6570\u503c\uff0c\u4f46\u662f\u5b83\u5185\u90e8\u7684\u5de5\u4f5c\u903b\u8f91\u662f\u9884\u5236\u597d\u7684\u3002 \u6a59\u8272\u7684\u9636\u6bb5\u88ab\u79f0\u4e3a\u53ef\u7f16\u7a0b\u9636\u6bb5 programmable \uff0c\u6211\u4eec\u53ef\u4ee5\u5411GPU\u63d0\u4ea4\u81ea\u5df1\u7f16\u5199\u7684\u4ee3\u7801\u6267\u884c\u5177\u4f53\u7684\u903b\u8f91\u3002\u6bd4\u5982\u5728\u4f7f\u7528 fragment shader \u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u5b9e\u73b0\u4efb\u4f55\u4ece\u8d34\u56fe\u5230\u706f\u5149\u7684\u5149\u7ebf\u8ffd\u8e2a\u3002\u8fd9\u4e9b\u7a0b\u5e8f\u540c\u65f6\u8fd0\u884c\u5728\u591a\u6838GPU\u4e0a\u5904\u7406\u8bb8\u591a\u5bf9\u8c61\uff0c\u6bd4\u5982\u5e76\u884c\u7684\u9876\u70b9\u548c\u7247\u6bb5\u7a0b\u5e8f\u3002 \u5982\u679c\u4e4b\u524d\u4f7f\u7528\u8fc7\u65e7\u7684API( OpenGL \u548c Direct3D ),\u90a3\u4e48\u5c06\u53ef\u4ee5\u968f\u610f\u901a\u8fc7 glBlendFunc \u548c OMSetBlendState \u8c03\u7528\u66f4\u6539\u7ba1\u7ebf\u8bbe\u7f6e\u3002 Vulkan\u4e2d \u7684\u56fe\u5f62\u7ba1\u7ebf\u51e0\u4e4e\u4e0d\u53ef\u6539\u53d8\uff0c\u56e0\u6b64\u5982\u679c\u9700\u8981\u66f4\u6539\u7740\u8272\u5668\uff0c\u7ed1\u5b9a\u5230\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u533a\u6216\u8005\u66f4\u6539\u6df7\u5408\u51fd\u6570\uff0c\u5219\u5fc5\u987b\u4ece\u5934\u521b\u5efa\u7ba1\u7ebf\u3002\u7f3a\u70b9\u662f\u5fc5\u987b\u521b\u5efa\u4e00\u4e9b\u7ba1\u7ebf\uff0c\u8fd9\u4e9b\u7ba1\u7ebf\u4ee3\u8868\u5728\u6e32\u67d3\u64cd\u4f5c\u4e2d\u4f7f\u7528\u7684\u4e0d\u540c\u7684\u7ec4\u5408\u72b6\u6001\u3002\u4f46\u662f\u7531\u4e8e\u6240\u6709\u7ba1\u7ebf\u7684\u64cd\u4f5c\u90fd\u662f\u63d0\u524d\u77e5\u9053\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7\u9a71\u52a8\u7a0b\u5e8f\u66f4\u597d\u7684\u4f18\u5316\u5b83\u3002 \u4e00\u4e9b\u53ef\u7f16\u7a0b\u9636\u6bb5\u662f\u57fa\u4e8e\u6253\u7b97\u505a\u4ec0\u4e48\u800c\u51b3\u5b9a\u7684\u3002\u6bd4\u5982\uff0c\u5982\u679c\u53ea\u662f\u7b80\u5355\u7684\u7ed8\u5236\u51e0\u4f55\u56fe\u5f62\uff0c\u5219\u53ef\u4ee5\u7981\u7528 tessellation \u548c geometry \u7740\u8272\u5668\u3002\u5982\u679c\u53ea\u5bf9\u6df1\u5ea6\u503c\u611f\u5174\u8da3\uff0c\u5219\u53ef\u4ee5\u7981\u7528 fragment \u7740\u8272\u5668\uff0c\u8fd9\u5bf9\u4e8e\u751f\u6210 shadow map \u751f\u6210\u5f88\u6709\u7528\u3002 \u5728\u4e0b\u4e00\u4e2a\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u9996\u5148\u521b\u5efa\u5c06\u4e09\u89d2\u5f62\u653e\u5728\u5c4f\u5e55\u4e0a\u6240\u9700\u8981\u7684\u4e24\u4e2a\u53ef\u7f16\u7a0b\u9636\u6bb5: vertice shader \u548c fragment shader \u3002\u56fa\u5b9a\u529f\u80fd\u7684\u8bbe\u7f6e\u5305\u62ec blending mode , viewport , rasterization \u5c06\u5728\u4e4b\u540e\u7684\u7ae0\u8282\u4e2d\u8bbe\u7f6e\u3002\u5728 Vulkan \u4e2d\u8bbe\u7f6e\u56fe\u5f62\u6d41\u6c34\u7ebf\u7684\u6700\u540e\u4e00\u90e8\u5206\u5185\u5bb9\u6d89\u53ca\u8f93\u5165\u548c\u8f93\u51fa\u5e27\u7f13\u51b2\u533a\u3002 \u5728 initVulkan \u4e2d\u521b\u5efa\u51fd\u6570 createGraphicsPipeline \u5e76\u5728 createImageViews \u540e\u7acb\u5373\u8c03\u7528\u3002\u6211\u4eec\u5728\u4e0b\u4e00\u7ae0\u8282\u4ecb\u7ecd\u51fd\u6570\u529f\u80fd\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createGraphicsPipeline(); } ... void createGraphicsPipeline() { } C++ \u5728\u7ed3\u5c3e\u5904\u5206\u4eab\u4e00\u4e0b Vulkan \u5b98\u65b9\u7684\u56fe\u5f62\u7ba1\u7ebf\u7ed3\u6784\u56fe\uff0c\u5982\u4e0b:","title":"Vulkan \u56fe\u5f62\u7ba1\u7ebf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_6","text":"Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe \uff0c\u4f7f\u7528\u4efb\u4f55\u7684 VkImage \uff0c\u5305\u62ec\u5728\u4ea4\u6362\u94fe\u6216\u8005\u6e32\u67d3\u7ba1\u7ebf\u4e2d\u7684\uff0c\u6211\u4eec\u90fd\u9700\u8981\u521b\u5efa VkImageView \u5bf9\u8c61\u3002\u4ece\u5b57\u9762\u4e0a\u7406\u89e3\u5b83\u5c31\u662f\u4e00\u4e2a\u9488\u5bf9\u56fe\u50cf\u7684\u89c6\u56fe\u6216\u5bb9\u5668\uff0c\u901a\u8fc7\u5b83\u5177\u4f53\u7684\u6e32\u67d3\u7ba1\u7ebf\u624d\u80fd\u591f\u8bfb\u5199\u6e32\u67d3\u6570\u636e\uff0c\u6362\u53e5\u8bdd\u8bf4 VkImage \u4e0d\u80fd\u4e0e\u6e32\u67d3\u7ba1\u7ebf\u8fdb\u884c\u4ea4\u4e92\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u56fe\u50cf\u89c6\u56fe\u53ef\u4ee5\u8fdb\u4e00\u6b65\u5b9a\u4e49\u5177\u4f53 Image \u7684\u683c\u5f0f\uff0c\u6bd4\u5982\u5b9a\u4e49\u4e3a2D\u8d34\u56fe\uff0c\u90a3\u4e48\u672c\u8d28\u4e0a\u5c31\u4e0d\u9700\u8981\u4efb\u4f55\u7ea7\u522b\u7684 mipmapping \u3002 \u5728\u672c\u7ae0\u8282\u6211\u4eec\u4f1a\u65b0\u589e\u4e00\u4e2a createImageViews \u51fd\u6570\uff0c\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u521b\u5efa\u57fa\u672c\u7684\u89c6\u56fe\uff0c\u8fd9\u4e9b\u89c6\u56fe\u5728\u540e\u9762\u7684\u5185\u5bb9\u4e2d\u4f1a\u88ab\u4f5c\u4e3a\u989c\u8272\u76ee\u6807\u4e0e\u6e32\u67d3\u7ba1\u7ebf\u914d\u5408\u4f7f\u7528\u3002 \u9996\u5148\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u7528\u4e8e\u4fdd\u5b58\u56fe\u50cf\u89c6\u56fe\u7684\u53e5\u67c4\u96c6: std::vector<VkImageView> swapChainImageViews; C++ \u521b\u5efa createImagesViews \u51fd\u6570\uff0c\u5e76\u5728\u521b\u5efa\u4ea4\u6362\u94fe\u5b8c\u6210\u4e4b\u540e\u8c03\u7528: void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); } void createImageViews() { } C++ \u6211\u4eec\u9700\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u9700\u8981\u5b9a\u4e49\u4fdd\u5b58\u56fe\u50cf\u89c6\u56fe\u96c6\u5408\u7684\u5927\u5c0f: void createImageViews() { swapChainImageViews.resize(swapChainImages.size()); } C++ \u4e0b\u4e00\u6b65\uff0c\u5faa\u73af\u8fed\u4ee3\u6240\u6709\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u3002 for (size_t i = 0; i < swapChainImages.size(); i++) { } C++ \u521b\u5efa\u56fe\u50cf\u89c6\u56fe\u7684\u53c2\u6570\u88ab\u5b9a\u4e49\u5728 VkImageViewCreateInfo \u7ed3\u6784\u4f53\u4e2d\u3002\u524d\u51e0\u4e2a\u53c2\u6570\u7684\u586b\u5145\u975e\u5e38\u7b80\u5355\u3001\u76f4\u63a5\u3002 VkImageViewCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; createInfo.image = swapChainImages[i]; C++ \u5176\u4e2d viewType \u548c format \u5b57\u6bb5\u7528\u4e8e\u63cf\u8ff0\u56fe\u50cf\u6570\u636e\u8be5\u88ab\u5982\u4f55\u89e3\u91ca\u3002 viewType \u53c2\u6570\u5141\u8bb8\u5c06\u56fe\u50cf\u5b9a\u4e49\u4e3a 1D textures , 2D textures , 3D textures \u548c cube maps \u3002 createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; createInfo.format = swapChainImageFormat; C++ components \u5b57\u6bb5\u5141\u8bb8\u8c03\u6574\u989c\u8272\u901a\u9053\u7684\u6700\u7ec8\u7684\u6620\u5c04\u903b\u8f91\u3002\u6bd4\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6240\u6709\u989c\u8272\u901a\u9053\u6620\u5c04\u4e3a\u7ea2\u8272\u901a\u9053\uff0c\u4ee5\u5b9e\u73b0\u5355\u8272\u7eb9\u7406\u3002\u6211\u4eec\u4e5f\u53ef\u4ee5\u5c06\u901a\u9053\u6620\u5c04\u5177\u4f53\u7684\u5e38\u91cf\u6570\u503c 0 \u548c 1 \u3002\u5728\u7ae0\u8282\u4e2d\u6211\u4eec\u4f7f\u7528\u9ed8\u8ba4\u7684\u6620\u5c04\u7b56\u7565\u3002 createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY; C++ subresourceRangle \u5b57\u6bb5\u7528\u4e8e\u63cf\u8ff0\u56fe\u50cf\u7684\u4f7f\u7528\u76ee\u6807\u662f\u4ec0\u4e48\uff0c\u4ee5\u53ca\u53ef\u4ee5\u88ab\u8bbf\u95ee\u7684\u6709\u6548\u533a\u57df\u3002\u6211\u4eec\u7684\u56fe\u50cf\u5c06\u4f1a\u4f5c\u4e3a color targets \uff0c\u6ca1\u6709\u4efb\u4f55 mipmapping levels \u6216\u662f\u591a\u5c42 multiple layers \u3002 createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; createInfo.subresourceRange.baseMipLevel = 0; createInfo.subresourceRange.levelCount = 1; createInfo.subresourceRange.baseArrayLayer = 0; createInfo.subresourceRange.layerCount = 1; C++ \u5982\u679c\u5728\u7f16\u5199\u6c89\u6d78\u5f0f\u7684 3D \u5e94\u7528\u7a0b\u5e8f\uff0c\u6bd4\u5982 VR \uff0c\u5c31\u9700\u8981\u521b\u5efa\u652f\u6301\u591a\u5c42\u7684\u4ea4\u6362\u94fe\u3002\u5e76\u4e14\u901a\u8fc7\u4e0d\u540c\u7684\u5c42\u4e3a\u6bcf\u4e00\u4e2a\u56fe\u50cf\u521b\u5efa\u591a\u4e2a\u89c6\u56fe\uff0c\u4ee5\u6ee1\u8db3\u4e0d\u540c\u5c42\u7684\u56fe\u50cf\u5728\u5de6\u53f3\u773c\u6e32\u67d3\u65f6\u5bf9\u89c6\u56fe\u7684\u9700\u8981\u3002 \u521b\u5efa\u56fe\u50cf\u89c6\u56fe\u8c03\u7528 vkCreateImageView \u51fd\u6570: if (vkCreateImageView(device, &createInfo, nullptr, &swapChainImageViews[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to create image views!\"); } C++ \u4e0e\u56fe\u50cf\u4e0d\u540c\u7684\u662f\uff0c\u56fe\u50cf\u89c6\u56fe\u9700\u8981\u660e\u786e\u7684\u521b\u5efa\u8fc7\u7a0b\uff0c\u6240\u4ee5\u5728\u7a0b\u5e8f\u9000\u51fa\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a\u5faa\u73af\u53bb\u9500\u6bc1\u4ed6\u4eec\u3002 void cleanup() { for (size_t i = 0; i < swapChainImageViews.size(); i++) { vkDestroyImageView(device, swapChainImageViews[i], nullptr); } ... } C++ \u62e5\u6709\u4e86\u56fe\u50cf\u89c6\u56fe\u540e\uff0c\u4f7f\u7528\u56fe\u50cf\u4f5c\u4e3a\u8d34\u56fe\u5df2\u7ecf\u8db3\u591f\u4e86\uff0c\u4f46\u662f\u5b83\u8fd8\u6ca1\u6709\u51c6\u5907\u597d\u4f5c\u4e3a\u6e32\u67d3\u7684 target \u3002\u5b83\u9700\u8981\u66f4\u591a\u7684\u95f4\u63a5\u6b65\u9aa4\u53bb\u51c6\u5907\uff0c\u5176\u4e2d\u4e00\u4e2a\u5c31\u662f framebuffer \uff0c\u88ab\u79f0\u4f5c\u5e27\u7f13\u51b2\u533a\u3002\u4f46\u9996\u5148\u6211\u4eec\u8981\u8bbe\u7f6e\u56fe\u5f62\u7ba1\u7ebf\u3002","title":"Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_7","text":"Vulkan \u7740\u8272\u5668\u6a21\u5757 \uff0c\u4e0e\u4e4b\u524d\u7684\u56fe\u50cf API \u4e0d\u540c\uff0c Vulkan \u4e2d\u7684\u7740\u8272\u5668\u4ee3\u7801\u5fc5\u987b\u4ee5\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u7684\u683c\u5f0f\u4f7f\u7528\uff0c\u800c\u4e0d\u662f\u50cf GLSL \u548c HLSL \u8fd9\u6837\u5177\u6709\u6bd4\u8f83\u597d\u7684\u53ef\u8bfb\u6027\u7684\u8bed\u6cd5\u3002\u6b64\u5b57\u8282\u683c\u5f0f\u6210\u4e3a SPIR-V \uff0c\u5b83\u53ef\u4ee5\u4e0e Vulkan \u548c OpenCL \u4e00\u540c\u4f7f\u7528\u3002\u8fd9\u662f\u4e00\u79cd\u53ef\u4ee5\u7f16\u5199\u56fe\u5f62\u548c\u8ba1\u7b97\u7740\u8272\u5668\u7684\u683c\u5f0f\uff0c\u4f46\u6211\u4eec\u91cd\u70b9\u4ecb\u7ecd\u672c\u6559\u7a0b\u4e2d Vulkan \u56fe\u5f62\u6d41\u6c34\u7ebf\u4f7f\u7528\u7684\u7740\u8272\u5668\u3002 \u4f7f\u7528\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u683c\u5f0f\u7684\u4f18\u70b9\u4e4b\u4e00\u662f \u4f7f\u5f97 GPU \u5382\u5546\u7f16\u5199\u5c06\u7740\u8272\u5668\u4ee3\u7801\u8f6c\u6362\u4e3a\u672c\u5730\u4ee3\u7801\u7684\u7f16\u8bd1\u5668\u590d\u6742\u5ea6\u51cf\u5c11\u4e86\u5f88\u591a\u3002\u7ecf\u9a8c\u8868\u660e\u4f7f\u7528\u53ef\u8bfb\u6027\u6bd4\u8f83\u5f3a\u7684\u8bed\u6cd5\uff0c\u6bd4\u5982 GLSL \u4e00\u4e9b GPU \u5382\u5546\u76f8\u5f53\u7075\u6d3b\u5730\u7406\u89e3\u8fd9\u4e2a\u6807\u51c6\u3002\u8fd9\u5bfc\u81f4\u4e00\u79cd\u60c5\u51b5\u4f1a\u53d1\u751f\uff0c\u6bd4\u5982\u7f16\u5199\u597d\uff0c\u5e76\u5728\u4e00\u4e2a\u5382\u5546\u7684 GPU \u8fd0\u884c\u7684\u4e0d\u9519\u7684\u7740\u8272\u5668\u7a0b\u5e8f\uff0c\u53ef\u80fd\u5728\u5176\u4ed6\u7684 GPU \u5382\u5546\u7684 GPU \u9a71\u52a8\u7a0b\u5e8f\u8fd0\u884c\u5f02\u5e38\uff0c\u53ef\u80fd\u662f\u8bed\u6cd5\u7684\u95ee\u9898\uff0c\u6216\u8005\u66f4\u7cdf\u7684\u662f\u4e0d\u540c GPU \u5382\u5546\u7f16\u5199\u7684\u7f16\u8bd1\u5668\u5dee\u5f02\uff0c\u5bfc\u81f4\u7740\u8272\u5668\u8fd0\u884c\u9519\u8bef\u3002\u5982\u679c\u76f4\u63a5\u4f7f\u7528\u7f16\u8bd1\u597d\u7684\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u683c\u5f0f\uff0c\u53ef\u4ee5\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\u3002 \u4f46\u662f\uff0c\u5e76\u4e0d\u610f\u5473\u7740\u6211\u4eec\u8981\u624b\u5199\u5b57\u8282\u7801\u3002 Khronos \u53d1\u5e03\u4e86\u4e0e\u5382\u5546\u65e0\u5173\u7684\u7f16\u8bd1\u5668\uff0c\u5b83\u5c06 GLSL \u7f16\u8bd1\u6210 SPIR-V \u3002\u8be5\u7f16\u8bd1\u5668\u7528\u4e8e\u9a8c\u8bc1\u7740\u8272\u5668\u4ee3\u7801\u662f\u5426\u7b26\u5408\u6807\u51c6\uff0c\u5e76\u751f\u6210\u4e0e Vulkan \u529f\u80fd\u8fd0\u884c\u7684 SPRIR-V \u4e8c\u8fdb\u5236\u6587\u4ef6\u3002\u9664\u6b64\u4e4b\u5916\u8fd8\u53ef\u4ee5\u5c06\u6b64\u7f16\u8bd1\u5668\u4f5c\u4e3a\u5e93\u5728\u8fd0\u884c\u65f6\u7f16\u8bd1\u751f\u6210 SPRI-V \uff0c\u4f46\u5728\u672c\u6559\u7a0b\u4e2d\u4e0d\u4f1a\u8fd9\u6837\u64cd\u4f5c\u3002\u7f16\u8bd1\u5668 glslangValidator.exe \u5305\u542b\u5728 LunarG SDK \u4e2d\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u4e0b\u8f7d\u4efb\u4f55\u989d\u5916\u7684\u5185\u5bb9\u3002 GLSL \u662f\u5177\u6709C\u98ce\u683c\u8bed\u6cd5\u7684\u7740\u8272\u8bed\u8a00\u3002\u5728\u7a0b\u5e8f\u4e2d\u9700\u8981\u5b9a\u4e49\u7f16\u5199 main \u51fd\u6570\u4f5c\u4e3a\u5165\u53e3\u3002 GLSL \u4e0d\u4f1a\u4f7f\u7528\u8f93\u5165\u53c2\u6570\u548c\u8fd4\u56de\u503c\u4f5c\u4e3a\u8f93\u51fa\uff0c\u800c\u662f\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\u6765\u5904\u7406\u8f93\u5165\u548c\u8f93\u51fa\u3002\u8be5\u8bed\u8a00\u5305\u62ec\u5f88\u591a\u529f\u80fd\u7b80\u5316\u56fe\u5f62\u7f16\u7a0b\uff0c\u6bd4\u5982\u5185\u7f6e\u7684\u57fa\u4e8e\u5411\u91cf\u548c\u77e9\u9635\u7684\u53c9\u79ef\u64cd\u4f5c\u51fd\u6570\uff0c\u77e9\u9635\u548c\u77e2\u91cf\u4e58\u6cd5\u64cd\u4f5c\u51fd\u6570\u3002\u77e2\u91cf\u7c7b\u578b\u4e3a vec \uff0c\u6570\u5b57\u8868\u793a\u5206\u91cf\u7684\u6570\u91cf\u3002\u4f8b\u59823D\u4f4d\u7f6e\u5b58\u50a8\u5728 vec3 \u4e2d\u3002\u53ef\u4ee5\u901a\u8fc7\u8bf8\u5982 .x \u4e4b\u7c7b\u7684\u6210\u5458\u8bbf\u95ee\u5355\u4e2a\u5206\u91cf\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u591a\u4e2a\u5206\u91cf\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5411\u91cf\u3002\u6bd4\u5982\uff0c\u8868\u8fbe\u5f0f vec3(1.0, 2.0, 3.0).xy \u622a\u53d6\u524d\u4e24\u4e2a\u5206\u91cf\uff0c\u5e76\u8d4b\u4e88\u65b0\u7684 vec2 \u4e2d\u3002\u5411\u91cf\u7684\u6784\u9020\u51fd\u6570\u4e5f\u53ef\u4ee5\u91c7\u7528\u77e2\u91cf\u5bf9\u8c61\u548c\u6807\u91cf\u503c\u7684\u7ec4\u5408\u3002\u6bd4\u5982 vec3 \u53ef\u4ee5\u7528 vec3(vec2(1.0, 2.0), 3.0) \u6784\u9020\u3002 \u5982\u524d\u9762\u63d0\u5230\u7684\u4e00\u6837\uff0c\u6211\u4eec\u9700\u8981\u7f16\u5199\u4e00\u4e2a vertex shader \u548c\u4e00\u4e2a fragment shader \u7ed8\u5236\u4e09\u89d2\u5f62\u5728\u5c4f\u5e55\u3002\u4e0b\u9762\u4e24\u4e2a\u5c0f\u8282\u4f1a\u63a2\u8ba8\u4e0e\u4e4b\u76f8\u5173\u7684 GLSL \u4ee3\u7801\uff0c\u5e76\u5c55\u793a\u5982\u4f55\u751f\u6210\u4e24\u4e2a SPIR-V \u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u6700\u540e\u52a0\u8f7d\u5230\u7a0b\u5e8f\u4e2d\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9876\u70b9\u7740\u8272\u5668 2 \u7247\u5143\u7740\u8272\u5668 3 \u9876\u70b9\u989c\u8272\u7ec4 4 \u7f16\u8bd1\u7740\u8272\u5668 5 \u52a0\u8f7d\u7740\u8272\u5668 6 \u521b\u5efa\u7740\u8272\u5668\u6a21\u578b 7 \u7740\u8272\u5668\u9636\u6bb5\u521b\u5efa","title":"Vulkan \u7740\u8272\u5668\u6a21\u5757"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_23","text":"\u9876\u70b9\u7740\u8272\u5668\u5904\u7406\u6bcf\u4e00\u4e2a\u9876\u70b9\u6570\u636e\u3002\u5b83\u7684\u5c5e\u6027\uff0c\u5982\u4e16\u754c\u5750\u6807\uff0c\u989c\u8272\uff0c\u6cd5\u7ebf\u548c\u7eb9\u7406UV\u5750\u6807\u4f5c\u4e3a\u8f93\u5165\u3002\u8f93\u51fa\u7684\u662f\u6700\u7ec8\u7684clip coordinates \u88c1\u526a\u5750\u6807\u548c\u9700\u8981\u4f20\u9012\u5230\u7247\u5143\u7740\u8272\u5668\u7684\u5c5e\u6027\uff0c\u5305\u62ec\u989c\u8272\u548c\u7eb9\u7406UV\u5750\u6807\u3002\u8fd9\u4e9b\u503c\u4f1a\u5728\u5149\u6805\u5316\u9636\u6bb5\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u4ee5\u4ea7\u751f\u5e73\u6ed1\u7684\u8fc7\u5ea6\u3002 \u88c1\u526a\u5750\u6807 clip coordinate \u662f\u4e00\u4e2a\u6765\u6b64\u9876\u70b9\u7740\u8272\u5668\u7684\u601d\u7ef4\u5411\u91cf\uff0c\u968f\u540e\u901a\u8fc7\u77e2\u91cf\u6700\u540e\u4e00\u4e2a\u5206\u91cf\u8fdb\u884c\u6574\u4f53\u5f52\u4e00\u5316\u64cd\u4f5c\u3002\u8fd9\u4e9b\u5f52\u4e00\u5316\u540e\u7684\u8bbe\u5907\u5750\u6807\u662f homogeneous coordinates ****\u6700\u7ec8\u6620\u5c04\u5230\u7f13\u51b2\u533a\u8303\u56f4\u4e3a [-1, 1] \u7684 [-1, 1] \u5750\u6807\u7cfb\u7edf\uff0c\u5982\u4e0b\u6240\u793a: \u5982\u679c\u4e4b\u524d\u7684\u8ba1\u7b97\u673a\u56fe\u5f62\u6bd4\u8f83\u719f\u6089\u7684\u8bdd\uff0c\u5bf9\u8fd9\u90e8\u5206\u4f1a\u6bd4\u8f83\u719f\u6089\u3002\u5982\u679c\u4f60\u4e4b\u524d\u4f7f\u7528\u8fc7 OpenGL \uff0c\u4f60\u4f1a\u6ce8\u610f\u5230Y\u5750\u6807\u8f74\u662f\u53cd\u8f6c\u7684\uff0cZ\u5750\u6807\u8f74\u7684\u8303\u56f4\u4e0e Direct3D \u662f\u4e00\u81f4\u7684\u8303\u56f4\uff0c\u4ece0\u52301. \u5bf9\u4e8e\u7b2c\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u6211\u4eec\u4e0d\u4f1a\u505a\u4efb\u4f55\u8f6c\u6362\u64cd\u4f5c\uff0c\u6211\u4eec\u5c06\u4e09\u4e2a\u9876\u70b9\u7684\u4f4d\u7f6e\u6307\u5b9a\u4e3a\u5f52\u4e00\u5316\u8bbe\u5907\u5750\u6807\uff0c\u521b\u5efa\u5982\u4e0b\u56fe\u5f62: \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5c06\u5176\u8f93\u51fa\u4e3a\u88c1\u526a\u5750\u6807\u76f4\u63a5\u8f93\u51fa\u5f52\u4e00\u5316\u7684\u8bbe\u5907\u5750\u6807\uff0c\u9876\u70b9\u7740\u8272\u5668\u7684\u5750\u6807\u4e0e\u6700\u540e\u4e00\u4e2a\u5206\u91cf\u8bbe\u7f6e\u4e3a 1 \u3002\u5c06\u88c1\u526a\u5750\u6807\u8f6c\u6362\u4e3a\u5f52\u4e00\u5316\u7684\u8bbe\u5907\u5750\u6807\u6ca1\u6709\u6539\u53d8\u4efb\u4f55\u4e1c\u897f\u3002 \u901a\u5e38\u60c5\u51b5\u4e0b\u9876\u70b9\u5750\u6807\u6570\u636e\u662f\u5b58\u50a8\u5728\u4e00\u4e2a\u9876\u70b9\u7f13\u51b2\u533a\u4e2d\uff0c\u4f46\u662f\u5728 Vulkan \u4e2d\u521b\u5efa\u4e00\u4e2a\u9876\u70b9\u7f13\u51b2\u533a\u5e76\u586b\u5145\u6570\u636e\u7684\u8fc7\u7a0b\u5e76\u4e0d\u662f\u76f4\u63a5\u7684\u3002\u6240\u4ee5\u6211\u4eec\u540e\u7f6e\u8fd9\u4e9b\u6b65\u9aa4\uff0c\u76f4\u5230\u6211\u4eec\u6ee1\u610f\u7684\u770b\u5230\u4e00\u4e2a\u4e09\u89d2\u5f62\u51fa\u73b0\u5728\u5c4f\u5e55\u4e0a\u3002\u540c\u65f6\u6211\u4eec\u9700\u8981\u505a\u4e00\u4e9b\u975e\u6b63\u7edf\u7684\u4e8b\u60c5:\u5c06\u5750\u6807\u76f4\u63a5\u5305\u542b\u5728\u9876\u70b9\u7740\u8272\u5668\u7684\u5185\u90e8\u3002\u4ee3\u7801\u5982\u4e0b\u6240\u793a: #version 450 #extension GL_ARB_separate_shader_objects : enable out gl_PerVertex { vec4 gl_Position; }; vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); } C++ main \u51fd\u6570\u7684\u6267\u884c\u5e94\u7528\u4e8e\u6bcf\u4e2a\u9876\u70b9\uff0c\u5185\u7f6e\u7684 gl_VertexIndex \u53d8\u91cf\u5305\u542b\u4e86\u5f53\u524d\u9876\u70b9\u7684\u7d22\u5f15\u4fe1\u606f\u3002\u901a\u5e38\u662f\u9876\u70b9\u7f13\u51b2\u533a\u7684\u7d22\u5f15\uff0c\u4f46\u662f\u5728\u8fd9\u91cc\u6211\u4eec\u786c\u7f16\u7801\u5230\u9876\u70b9\u6570\u636e\u7684\u96c6\u5408\u4e2d\u3002\u6bcf\u4e2a\u9876\u70b9\u7684\u4f4d\u7f6e\u4ece\u5e38\u91cf\u6570\u7ec4\u4e2d\u8bbf\u95ee\uff0c\u5e76\u4e0e z \u548c w \u5206\u91cf\u7ec4\u5408\u4f7f\u7528\uff0c\u4ee5\u4ea7\u751f\u88c1\u526a\u5750\u6807\u4e2d\u7684\u6709\u6548\u4f4d\u7f6e\u4fe1\u606f\u3002\u5185\u7f6e\u7684 gl_Position \u53d8\u91cf\u4f5c\u4e3a\u8f93\u51fa\u3002\u6700\u540eVulkan\u4e2d\u4f7f\u7528shader\uff0c\u9700\u8981\u786e\u4fdd GL_ARG_separate_shader_objects \u6269\u5c55\u5f00\u542f\u3002","title":"\u9876\u70b9\u7740\u8272\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_24","text":"\u7531\u9876\u70b9\u7740\u8272\u5668\u7684\u4f4d\u7f6e\u6570\u636e\u5f62\u6210\u7684\u4e09\u89d2\u5f62\u7528\u7247\u6bb5\u7740\u8272\u5668\u586b\u5145\u5c4f\u5e55\u4e0a\u7684\u533a\u57df\u4e2d\u3002\u7247\u6bb5\u7740\u8272\u5668\u9488\u5bf9\u4e00\u4e2a\u6216\u8005\u591a\u4e2aframebuffer\u5e27\u7f13\u51b2\u533a\u7684\u6bcf\u4e2a\u7247\u5143\u4ea7\u751f\u5177\u4f53\u7684\u989c\u8272\u548c\u6df1\u5ea6\u4fe1\u606f\u3002\u4e00\u4e2a\u7b80\u5355\u7684\u7247\u6bb5\u7740\u8272\u5668\u4e3a\u5b8c\u6210\u7684\u4e09\u89d2\u5f62\u8f93\u51fa\u7ea2\u8272\u4fe1\u606f\u7684\u4ee3\u7801\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable layout(location = 0) out vec4 outColor; void main() { outColor = vec4(1.0, 0.0, 0.0, 1.0); } C++ fragment sahder\u4e2d\u7684 main \u51fd\u6570\u4e0e vertex shader \u4e2d\u7684 main \u51fd\u6570\u7c7b\u4f3c\uff0c\u4f1a\u4e3a\u6bcf\u4e00\u4e2a\u7247\u5143\u8c03\u7528\u5904\u7406\u3002\u989c\u8272\u7684\u4fe1\u606f\u5728GLSL\u4e2d\u662f4\u4e2a\u5206\u91cf\u7ec4\u6210\u7684\u77e2\u91cf\uff0c\u5305\u62ecR,G,B\u548cAlpha\u901a\u9053\uff0c\u503c\u57df\u6536\u655b\u5728[0, 1]\u8303\u56f4\u5185\u3002\u4e0d\u50cf\u9876\u70b9\u7740\u8272\u5668\u7684 gl_Position \uff0c\u5b83\u6ca1\u6709\u5185\u7f6e\u7684\u53d8\u91cf\u4e3a\u5f53\u524d\u7247\u5143\u8f93\u51fa\u989c\u8272\u4fe1\u606f\u3002\u5728\u8fd9\u91cc\u5fc5\u987b\u4e3aframebuffer\u5b9a\u4e49\u8f93\u51fa\u53d8\u91cf\uff0c layout(location = 0) \u4fee\u9970\u7b26\u660e\u786eframebuffer\u7684\u7d22\u5f15\u3002\u7ea2\u8272\u4fe1\u606f\u5199\u8fdb outColor \u53d8\u91cf\u4e2d\uff0c\u8be5\u53d8\u91cf\u94fe\u63a5\u7b2c\u4e00\u4e2aframebuffer\u4e2d\uff0c\u7d22\u5f15\u4e3a 0 \u3002","title":"\u7247\u5143\u7740\u8272\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_25","text":"\u4e00\u4e2a\u7eaf\u7ea2\u8272\u7684\u4e09\u89d2\u5f62\u770b\u8d77\u6765\u5e76\u4e0d\u662f\u5f88\u9177\u70ab\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u8bd5\u7740\u9177\u70ab\u4e00\u4e9b\u5462? \u6211\u4eec\u9488\u5bf9\u4e24\u4e2a\u7c7b\u578b\u7684\u7740\u8272\u5668\u5c1d\u8bd5\u505a\u4e00\u4e9b\u6539\u53d8\uff0c\u5b8c\u6210\u4e0a\u56fe\u7684\u6548\u679c\u3002\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u6bcf\u4e2a\u9876\u70b9\u8bbe\u7f6e\u5dee\u5f02\u5316\u7684\u989c\u8272\u3002\u9876\u70b9\u7740\u8272\u5668\u5e94\u8be5\u5305\u542b\u4e00\u4e2a\u989c\u8272\u6570\u7ec4\uff0c\u5c31\u50cf\u4f4d\u7f6e\u4fe1\u606f\u7684\u6570\u7ec4\u4e00\u6837: vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) ); C++ \u73b0\u5728\u6211\u4eec\u9700\u8981\u628a\u6bcf\u4e2a\u9876\u70b9\u7684\u989c\u8272\u4f20\u9012\u5230\u7247\u6bb5\u7740\u8272\u5668\u4e2d\uff0c\u4ece\u800c\u8f93\u51fa\u7ecf\u8fc7\u63d2\u503c\u540e\u7684\u989c\u8272\u4fe1\u606f\u5230 framebuffer \u4e2d\u3002\u4e3a\u9876\u70b9\u7740\u8272\u5668\u6dfb\u589e\u52a0\u8f93\u51fa\u989c\u8272\u652f\u6301\uff0c\u5728 main \u51fd\u6570\u4e2d\u5b9a\u4e49\u5982\u4e0b: layout(location = 0) out vec3 fragColor; void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex]; } C++ \u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u9700\u8981\u5c06\u7247\u6bb5\u7740\u8272\u5668\u7684\u8f93\u5165\u5339\u914d\u9876\u70b9\u7740\u8272\u5668\u7684\u8f93\u51fa: layout(location = 0) in vec3 fragColor; void main() { outColor = vec4(fragColor, 1.0); } C++ \u8f93\u5165\u7684\u53d8\u91cf\u4e0d\u4e00\u5b9a\u8981\u540c\u540d\uff0c\u5b83\u4eec\u5c06\u901a\u8fc7 location \u7d22\u5f15\u6307\u4ee4\u94fe\u63a5\u5728\u4e00\u8d77\u3002 main \u51fd\u6570\u4e2d\u4fee\u6539\u5c06\u8981\u8f93\u51fa\u7684\u989c\u8272alpha\u503c\u3002\u5c31\u50cf\u4e4b\u524d\u8ba8\u8bba\u7684\u4e00\u6837\uff0c fragColor \u5c06\u4f1a\u4e3a\u4e09\u4e2a\u9876\u70b9\u6240\u5c5e\u7684\u7247\u5143\u81ea\u52a8\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u5f62\u6210\u5e73\u6ed1\u7684\u989c\u8272\u8fc7\u5ea6\u3002","title":"\u9876\u70b9\u989c\u8272\u7ec4"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_26","text":"\u5728\u9879\u76ee\u6839\u76ee\u5f55\u4e0b\u521b\u5efa\u4e00\u4e2a\u5b50\u76ee\u5f55\uff0c\u540d shaders \u7528\u4e8e\u5b58\u50a8\u9876\u70b9\u7740\u8272\u5668\u6587\u4ef6 shader.vert \u548c\u7247\u6bb5\u7740\u8272\u5668\u6587\u4ef6 shader.frag \u3002GLSL\u7740\u8272\u5668\u5b98\u65b9\u6ca1\u6709\u7ea6\u5b9a\u7684\u6269\u5c55\u540d\uff0c\u4f46\u662f\u8fd9\u4e24\u4e2a\u6269\u5c55\u540d\u662f\u6bd4\u8f83\u666e\u904d\u901a\u7528\u7684\u3002 shader.vert \u5185\u5bb9\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable out gl_PerVertex { vec4 gl_Position; }; layout(location = 0) out vec3 fragColor; vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex]; } C++ shader.frag \u6587\u4ef6\u5185\u5bb9\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable layout(location = 0) in vec3 fragColor; layout(location = 0) out vec4 outColor; void main() { outColor = vec4(fragColor, 1.0); } C++ \u73b0\u5728\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 glslangValidator \u7a0b\u5e8f\u7f16\u8bd1SPIR-V\u4e8c\u8fdb\u5236\u7801\u3002 \u521b\u5efa\u4e00\u4e2acompile.bat\u6279\u5904\u7406\u6587\u4ef6\uff0c\u5185\u5bb9\u5982\u4e0b: C:/VulkanSDK/1.0.17.0/Bin32/glslangValidator.exe -V shader.vert C:/VulkanSDK/1.0.17.0/Bin32/glslangValidator.exe -V shader.frag pause C++ \u5c06 glslangValidator.exe \u7684path\u8def\u5f84\u66ff\u6362\u4e3a\u4f60\u7684VulkanSDK\u5b89\u88c5\u8def\u5f84\uff0c\u7136\u540e\u53cc\u51fb\u8be5\u6587\u4ef6\u8fd0\u884c\u3002 \u8fd9\u4e24\u4e2a\u547d\u4ee4\u4f7f\u7528 -V \u6807\u5fd7\u8c03\u7528\u7f16\u8bd1\u5668\uff0c\u8be5\u6807\u5fd7\u544a\u8bc9\u5b83\u5c06GLSL\u6e90\u6587\u4ef6\u7f16\u8bd1\u4e3aSPIR-V\u5b57\u8282\u7801\u3002\u8fd0\u884c\u7f16\u8bd1\u811a\u672c\u65f6\uff0c\u4f1a\u770b\u5230\u521b\u5efa\u4e86\u4e24\u4e2aSPIR-V\u4e8c\u8fdb\u5236\u6587\u4ef6: vert.spv \u548c frag.spv \u3002\u8fd9\u4e9b\u540d\u79f0\u4ece\u7740\u8272\u5668\u4e2d\u6d3e\u751f\u800c\u6765\uff0c\u4f46\u662f\u53ef\u4ee5\u91cd\u547d\u540d\u4e3a\u4efb\u4f55\u540d\u5b57\u3002\u5728\u7f16\u8bd1\u7740\u8272\u5668\u65f6\uff0c\u53ef\u80fd\u6536\u5230\u5173\u4e8e\u67d0\u4e9b\u529f\u80fd\u7f3a\u5931\u7684\u8b66\u544a\u4fe1\u606f\uff0c\u5728\u8fd9\u91cc\u653e\u5fc3\u7684\u5ffd\u7565\u5b83\u4eec\u3002 \u5982\u679c\u7740\u8272\u5668\u5305\u542b\u8bed\u6cd5\u9519\u8bef\uff0c\u90a3\u4e48\u7f16\u8bd1\u5668\u4f1a\u6309\u7167\u60a8\u7684\u9884\u671f\u544a\u8bc9\u5177\u4f53\u7684\u884c\u53f7\u548c\u95ee\u9898\u3002\u5c1d\u8bd5\u7701\u7565\u4e00\u4e2a\u5206\u53f7\uff0c\u7136\u540e\u91cd\u65b0\u8fd0\u884c\u7f16\u8bd1\u811a\u672c\u3002\u8fd8\u53ef\u4ee5\u5c1d\u8bd5\u8fd0\u884c\u7f16\u8bd1\u5668\uff0c\u800c\u65e0\u9700\u4efb\u4f55\u53c2\u6570\u6765\u67e5\u770b\u5b83\u652f\u6301\u54ea\u4e9b\u7c7b\u578b\u7684\u6807\u5fd7\u3002\u4f8b\u5982\uff0c\u5b83\u53ef\u4ee5\u5c06\u5b57\u8282\u7801\u8f93\u51fa\u4e3a\u53ef\u8bfb\u7684\u683c\u5f0f\uff0c\u4ee5\u4fbf\u51c6\u786e\u4e86\u89e3\u7740\u8272\u5668\u6b63\u5728\u6267\u884c\u7684\u64cd\u4f5c\u4ee5\u53ca\u5728\u6b64\u9636\u6bb5\u5e94\u7528\u7684\u4efb\u4f55\u4f18\u5316\u3002","title":"\u7f16\u8bd1\u7740\u8272\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_27","text":"\u73b0\u5728\u6211\u4eec\u6709\u4e00\u79cd\u4ea7\u751fSPIR-V\u7740\u8272\u5668\u7684\u65b9\u6cd5\uff0c\u662f\u65f6\u5019\u52a0\u8f7d\u5b83\u4eec\u5230\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\uff0c\u4ee5\u4fbf\u5728\u9002\u5f53\u7684\u65f6\u5019\u63d2\u5165\u5230\u56fe\u5f62\u7ba1\u7ebf\u4e2d\u3002\u9996\u5148\u6211\u4eec\u7f16\u5199\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\u7528\u4ee5\u52a0\u8f7d\u4e8c\u8fdb\u5236\u6570\u636e\u6587\u4ef6\u3002 #include <fstream> ... static std::vector<char> readFile(const std::string& filename) { std::ifstream file(filename, std::ios::ate | std::ios::binary); if (!file.is_open()) { throw std::runtime_error(\"failed to open file!\"); } } C++ readFile \u51fd\u6570\u5c06\u4f1a\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6240\u6709\u7684\u4e8c\u8fdb\u5236\u6570\u636e\uff0c\u5e76\u7528 std::vector \u5b57\u8282\u96c6\u5408\u7ba1\u7406\u3002\u6211\u4eec\u4f7f\u7528\u4e24\u4e2a\u6807\u5fd7\u7528\u4ee5\u6253\u5f00\u6587\u4ef6: ate :\u5728\u6587\u4ef6\u672b\u5c3e\u5f00\u59cb\u8bfb\u53d6 binary :\u4ee5\u4e8c\u8fdb\u5236\u683c\u5f0f\u53bb\u8bfb\u6587\u4ef6(\u907f\u514d\u5b57\u7b26\u683c\u5f0f\u7684\u8f6c\u4e49) \u4ece\u6587\u4ef6\u672b\u5c3e\u5f00\u59cb\u8bfb\u53d6\u7684\u4f18\u70b9\u662f\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u8bfb\u53d6\u4f4d\u7f6e\u6765\u786e\u5b9a\u6587\u4ef6\u7684\u5927\u5c0f\u5e76\u5206\u914d\u7f13\u51b2\u533a: size_t fileSize = (size_t) file.tellg(); std::vector<char> buffer(fileSize); C++ \u4e4b\u540e\u6211\u4eec\u53ef\u4ee5\u8ffd\u6eaf\u5230\u6587\u4ef6\u7684\u5f00\u5934\uff0c\u540c\u65f6\u8bfb\u53d6\u6240\u6709\u7684\u5b57\u8282: file.seekg(0); file.read(buffer.data(), fileSize); C++ \u6700\u540e\u5173\u95ed\u6587\u4ef6\uff0c\u8fd4\u56de\u5b57\u8282\u6570\u636e: file.close(); return buffer; C++ \u6211\u4eec\u8c03\u7528\u51fd\u6570createGraphicsPipeline\u52a0\u8f7d\u4e24\u4e2a\u7740\u8272\u5668\u7684\u4e8c\u8fdb\u5236\u7801: void createGraphicsPipeline() { auto vertShaderCode = readFile(\"shaders/vert.spv\"); auto fragShaderCode = readFile(\"shaders/frag.spv\"); } C++ \u786e\u4fdd\u7740\u8272\u5668\u6b63\u786e\u52a0\u8f7d\uff0c\u5e76\u6253\u5370\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u662f\u5426\u4e0e\u6587\u4ef6\u5b9e\u9645\u5927\u5c0f\u4e00\u81f4\u3002","title":"\u52a0\u8f7d\u7740\u8272\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_28","text":"\u5728\u5c06\u4ee3\u7801\u4f20\u9012\u7ed9\u6e32\u67d3\u7ba1\u7ebf\u4e4b\u524d\uff0c\u6211\u4eec\u5fc5\u987b\u5c06\u5176\u5c01\u88c5\u5230 VkShaderModule \u5bf9\u8c61\u4e2d\u3002\u8ba9\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570 createShaderModule \u5b9e\u73b0\u8be5\u903b\u8f91\u3002 VkShaderModule createShaderModule(const std::vector<char>& code) { } C++ \u8be5\u51fd\u6570\u9700\u8981\u5b57\u8282\u7801\u7684\u7f13\u51b2\u533a\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u901a\u8fc7\u7f13\u51b2\u533a\u521b\u5efa VkShaderModule \u3002 \u521b\u5efashader module\u662f\u6bd4\u8f83\u7b80\u5355\u7684\uff0c\u6211\u4eec\u4ec5\u4ec5\u9700\u8981\u6307\u5b9a\u4e8c\u8fdb\u5236\u7801\u7f13\u51b2\u533a\u7684\u6307\u9488\u548c\u5b83\u7684\u5177\u4f53\u957f\u5ea6\u3002\u8fd9\u4e9b\u4fe1\u606f\u88ab\u586b\u5145\u5728 VkShaderModuleCreateInfo \u7ed3\u6784\u4f53\u4e2d\u3002\u9700\u8981\u7559\u610f\u7684\u662f\u5b57\u8282\u7801\u7684\u5927\u5c0f\u662f\u4ee5\u5b57\u8282\u6307\u5b9a\u7684\uff0c\u4f46\u662f\u5b57\u8282\u7801\u6307\u9488\u662f\u4e00\u4e2a uint32_t \u7c7b\u578b\u7684\u6307\u9488\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a char \u6307\u9488\u3002\u6240\u4ee5\u6211\u4eec\u4f7f\u7528 reinterpret_cast \u8fdb\u884c\u8f6c\u6362\u6307\u9488\u3002\u5982\u4e0b\u6240\u793a\uff0c\u5f53\u9700\u8981\u8f6c\u6362\u65f6\uff0c\u8fd8\u9700\u8981\u786e\u4fdd\u6570\u636e\u6ee1\u8db3 uint32_t \u7684\u5bf9\u9f50\u8981\u6c42\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u6570\u636e\u5b58\u50a8\u5728 std::vector \u4e2d\uff0c\u9ed8\u8ba4\u5206\u914d\u5668\u5df2\u7ecf\u786e\u4fdd\u6570\u636e\u6ee1\u8db3\u6700\u5dee\u60c5\u51b5\u4e0b\u7684\u5bf9\u9f50\u8981\u6c42\u3002 VkShaderModuleCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; createInfo.codeSize = code.size(); createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data()); C++ \u8c03\u7528 vkCreateShaderMoudle \u521b\u5efa VkShaderModule : VkShaderModule shaderModule; if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) { throw std::runtime_error(\"failed to create shader module!\"); } C++ \u53c2\u6570\u4e0e\u4e4b\u524d\u521b\u5efa\u5bf9\u8c61\u529f\u80fd\u7c7b\u4f3c:\u903b\u8f91\u8bbe\u5907\uff0c\u521b\u5efa\u5bf9\u8c61\u4fe1\u606f\u7ed3\u6784\u4f53\u7684\u6307\u9488\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u4fdd\u5b58\u7ed3\u679c\u7684\u53e5\u67c4\u53d8\u91cf\u3002\u5728shader module\u521b\u5efa\u5b8c\u6bd5\u540e\uff0c\u53ef\u4ee5\u5bf9\u4e8c\u8fdb\u5236\u7801\u7684\u7f13\u51b2\u533a\u8fdb\u884c\u7acb\u5373\u7684\u91ca\u653e\u3002\u6700\u540e\u4e0d\u8981\u5fd8\u8bb0\u8fd4\u56de\u521b\u5efa\u597d\u7684shader module\u3002 return shaderModule; C++ shader module\u5bf9\u8c61\u4ec5\u4ec5\u5728\u6e32\u67d3\u7ba1\u7ebf\u5904\u7406\u8fc7\u7a0b\u4e2d\u9700\u8981\uff0c\u6240\u4ee5\u6211\u4eec\u4f1a\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u5b9a\u4e49\u672c\u5730\u53d8\u91cf\u4fdd\u5b58\u5b83\u4eec\uff0c\u800c\u4e0d\u662f\u5b9a\u4e49\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709\u5b83\u4eec\u7684\u53e5\u67c4: VkShaderModule vertShaderModule; VkShaderModule fragShaderModule; C++ \u8c03\u7528\u52a0\u8f7dshader module\u7684\u8f85\u52a9\u51fd\u6570: vertShaderModule = createShaderModule(vertShaderCode); fragShaderModule = createShaderModule(fragShaderCode); C++ \u5728\u56fe\u5f62\u7ba1\u7ebf\u521b\u5efa\u5b8c\u6210\u4e14 createGraphicsPipeline \u51fd\u6570\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u5b83\u4eec\u5e94\u8be5\u88ab\u6e05\u7406\u6389\uff0c\u6240\u4ee5\u5728\u8be5\u51fd\u6570\u540e\u5220\u9664\u5b83\u4eec: ... vkDestroyShaderModule(device, fragShaderModule, nullptr); vkDestroyShaderModule(device, vertShaderModule, nullptr); } C++","title":"\u521b\u5efa\u7740\u8272\u5668\u6a21\u578b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_29","text":"VkShaderModule \u5bf9\u8c61\u53ea\u662f\u5b57\u8282\u7801\u7f13\u51b2\u533a\u7684\u4e00\u4e2a\u5305\u88c5\u5bb9\u5668\u3002\u7740\u8272\u5668\u5e76\u6ca1\u6709\u5f7c\u6b64\u94fe\u63a5\uff0c\u751a\u81f3\u6ca1\u6709\u7ed9\u51fa\u76ee\u7684\u3002\u901a\u8fc7 VkPipelineShaderStageCreateInfo \u7ed3\u6784\u5c06\u7740\u8272\u5668\u6a21\u5757\u5206\u914d\u5230\u7ba1\u7ebf\u4e2d\u7684\u9876\u70b9\u6216\u8005\u7247\u6bb5\u7740\u8272\u5668\u9636\u6bb5\u3002VkPipelineShaderStageCreateInfo\u7ed3\u6784\u4f53\u662f\u5b9e\u9645\u7ba1\u7ebf\u521b\u5efa\u8fc7\u7a0b\u7684\u4e00\u90e8\u5206\u3002 \u6211\u4eec\u9996\u5148\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u586b\u5199\u9876\u70b9\u7740\u8272\u5668\u7ed3\u6784\u4f53\u3002 VkPipelineShaderStageCreateInfo vertShaderStageInfo = {}; vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; C++ \u9664\u4e86\u5f3a\u5236\u7684 sType \u6210\u5458\u5916\uff0c\u7b2c\u4e00\u4e2a\u9700\u8981\u544a\u77e5Vulkan\u5c06\u5728\u54ea\u4e2a\u6d41\u6c34\u7ebf\u9636\u6bb5\u4f7f\u7528\u7740\u8272\u5668\u3002\u5728\u4e0a\u4e00\u4e2a\u7ae0\u8282\u7684\u6bcf\u4e2a\u53ef\u7f16\u7a0b\u9636\u6bb5\u90fd\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u679a\u4e3e\u503c\u3002 vertShaderStageInfo.module = vertShaderModule; vertShaderStageInfo.pName = \"main\"; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u6210\u5458\u6307\u5b9a\u5305\u542b\u4ee3\u7801\u7684\u7740\u8272\u5668\u6a21\u5757\u548c\u8c03\u7528\u7684\u4e3b\u51fd\u6570\u3002\u8fd9\u610f\u5473\u7740\u53ef\u4ee5\u5c06\u591a\u4e2a\u7247\u6bb5\u7740\u8272\u5668\u7ec4\u5408\u5230\u5355\u4e2a\u7740\u8272\u5668\u6a21\u5757\u4e2d\uff0c\u5e76\u4f7f\u7528\u4e0d\u540c\u7684\u5165\u53e3\u70b9\u6765\u533a\u5206\u5b83\u4eec\u7684\u884c\u4e3a\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u575a\u6301\u4f7f\u7528\u6807\u51c6 main \u51fd\u6570\u4f5c\u4e3a\u5165\u53e3\u3002 \u8fd8\u6709\u4e00\u4e2a\u53ef\u9009\u6210\u5458\uff0c pSpecializationInfo ,\u5728\u8fd9\u91cc\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u5b83\uff0c\u4f46\u662f\u503c\u5f97\u8ba8\u8bba\u4e00\u4e0b\u3002\u5b83\u5141\u8bb8\u4e3a\u7740\u8272\u5668\u6307\u5b9a\u5e38\u91cf\u503c\u3002\u4f7f\u7528\u5355\u4e2a\u7740\u8272\u5668\u6a21\u5757\uff0c\u901a\u8fc7\u4e3a\u5176\u4e2d\u4f7f\u7528\u4e0d\u540c\u7684\u5e38\u91cf\u503c\uff0c\u53ef\u4ee5\u5728\u6d41\u6c34\u7ebf\u521b\u5efa\u65f6\u5bf9\u884c\u4e3a\u8fdb\u884c\u914d\u7f6e\u3002\u8fd9\u6bd4\u5728\u6e32\u67d3\u65f6\u4f7f\u7528\u53d8\u91cf\u914d\u7f6e\u7740\u8272\u5668\u66f4\u6709\u6548\u7387\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u53ef\u4ee5\u8fdb\u884c\u4f18\u5316\uff0c\u4f8b\u5982\u6d88\u9664 if \u503c\u5224\u65ad\u7684\u8bed\u53e5\u3002\u5982\u679c\u6ca1\u6709\u8fd9\u6837\u7684\u5e38\u91cf\uff0c\u53ef\u4ee5\u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a nullptr \uff0c\u6211\u4eec\u7684struct\u7ed3\u6784\u4f53\u521d\u59cb\u5316\u81ea\u52a8\u8fdb\u884c\u3002 \u4fee\u6539\u7ed3\u6784\u4f53\u6ee1\u8db3\u7247\u6bb5\u7740\u8272\u5668\u7684\u9700\u8981: VkPipelineShaderStageCreateInfo fragShaderStageInfo = {}; fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; fragShaderStageInfo.module = fragShaderModule; fragShaderStageInfo.pName = \"main\"; C++ \u5b8c\u6210\u4e24\u4e2a\u7ed3\u6784\u4f53\u7684\u521b\u5efa\uff0c\u5e76\u901a\u8fc7\u6570\u7ec4\u4fdd\u5b58\uff0c\u8fd9\u90e8\u5206\u5f15\u7528\u5c06\u4f1a\u5728\u5b9e\u9645\u7684\u7ba1\u7ebf\u521b\u5efa\u5f00\u59cb\u3002 VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo}; C++ \u5230\u6b64\u4e3a\u6b62\uff0c\u5c31\u662f\u6240\u6709\u5173\u4e8e\u53ef\u7f16\u7a0b\u7ba1\u7ebf\u9636\u6bb5\u7684\u903b\u8f91\u3002\u5728 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u4f1a\u770b\u4e00\u4e0b\u56fa\u5b9a\u7ba1\u7ebf\u5404\u4e2a\u9636\u6bb5\u3002","title":"\u7740\u8272\u5668\u9636\u6bb5\u521b\u5efa"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_8","text":"Vulkan \u56fa\u6709\u529f\u80fd \uff0c\u65e9\u8d77\u7684\u56fe\u5f62API\u5728\u56fe\u5f62\u6e32\u67d3\u7ba1\u7ebf\u7684\u8bb8\u591a\u9636\u6bb5\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u7684\u72b6\u6001\u3002\u5728 Vulkan \u4e2d\uff0c\u4ece viewport \u7684\u5927\u5c0f\u5230\u6df7\u8272\u51fd\u6570\uff0c\u9700\u8981\u51e1\u4e8b\u505a\u5230\u4eb2\u5386\u4eb2\u4e3a\u3002\u5728\u672c\u7ae0\u8282\u4e2d\u6211\u4eec\u4f1a\u586b\u5145\u6709\u5173\u56fa\u6709\u529f\u80fd\u64cd\u4f5c\u7684\u6240\u6709\u7ed3\u6784\u4f53\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9876\u70b9\u8f93\u5165 2 \u8f93\u5165\u7ec4\u4ef6 3 \u89c6\u7a97\u548c\u88c1\u526a 4 \u5149\u6805\u5316 5 \u91cd\u91c7\u6837 6 \u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5 7 \u989c\u8272\u6df7\u5408 8 \u52a8\u6001\u4fee\u6539 9 \u7ba1\u9053\u5e03\u5c40 10 \u7ed3\u8bba","title":"Vulkan \u56fa\u6709\u529f\u80fd"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_30","text":"VkPipelineVertexInputStateCreateInfo \u7ed3\u6784\u4f53\u63cf\u8ff0\u4e86\u9876\u70b9\u6570\u636e\u7684\u683c\u5f0f\uff0c\u8be5\u7ed3\u6784\u4f53\u6570\u636e\u4f20\u9012\u5230 vertex shader \u4e2d\u3002\u5b83\u4ee5\u4e24\u79cd\u65b9\u5f0f\u8fdb\u884c\u63cf\u8ff0: Bindings :\u6839\u636e\u6570\u636e\u7684\u95f4\u9699\uff0c\u786e\u5b9a\u6570\u636e\u662f\u6bcf\u4e2a\u9876\u70b9\u6216\u8005\u662f\u6bcf\u4e2ainstance( instancing ) Attribute \u63cf\u8ff0:\u63cf\u8ff0\u5c06\u8981\u8fdb\u884c\u7ed1\u5b9a\u53ca\u52a0\u8f7d\u5c5e\u6027\u7684\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684\u76f8\u5173\u5c5e\u6027\u7c7b\u578b\u3002 \u56e0\u4e3a\u6211\u4eec\u5c06\u9876\u70b9\u6570\u636e\u786c\u7f16\u7801\u5230 vertex shader \u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u5c06\u8981\u586b\u5145\u7684\u7ed3\u6784\u4f53\u6ca1\u6709\u9876\u70b9\u6570\u636e\u53bb\u52a0\u8f7d\u3002\u6211\u4eec\u5c06\u4f1a\u5728 vertex buffer \u7ae0\u8282\u4e2d\u56de\u6765\u64cd\u4f5c\u3002 VkPipelineVertexInputStateCreateInfo vertexInputInfo = {}; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.pVertexBindingDescriptions = nullptr; // Optional vertexInputInfo.vertexAttributeDescriptionCount = 0; vertexInputInfo.pVertexAttributeDescriptions = nullptr; // Optional C++ pVertexBindingDescriptions \u548c pVertexAttributeDescriptions \u6210\u5458\u6307\u5411\u7ed3\u6784\u4f53\u6570\u7ec4\uff0c\u7528\u4e8e\u8fdb\u4e00\u6b65\u63cf\u8ff0\u52a0\u8f7d\u7684\u9876\u70b9\u6570\u636e\u4fe1\u606f\u3002\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u7684 shaderStages \u6570\u7ec4\u540e\u6dfb\u52a0\u8be5\u7ed3\u6784\u4f53\u3002","title":"\u9876\u70b9\u8f93\u5165"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_31","text":"VkPipelineInputAssemblyStateCreateInfo \u7ed3\u6784\u4f53\u63cf\u8ff0\u4e24\u4ef6\u4e8b\u60c5:\u9876\u70b9\u6570\u636e\u4ee5\u4ec0\u4e48\u7c7b\u578b\u7684\u51e0\u4f55\u56fe\u5143\u62d3\u6251\u8fdb\u884c\u7ed8\u5236\u53ca\u662f\u5426\u542f\u7528\u9876\u70b9\u7d22\u91cd\u65b0\u5f00\u59cb\u56fe\u5143\u3002\u56fe\u5143\u7684\u62d3\u6251\u7ed3\u6784\u7c7b\u578b topology \u679a\u4e3e\u503c\u5982\u4e0b: VK_PRIMITIVE_TOPOLOGY_POINT_LIST : \u9876\u70b9\u5230\u70b9 VK_PRIMITIVE_TOPOLOGY_LINE_LIST : \u4e24\u70b9\u6210\u7ebf\uff0c\u9876\u70b9\u4e0d\u5171\u7528 VK_PRIMITIVE_TOPOLOGY_LINE_STRIP : \u4e24\u70b9\u6210\u7ebf\uff0c\u6bcf\u4e2a\u7ebf\u6bb5\u7684\u7ed3\u675f\u9876\u70b9\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u7ebf\u6bb5\u7684\u5f00\u59cb\u9876\u70b9 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST : \u4e09\u70b9\u6210\u9762\uff0c\u9876\u70b9\u4e0d\u5171\u7528 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP : \u6bcf\u4e2a\u4f46\u6559\u8bad\u7684\u7b2c\u4e8c\u4e2a\u3001\u7b2c\u4e09\u4e2a\u9876\u70b9\u90fd\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u4e09\u89d2\u5f62\u7684\u524d\u4e24\u4e2a\u9876\u70b9 \u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u9876\u70b9\u6570\u636e\u6309\u7167\u7f13\u51b2\u533a\u4e2d\u7684\u5e8f\u5217\u4f5c\u4e3a\u7d22\u5f15\uff0c\u4f46\u662f\u4e5f\u53ef\u4ee5\u901a\u8fc7element buffer\u7f13\u51b2\u533a\u81ea\u884c\u6307\u5b9a\u9876\u70b9\u6570\u636e\u7684\u7d22\u5f15\u3002\u901a\u8fc7\u590d\u7528\u9876\u70b9\u6570\u636e\u63d0\u5347\u6027\u80fd\u3002\u5982\u679c\u8bbe\u7f6e primitiveRestartEnable \u6210\u5458\u4e3a VK_TRUE \uff0c\u53ef\u4ee5\u901a\u8fc7 0xFFFF \u6216\u8005 0xFFFFFFFF \u4f5c\u4e3a\u7279\u6b8a\u7d22\u5f15\u6765\u5206\u89e3\u7ebf\u548c\u4e09\u89d2\u5f62\u5728 _STRIP \u6a21\u5f0f\u4e0b\u7684\u56fe\u5143\u62d3\u6251\u7ed3\u6784\u3002 \u901a\u8fc7\u672c\u6559\u7a0b\u7ed8\u5236\u4e09\u89d2\u5f62\uff0c\u6240\u4ee5\u6211\u4eec\u575a\u6301\u6309\u7167\u5982\u4e0b\u683c\u5f0f\u586b\u5145\u6570\u636e\u7ed3\u6784: VkPipelineInputAssemblyStateCreateInfo inputAssembly = {}; inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; inputAssembly.primitiveRestartEnable = VK_FALSE; C++","title":"\u8f93\u5165\u7ec4\u4ef6"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_32","text":"Viewport\u7528\u4e8e\u63cf\u8ff0framebuffer\u4f5c\u4e3a\u6e32\u67d3\u8f93\u51fa\u7ed3\u679c\u76ee\u6807\u533a\u57df\u3002\u5b83\u7684\u6570\u503c\u5728\u672c\u6559\u7a0b\u4e2d\u603b\u662f\u8bbe\u7f6e\u5728 (0, 0) \u548c (width, height) \u3002 VkViewport viewport = {}; viewport.x = 0.0f; viewport.y = 0.0f; viewport.width = (float) swapChainExtent.width; viewport.height = (float) swapChainExtent.height; viewport.minDepth = 0.0f; viewport.maxDepth = 1.0f; C++ \u8bb0\u5f97\u4ea4\u6362\u94fe\u548c\u5b83\u7684images\u56fe\u50cf\u5927\u5c0f WIDTH \u548c HEIGHT \u4f1a\u6839\u636e\u4e0d\u540c\u7684\u7a97\u4f53\u800c\u4e0d\u540c\u3002\u4ea4\u6362\u94fe\u56fe\u50cf\u5c06\u4f1a\u5728\u5e27\u7f13\u51b2\u533aframebuffers\u4f7f\u7528\uff0c\u6240\u4ee5\u6211\u4eec\u5e94\u8be5\u575a\u6301\u5b83\u4eec\u7684\u5927\u5c0f\u3002 minDepth \u548c maxDepth \u6570\u503c\u6307\u5b9aframebuffer\u4e2d\u6df1\u5ea6\u7684\u8303\u56f4\u3002\u8fd9\u4e9b\u6570\u503c\u5fc5\u987b\u6536\u655b\u5728 [0.0f, 1.0f] \u533a\u95f4\u51b2\uff0c\u4f46\u662f minDepth \u53ef\u80fd\u4f1a\u5927\u4e8e maxDepth \u3002\u5982\u679c\u4f60\u4e0d\u505a\u4efb\u4f55\u6307\u5b9a\uff0c\u5efa\u8bae\u4f7f\u7528\u6807\u51c6\u7684\u6570\u503c 0.0 f\u548c 1.0f \u3002 viewports \u5b9a\u4e49\u4e86image\u56fe\u50cf\u5230framebuffer\u5e27\u7f13\u51b2\u533a\u7684\u8f6c\u6362\u5173\u7cfb\uff0c\u88c1\u526a\u77e9\u5f62\u5b9a\u4e49\u4e86\u54ea\u4e9b\u533a\u57df\u7684\u50cf\u7d20\u88ab\u5b58\u50a8\u3002\u4efb\u4f55\u5728\u88c1\u526a\u5de8\u578b\u5916\u7684\u50cf\u7d20\u90fd\u4f1a\u5728\u5149\u6805\u5316\u9636\u6bb5\u4e22\u5f03\u3002\u5b83\u4eec\u7684\u529f\u80fd\u66f4\u50cf\u8fc7\u6ee4\u5668\u800c\u4e0d\u662f\u5b9a\u4e49\u8f6c\u6362\u5173\u7cfb\u3002\u8fd9\u4e2a\u533a\u522b\u5982\u4e0b\u56fe\u6240\u793a\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5bf9\u4e8e\u56fe\u50cf\u6bd4 viewport \u5c3a\u5bf8\u5927\u7684\u60c5\u5f62\uff0c\u5de6\u4fa7\u7684\u88c1\u526a\u77e9\u5f62\u53ea\u662f\u4f17\u591a\u53ef\u80fd\u7684\u4e00\u4e2a\u8868\u73b0\u3002 \u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u9700\u8981\u5c06\u56fe\u50cf\u7ed8\u5236\u5230\u5b8c\u6574\u7684\u5e27\u7f13\u51b2\u533a framebuffer \u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u5b9a\u4e49\u88c1\u526a\u77e9\u5f62\u8986\u76d6\u5230\u6574\u4f53\u56fe\u50cf: VkRect2D scissor = {}; scissor.offset = {0, 0}; scissor.extent = swapChainExtent; C++ viewport\u548c\u88c1\u526a\u77e9\u5f62\u9700\u8981\u501f\u52a9 VkPipelineViewportStateCreateInfo \u7ed3\u6784\u4f53\u8054\u5408\u4f7f\u7528\u3002\u53ef\u4ee5\u4f7f\u7528\u591a viewports \u548c\u88c1\u526a\u77e9\u5f62\u5728\u4e00\u4e9b\u56fe\u5f62\u5361\uff0c\u901a\u8fc7\u6570\u7ec4\u5f15\u7528\u3002\u4f7f\u7528\u8be5\u7279\u6027\u9700\u8981GPU\u652f\u6301\u8be5\u529f\u80fd\uff0c\u5177\u4f53\u770b\u903b\u8f91\u8bbe\u5907\u7684\u521b\u5efa\u3002 VkPipelineViewportStateCreateInfo viewportState = {}; viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; viewportState.pScissors = &scissor; C++","title":"\u89c6\u7a97\u548c\u88c1\u526a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_33","text":"\u5149\u6805\u5316\u901a\u8fc7\u9876\u70b9\u7740\u8272\u5668\u53ca\u5177\u4f53\u7684\u51e0\u4f55\u7b97\u6cd5\u5c06\u9876\u70b9\u8fdb\u884c\u5851\u5f62\uff0c\u5e76\u5c06\u56fe\u5f62\u4f20\u9012\u5230\u7247\u6bb5\u7740\u8272\u5668\u8fdb\u884c\u7740\u8272\u5de5\u4f5c\u3002\u5b83\u4e5f\u4f1a\u6267\u884c\u6df1\u5ea6\u6d4b\u8bd5 depth testing \u3001\u9762\u88c1\u5207 face culling \u548c\u88c1\u526a\u6d4b\u8bd5\uff0c\u5b83\u53ef\u4ee5\u5bf9\u8f93\u51fa\u7684\u7247\u5143\u8fdb\u884c\u914d\u7f6e\uff0c\u51b3\u5b9a\u662f\u5426\u8f93\u51fa\u6574\u4e2a\u56fe\u5143\u62d3\u6251\u6216\u8005\u662f\u8fb9\u6846(\u7ebf\u6846\u6e32\u67d3)\u3002\u6240\u6709\u7684\u914d\u7f6e\u901a\u8fc7 VkPipelineRasterizationStateCreateInfo \u7ed3\u6784\u4f53\u5b9a\u4e49\u3002 VkPipelineRasterizationStateCreateInfo rasterizer = {}; rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterizer.depthClampEnable = VK_FALSE; C++ \u5b83\u7684 depthClampEnable \u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u8d85\u8fc7\u8fdc\u8fd1\u88c1\u526a\u9762\u7684\u7247\u5143\u4f1a\u8fdb\u884c\u6536\u655b\uff0c\u800c\u4e0d\u662f\u4e22\u5f03\u5b83\u4eec\u3002\u5b83\u5728\u7279\u6b8a\u7684\u60c5\u51b5\u4e0b\u6bd4\u8f83\u6709\u7528\uff0c\u50cf\u9634\u5f71\u8d34\u56fe\u3002\u4f7f\u7528\u8be5\u529f\u80fd\u9700\u8981\u5f97\u5230 GPU \u7684\u652f\u6301\u3002 rasterizer.rasterizerDiscardEnable = VK_FALSE; C++ \u5982\u679c rasterizerDiscardEnable \u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u90a3\u4e48\u51e0\u4f55\u56fe\u5143\u6c38\u8fdc\u4e0d\u4f1a\u4f20\u9012\u5230\u5149\u6805\u5316\u9636\u6bb5\u3002\u8fd9\u662f\u57fa\u672c\u7684\u7981\u6b62\u4efb\u4f55\u8f93\u51fa\u5230framebuffer\u5e27\u7f13\u51b2\u533a\u7684\u65b9\u6cd5\u3002 rasterizer.polygonMode = VK_POLYGON_MODE_FILL; C++ polygonMode \u51b3\u5b9a\u51e0\u4f55\u4ea7\u751f\u56fe\u7247\u7684\u5185\u5bb9\u3002\u4e0b\u5217\u6709\u6548\u6a21\u5f0f: VK_POLYGON_MODE_FILL : \u591a\u8fb9\u5f62\u533a\u57df\u586b\u5145 VK_POLYGON_MODE_LINE : \u591a\u8fb9\u5f62\u8fb9\u7f18\u7ebf\u6846\u7ed8\u5236 VK_POLYGON_MODE_POINT : \u591a\u8fb9\u5f62\u9876\u70b9\u4f5c\u4e3a\u63cf\u70b9\u7ed8\u5236 \u4f7f\u7528\u4efb\u4f55\u6a21\u5f0f\u586b\u5145\u9700\u8981\u5f00\u542fGPU\u529f\u80fd\u3002 rasterizer.lineWidth = 1.0f; C++ lineWidth \u6210\u5458\u662f\u76f4\u63a5\u586b\u5145\u7684\uff0c\u6839\u636e\u7247\u5143\u7684\u6570\u91cf\u63cf\u8ff0\u7ebf\u7684\u5bbd\u5ea6\u3002\u6700\u5927\u7684\u7ebf\u5bbd\u652f\u6301\u53d6\u51b3\u4e8e\u786c\u4ef6\uff0c\u4efb\u4f55\u5927\u4e8e 1.0 \u7684\u7ebf\u5bbd\u9700\u8981\u5f00\u542fGPU\u7684 wideLines \u7279\u6027\u652f\u6301\u3002 rasterizer.cullMode = VK_CULL_MODE_BACK_BIT; rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; C++ cullMode \u53d8\u91cf\u7528\u4e8e\u51b3\u5b9a\u9762\u88c1\u526a\u7684\u7c7b\u578b\u65b9\u5f0f\u3002\u53ef\u4ee5\u7981\u6b62 culling \uff0c\u88c1\u526a front faces \uff0c cull back faces \u6216\u8005\u5168\u90e8\u3002 frontFace \u7528\u4e8e\u63cf\u8ff0\u4f5c\u4e3a front-facing \u9762\u7684\u9876\u70b9\u7684\u987a\u5e8f\uff0c\u53ef\u4ee5\u662f\u987a\u65f6\u9488\u4e5f\u53ef\u4ee5\u662f\u9006\u65f6\u9488\u3002 rasterizer.depthBiasEnable = VK_FALSE; rasterizer.depthBiasConstantFactor = 0.0f; // Optional rasterizer.depthBiasClamp = 0.0f; // Optional rasterizer.depthBiasSlopeFactor = 0.0f; // Optional C++ \u5149\u6805\u5316\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u5e38\u91cf\u6216\u8005\u57fa\u4e8e\u7247\u5143\u7684\u659c\u7387\u6765\u66f4\u6539\u6df1\u5ea6\u503c\u3002\u4e00\u4e9b\u65f6\u5019\u5bf9\u4e8e\u9634\u5f71\u8d34\u56fe\u662f\u6709\u7528\u7684\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u4f1a\u5728\u7ae0\u8282\u4e2d\u4f7f\u7528\uff0c\u8bbe\u7f6e depthBiasEnable \u4e3a VK_FALSE \u3002","title":"\u5149\u6805\u5316"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_34","text":"VkPipelineMultisampleStateCreateInfo \u7ed3\u6784\u4f53\u7528\u4e8e\u914d\u7f6e\u591a\u91cd\u91c7\u6837\u3002\u6240\u8c13\u591a\u91cd\u91c7\u6837\u662f\u6297\u952f\u9f7f anti-aliasing \u7684\u4e00\u79cd\u5b9e\u73b0\u3002\u5b83\u901a\u8fc7\u7ec4\u5408\u591a\u4e2a\u591a\u8fb9\u5f62\u7684\u7247\u6bb5\u7740\u8272\u5668\u7ed3\u679c\uff0c\u5149\u6805\u5316\u5230\u540c\u4e00\u4e2a\u50cf\u7d20\u3002\u8fd9\u4e3b\u8981\u53d1\u751f\u5728\u8fb9\u7f18\uff0c\u8fd9\u4e5f\u662f\u6700\u5f15\u4eba\u6ce8\u76ee\u7684\u952f\u9f7f\u51fa\u73b0\u7684\u5730\u65b9\u3002\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u591a\u8fb9\u5f62\u6620\u5c04\u5230\u50cf\u7d20\u662f\u4e0d\u9700\u8981\u591a\u6b21\u8fd0\u884c\u7247\u6bb5\u7740\u8272\u5668\u8fdb\u884c\u91c7\u6837\u7684\uff0c\u76f8\u6bd4\u9ad8\u5206\u8fa8\u7387\u6765\u8bf4\uff0c\u5b83\u4f1a\u82b1\u8d39\u8f83\u4f4e\u7684\u5f00\u9500\u3002\u5f00\u542f\u8be5\u529f\u80fd\u9700\u8981GPU\u652f\u6301\u3002 VkPipelineMultisampleStateCreateInfo multisampling = {}; multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampling.sampleShadingEnable = VK_FALSE; multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; multisampling.minSampleShading = 1.0f; // Optional multisampling.pSampleMask = nullptr; // Optional multisampling.alphaToCoverageEnable = VK_FALSE; // Optional multisampling.alphaToOneEnable = VK_FALSE; // Optional C++ \u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u591a\u91cd\u91c7\u6837\uff0c\u4f46\u662f\u53ef\u4ee5\u968f\u610f\u7684\u5c1d\u8bd5\uff0c\u5177\u4f53\u7684\u53c2\u6570\u8bf7\u53c2\u9605\u89c4\u8303\u3002","title":"\u91cd\u91c7\u6837"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_35","text":"\u5982\u679c\u4f7f\u7528depth \u6216\u8005 stencil\u7f13\u51b2\u533a\uff0c\u9700\u8981\u4f7f\u7528 VkPipelineDepthStencilStateCreateInfo \u914d\u7f6e\u3002\u6211\u4eec\u73b0\u5728\u4e0d\u9700\u8981\u4f7f\u7528\uff0c\u6240\u4ee5\u7b80\u5355\u7684\u4f20\u9012 nullptr \uff0c\u5173\u4e8e\u8fd9\u90e8\u5206\u4f1a\u4e13\u95e8\u5728\u6df1\u5ea6\u7f13\u51b2\u533a\u7ae0\u8282\u4e2d\u8ba8\u8bba\u3002","title":"\u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_36","text":"\u7247\u6bb5\u7740\u8272\u5668\u8f93\u51fa\u5177\u4f53\u7684\u989c\u8272\uff0c\u5b83\u9700\u8981\u4e0e\u5e27\u7f13\u51b2\u533a framebuffer \u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\u3002\u8fd9\u4e2a\u8f6c\u6362\u7684\u8fc7\u7a0b\u6210\u4e3a\u6df7\u8272\uff0c\u5b83\u6709\u4e24\u79cd\u65b9\u5f0f: \u5c06old\u548cnew\u989c\u8272\u8fdb\u884c\u6df7\u5408\u4ea7\u51fa\u4e00\u4e2a\u6700\u7ec8\u7684\u989c\u8272 \u4f7f\u7528\u6309\u4f4d\u64cd\u4f5c\u6df7\u5408old\u548cnew\u989c\u8272\u7684\u503c \u6709\u4e24\u4e2a\u7ed3\u6784\u4f53\u7528\u4e8e\u914d\u7f6e\u989c\u8272\u6df7\u5408\u3002\u7b2c\u4e00\u4e2a\u7ed3\u6784\u4f53 VkPipelineColorBlendAttachmentState \u5305\u62ec\u4e86\u6bcf\u4e2a\u9644\u52a0\u5230\u5e27\u7f13\u51b2\u533a\u7684\u914d\u7f6e\u3002\u7b2c\u4e8c\u4e2a\u7ed3\u6784\u4f53 VkPipelineColorBlendStateCreateInfo \u5305\u542b\u4e86\u5168\u5c40\u6df7\u8272\u7684\u8bbe\u7f6e\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u4ec5\u4f7f\u7528\u7b2c\u4e00\u79cd\u65b9\u5f0f: VkPipelineColorBlendAttachmentState colorBlendAttachment = {}; colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; colorBlendAttachment.blendEnable = VK_FALSE; colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; // Optional colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; // Optional colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; // Optional colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; // Optional C++ \u8fd9\u79cd\u9488\u5bf9\u6bcf\u4e2a\u5e27\u7f13\u51b2\u533a\u914d\u7f6e\u6df7\u8272\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528\u5982\u4e0b\u4f2a\u4ee3\u7801\u8fdb\u884c\u8bf4\u660e: if (blendEnable) { finalColor.rgb = (srcColorBlendFactor * newColor.rgb) <colorBlendOp> (dstColorBlendFactor * oldColor.rgb); finalColor.a = (srcAlphaBlendFactor * newColor.a) <alphaBlendOp> (dstAlphaBlendFactor * oldColor.a); } else { finalColor = newColor; } finalColor = finalColor & colorWriteMask; C++ \u5982\u679c blendEnable \u8bbe\u7f6e\u4e3a VK_FALSE ,\u90a3\u4e48\u4ece\u7247\u6bb5\u7740\u8272\u5668\u8f93\u51fa\u7684\u65b0\u989c\u8272\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u5426\u5219\u4e24\u4e2a\u6df7\u8272\u64cd\u4f5c\u4f1a\u8ba1\u7b97\u65b0\u7684\u989c\u8272\u3002\u6240\u5f97\u5230\u7684\u7ed3\u679c\u4e0e colorWriteMask \u8fdb\u884cAND\u8fd0\u7b97\uff0c\u4ee5\u786e\u5b9a\u5b9e\u9645\u4f20\u9012\u7684\u901a\u9053\u3002 \u5927\u591a\u6570\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u6df7\u8272\u7528\u4e8e\u5b9e\u73b0 alpha blending \uff0c\u65b0\u7684\u989c\u8272\u4e0e\u65e7\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\u4f1a\u57fa\u4e8e\u5b83\u4eec\u7684 opacity \u900f\u660e\u901a\u9053\u3002 finalColor \u4f5c\u4e3a\u6700\u7ec8\u7684\u8f93\u51fa: finalColor.rgb = newAlpha * newColor + (1 - newAlpha) * oldColor; finalColor.a = newAlpha.a; C++ \u53ef\u4ee5\u901a\u8fc7\u4e00\u4e0b\u53c2\u6570\u5b8c\u6210: colorBlendAttachment.blendEnable = VK_TRUE; colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA; colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; C++ \u53ef\u4ee5\u5728\u89c4\u8303\u4e2d\u627e\u5230\u6240\u6709\u6709\u5173 VkBlendFactor \u548c VkBlendOp \u7684\u679a\u4e3e\u503c\u3002 \u7b2c\u4e8c\u4e2a\u7ed3\u6784\u4f53\u6301\u6709\u6240\u6709\u5e27\u7f13\u51b2\u533a\u7684\u5f15\u7528\uff0c\u5b83\u5141\u8bb8\u8bbe\u7f6e\u6df7\u5408\u64cd\u4f5c\u7684\u5e38\u91cf\uff0c\u8be5\u5e38\u91cf\u53ef\u4ee5\u4f5c\u4e3a\u540e\u7eed\u8ba1\u7b97\u7684\u6df7\u5408\u56e0\u5b50: VkPipelineColorBlendStateCreateInfo colorBlending = {}; colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; colorBlending.logicOpEnable = VK_FALSE; colorBlending.logicOp = VK_LOGIC_OP_COPY; // Optional colorBlending.attachmentCount = 1; colorBlending.pAttachments = &colorBlendAttachment; colorBlending.blendConstants[0] = 0.0f; // Optional colorBlending.blendConstants[1] = 0.0f; // Optional colorBlending.blendConstants[2] = 0.0f; // Optional colorBlending.blendConstants[3] = 0.0f; // Optional C++ \u5982\u679c\u9700\u8981\u4f7f\u7528\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u8bbe\u7f6e\u6df7\u5408\u64cd\u4f5c( bitwise combination ), \u9700\u8981\u8bbe\u7f6e logicOpEnable \u4e3a VK_TURE \u3002\u4e8c\u8fdb\u5236\u4f4d\u64cd\u4f5c\u5728 logicOp \u5b57\u6bb5\u4e2d\u6307\u5b9a\u3002\u5728\u7b2c\u4e00\u79cd\u65b9\u5f0f\u4e2d\u4f1a\u81ea\u52a8\u7981\u6b62\uff0c\u7b49\u540c\u4e8e\u4e3a\u6bcf\u4e00\u4e2a\u9644\u52a0\u7684\u5e27\u7f13\u51b2\u533aframebuffer\u5173\u95ed\u6df7\u5408\u64cd\u4f5c\uff0c blendEnable \u4e3a VK_FALSE \u3002 colorWriteMask \u63a9\u7801\u4f1a\u7528\u786e\u5b9a\u5e27\u7f13\u51b2\u533a\u4e2d\u5177\u4f53\u54ea\u4e2a\u901a\u9053\u7684\u989c\u8272\u53d7\u5230\u5f71\u54cd\u3002\u5b83\u4e5f\u53ef\u4ee5\u5728\u4e24\u79cd\u65b9\u5f0f\u4e0b\u7981\u6b62\uff0c\u622a\u81f3\u76ee\u524d\uff0c\u7247\u6bb5\u7f13\u51b2\u533a\u5411\u5e27\u7f13\u51b2\u533a\u4e2d\u8f93\u51fa\u7684\u989c\u8272\u4e0d\u4f1a\u8fdb\u884c\u4efb\u4f55\u53d8\u5316\u3002","title":"\u989c\u8272\u6df7\u5408"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_37","text":"\u4e4b\u524d\u521b\u5efa\u7684\u4e00\u4e9b\u7ed3\u6784\u4f53\u7684\u72b6\u6001\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u52a8\u6001\u4fee\u6539\uff0c\u800c\u4e0d\u5fc5\u91cd\u65b0\u521b\u5efa\u3002\u6bd4\u5982 viewport \u7684\u5927\u5c0f, line width \u548c blend constants \u3002\u5982\u679c\u9700\u8981\u8fdb\u884c\u8fd9\u6837\u7684\u64cd\u4f5c\uff0c\u9700\u8981\u586b\u5145 VkPipelineDynamicStateCreateInfo \u7ed3\u6784\u4f53: VkDynamicState dynamicStates[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_LINE_WIDTH }; VkPipelineDynamicStateCreateInfo dynamicState = {}; dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO; dynamicState.dynamicStateCount = 2; dynamicState.pDynamicStates = dynamicStates; C++ \u5728\u7ed8\u5236\u7684\u8fc7\u7a0b\u4e2d\u6307\u5b9a\u8fd9\u4e9b\u6570\u636e\uff0c\u8fd9\u4f1a\u5bfc\u81f4\u5ffd\u7565\u4e4b\u524d\u7684\u76f8\u5173\u6570\u503c\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7684\u7ae0\u8282\u4e2d\u56de\u8fc7\u5934\u6765\u8ba8\u8bba\u3002\u5982\u679c\u6ca1\u6709\u4efb\u4f55\u9700\u8981\u52a8\u6001\u4fee\u6539\u7684\u6570\u503c\u6e05\u8bbe\u7f6e\u4e3a nullptr \u3002","title":"\u52a8\u6001\u4fee\u6539"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_38","text":"\u53ef\u4ee5\u5728\u7740\u8272\u5668\u4e2d\u4f7f\u7528 uniform \uff0c\u5b83\u662f\u7c7b\u4f3c\u4e0e\u52a8\u6001\u72b6\u6001\u53d8\u91cf\u7684\u5168\u5c40\u53d8\u91cf\uff0c\u53ef\u4ee5\u5728\u7ed8\u753b\u65f6\u4fee\u6539\uff0c\u53ef\u4ee5\u66f4\u6539\u7740\u8272\u5668\u7684\u884c\u4e3a\u800c\u65e0\u9700\u91cd\u65b0\u521b\u5efa\u5b83\u4eec\u3002\u5b83\u4eec\u901a\u5e38\u7528\u4e8e\u5c06\u53d8\u6362\u77e9\u9635\u4f20\u9012\u5230\u9876\u70b9\u7740\u8272\u5668\u6216\u8005\u5728\u7247\u6bb5\u7740\u8272\u5668\u51b2\u521b\u5efa\u7eb9\u7406\u91c7\u6837\u5668\u3002 \u8fd9\u4e9b uniform \u6570\u503c\u9700\u8981\u5728\u7ba1\u7ebf\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u901a\u8fc7 VkPipelineLayout \u5bf9\u8c61\u6307\u5b9a\u3002\u5373\u4f7f\u5728\u540e\u7eed\u5185\u5bb9\u4e2d\u7528\u5230\uff0c\u6211\u4eec\u4e5f\u4ecd\u7136\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u7a7a\u7684 pipeline layout \u3002 \u521b\u5efa\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709\u8be5\u5bf9\u8c61\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u540e\u7eed\u7ae0\u8282\u4e2d\u7684\u51fd\u6570\u4e2d\u5f15\u7528\u5b83: VkPipelineLayout pipelineLayout; C++ \u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u521b\u5efa\u5bf9\u8c61: VkPipelineLayoutCreateInfo pipelineLayoutInfo = {}; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; // Optional pipelineLayoutInfo.pSetLayouts = nullptr; // Optional pipelineLayoutInfo.pushConstantRangeCount = 0; // Optional pipelineLayoutInfo.pPushConstantRanges = 0; // Optional if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) { throw std::runtime_error(\"failed to create pipeline layout!\"); } C++ \u8be5\u7ed3\u6784\u4f53\u8fd8\u6307\u5b9a\u4e86 push \u5e38\u91cf\uff0c\u8fd9\u662f\u5c06\u52a8\u6001\u503c\u4f20\u9012\u7ed9\u7740\u8272\u5668\u7684\u62ce\u4e00\u4e2a\u65b9\u5f0f\u3002 pipeline layout \u53ef\u4ee5\u5728\u6574\u4e2a\u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\u5185\u5f15\u7528\uff0c\u6240\u4ee5\u5b83\u5728\u7a0b\u5e8f\u9000\u51fa\u7684\u65f6\u5019\u8fdb\u884c\u9500\u6bc1\u3002 void cleanup() { vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ... } C++","title":"\u7ba1\u9053\u5e03\u5c40"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_39","text":"\u8fd9\u5c31\u662f\u6240\u6709\u6709\u5173 fixed-function \u7684\u5185\u5bb9\uff0c\u770b\u8d77\u6765\u6709\u5f88\u591a\u7684\u5de5\u4f5c\u53bb\u505a\uff0c\u503c\u5f97\u5e86\u5e78\u7684\u662f\u6211\u4eec\u51e0\u4e4e\u4e86\u89e3\u4e86\u6240\u6709\u6709\u5173\u6e32\u67d3\u7ba1\u7ebf\u7684\u5185\u5bb9\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u51cf\u5c11\u4e86\u56e0\u4e3a\u4e0d\u4e86\u89e3\u67d0\u4e9b\u7ec4\u4ef6\u7684\u9ed8\u8ba4\u72b6\u6001\uff0c\u800c\u9020\u6210\u8fd0\u884c\u65f6\u78b0\u5230\u672a\u77e5\u884c\u4e3a\u7684\u53ef\u80fd\u6027\u3002 \u7136\u800c\uff0c\u5728\u6211\u4eec\u53ef\u4ee5\u6700\u7ec8\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u4e4b\u524d\uff0c\u8fd8\u6709\u4e00\u4e2a\u5bf9\u8c61\u9700\u8981\u521b\u5efa\uff0c\u5b83\u5c31\u662f render pass \u3002","title":"\u7ed3\u8bba"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_9","text":"Vulkan \u5e27\u7f13\u51b2\u533a \uff0c\u6211\u4eec\u5728\u524d\u9762\u7684\u7ae0\u8282\u4e2d\u5df2\u7ecf\u8ba8\u8bba\u4e86\u5f88\u591a\u6b21 framebuffers \u5e27\u7f13\u51b2\u533a\uff0c\u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u914d\u7f6e\u4e86 render pass \u6e32\u67d3\u901a\u9053\u5e76\u5e0c\u671b\u8f93\u51fa\u4e00\u4e2a\u4e0e\u4ea4\u6362\u94fe\u56fe\u50cf\u683c\u5f0f\u4e00\u81f4\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u4f46\u662f\u6211\u4eec\u5b9e\u9645\u4e0a\u8fd8\u6ca1\u6709\u521b\u5efa\u3002 \u5728 render pass \u521b\u5efa\u9636\u6bb5\u6211\u4eec\u6307\u5b9a\u4e86\u5177\u4f53\u7684\u9644\u4ef6\uff0c\u5e76\u901a\u8fc7 VkFramebuffer \u5bf9\u8c61\u5305\u88c5\u7ed1\u5b9a\u3002\u5e27\u7f13\u51b2\u533a\u5bf9\u8c61\u5f15\u7528\u8868\u793a\u4e3a\u9644\u4ef6\u7684\u6240\u6709\u7684 VkImageView \u5bf9\u8c61\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u53ea\u4f1a\u4f7f\u7528\u4e00\u4e2a\u5e27\u7f13\u51b2\u533a: color attachment \u3002\u7136\u800c\u6211\u4eec\u4f5c\u4e3a\u9644\u4ef6\u7684\u56fe\u50cf\u4f9d\u8d56\u4ea4\u6362\u94fe\u7528\u4e8e\u5448\u73b0\u65f6\u8fd4\u56de\u7684\u56fe\u50cf\u3002\u8fd9\u610f\u5473\u7740\u6211\u4eec\u5fc5\u987b\u4e3a\u4ea4\u6362\u94fe\u4e2d\u7684\u6240\u6709\u56fe\u50cf\u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u5728\u7ed8\u5236\u7684\u65f6\u5019\u4f7f\u7528\u5bf9\u5e94\u7684\u56fe\u50cf\u3002 \u6700\u540e\uff0c\u5728\u7c7b\u6210\u5458\u4e2d\u521b\u5efa\u53e6\u4e00\u4e2a std::vector \u7528\u4e8e\u4fdd\u5b58 framebuffers : std::vector<VkFramebuffer> swapChainFramebuffers; C++ \u6211\u4eec\u5728\u65b0\u7684\u51fd\u6570 createFramebuffers \u4e2d\u4e3a\u6570\u7ec4\u521b\u5efa\u5bf9\u8c61\u96c6\u5408\uff0c\u8fd9\u4e2a\u51fd\u6570\u5728 initVulkan \u521b\u5efa\u5b8c\u7ba1\u7ebf\u540e\u8c03\u7528: void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); } ... void createFramebuffers() { } C++ \u52a8\u6001\u8c03\u6574\u7528\u4e8e\u4fdd\u5b58 framebuffers \u7684\u5bb9\u5668\u5927\u5c0f: void createFramebuffers() { swapChainFramebuffers.resize(swapChainImageViews.size()); } C++ \u6211\u4eec\u63a5\u4e0b\u6765\u8fed\u4ee3\u5de6\u53f3\u7684\u56fe\u50cf\u89c6\u56fe\u5e76\u901a\u8fc7\u5b83\u4eec\u521b\u5efa\u5bf9\u5e94\u7684 framebuffers : for (size_t i = 0; i < swapChainImageViews.size(); i++) { VkImageView attachments[] = { swapChainImageViews[i] }; VkFramebufferCreateInfo framebufferInfo = {}; framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; framebufferInfo.renderPass = renderPass; framebufferInfo.attachmentCount = 1; framebufferInfo.pAttachments = attachments; framebufferInfo.width = swapChainExtent.width; framebufferInfo.height = swapChainExtent.height; framebufferInfo.layers = 1; if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &swapChainFramebuffers[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to create framebuffer!\"); } } C++ \u5982\u4f60\u6240\u89c1\uff0c\u521b\u5efa framebuffers \u662f\u975e\u5e38\u76f4\u63a5\u7684\u3002\u9996\u5148\u9700\u8981\u6307\u5b9a framebuffer \u9700\u8981\u517c\u5bb9\u7684 renderPass \u3002\u6211\u4eec\u53ea\u80fd\u4f7f\u7528\u4e0e\u5176\u517c\u5bb9\u7684\u6e32\u67d3\u901a\u9053\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u8fd9\u5927\u4f53\u4e0a\u610f\u5473\u7740\u5b83\u4eec\u4f7f\u7528\u76f8\u540c\u7684\u9644\u4ef6\u6570\u91cf\u548c\u7c7b\u578b\u3002 attachmentCount \u548c pAttachments \u53c2\u6570\u6307\u5b9a\u5728\u6e32\u67d3\u901a\u9053\u7684 pAttachment \u6570\u7ec4\u4e2d\u7ed1\u5b9a\u5230\u76f8\u5e94\u7684\u9644\u4ef6\u63cf\u8ff0\u7684 VkImageView \u5bf9\u8c61\u3002 width \u548c height \u53c2\u6570\u662f\u5bb9\u6613\u7406\u89e3\u7684\uff0c layer \u662f\u6307\u5b9a\u56fe\u50cf\u6570\u7ec4\u4e2d\u7684\u5c42\u6570\u3002\u6211\u4eec\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u662f\u5355\u4e2a\u56fe\u50cf\uff0c\u56e0\u6b64\u5c42\u6570\u4e3a 1 \u3002 \u6211\u4eec\u5728\u56fe\u50cf\u89c6\u56fe\u548c\u6e32\u67d3\u901a\u9053\u6e32\u67d3\u5b8c\u6bd5\u4e4b\u540e\uff0c\u5220\u9664\u5bf9\u5e94\u7684\u5e27\u7f13\u51b2\u533a: void cleanup() { for (size_t i = 0; i < swapChainFramebuffers.size(); i++) { vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); } ... } C++ \u6211\u4eec\u5df2\u7ecf\u8fbe\u5230\u4e86\u4e00\u4e2a\u91cc\u7a0b\u7891\uff0c\u6211\u4eec\u62e5\u6709\u6e32\u67d3\u9700\u8981\u7684\u6240\u6709\u5bf9\u8c61\u3002\u5728\u4e0b\u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u7f16\u5199\u7b2c\u4e00\u4e2a\u5b9e\u9645\u7ed8\u5236\u7684\u547d\u4ee4\u3002","title":"Vulkan \u5e27\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_10","text":"Vulkan \u6e32\u67d3\u901a\u9053 \uff0c\u5728\u6211\u4eec\u5b8c\u6210\u7ba1\u7ebf\u7684\u521b\u5efa\u5de5\u4f5c\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9 Vulkan \u6e32\u67d3\u65f6\u5019\u4f7f\u7528\u7684 framebuffer \u5e27\u7f13\u51b2\u533a\u9644\u4ef6\u76f8\u5173\u4fe1\u606f\u3002\u6211\u4eec\u9700\u8981\u6307\u5b9a\u591a\u5c11\u4e2a\u989c\u8272\u548c\u6df1\u5ea6\u7f13\u51b2\u533a\u5c06\u4f1a\u88ab\u4f7f\u7528\uff0c\u6307\u5b9a\u591a\u5c11\u4e2a\u91c7\u6837\u5668\u88ab\u7528\u5230\u53ca\u5728\u6574\u4e2a\u6e32\u67d3\u64cd\u4f5c\u4e2d\u76f8\u5173\u7684\u5185\u5bb9\u5982\u4f55\u5904\u7406\u3002\u6240\u6709\u7684\u8fd9\u4e9b\u4fe1\u606f\u90fd\u88ab\u5c01\u88c5\u5728\u4e00\u4e2a\u53eb\u505a render pass \u7684\u5bf9\u8c61\u4e2d\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u8bbe\u7f6e 2 \u9644\u4ef6\u63cf\u8ff0 3 \u5b50\u901a\u9053\u548c\u9644\u4ef6\u5f15\u7528 4 \u6e32\u67d3\u901a\u9053","title":"Vulkan \u6e32\u67d3\u901a\u9053"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_40","text":"\u6211\u4eec\u65b0\u6dfb\u52a0\u4e00\u4e2a createRenderPass \u51fd\u6570\uff0c\u5728 initVulkan \u51fd\u6570\u4e2d\u786e\u4fdd createGraphicsPipeline \u8c03\u7528\u4e4b\u524d\uff0c\u8c03\u7528\u5b83\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); } ... void createRenderPass() { } C++","title":"\u8bbe\u7f6e"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_41","text":"\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u5c06\u53ea\u6709\u4e00\u4e2a\u989c\u8272\u7f13\u51b2\u533a\u9644\u4ef6\uff0c\u5b83\u7531\u4ea4\u6362\u94fe\u4e2d\u7684\u4e00\u4e2a\u56fe\u50cf\u6240\u8868\u793a\u3002 void createRenderPass() { VkAttachmentDescription colorAttachment = {}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; } C++ format \u662f\u989c\u8272\u9644\u4ef6\u7684\u683c\u5f0f\uff0c\u5b83\u5e94\u8be5\u4e0e\u4ea4\u6362\u94fe\u4e2d\u56fe\u50cf\u7684\u683c\u5f0f\u76f8\u5339\u914d\uff0c\u540c\u65f6\u6211\u4eec\u4e0d\u4f1a\u505a\u4efb\u4f55\u591a\u91cd\u91c7\u6837\u7684\u5de5\u4f5c\uff0c\u6240\u4ee5\u91c7\u6837\u5668\u8bbe\u7f6e\u4e3a1\u3002 colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; C++ loadOp \u548c storeOp \u51b3\u5b9a\u4e86\u6e32\u67d3\u524d\u548c\u6e32\u67d3\u540e\u6570\u636e\u5728\u5bf9\u5e94\u9644\u4ef6\u7684\u64cd\u4f5c\u884c\u4e3a\u3002\u5bf9\u4e8e loadOp \u6211\u4eec\u6709\u5982\u4e0b\u9009\u9879\uff1a VK_ATTACHMENT_LOAD_OP_LOAD : \u4fdd\u5b58\u5df2\u7ecf\u5b58\u5728\u4e8e\u5f53\u524d\u9644\u4ef6\u7684\u5185\u5bb9 VK_ATTACHMENT_LOAD_OP_CLEAR : \u8d77\u59cb\u9636\u6bb5\u4ee5\u4e00\u4e2a\u5e38\u91cf\u6e05\u7406\u9644\u4ef6\u5185\u5bb9 VK_ATTACHMENT_LOAD_OP_DONT_CARE : \u5b58\u5728\u7684\u5185\u5bb9\u672a\u5b9a\u4e49\uff0c\u5ffd\u7565\u5b83\u4eec \u5728\u7ed8\u5236\u65b0\u7684\u4e00\u5e27\u5185\u5bb9\u4e4b\u524d\uff0c\u6211\u4eec\u8981\u505a\u7684\u662f\u4f7f\u7528\u6e05\u7406\u64cd\u4f5c\u6765\u6e05\u7406\u5e27\u7f13\u51b2\u533aframebuffer\u4e3a\u9ed1\u8272\u3002\u540c\u65f6\u5bf9\u4e8e storeOp \u4ec5\u6709\u4e24\u4e2a\u9009\u9879\uff1a VK_ATTACHMENT_STORE_OP_STORE : \u6e32\u67d3\u7684\u5185\u5bb9\u4f1a\u5b58\u50a8\u5728\u5185\u5b58\uff0c\u5e76\u5728\u4e4b\u540e\u8fdb\u884c\u8bfb\u53d6\u64cd\u4f5c VK_ATTACHMENT_STORE_OP_DONT_CARE : \u5e27\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u5728\u6e32\u67d3\u64cd\u4f5c\u5b8c\u6bd5\u540e\u8bbe\u7f6e\u4e3aundefined \u6211\u4eec\u8981\u505a\u7684\u662f\u6e32\u67d3\u4e00\u4e2a\u4e09\u89d2\u5f62\u5728\u5c4f\u5e55\u4e0a\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u5b58\u50a8\u64cd\u4f5c\u3002 colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; C++ loadOp \u548c storeOp \u5e94\u7528\u5728\u989c\u8272\u548c\u6df1\u5ea6\u6570\u636e\uff0c\u540c\u65f6 stencilLoadOp / stencilStoreOp \u5e94\u7528\u5728\u6a21\u7248\u6570\u636e\u3002\u6211\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u4e0d\u4f1a\u505a\u4efb\u4f55\u6a21\u7248\u7f13\u51b2\u533a\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u5b83\u7684loading\u548cstoring\u65e0\u5173\u7d27\u8981\u3002 colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; C++ \u7eb9\u7406\u548c\u5e27\u7f13\u51b2\u533a\u5728Vulkan\u4e2d\u901a\u5e38\u7528 VkImage \u5bf9\u8c61\u914d\u4ee5\u67d0\u79cd\u50cf\u7d20\u683c\u5f0f\u6765\u4ee3\u8868\u3002\u4f46\u662f\u50cf\u7d20\u5728\u5185\u5b58\u4e2d\u7684\u5e03\u5c40\u53ef\u4ee5\u57fa\u4e8e\u9884\u8981\u5bf9image\u56fe\u50cf\u8fdb\u884c\u7684\u64cd\u4f5c\u53d1\u751f\u5185\u5b58\u5e03\u5c40\u7684\u53d8\u5316\u3002 \u4e00\u4e9b\u5e38\u7528\u7684\u5e03\u5c40: VK_IMAGE_LAYOUT_COLOR_ATTACHMET_OPTIMAL : \u56fe\u50cf\u4f5c\u4e3a\u989c\u8272\u9644\u4ef6 VK_IMAGE_LAYOUT_PRESENT_SRC_KHR : \u56fe\u50cf\u5728\u4ea4\u6362\u94fe\u4e2d\u88ab\u5448\u73b0 VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL : \u56fe\u50cf\u4f5c\u4e3a\u76ee\u6807\uff0c\u7528\u4e8e\u5185\u5b58COPY\u64cd\u4f5c \u6211\u4eec\u4f1a\u6df1\u5165\u8ba8\u8bba\u8fd9\u4e9b\u5185\u5bb9\u5728\u7eb9\u7406\u7ae0\u8282\uff0c\u73b0\u5728\u6700\u91cd\u8981\u7684\u662f\u4e3a\u9700\u8981\u8f6c\u53d8\u7684\u56fe\u50cf\u6307\u5b9a\u5408\u9002\u7684layout\u5e03\u5c40\u8fdb\u884c\u64cd\u4f5c\u3002 initialLayout \u6307\u5b9a\u56fe\u50cf\u5728\u5f00\u59cb\u8fdb\u5165\u6e32\u67d3\u901a\u9053render pass\u524d\u5c06\u8981\u4f7f\u7528\u7684\u5e03\u5c40\u7ed3\u6784\u3002 finalLayout \u6307\u5b9a\u5f53\u6e32\u67d3\u901a\u9053\u7ed3\u675f\u81ea\u52a8\u53d8\u6362\u65f6\u4f7f\u7528\u7684\u5e03\u5c40\u3002\u4f7f\u7528 VK_IMAGE_LAYOUT_UNDEFINED \u8bbe\u7f6e initialLayout \uff0c\u610f\u4e3a\u4e0d\u5173\u5fc3\u56fe\u50cf\u4e4b\u524d\u7684\u5e03\u5c40\u3002\u7279\u6b8a\u503c\u8868\u660e\u56fe\u50cf\u7684\u5185\u5bb9\u4e0d\u786e\u5b9a\u4f1a\u88ab\u4fdd\u7559\uff0c\u4f46\u662f\u8fd9\u5e76\u4e0d\u603b\u8981\uff0c\u56e0\u4e3a\u65e0\u8bba\u5982\u4f55\u6211\u4eec\u90fd\u8981\u6e05\u7406\u5b83\u3002\u6211\u4eec\u5e0c\u671b\u56fe\u50cf\u6e32\u67d3\u5b8c\u6bd5\u540e\u4f7f\u7528\u4ea4\u6362\u94fe\u8fdb\u884c\u5448\u73b0\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48 finalLayout \u8981\u8bbe\u7f6e\u4e3a VK_IMAGE_LAYOUT_PRESENT_SRC_KHR \u3002 \u5982\u679c\u6ca1\u6709\u641e\u6e05\u695a\u5e03\u5c40\u5b58\u5728\u7684\u610f\u4e49\uff0c\u8fdb\u4e00\u6b65\u89e3\u91calayout\u8bf7\u770b\u5982\u4e0b\u56fe\u793a: \u4e00\u822c\u610f\u4e49\u4e0a\uff0c\u6211\u4eec\u7406\u89e3 CPU \u8fdb\u884c\u5185\u5b58\u4e2d\u7684\u6570\u636e\u8bfb\u5199\u5f80\u5f80\u90fd\u662f\u7ebf\u6027\u6392\u5e8f\u7684 linear memory layout \uff0c\u53ef\u4ee5\u770b\u5230 AB \u4e0e CD \u4f5c\u4e3a\u6765\u4e2a\u8fde\u7eed\u7684\u884c\u6765\u8fdb\u884c\u8bfb\u53d6\u3002\u4f46\u662f\u5728\u5f88\u591a\u65f6\u5019\u5bf9\u4e8e\u50cf\u7d20\u7eb9\u7406\u6570\u636e\u7684\u64cd\u4f5c\u662f\u975e\u7ebf\u6027\u8fde\u7eed\u7684\uff0c\u8fd9\u79cd\u60c5\u666f\u66f4\u591a\u53d1\u751f\u5728 GPU \u64cd\u4f5c\u4e2d\uff0c\u6240\u4ee5 GPU \u786c\u4ef6\u66f4\u591a\u7684\u652f\u6301\u57fa\u4e8e( Tiled )\u5e73\u94fa\u7684\u6216\u8005\u6210\u4e3a\u6700\u4f73\u7684\u5185\u5b58\u5e03\u5c40\u7ed3\u6784\uff0c\u6765\u63d0\u964d\u4f4e GPU \u5904\u7406\u6570\u636e\u7684\u5f00\u9500\u3002 \u6240\u4ee5\u4ece CPU linear layout \u5185\u5b58\u6570\u636e \u5230 GPU optimal layout \u663e\u5b58\u6570\u636e\u7684\u8bfb\u5199 \u5f80\u8fd4\u4e4b\u95f4\u5b58\u5728\u6570\u636e\u5b58\u50a8\u683c\u5f0f\u7684\u4f18\u5316\u8f6c\u53d8\u6b65\u9aa4\u3002","title":"\u9644\u4ef6\u63cf\u8ff0"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_42","text":"\u4e00\u4e2a\u5355\u72ec\u7684\u6e32\u67d3\u901a\u9053\u53ef\u4ee5\u7531\u591a\u4e2a\u5b50\u901a\u9053\u7ec4\u6210\u3002\u5b50\u901a\u9053\u662f\u6e32\u67d3\u64cd\u4f5c\u7684\u4e00\u4e2a\u5e8f\u5217\u3002\u5b50\u901a\u9053\u4f5c\u7528\u4e0e\u540e\u7eed\u7684\u6e32\u67d3\u64cd\u4f5c\uff0c\u5e76\u4f9d\u8d56\u4e4b\u524d\u6e32\u67d3\u901a\u9053\u8f93\u51fa\u5230\u5e27\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u3002\u6bd4\u5982\u8bf4\u540e\u5904\u7406\u6548\u679c\u7684\u5e8f\u5217\u901a\u5e38\u6bcf\u4e00\u6b65\u90fd\u4f9d\u8d56\u4e4b\u524d\u7684\u64cd\u4f5c\u3002\u5982\u679c\u5c06\u8fd9\u4e9b\u6e32\u67d3\u64cd\u4f5c\u5206\u7ec4\u5230\u4e00\u4e2a\u6e32\u67d3\u901a\u9053\u4e2d\uff0c\u901a\u8fc7 Vulkan \u5c06\u901a\u9053\u4e2d\u7684\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u91cd\u6392\u5e8f\uff0c\u53ef\u4ee5\u8282\u7701\u5185\u5b58\u4ece\u800c\u83b7\u5f97\u66f4\u597d\u7684\u6027\u80fd\u3002\u5bf9\u4e8e\u6211\u4eec\u8981\u7ed8\u5236\u7684\u4e09\u89d2\u5f62\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4e00\u4e2a\u5b50\u901a\u9053\u3002 \u6bcf\u4e2a\u5b50\u901a\u9053\u5f15\u7528\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\u4e4b\u524d\u4f7f\u7528\u7ed3\u6784\u4f53\u63cf\u8ff0\u7684\u9644\u4ef6\u3002\u8fd9\u4e9b\u5f15\u7528\u672c\u8eab\u5c31\u662f VkAttachmentReference \u7ed3\u6784\u4f53: VkAttachmentReference colorAttachmentRef = {}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; C++ attachment \u9644\u4ef6\u53c2\u6570\u901a\u8fc7\u9644\u4ef6\u63cf\u8ff0\u7b26\u96c6\u5408\u4e2d\u7684\u7d22\u5f15\u6765\u6301\u6709\u3002\u6211\u4eec\u7684\u96c6\u5408\u662f\u7531\u4e00\u4e2a VkAttachmentDesription \u7ec4\u6210\u7684\uff0c\u6240\u4ee5\u5b83\u7684\u7d22\u5f15\u4e3a 0 \u3002 layout \u4e3a\u9644\u4ef6\u6307\u5b9a\u5b50\u901a\u9053\u5728\u6301\u6709\u5f15\u7528\u65f6\u5019\u7684layout\u3002\u5f53\u5b50\u901a\u9053\u5f00\u59cb\u7684\u65f6\u5019Vulkan\u4f1a\u81ea\u52a8\u8f6c\u53d8\u9644\u4ef6\u5230\u8fd9\u4e2alayout\u3002\u56e0\u4e3a\u6211\u4eec\u671f\u671b\u9644\u4ef6\u8d77\u5230\u989c\u8272\u7f13\u51b2\u533a\u7684\u4f5c\u7528\uff0clayout\u8bbe\u7f6e\u4e3a VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL \u4f1a\u7ed9\u6211\u4eec\u6700\u597d\u7684\u6027\u80fd\u3002 \u5b50\u901a\u9053\u4f7f\u7528 VkSubpassDescription \u7ed3\u6784\u4f53\u63cf\u8ff0: VkSubpassDescription subpass = {}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; C++ Vulkan\u5728\u672a\u6765\u53ef\u80fd\u4f1a\u652f\u6301\u5173\u4e8e compute subpasses \u7684\u529f\u80fd\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u4eec\u660e\u786e\u6307\u5b9a graphics subpass \u56fe\u5f62\u5b50\u901a\u9053\u3002\u4e0b\u4e00\u6b65\u4e3a\u5b83\u6307\u5b9a\u989c\u8272\u9644\u4ef6\u7684\u5f15\u7528: subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; C++ \u9644\u4ef6\u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15\u76f4\u63a5\u4ece\u7247\u6bb5\u7740\u8272\u5668\u5f15\u7528\uff0c\u5176 layout(location = 0) out vec4 outColor \u6307\u4ee4! \u53ef\u4ee5\u88ab\u5b50\u901a\u9053\u5f15\u7528\u7684\u9644\u4ef6\u7c7b\u578b\u5982\u4e0b: pInputAttachments : \u9644\u4ef6\u4ece\u7740\u8272\u5668\u4e2d\u8bfb\u53d6 pResolveAttachments : \u9644\u4ef6\u7528\u4e8e\u989c\u8272\u9644\u4ef6\u7684\u591a\u91cd\u91c7\u6837 pDepthStencilAttachment : \u9644\u4ef6\u7528\u4e8e\u6df1\u5ea6\u548c\u6a21\u7248\u6570\u636e pPreserveAttachments : \u9644\u4ef6\u4e0d\u88ab\u5b50\u901a\u9053\u4f7f\u7528\uff0c\u4f46\u662f\u6570\u636e\u88ab\u4fdd\u5b58","title":"\u5b50\u901a\u9053\u548c\u9644\u4ef6\u5f15\u7528"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_43","text":"\u73b0\u5728\u9644\u4ef6\u548c\u57fa\u672c\u7684\u5b50\u901a\u9053\u5df2\u7ecf\u4ecb\u7ecd\u8fc7\u4e86\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u6e32\u67d3\u901a\u9053\u4e86\u3002\u9996\u5148\u65b0\u5efa\u4e00\u4e2a\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709 VkRenderPass \u5bf9\u8c61\uff0c\u8be5\u53d8\u91cf\u5728 pipelineLayout \u4e0a\u5b9a\u4e49: VkRenderPass renderPass; VkPipelineLayout pipelineLayout; C++ \u6e32\u67d3\u901a\u9053\u5bf9\u8c61\u521b\u5efa\u901a\u8fc7\u586b\u5145 VkRenderPassCreateInfo \u7ed3\u6784\u4f53\uff0c\u5e76\u914d\u5408\u76f8\u5173\u9644\u4ef6\u548c\u5b50\u901a\u9053\u6765\u5b8c\u6210\u3002 VkAttachmentReference \u5bf9\u8c61\u5f15\u7528\u9644\u4ef6\u6570\u7ec4\u3002 VkRenderPassCreateInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } C++ \u5c31\u50cf pipeline layout \u4e00\u6837\uff0c\u6e32\u67d3\u901a\u9053\u5728\u6574\u4e2a\u7a0b\u5e8f\u751f\u547d\u5468\u671f\u5185\u90fd\u88ab\u4f7f\u7528\uff0c\u6240\u4ee5\u9700\u8981\u5728\u9000\u51fa\u9636\u6bb5\u8fdb\u884c\u6e05\u7406\uff1a void cleanup() { vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); ... } C++ \u8fd9\u770b\u8d77\u6765\u5f88\u591a\u5de5\u4f5c\u91cf\uff0c\u4f46\u662f\u5728 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u4f1a\u628a\u6240\u6709\u7684\u7ec4\u4ef6\u6574\u5408\u8d77\u6765\uff0c\u521b\u5efa\u6700\u7ec8\u7684\u56fe\u5f62\u7ba1\u7ebf\u5bf9\u8c61\u3002","title":"\u6e32\u67d3\u901a\u9053"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_11","text":"ulkan \u96c6\u6210\u7ba1\u7ebf \uff0c\u6211\u4eec\u73b0\u5728\u6574\u5408\u524d\u51e0\u7ae0\u8282\u7684\u7ed3\u6784\u4f53\u548c \u5bf9\u8c61\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf \uff01\u4ee5\u4e0b\u662f\u6211\u4eec\u73b0\u5728\u7528\u5230\u7684\u5bf9\u8c61\u7c7b\u578b\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u5feb\u901f\u56de\u987e: Shader stages : \u7740\u8272\u5668\u6a21\u5757\u5b9a\u4e49\u4e86\u56fe\u5f62\u7ba1\u7ebf\u53ef\u7f16\u7a0b\u9636\u6bb5\u7684\u529f\u80fd Fixed-function state : \u7ed3\u6784\u4f53\u5b9a\u4e49\u56fa\u5b9a\u7ba1\u7ebf\u529f\u80fd\uff0c\u6bd4\u5982\u8f93\u5165\u88c5\u914d\u3001\u5149\u6805\u5316\u3001viewport\u548ccolor blending Pipeline layout : \u7ba1\u7ebf\u5e03\u5c40\u5b9a\u4e49uniform \u548c push values\uff0c\u88ab\u7740\u8272\u5668\u6bcf\u4e00\u6b21\u7ed8\u5236\u7684\u65f6\u5019\u5f15\u7528 Render pass : \u6e32\u67d3\u901a\u9053\u901a\u8fc7\u7ba1\u7ebf\u9636\u6bb5\u5f15\u7528\u9644\u4ef6\uff0c\u5e76\u5b9a\u4e49\u5b83\u7684\u4f7f\u7528\u65b9\u5f0f \u6240\u6709\u8fd9\u4e9b\u51b3\u5b9a\u4e86\u56fe\u5f62\u7ba1\u7ebf\u7684\u6700\u7ec8\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u5728 createGraphicsPipeline \u51fd\u6570\u7684\u6700\u540e\u586b\u5145 VkGraphicsPipelineCreateInfo \u7ed3\u6784\u4f53\u3002 VkGraphicsPipelineCreateInfo pipelineInfo = {}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 2; pipelineInfo.pStages = shaderStages; C++ \u73b0\u5728\u5f00\u59cb\u5f15\u7528\u4e4b\u524d\u7684 VkPipelineShaderStageCreateInfo \u7ed3\u6784\u4f53\u6570\u7ec4\u3002 pipelineInfo.pVertexInputState = &vertexInputInfo; pipelineInfo.pInputAssemblyState = &inputAssembly; pipelineInfo.pViewportState = &viewportState; pipelineInfo.pRasterizationState = &rasterizer; pipelineInfo.pMultisampleState = &multisampling; pipelineInfo.pDepthStencilState = nullptr; // Optional pipelineInfo.pColorBlendState = &colorBlending; pipelineInfo.pDynamicState = nullptr; // Optional C++ \u5e76\u5f15\u7528\u4e4b\u524d\u63cf\u8ff0\u56fa\u5b9a\u7ba1\u7ebf\u529f\u80fd\u7684\u7ed3\u6784\u4f53\u3002 pipelineInfo.layout = pipelineLayout; C++ \u5b8c\u6210\u4e4b\u540e\uff0c pipeline layout \u7ba1\u7ebf\u5e03\u5c40\uff0c\u5b83\u662f\u4e00\u4e2a Vulkan \u53e5\u67c4\u800c\u4e0d\u662f\u7ed3\u6784\u4f53\u6307\u9488\u3002 pipelineInfo.renderPass = renderPass; pipelineInfo.subpass = 0; C++ \u6700\u540e\u6211\u4eec\u9700\u8981\u5f15\u7528 render pass \u548c\u56fe\u5f62\u7ba1\u7ebf\u5c06\u8981\u4f7f\u7528\u7684\u5b50\u901a\u9053 sub pass \u7684\u7d22\u5f15\u3002 pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; // Optional pipelineInfo.basePipelineIndex = -1; // Optional C++ \u5b9e\u9645\u4e0a\u8fd8\u6709\u4e24\u4e2a\u53c2\u6570: basePipelineHandle \u548c basePipelineIndex \u3002Vulkan\u5141\u8bb8\u60a8\u901a\u8fc7\u5df2\u7ecf\u5b58\u5728\u7684\u7ba1\u7ebf\u521b\u5efa\u65b0\u7684\u56fe\u5f62\u7ba1\u7ebf\u3002\u8fd9\u79cd\u884d\u751f\u51fa\u65b0\u7ba1\u7ebf\u7684\u60f3\u6cd5\u5728\u4e8e\uff0c\u5f53\u8981\u521b\u5efa\u7684\u7ba1\u7ebf\u4e0e\u73b0\u6709\u7ba1\u9053\u529f\u80fd\u76f8\u540c\u65f6\uff0c\u83b7\u5f97\u8f83\u4f4e\u7684\u5f00\u9500\uff0c\u540c\u65f6\u4e5f\u53ef\u4ee5\u66f4\u5feb\u7684\u5b8c\u6210\u7ba1\u7ebf\u5207\u6362\uff0c\u5f53\u5b83\u4eec\u6765\u81ea\u540c\u4e00\u4e2a\u7236\u7ba1\u7ebf\u3002\u53ef\u4ee5\u901a\u8fc7 basePipelineHandle \u6307\u5b9a\u73b0\u6709\u7ba1\u7ebf\u7684\u53e5\u67c4\uff0c\u4e5f\u53ef\u4ee5\u5f15\u7528\u7531 basePipelineIndex \u6240\u4ee5\u521b\u5efa\u7684\u53e6\u4e00\u4e2a\u7ba1\u7ebf\u3002\u76ee\u524d\u53ea\u6709\u4e00\u4e2a\u7ba1\u7ebf\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u6307\u5b9a\u4e00\u4e2a\u7a7a\u53e5\u67c4\u548c\u4e00\u4e2a\u65e0\u6548\u7684\u7d22\u5f15\u3002\u53ea\u6709\u5728 VkGraphicsPipelineCreateInfo \u7684 flags \u5b57\u6bb5\u4e2d\u4e5f\u6307\u5b9a\u4e86 VK_PIPELINE_CREATE_DERIVATIVE_BIT \u6807\u5fd7\u65f6\uff0c\u624d\u9700\u8981\u4f7f\u7528\u8fd9\u4e9b\u503c\u3002 \u73b0\u5728\u51c6\u5907\u6700\u540e\u4e00\u6b65\uff0c\u521b\u5efa\u4e00\u4e2a\u7c7b\u6210\u5458\u4fdd\u5b58 VkPipeline \u5bf9\u8c61: VkPipeline graphicsPipeline; C++ \u6700\u540e\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf: if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline) != VK_SUCCESS) { throw std::runtime_error(\"failed to create graphics pipeline!\"); } C++ vkCreateGraphicsPipelines \u51fd\u6570\u5728Vulkan\u4e2d\u6bd4\u8d77\u4e00\u822c\u7684\u521b\u5efa\u5bf9\u8c61\u51fd\u6570\u9700\u8981\u66f4\u591a\u7684\u53c2\u6570\u3002\u5b83\u53ef\u4ee5\u7528\u6765\u4f20\u9012\u591a\u4e2a VkGraphicsPipelineCreateInfo \u5bf9\u8c61\u5e76\u521b\u5efa\u591a\u4e2a VkPipeline \u5bf9\u8c61\u3002 \u6211\u4eec\u4f20\u9012 VK_NULL_HANDLE \u53c2\u6570\u4f5c\u4e3a\u7b2c\u4e8c\u4e2a\u53c2\u6570\uff0c\u4f5c\u4e3a\u53ef\u9009 VkPipelineCache \u5bf9\u8c61\u7684\u5f15\u7528\u3002\u7ba1\u7ebf\u7f13\u5b58\u53ef\u4ee5\u7528\u4e8e\u5b58\u50a8\u548c\u590d\u7528\u4e0e\u901a\u8fc7\u591a\u6b21\u8c03\u7528 vkCreateGraphicsPipelines \u51fd\u6570\u76f8\u5173\u7684\u6570\u636e\uff0c\u751a\u81f3\u5728\u7a0b\u5e8f\u6267\u884c\u7684\u65f6\u5019\u7f13\u5b58\u5230\u4e00\u4e2a\u6587\u4ef6\u4e2d\u3002\u8fd9\u6837\u53ef\u4ee5\u52a0\u901f\u540e\u7eed\u7684\u7ba1\u7ebf\u521b\u5efa\u903b\u8f91\u3002\u5177\u4f53\u7684\u5185\u5bb9\u6211\u4eec\u4f1a\u5728\u7ba1\u7ebf\u7f13\u5b58\u7ae0\u8282\u4ecb\u7ecd\u3002 \u56fe\u5f62\u7ba1\u7ebf\u5bf9\u4e8e\u5e38\u89c1\u7684\u7ed8\u56fe\u64cd\u4f5c\u662f\u5fc5\u987b\u7684\uff0c\u6240\u4ee5\u5b83\u4e5f\u5e94\u8be5\u5728\u7a0b\u5e8f\u7ed3\u675f\u65f6\u9500\u6bc1: void cleanup() { vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ... } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\uff0c\u786e\u8ba4\u6240\u6709\u5de5\u4f5c\u6b63\u5e38\uff0c\u5e76\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u6210\u529f\uff01\u6211\u4eec\u5df2\u7ecf\u65e0\u6bd4\u63a5\u8fd1\u5728\u5c4f\u5e55\u4e0a\u7ed8\u5236\u51fa\u4e1c\u897f\u6765\u4e86\u3002\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u4e2a\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4ece\u4ea4\u6362\u94fe\u56fe\u50cf\u4e2d\u8bbe\u7f6e\u5b9e\u9645\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u51c6\u5907\u7ed8\u5236\u547d\u4ee4\u3002","title":"Vulkan \u96c6\u6210\u7ba1\u7ebf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_12","text":"Vulkan \u547d\u4ee4\u7f13\u51b2\u533a \uff0c\u8bf8\u5982\u7ed8\u5236\u548c\u5185\u5b58\u64cd\u4f5c\u76f8\u5173\u547d\u4ee4\uff0c\u5728 Vulkan \u4e2d\u4e0d\u662f\u901a\u8fc7\u51fd\u6570\u76f4\u63a5\u8c03\u7528\u7684\u3002\u6211\u4eec\u9700\u8981\u5728\u547d\u4ee4\u7f13\u51b2\u533a\u5bf9\u8c61\u4e2d\u8bb0\u5f55\u6211\u4eec\u671f\u671b\u7684\u4efb\u4f55\u64cd\u4f5c\u3002\u8fd9\u6837\u505a\u7684\u4f18\u70b9\u662f\u53ef\u4ee5\u63d0\u524d\u5728\u591a\u7ebf\u7a0b\u4e2d\u5b8c\u6210\u6240\u6709\u7ed8\u5236\u547d\u4ee4\u76f8\u5173\u7684\u88c5\u914d\u5de5\u4f5c\uff0c\u5e76\u5728\u4e3b\u7ebf\u7a0b\u5faa\u73af\u7ed3\u6784\u4e2d\u901a\u77e5 Vulkan \u6267\u884c\u5177\u4f53\u7684\u547d\u4ee4\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u547d\u4ee4\u6c60 2 \u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a 3 \u542f\u52a8\u547d\u4ee4\u7f13\u51b2\u8bb0\u5f55 4 \u542f\u52a8\u6e32\u67d3\u901a\u9053 5 \u57fa\u672c\u7ed8\u56fe\u547d\u4ee4 6 \u7ed3\u675f\u6e32\u67d3","title":"Vulkan \u547d\u4ee4\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_44","text":"\u6211\u4eec\u5728\u4f7f\u7528\u4efb\u4f55 command buffers \u4e4b\u524d\u9700\u8981\u521b\u5efa\u547d\u4ee4\u5bf9\u8c61\u6c60 command pool \u3002 Command pools \u7ba1\u7406\u7528\u4e8e\u5b58\u50a8\u7f13\u51b2\u533a\u7684\u5185\u5b58\uff0c\u5e76\u4ece\u4e2d\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u6dfb\u52a0\u65b0\u7684\u7c7b\u6210\u5458\u4fdd\u5b58 VkCommandPool : VkCommandPool commandPool; \u521b\u5efa\u65b0\u7684\u51fd\u6570 createCommandPool \u5e76\u5728 initVulkan \u51fd\u6570\u521b\u5efa\u5b8c framebuffers \u540e\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); } ... void createCommandPool() { } \u547d\u4ee4\u5bf9\u8c61\u6c60\u521b\u5efa\u4ec5\u4ec5\u9700\u8981\u4e24\u4e2a\u53c2\u6570: QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice); VkCommandPoolCreateInfo poolInfo = {}; poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily; poolInfo.flags = 0; // Optional \u547d\u4ee4\u7f13\u51b2\u533a\u901a\u8fc7\u5c06\u5176\u63d0\u4ea4\u5230\u5176\u4e2d\u4e00\u4e2a\u8bbe\u5907\u961f\u5217\u4e0a\u6765\u6267\u884c\uff0c\u5982\u6211\u4eec\u68c0\u7d22\u7684 graphics \u548c presentation \u961f\u5217\u3002\u6bcf\u4e2a\u547d\u4ee4\u5bf9\u8c61\u6c60\u53ea\u80fd\u5206\u914d\u5728\u5355\u4e00\u7c7b\u578b\u7684\u961f\u5217\u4e0a\u63d0\u4ea4\u7684\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u6362\u53e5\u8bdd\u8bf4\u8981\u5206\u914d\u7684\u547d\u4ee4\u9700\u8981\u4e0e\u961f\u5217\u7c7b\u578b\u4e00\u81f4\u3002\u6211\u4eec\u8981\u8bb0\u5f55\u7ed8\u5236\u7684\u547d\u4ee4\uff0c\u8fd9\u5c31\u8bf4\u660e\u4e3a\u4ec0\u4e48\u8981\u9009\u62e9\u56fe\u5f62\u961f\u5217\u7c07\u7684\u539f\u56e0\u3002 \u6709\u4e24\u4e2a\u6807\u5fd7\u4f4d\u7528\u4e8e command pools : VK_COMMAND_POOL_CREATE_TRANSIENT_BIT : \u63d0\u793a\u547d\u4ee4\u7f13\u51b2\u533a\u975e\u5e38\u9891\u7e41\u7684\u91cd\u65b0\u8bb0\u5f55\u65b0\u547d\u4ee4(\u53ef\u80fd\u4f1a\u6539\u53d8\u5185\u5b58\u5206\u914d\u884c\u4e3a) VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT : \u5141\u8bb8\u547d\u4ee4\u7f13\u51b2\u533a\u5355\u72ec\u91cd\u65b0\u8bb0\u5f55\uff0c\u6ca1\u6709\u8fd9\u4e2a\u6807\u5fd7\uff0c\u6240\u6709\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u90fd\u5fc5\u987b\u4e00\u8d77\u91cd\u7f6e \u6211\u4eec\u4ec5\u4ec5\u5728\u7a0b\u5e8f\u5f00\u59cb\u7684\u65f6\u5019\u8bb0\u5f55\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u5e76\u5728\u4e3b\u5faa\u73af\u4f53 main loop \u4e2d\u591a\u6b21\u6267\u884c\uff0c\u56e0\u6b64\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u8fd9\u4e9b\u6807\u5fd7\u3002 if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) { throw std::runtime_error(\"failed to create command pool!\"); } \u901a\u8fc7 vkCreateCommandPool \u51fd\u6570\u5b8c\u6210 command pool \u521b\u5efa\u5de5\u4f5c\u3002\u5b83\u4e0d\u9700\u8981\u4efb\u4f55\u7279\u6b8a\u7684\u53c2\u6570\u8bbe\u7f6e\u3002\u547d\u4ee4\u5c06\u88ab\u6574\u4e2a\u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\u4f7f\u7528\u4ee5\u5b8c\u6210\u5c4f\u5e55\u7684\u7ed8\u5236\u5de5\u4f5c\uff0c\u6240\u4ee5\u5bf9\u8c61\u6c60\u5e94\u8be5\u88ab\u5728\u6700\u540e\u9500\u6bc1: void cleanup() { vkDestroyCommandPool(device, commandPool, nullptr); ... }","title":"\u547d\u4ee4\u6c60"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_45","text":"\u73b0\u5728\u6211\u4eec\u5f00\u59cb\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a\u5e76\u901a\u8fc7\u5b83\u4eec\u8bb0\u5f55\u7ed8\u5236\u6307\u4ee4\u3002\u56e0\u4e3a\u5176\u4e2d\u4e00\u4e2a\u7ed8\u56fe\u547d\u4ee4\u9700\u8981\u6b63\u786e\u7ed1\u5b9a VkFrameBuffer \uff0c\u6211\u4eec\u5b9e\u9645\u4e0a\u9700\u8981\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u8bb0\u5f55\u4e00\u4e2a\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u6700\u540e\u521b\u5efa\u4e00\u4e2a VkCommandBuffer \u5bf9\u8c61\u5217\u8868\u4f5c\u4e3a\u6210\u5458\u53d8\u91cf\u3002\u547d\u4ee4\u7f13\u51b2\u533a\u4f1a\u5728 common pool \u9500\u6bc1\u7684\u65f6\u5019\u81ea\u52a8\u91ca\u653e\u7cfb\u7edf\u8d44\u6e90\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u660e\u786e\u7f16\u5199 cleanup \u903b\u8f91\u3002 std::vector<VkCommandBuffer> commandBuffers; \u73b0\u5728\u5f00\u59cb\u4f7f\u7528\u4e00\u4e2a createCommandBuffers \u51fd\u6570\u6765\u5206\u914d\u548c\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u56fe\u50cf\u5c06\u8981\u5e94\u7528\u7684\u547d\u4ee4\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); } ... void createCommandBuffers() { commandBuffers.resize(swapChainFramebuffers.size()); } \u547d\u4ee4\u7f13\u51b2\u533a\u901a\u8fc7 vkAllocateCommandBuffers \u51fd\u6570\u5206\u914d\uff0c\u5b83\u9700\u8981 VkCommandBufferAllocateInfo \u7ed3\u6784\u4f53\u4f5c\u4e3a\u53c2\u6570\uff0c\u7528\u4ee5\u6307\u5b9a command pool \u548c\u7f13\u51b2\u533a\u5c06\u4f1a\u5206\u914d\u7684\u5927\u5c0f: VkCommandBufferAllocateInfo allocInfo = {}; allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; allocInfo.commandPool = commandPool; allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; allocInfo.commandBufferCount = (uint32_t) commandBuffers.size(); if (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.data()) != VK_SUCCESS) { throw std::runtime_error(\"failed to allocate command buffers!\"); } level \u53c2\u6570\u6307\u5b9a\u5206\u914d\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u4e3b\u4ece\u5173\u7cfb\u3002 VK_COMMAND_BUFFER_LEVEL_PRIMARY : \u53ef\u4ee5\u63d0\u4ea4\u5230\u961f\u5217\u6267\u884c\uff0c\u4f46\u4e0d\u80fd\u4ece\u5176\u4ed6\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u8c03\u7528\u3002 VK_COMMAND_BUFFER_LEVEL_SECONDARY : \u65e0\u6cd5\u76f4\u63a5\u63d0\u4ea4\uff0c\u4f46\u662f\u53ef\u4ee5\u4ece\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u8c03\u7528\u3002 \u6211\u4eec\u4e0d\u4f1a\u5728\u8fd9\u91cc\u4f7f\u7528\u8f85\u52a9\u7f13\u51b2\u533a\u529f\u80fd\uff0c\u4f46\u662f\u53ef\u4ee5\u60f3\u50cf\uff0c\u5bf9\u4e8e\u590d\u7528\u4e3b\u7f13\u51b2\u533a\u7684\u5e38\u7528\u64cd\u4f5c\u5f88\u6709\u5e2e\u52a9\u3002","title":"\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_46","text":"\u901a\u8fc7 vkBeginCommandBuffer \u6765\u5f00\u542f\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u8bb0\u5f55\u529f\u80fd\uff0c\u8be5\u51fd\u6570\u9700\u8981\u4f20\u9012 VkCommandBufferBeginInfo \u7ed3\u6784\u4f53\u4f5c\u4e3a\u53c2\u6570\uff0c\u7528\u4ee5\u6307\u5b9a\u547d\u4ee4\u7f13\u51b2\u533a\u5728\u4f7f\u7528\u8fc7\u7a0b\u4e2d\u7684\u4e00\u4e9b\u5177\u4f53\u4fe1\u606f\u3002 for (size_t i = 0; i < commandBuffers.size(); i++) { VkCommandBufferBeginInfo beginInfo = {}; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT; beginInfo.pInheritanceInfo = nullptr; // Optional vkBeginCommandBuffer(commandBuffers[i], &beginInfo); } flags \u6807\u5fd7\u4f4d\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u5982\u4f55\u4f7f\u7528\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u53ef\u9009\u7684\u53c2\u6570\u7c7b\u578b\u5982\u4e0b: VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT : \u547d\u4ee4\u7f13\u51b2\u533a\u5c06\u5728\u6267\u884c\u4e00\u6b21\u540e\u7acb\u5373\u91cd\u65b0\u8bb0\u5f55\u3002 VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT : \u8fd9\u662f\u4e00\u4e2a\u8f85\u52a9\u7f13\u51b2\u533a\uff0c\u5b83\u9650\u5236\u5728\u5728\u4e00\u4e2a\u6e32\u67d3\u901a\u9053\u4e2d\u3002 VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT : \u547d\u4ee4\u7f13\u51b2\u533a\u4e5f\u53ef\u4ee5\u91cd\u65b0\u63d0\u4ea4\uff0c\u540c\u65f6\u5b83\u4e5f\u5728\u7b49\u5f85\u6267\u884c\u3002 \u6211\u4eec\u4f7f\u7528\u4e86\u6700\u540e\u4e00\u4e2a\u6807\u5fd7\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u80fd\u5df2\u7ecf\u5728\u4e0b\u4e00\u5e27\u7684\u65f6\u5019\u5b89\u6392\u4e86\u7ed8\u5236\u547d\u4ee4\uff0c\u800c\u6700\u540e\u4e00\u5e27\u5c1a\u672a\u5b8c\u6210\u3002 pInheritanceInfo \u53c2\u6570\u4e0e\u8f85\u52a9\u7f13\u51b2\u533a\u76f8\u5173\u3002\u5b83\u6307\u5b9a\u4ece\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u7ee7\u627f\u7684\u72b6\u6001\u3002 \u5982\u679c\u547d\u4ee4\u7f13\u51b2\u533a\u5df2\u7ecf\u88ab\u8bb0\u5f55\u4e00\u6b21\uff0c\u90a3\u4e48\u8c03\u7528 vkBeginCommandBuffer \u4f1a\u9690\u5f0f\u5730\u91cd\u7f6e\u5b83\u3002\u5426\u5219\u5c06\u547d\u4ee4\u9644\u52a0\u5230\u7f13\u51b2\u533a\u662f\u4e0d\u53ef\u80fd\u7684\u3002","title":"\u542f\u52a8\u547d\u4ee4\u7f13\u51b2\u8bb0\u5f55"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_47","text":"\u7ed8\u5236\u5f00\u59cb\u4e8e\u8c03\u7528 vkCmdBeginRenderPass \u5f00\u542f\u6e32\u67d3\u901a\u9053\u3002render pass\u4f7f\u7528 VkRenderPassBeginInfo \u7ed3\u6784\u4f53\u586b\u5145\u914d\u7f6e\u4fe1\u606f\u4f5c\u4e3a\u8c03\u7528\u65f6\u4f7f\u7528\u7684\u53c2\u6570\u3002 VkRenderPassBeginInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; renderPassInfo.renderPass = renderPass; renderPassInfo.framebuffer = swapChainFramebuffers[i]; \u7ed3\u6784\u4f53\u7b2c\u4e00\u4e2a\u53c2\u6570\u4f20\u9012\u4e3a\u7ed1\u5b9a\u5230\u5bf9\u5e94\u9644\u4ef6\u7684\u6e32\u67d3\u901a\u9053\u672c\u8eab\u3002\u6211\u4eec\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u521b\u5efa\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u6307\u5b9a\u4e3a\u989c\u8272\u9644\u4ef6\u3002 renderPassInfo.renderArea.offset = {0, 0}; renderPassInfo.renderArea.extent = swapChainExtent; \u540e\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u4e86\u6e32\u67d3\u533a\u57df\u7684\u5927\u5c0f\u3002\u6e32\u67d3\u533a\u57df\u5b9a\u4e49\u7740\u8272\u5668\u52a0\u8f7d\u548c\u5b58\u50a8\u5c06\u8981\u53d1\u751f\u7684\u4f4d\u7f6e\u3002\u533a\u57df\u5916\u7684\u50cf\u7d20\u5c06\u5177\u6709\u672a\u5b9a\u7684\u503c\u3002\u4e3a\u4e86\u6700\u4f73\u7684\u6027\u80fd\u5b83\u7684\u5c3a\u5bf8\u5e94\u8be5\u4e0e\u9644\u4ef6\u5339\u914d\u3002 VkClearValue clearColor = {0.0f, 0.0f, 0.0f, 1.0f}; renderPassInfo.clearValueCount = 1; renderPassInfo.pClearValues = &clearColor; \u6700\u540e\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u4e86\u7528\u4e8e VK_ATTACHMENT_LOAD_OP_CLEAR \u7684\u6e05\u9664\u503c\uff0c\u6211\u4eec\u5c06\u5176\u7528\u4f5c\u989c\u8272\u9644\u4ef6\u7684\u52a0\u8f7d\u64cd\u4f5c\u3002\u4e3a\u4e86\u7b80\u5316\u64cd\u4f5c\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86 clear color \u4e3a100%\u9ed1\u8272\u3002 vkCmdBeginRenderPass(commandBuffers[i], &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE); \u6e32\u67d3\u901a\u9053\u73b0\u5728\u53ef\u4ee5\u542f\u7528\u3002\u6240\u6709\u53ef\u4ee5\u88ab\u8bb0\u5f55\u7684\u547d\u4ee4\uff0c\u88ab\u8bc6\u522b\u7684\u524d\u63d0\u662f\u4f7f\u7528 vkCmd \u524d\u7f00\u3002\u5b83\u4eec\u5168\u90e8\u8fd4\u56de void \uff0c\u6240\u4ee5\u5728\u7ed3\u675f\u8bb0\u5f55\u4e4b\u524d\u4e0d\u4f1a\u6709\u4efb\u4f55\u9519\u8bef\u5904\u7406\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u547d\u4ee4\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u603b\u662f\u8bb0\u5f55\u8be5\u547d\u4ee4\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u7b2c\u4e8c\u4e2a\u53c2\u6570\u6307\u5b9a\u6211\u4eec\u4f20\u9012\u7684\u6e32\u67d3\u901a\u9053\u7684\u5177\u4f53\u4fe1\u606f\u3002\u6700\u540e\u7684\u53c2\u6570\u63a7\u5236\u5982\u4f55\u63d0\u4f9b render pass \u5c06\u8981\u5e94\u7528\u7684\u7ed8\u5236\u547d\u4ee4\u3002\u5b83\u4f7f\u7528\u4ee5\u4e0b\u6570\u503c\u4efb\u610f\u4e00\u4e2a: VK_SUBPASS_CONTENTS_INLINE : \u6e32\u67d3\u8fc7\u7a0b\u547d\u4ee4\u88ab\u5d4c\u5165\u5728\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u4e2d\uff0c\u6ca1\u6709\u8f85\u52a9\u7f13\u51b2\u533a\u6267\u884c\u3002 VK_SUBPASS_CONTENTS_SECONDARY_COOMAND_BUFFERS : \u6e32\u67d3\u901a\u9053\u547d\u4ee4\u5c06\u4f1a\u4ece\u8f85\u52a9\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u3002 \u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u8f85\u52a9\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u7b2c\u4e00\u4e2a\u3002","title":"\u542f\u52a8\u6e32\u67d3\u901a\u9053"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_48","text":"\u73b0\u5728\u6211\u4eec\u7ed1\u5b9a\u56fe\u5f62\u7ba1\u7ebf: vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline); \u7b2c\u4e8c\u4e2a\u53c2\u6570\u6307\u5b9a\u5177\u4f53\u7ba1\u7ebf\u7c7b\u578b\uff0c graphics or compute pipeline \u3002\u6211\u4eec\u544a\u8bc9Vulkan\u5728\u56fe\u5f62\u7ba1\u7ebf\u4e2d\u6bcf\u4e00\u4e2a\u64cd\u4f5c\u5982\u4f55\u6267\u884c\u53ca\u54ea\u4e2a\u9644\u4ef6\u5c06\u4f1a\u5728\u7247\u6bb5\u7740\u8272\u5668\u4e2d\u4f7f\u7528\uff0c\u6240\u4ee5\u5269\u4e0b\u7684\u5c31\u662f\u544a\u8bc9\u5b83\u7ed8\u5236\u4e09\u89d2\u5f62\u3002 vkCmdDraw(commandBuffers[i], 3, 1, 0, 0); C++ \u5b9e\u9645\u7684 vkCmdDraw \u51fd\u6570\u6709\u70b9\u4e0e\u5b57\u9762\u610f\u601d\u4e0d\u4e00\u81f4\uff0c\u5b83\u662f\u5982\u6b64\u7b80\u5355\uff0c\u4ec5\u56e0\u4e3a\u6211\u4eec\u63d0\u524d\u6307\u5b9a\u6240\u6709\u6e32\u67d3\u76f8\u5173\u7684\u4fe1\u606f\u3002\u5b83\u6709\u5982\u4e0b\u7684\u53c2\u6570\u9700\u8981\u6307\u5b9a\uff0c\u9664\u4e86\u547d\u4ee4\u7f13\u51b2\u533a: vertexCount : \u5373\u4f7f\u6211\u4eec\u6ca1\u6709\u9876\u70b9\u7f13\u51b2\u533a\uff0c\u4f46\u662f\u6211\u4eec\u4ecd\u7136\u67093\u4e2a\u5b9a\u70b9\u9700\u8981\u7ed8\u5236\u3002 instanceCount : \u7528\u4e8einstanced \u6e32\u67d3\uff0c\u5982\u679c\u6ca1\u6709\u4f7f\u7528\u8bf7\u586b1\u3002 firstVertex : \u4f5c\u4e3a\u9876\u70b9\u7f13\u51b2\u533a\u7684\u504f\u79fb\u91cf\uff0c\u5b9a\u4e49gl_VertexIndex\u7684\u6700\u5c0f\u503c\u3002 firstInstance : \u4f5c\u4e3ainstanced \u6e32\u67d3\u7684\u504f\u79fb\u91cf\uff0c\u5b9a\u4e49\u4e86gl_InstanceIndex\u7684\u6700\u5c0f\u503c\u3002","title":"\u57fa\u672c\u7ed8\u56fe\u547d\u4ee4"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_49","text":"render pass \u6267\u884c\u5b8c\u7ed8\u5236\uff0c\u53ef\u4ee5\u7ed3\u675f\u6e32\u67d3\u4f5c\u4e1a: vkCmdEndRenderPass(commandBuffers[i]); C++ \u5e76\u505c\u6b62\u8bb0\u5f55\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u5de5\u4f5c: if (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to record command buffer!\"); } C++ \u5728\u4e0b\u4e00\u7ae0\u8282\u6211\u4eec\u4f1a\u5c1d\u8bd5\u5728 main loop \u4e2d\u7f16\u5199\u4ee3\u7801\uff0c\u7528\u4e8e\u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u56fe\u50cf\uff0c\u6267\u884c\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u547d\u4ee4\uff0c\u518d\u5c06\u6e32\u67d3\u540e\u7684\u56fe\u50cf\u8fd4\u8fd8\u7ed9\u4ea4\u6362\u94fe\u3002","title":"\u7ed3\u675f\u6e32\u67d3"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_13","text":"Vulkan \u6e32\u67d3\u548c\u663e\u793a \uff0c\u8fd9\u4e00\u7ae0\u8282\u4f1a\u628a\u4e4b\u524d\u7684\u6240\u6709\u5185\u5bb9\u8fdb\u884c\u6574\u5408\uff0c\u6211\u4eec\u5c06\u4f1a\u7f16\u5199 drawFrame \u51fd\u6570\uff0c\u901a\u8fc7\u4e3b\u5faa\u73af main loop \u5c06\u4e09\u89d2\u5f62\u7ed8\u5236\u5230\u5c4f\u5e55\u3002 drawFrame \u51fd\u6570\u5c06\u4f1a\u6267\u884c\u5982\u4e0b\u64cd\u4f5c: \u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u4e00\u4e2a\u56fe\u50cf \u5728\u5e27\u7f13\u51b2\u533a\u4e2d\uff0c\u4f7f\u7528\u4f5c\u4e3a\u9644\u4ef6\u7684\u56fe\u50cf\u6765\u6267\u884c\u547d\u4ee4\u7f13\u51b2\u533a\u4e2d\u7684\u547d\u4ee4 \u4e3a\u4e86\u6700\u7ec8\u5448\u73b0\uff0c\u5c06\u56fe\u50cf\u8fd4\u8fd8\u5230\u4ea4\u6362\u94fe \u6bcf\u4e2a\u4e8b\u4ef6\u6d3e\u53d1\u90fd\u6709\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u6765\u5bf9\u5e94\uff0c\u4f46\u5b83\u4eec\u7684\u6267\u884c\u662f\u5f02\u6b65\u7684\u3002\u51fd\u6570\u8c03\u7528\u5c06\u5728\u64cd\u4f5c\u5b9e\u9645\u5b8c\u6210\u4e4b\u524d\u8fd4\u56de\uff0c\u5e76\u4e14\u6267\u884c\u987a\u5e8f\u4e5f\u662f\u672a\u5b9a\u4e49\u7684\u3002\u8fd9\u662f\u4e0d\u7406\u60f3\u7684\uff0c\u56e0\u4e3a\u6bcf\u4e00\u4e2a\u64cd\u4f5c\u90fd\u53d6\u51b3\u4e8e\u524d\u4e00\u4e2a\u64cd\u4f5c\u3002 \u5728 mainLoop \u51fd\u6570\u8c03\u7528: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); drawFrame(); } } ... void drawFrame() { } C++ \u540c\u6b65\u4ea4\u6362\u94fe\u4e8b\u4ef6\u6709\u4e24\u79cd\u65b9\u6cd5:\u6805\u680f\u548c\u4fe1\u53f7\u91cf\u3002\u5b83\u4eec\u90fd\u662f\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u4e00\u4e2a\u64cd\u4f5c\u4fe1\u53f7\uff0c\u8d1f\u8d23\u534f\u8c03\u64cd\u4f5c\u7684\u5bf9\u8c61\u3002\u53e6\u4e00\u4e2a\u64cd\u4f5c\u7b49\u5f85\u6805\u680f\u6216\u8005\u4fe1\u53f7\u91cf\u4ece\u65e0\u4fe1\u53f7\u72b6\u6001\u8f6c\u53d8\u5230\u6709\u4fe1\u53f7\u72b6\u6001\u3002 \u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u53ef\u4ee5\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u8c03\u7528 vkWaitForFence \u8fdb\u5165\u6805\u680f\u72b6\u6001\uff0c\u800c\u4fe1\u53f7\u91cf\u4e0d\u53ef\u4ee5\u3002\u6805\u680f\u4e3b\u8981\u7528\u4e8e\u5e94\u7528\u7a0b\u5e8f\u81ea\u8eab\u4e0e\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u540c\u6b65\uff0c\u800c\u4fe1\u53f7\u91cf\u7528\u4e8e\u5728\u547d\u4ee4\u961f\u5217\u5185\u6216\u8005\u8de8\u547d\u4ee4\u961f\u5217\u540c\u6b65\u64cd\u4f5c\u3002\u6211\u4eec\u671f\u671b\u540c\u6b65\u7ed8\u5236\u4e0e\u5448\u73b0\u7684\u961f\u5217\u64cd\u4f5c\uff0c\u6240\u4ee5\u4f7f\u7528\u4fe1\u53f7\u91cf\u6700\u5408\u9002\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u4fe1\u53f7\u91cf 2 \u4ece\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf 3 \u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a 4 Subpass \u4f9d\u8d56\u6027 5 \u5448\u73b0 6 \u5185\u5b58\u6cc4\u6f0f 7 \u7ed3\u8bba","title":"Vulkan \u6e32\u67d3\u548c\u663e\u793a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_50","text":"\u5728\u83b7\u5f97\u4e00\u4e2a\u56fe\u50cf\u65f6\uff0c\u6211\u4eec\u9700\u8981\u53d1\u51fa\u4e00\u4e2a\u4fe1\u53f7\u91cf\u51c6\u5907\u8fdb\u884c\u6e32\u67d3\uff0c\u53e6\u4e00\u4e2a\u4fe1\u53f7\u91cf\u7684\u53d1\u51fa\u7528\u4e8e\u6e32\u67d3\u7ed3\u675f\uff0c\u51c6\u5907\u8fdb\u884c\u5448\u73b0presentation\u3002\u521b\u5efa\u4e24\u4e2a\u6210\u5458\u53d8\u91cf\u5b58\u50a8\u4fe1\u53f7\u91cf\u5bf9\u8c61: VkSemaphore imageAvailableSemaphore; VkSemaphore renderFinishedSemaphore; C++ \u4e3a\u4e86\u521b\u5efa\u4fe1\u53f7\u91cfsemaphores\uff0c\u6211\u4eec\u5c06\u8981\u65b0\u589e\u672c\u7cfb\u5217\u6559\u7a0b\u6700\u540e\u4e00\u4e2a\u51fd\u6570: createSemaphores : void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); createSemaphores(); } ... void createSemaphores() { } C++ \u521b\u5efa\u4fe1\u53f7\u91cf\u5bf9\u8c61\u9700\u8981\u586b\u5145 VkSemaphoreCreateInfo \u7ed3\u6784\u4f53\uff0c\u4f46\u662f\u5728\u5f53\u524d\u7248\u672c\u7684 API \u4e2d\uff0c\u5b9e\u9645\u4e0a\u4e0d\u9700\u8981\u586b\u5145\u4efb\u4f55\u5b57\u6bb5\uff0c\u9664 sType : void createSemaphores() { VkSemaphoreCreateInfo semaphoreInfo = {}; semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; } C++ Vulkan API\u672a\u6765\u7248\u672c\u6216\u8005\u6269\u5c55\u4e2d\u6216\u8bb8\u4f1a\u4e3a flags \u548c pNext \u53c2\u6570\u589e\u52a0\u529f\u80fd\u9009\u9879\u3002\u521b\u5efa\u4fe1\u53f7\u91cf\u5bf9\u8c61\u7684\u8fc7\u7a0b\u5f88\u719f\u6089\u4e86\uff0c\u5728\u8fd9\u91cc\u4f7f\u7528 vkCreateSemaphore : if (vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphore) != VK_SUCCESS || vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphore) != VK_SUCCESS) { throw std::runtime_error(\"failed to create semaphores!\"); } C++ \u5728\u7a0b\u5e8f\u7ed3\u675f\u65f6\uff0c\u5f53\u6240\u6709\u547d\u4ee4\u5b8c\u6210\u5e76\u4e0d\u9700\u8981\u540c\u6b65\u65f6\uff0c\u5e94\u8be5\u6e05\u9664\u4fe1\u53f7\u91cf: void cleanup() { vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); C++","title":"\u4fe1\u53f7\u91cf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_51","text":"\u5c31\u50cf\u4e4b\u524d\u8bf4\u5230\u7684\uff0c drawFrame \u51fd\u6570\u9700\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u56fe\u50cf\u3002\u56de\u60f3\u4e00\u4e0b\u4ea4\u6362\u94fe\u662f\u4e00\u4e2a\u6269\u5c55\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u4f7f\u7528\u5177\u6709vk*KHR\u547d\u540d\u7ea6\u5b9a\u7684\u51fd\u6570: void drawFrame() { uint32_t imageIndex; vkAcquireNextImageKHR(device, swapChain, std::numeric_limits<uint64_t>::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex); } C++ vkAcquireNextImageKHR \u51fd\u6570\u524d\u4e24\u4e2a\u53c2\u6570\u662f\u6211\u4eec\u5e0c\u671b\u83b7\u53d6\u5230\u56fe\u50cf\u7684\u903b\u8f91\u8bbe\u5907\u548c\u4ea4\u6362\u94fe\u3002\u7b2c\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u83b7\u53d6\u6709\u6548\u56fe\u50cf\u7684\u64cd\u4f5ctimeout\uff0c\u5355\u4f4d\u7eb3\u79d2\u3002\u6211\u4eec\u4f7f\u752864\u4f4d\u65e0\u7b26\u53f7\u6700\u5927\u503c\u7981\u6b62 timeout \u3002 \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u4f7f\u7528\u7684\u540c\u6b65\u5bf9\u8c61\uff0c\u5f53 presentation \u5f15\u64ce\u5b8c\u6210\u4e86\u56fe\u50cf\u7684\u5448\u73b0\u540e\u4f1a\u4f7f\u7528\u8be5\u5bf9\u8c61\u53d1\u8d77\u4fe1\u53f7\u3002\u8fd9\u5c31\u662f\u5f00\u59cb\u7ed8\u5236\u7684\u65f6\u95f4\u70b9\u3002\u5b83\u53ef\u4ee5\u6307\u5b9a\u4e00\u4e2a\u4fe1\u53f7\u91cf semaphore \u6216\u8005\u6805\u680f\u6216\u8005\u4e24\u8005\u3002\u51fa\u4e8e\u76ee\u7684\u6027\uff0c\u6211\u4eec\u4f1a\u4f7f\u7528 imageAvailableSemaphore \u3002 \u6700\u540e\u7684\u53c2\u6570\u6307\u5b9a\u4ea4\u6362\u94fe\u4e2d\u6210\u4e3a available \u72b6\u6001\u7684\u56fe\u50cf\u5bf9\u5e94\u7684\u7d22\u5f15\u3002\u5176\u4e2d\u7d22\u5f15\u4f1a\u5f15\u7528\u4ea4\u6362\u94fe\u56fe\u50cf\u6570\u7ec4 swapChainImages \u7684\u56fe\u50cf VkImage \u3002\u6211\u4eec\u4f7f\u7528\u8fd9\u4e2a\u7d22\u5f15\u9009\u62e9\u6b63\u786e\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002","title":"\u4ece\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_52","text":"\u961f\u5217\u63d0\u4ea4\u548c\u540c\u6b65\u901a\u8fc7 VkSubmitInfo \u7ed3\u6784\u4f53\u8fdb\u884c\u53c2\u6570\u914d\u7f6e\u3002 VkSubmitInfo submitInfo = {}; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; VkSemaphore waitSemaphores[] = {imageAvailableSemaphore}; VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT}; submitInfo.waitSemaphoreCount = 1; submitInfo.pWaitSemaphores = waitSemaphores; submitInfo.pWaitDstStageMask = waitStages; C++ \u524d\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u5728\u6267\u884c\u5f00\u59cb\u4e4b\u524d\u8981\u7b49\u5f85\u7684\u54ea\u4e2a\u4fe1\u53f7\u91cf\u53ca\u8981\u7b49\u5f85\u7684\u901a\u9053\u7684\u54ea\u4e2a\u9636\u6bb5\u3002\u4e3a\u4e86\u5411\u56fe\u50cf\u5199\u5165\u989c\u8272\uff0c\u6211\u4eec\u4f1a\u7b49\u5f85\u56fe\u50cf\u72b6\u6001\u53d8\u4e3a available \uff0c\u6240\u6211\u4eec\u6307\u5b9a\u5199\u5165\u989c\u8272\u9644\u4ef6\u7684\u56fe\u5f62\u7ba1\u7ebf\u9636\u6bb5\u3002\u7406\u8bba\u4e0a\u8fd9\u610f\u5473\u7740\uff0c\u5177\u4f53\u7684\u9876\u70b9\u7740\u8272\u5668\u5f00\u59cb\u6267\u884c\uff0c\u800c\u56fe\u50cf\u4e0d\u53ef\u7528\u3002 waitStages \u6570\u7ec4\u5bf9\u5e94 pWaitSemaphores \u4e2d\u5177\u6709\u76f8\u540c\u7d22\u5f15\u7684\u4fe1\u53f7\u91cf\u3002 submitInfo.commandBufferCount = 1; submitInfo.pCommandBuffers = &commandBuffers[imageIndex]; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u54ea\u4e2a\u547d\u4ee4\u7f13\u51b2\u533a\u88ab\u5b9e\u9645\u63d0\u4ea4\u6267\u884c\u3002\u5982\u521d\u671f\u63d0\u5230\u7684\uff0c\u6211\u4eec\u5e94\u8be5\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u5b83\u5c06\u6211\u4eec\u521a\u83b7\u53d6\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u505a\u4e3a\u989c\u8272\u9644\u4ef6\u8fdb\u884c\u7ed1\u5b9a\u3002 VkSemaphore signalSemaphores[] = {renderFinishedSemaphore}; submitInfo.signalSemaphoreCount = 1; submitInfo.pSignalSemaphores = signalSemaphores; C++ signalSemaphoreCount \u548c pSignalSemaphores \u53c2\u6570\u6307\u5b9a\u4e86\u5f53\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u7ed3\u675f\u5411\u54ea\u4e9b\u4fe1\u53f7\u91cf\u53d1\u51fa\u4fe1\u53f7\u3002\u6839\u636e\u6211\u4eec\u7684\u9700\u8981\u4f7f\u7528 renderFinishedSemaphore \u3002 if (vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE) != VK_SUCCESS) { throw std::runtime_error(\"failed to submit draw command buffer!\"); } C++ \u4f7f\u7528 vkQueueSubmit \u51fd\u6570\u5411\u56fe\u50cf\u961f\u5217\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u5f53\u5f00\u9500\u8d1f\u8f7d\u6bd4\u8f83\u5927\u7684\u65f6\u5019\uff0c\u5904\u4e8e\u6548\u7387\u8003\u8651\uff0c\u51fd\u6570\u53ef\u4ee5\u6301\u6709 VkSubmitInfo \u7ed3\u6784\u4f53\u6570\u7ec4\u3002\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u5f15\u7528\u4e86\u4e00\u4e2a\u53ef\u9009\u7684\u6805\u680f\uff0c\u5f53\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u5b8c\u6bd5\u65f6\u5019\u5b83\u4f1a\u88ab\u53d1\u9001\u4fe1\u53f7\u3002\u6211\u4eec\u4f7f\u7528\u4fe1\u53f7\u91cf\u8fdb\u884c\u540c\u6b65\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4f20\u9012 VK_NULL_HANDLE \u3002","title":"\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#subpass","text":"\u8bf7\u8bb0\u4f4f\uff0c\u6e32\u67d3\u901a\u9053\u4e2d\u7684\u5b50\u901a\u9053\u4f1a\u81ea\u52a8\u5904\u7406\u5e03\u5c40\u7684\u53d8\u6362\u3002\u8fd9\u4e9b\u53d8\u6362\u901a\u8fc7\u5b50\u901a\u9053\u7684\u4f9d\u8d56\u5173\u7cfb\u8fdb\u884c\u63a7\u5236\uff0c\u5b83\u4eec\u6307\u5b9a\u4e86\u5f7c\u6b64\u4e4b\u95f4\u5185\u5b58\u548c\u6267\u884c\u7684\u4f9d\u8d56\u5173\u7cfb\u3002\u73b0\u5728\u53ea\u6709\u4e00\u4e2a\u5b50\u901a\u9053\uff0c\u4f46\u662f\u5728\u6b64\u5b50\u901a\u9053\u4e4b\u524d\u548c\u4e4b\u540e\u7684\u64cd\u4f5c\u4e5f\u88ab\u89c6\u4e3a\u9690\u5f0f\u201c\u5b50\u901a\u9053\u201d\u3002 \u6709\u4e24\u4e2a\u5185\u7f6e\u7684\u4f9d\u8d56\u5173\u7cfb\u5728\u6e32\u67d3\u901a\u9053\u5f00\u59cb\u548c\u6e32\u67d3\u901a\u9053\u7ed3\u675f\u5904\u7406\u8f6c\u6362\uff0c\u4f46\u662f\u524d\u8005\u4e0d\u4f1a\u5728\u5f53\u4e0b\u53d1\u751f\u3002\u5047\u8bbe\u8f6c\u6362\u53d1\u751f\u5728\u7ba1\u7ebf\u7684\u8d77\u59cb\u9636\u6bb5\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u83b7\u53d6\u56fe\u50cf\uff01\u6709\u4e24\u4e2a\u65b9\u6cd5\u5904\u7406\u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u5c06 imageAvailableSemaphore \u7684 waitStages \u66f4\u6539\u4e3a VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT \uff0c\u786e\u4fdd\u56fe\u50cf\u6709\u6548\u4e4b\u524d\u6e32\u67d3\u901a\u9053\u4e0d\u4f1a\u5f00\u59cb\uff0c\u6216\u8005\u6211\u4eec\u8ba9\u6e32\u67d3\u901a\u9053\u7b49\u5f85 VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT \u9636\u6bb5\u3002\u6211\u89c9\u5f97\u4f7f\u7528\u7b2c\u4e8c\u4e2a\u9009\u9879\uff0c\u56e0\u4e3a\u53ef\u4ee5\u6bd4\u8f83\u5168\u9762\u7684\u4e86\u89e3 subpass \u4f9d\u8d56\u5173\u7cfb\u53ca\u5176\u5de5\u4f5c\u65b9\u5f0f\u3002 \u5b50\u901a\u9053\u4f9d\u8d56\u5173\u7cfb\u53ef\u4ee5\u901a\u8fc7 VkSubpassDependency \u7ed3\u6784\u4f53\u6307\u5b9a\uff0c\u5728 createRenderPass \u51fd\u6570\u4e2d\u6dfb\u52a0: VkSubpassDependency dependency = {}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; C++ \u524d\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u4f9d\u8d56\u7684\u5173\u7cfb\u548c\u4ece\u5c5e\u5b50\u901a\u9053\u7684\u7d22\u5f15\u3002\u7279\u6b8a\u503c VK_SUBPASS_EXTERNAL \u662f\u6307\u5728\u6e32\u67d3\u901a\u9053\u4e4b\u524d\u6216\u8005\u4e4b\u540e\u7684\u9690\u5f0f\u5b50\u901a\u9053\uff0c\u53d6\u51b3\u4e8e\u5b83\u662f\u5426\u5728 srcSubpass \u6216\u8005 dstSubPass \u4e2d\u6307\u5b9a\u3002\u7d22\u5f150\u6307\u5b9a\u6211\u4eec\u7684\u5b50\u901a\u9053\uff0c\u8fd9\u662f\u7b2c\u4e00\u4e2a\u4e5f\u662f\u552f\u4e00\u7684\u3002 dstSubpass \u5fc5\u987b\u59cb\u7ec8\u9ad8\u4e8e srcSubPass \u4ee5\u9632\u6b62\u4f9d\u8d56\u5173\u7cfb\u51fa\u73b0\u5faa\u73af\u3002 dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u5b57\u6bb5\u6307\u5b9a\u8981\u7b49\u5f85\u7684\u64cd\u4f5c\u548c\u8fd9\u4e9b\u64cd\u4f5c\u53d1\u751f\u7684\u9636\u6bb5\u3002\u5728\u6211\u4eec\u53ef\u4ee5\u8bbf\u95ee\u5bf9\u8c61\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u7b49\u5f85\u4ea4\u6362\u94fe\u5b8c\u6210\u5bf9\u5e94\u56fe\u50cf\u7684\u8bfb\u53d6\u64cd\u4f5c\u3002\u8fd9\u53ef\u4ee5\u901a\u8fc7\u7b49\u5f85\u989c\u8272\u9644\u4ef6\u8f93\u51fa\u7684\u9636\u6bb5\u6765\u5b9e\u73b0\u3002 dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; C++ \u5728\u989c\u8272\u9644\u4ef6\u9636\u6bb5\u7684\u64cd\u4f5c\u53ca\u6d89\u53ca\u989c\u8272\u9644\u4ef6\u7684\u8bfb\u53d6\u548c\u5199\u5165\u7684\u64cd\u4f5c\u5e94\u8be5\u7b49\u5f85\u3002\u8fd9\u4e9b\u8bbe\u7f6e\u5c06\u963b\u6b62\u8f6c\u6362\u53d1\u751f\uff0c\u76f4\u5230\u5b9e\u9645\u9700\u8981(\u5e76\u5141\u8bb8):\u5f53\u6211\u4eec\u9700\u8981\u5199\u5165\u989c\u8272\u65f6\u5019\u3002 renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; C++ VkRenderPassCreateInfo \u7ed3\u6784\u4f53\u6709\u4e24\u4e2a\u5b57\u6bb5\u6307\u5b9a\u4f9d\u8d56\u7684\u6570\u7ec4\u3002","title":"Subpass \u4f9d\u8d56\u6027"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_53","text":"\u7ed8\u5236\u5e27\u6700\u540e\u4e00\u4e2a\u6b65\u9aa4\u662f\u5c06\u7ed3\u679c\u63d0\u4ea4\u5230\u4ea4\u6362\u94fe\uff0c\u4f7f\u5176\u6700\u7ec8\u663e\u793a\u5728\u5c4f\u5e55\u4e0a\u3002 Presentation \u901a\u8fc7 VkPresentInfoKHR \u7ed3\u6784\u4f53\u914d\u7f6e\uff0c\u5177\u4f53\u4f4d\u7f6e\u5728 drawFrame \u51fd\u6570\u6700\u540e\u3002 VkPresentInfoKHR presentInfo = {}; presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR; presentInfo.waitSemaphoreCount = 1; presentInfo.pWaitSemaphores = signalSemaphores; C++ \u524d\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u5728\u8fdb\u884cpresentation\u4e4b\u524d\u8981\u7b49\u5f85\u7684\u4fe1\u53f7\u91cf\uff0c\u5c31\u50cf VkSubmitInfo \u4e00\u6837\u3002 VkSwapchainKHR swapChains[] = {swapChain}; presentInfo.swapchainCount = 1; presentInfo.pSwapchains = swapChains; presentInfo.pImageIndices = &imageIndex; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u7528\u4e8e\u63d0\u4ea4\u56fe\u50cf\u7684\u4ea4\u6362\u94fe\u548c\u6bcf\u4e2a\u4ea4\u6362\u94fe\u56fe\u50cf\u7d22\u5f15\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4ec5\u4e00\u4e2a\u3002 presentInfo.pResults = nullptr; // Optional C++ \u6700\u540e\u4e00\u4e2a\u53ef\u9009\u53c2\u6570 pResults \uff0c\u5b83\u5141\u8bb8\u6307\u5b9a\u4e00\u7ec4 VkResult \u503c\uff0c\u4ee5\u4fbf\u5728 presentation \u6210\u529f\u65f6\u68c0\u67e5\u6bcf\u4e2a\u72ec\u7acb\u7684\u4ea4\u6362\u94fe\u3002\u5982\u679c\u53ea\u4f7f\u7528\u5355\u4e2a\u4ea4\u6362\u94fe\uff0c\u5219\u4e0d\u9700\u8981\uff0c\u56e0\u4e3a\u53ef\u4ee5\u7b80\u5355\u7684\u4f7f\u7528\u5f53\u524d\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002 vkQueuePresentKHR(presentQueue, &presentInfo); C++ vkQueuePresentKHR \u51fd\u6570\u63d0\u4ea4\u8bf7\u6c42\u5448\u73b0\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u3002\u6211\u4eec\u5728\u4e0b\u4e00\u4e2a\u7ae0\u8282\u4e3a vkAcquireNextImageKHR \u548c vkQueuePresentKHR \u53ef\u4ee5\u6dfb\u52a0\u9519\u8bef\u5904\u7406\u3002\u56e0\u4e3a\u5b83\u4eec\u5931\u8d25\u5e76\u4e0d\u4e00\u5b9a\u610f\u5473\u7740\u7a0b\u5e8f\u5e94\u8be5\u7ec8\u6b62\uff0c\u4e0e\u6211\u4eec\u8fc4\u4eca\u4e3a\u6b62\u770b\u5230\u7684\u529f\u80fd\u4e0d\u540c\u3002 \u5982\u679c\u4e00\u5207\u987a\u5229\uff0c\u5f53\u518d\u6b21\u8fd0\u884c\u7a0b\u5e8f\u65f6\u5019\uff0c\u5e94\u8be5\u53ef\u4ee5\u770b\u5230\u4e00\u4e0b\u5185\u5bb9: \u9057\u61be\u7684\u662f\uff0c\u53ea\u8981\u7a0b\u5e8f\u5173\u95ed\uff0c\u7531\u4e8e\u5f00\u542f\u4e86validation layers\u4f60\u5c06\u4f1a\u770b\u5230\u7a0b\u5e8f\u5d29\u6e83\u7684\u4fe1\u606f\u3002\u4ece\u7ec8\u7aef\u63a7\u5236\u53f0\u6253\u5370\u7684\u4fe1\u606f\u6765\u6e90 debugCallback \uff0c\u544a\u8bc9\u4e86\u6211\u4eec\u5177\u4f53\u7684\u539f\u56e0: \u9700\u8981\u4e86\u89e3\u7684\u662f drawFrame \u51fd\u6570\u4e2d\u6240\u6709\u7684\u64cd\u4f5c\u90fd\u662f\u5f02\u6b65\u7684\u3002\u610f\u5473\u7740\u5f53\u7a0b\u5e8f\u9000\u51fa mainLoop \uff0c\u7ed8\u5236\u548c\u5448\u73b0\u64cd\u4f5c\u53ef\u80fd\u4ecd\u7136\u5728\u6267\u884c\u3002\u6240\u4ee5\u6e05\u7406\u8be5\u90e8\u5206\u7684\u8d44\u6e90\u662f\u4e0d\u53cb\u597d\u7684\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u5e94\u8be5\u5728\u9000\u51fa mainLoop \u9500\u6bc1\u7a97\u4f53\u524d\u7b49\u5f85\u903b\u8f91\u8bbe\u5907\u7684\u64cd\u4f5c\u5b8c\u6210: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); drawFrame(); } vkDeviceWaitIdle(device); } C++ \u4e5f\u53ef\u4ee5\u4f7f\u7528 vkQueueWaitIdle \u7b49\u5f85\u7279\u5b9a\u547d\u4ee4\u961f\u5217\u4e2d\u7684\u64cd\u4f5c\u5b8c\u6210\u3002\u8fd9\u4e9b\u529f\u80fd\u53ef\u4ee5\u4f5c\u4e3a\u4e00\u4e2a\u975e\u5e38\u57fa\u672c\u7684\u65b9\u5f0f\u6765\u6267\u884c\u540c\u6b65\u3002\u8fd9\u4e2a\u65f6\u5019\u7a97\u4f53\u5173\u95ed\u540e\u8be5\u95ee\u9898\u4e0d\u4f1a\u51fa\u73b0\u3002","title":"\u5448\u73b0"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_54","text":"\u5982\u679c\u8fd0\u884c\u65f6\u542f\u7528\u4e86 validation layers \u5e76\u76d1\u89c6\u5e94\u7528\u7a0b\u5e8f\u7684\u5185\u5b58\u4f7f\u7528\u60c5\u51b5\uff0c\u4f60\u4f1a\u53d1\u73b0\u5b83\u5728\u6162\u6162\u589e\u52a0\u3002\u539f\u56e0\u662f validation layers \u7684\u5b9e\u73b0\u671f\u671b\u4e0e GPU \u540c\u6b65\u3002\u867d\u7136\u5728\u6280\u672f\u4e0a\u662f\u4e0d\u9700\u8981\u7684\uff0c\u4f46\u662f\u4e00\u65e6\u8fd9\u6837\u505a\uff0c\u6bcf\u4e00\u9488\u5e27\u4e0d\u4f1a\u51fa\u73b0\u660e\u663e\u7684\u6027\u80fd\u5f71\u54cd\u3002 \u6211\u4eec\u53ef\u4ee5\u5728\u5f00\u59cb\u7ed8\u5236\u4e0b\u4e00\u5e27\u4e4b\u524d\u660e\u786e\u7684\u7b49\u5f85 presentation \u5b8c\u6210: void drawFrame() { ... vkQueuePresentKHR(presentQueue, &presentInfo); vkQueueWaitIdle(presentQueue); } C++ \u5728\u5f88\u591a\u5e94\u7528\u7a0b\u5e8f\u7684\u7684\u72b6\u6001\u4e5f\u4f1a\u5728\u6bcf\u4e00\u5e27\u66f4\u65b0\u3002\u4e3a\u6b64\u66f4\u9ad8\u6548\u7684\u7ed8\u5236\u4e00\u9635\u7684\u65b9\u5f0f\u5982\u4e0b\uff1a void drawFrame() { updateAppState(); vkQueueWaitIdle(presentQueue); vkAcquireNextImageKHR(...) submitDrawCommands(); vkQueuePresentKHR(presentQueue, &presentInfo); } C++ \u8be5\u65b9\u6cd5\u5141\u8bb8\u6211\u4eec\u66f4\u65b0\u5e94\u7528\u7a0b\u5e8f\u7684\u72b6\u6001\uff0c\u6bd4\u5982\u8fd0\u884c\u6e38\u620f\u7684AI\u534f\u540c\u7a0b\u5e8f\uff0c\u800c\u524d\u4e00\u5e27\u88ab\u6e32\u67d3\u3002\u8fd9\u6837\uff0c\u59cb\u7ec8\u4fdd\u6301 CPU \u548c GPU \u5904\u4e8e\u5de5\u4f5c\u72b6\u6001\u3002","title":"\u5185\u5b58\u6cc4\u6f0f"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_55","text":"\u5927\u7ea6800\u884c\u4ee3\u7801\u4e4b\u540e\uff0c\u6211\u4eec\u7ec8\u4e8e\u770b\u5230\u4e86\u4e09\u89d2\u5f62\u7ed8\u5236\u5728\u5c4f\u5e55\u4e0a\uff01 Vulkan \u5f15\u5bfc\u7a0b\u5e8f\u9700\u8981\u5f88\u591a\u7684\u5de5\u4f5c\u8981\u53bb\u505a\uff0c\u4f46\u597d\u5904\u662f Vulkan \u901a\u8fc7\u8981\u6c42\u6bcf\u4e00\u4e2a\u660e\u786e\u7684\u5b9e\u73b0\uff0c\u5e26\u6765\u4e86\u4e86\u5de8\u5927\u7684\u63a7\u5236\u6743\u3002\u5efa\u8bae\u82b1\u8d39\u4e00\u4e9b\u65f6\u95f4\u91cd\u65b0\u8bfb\u4ee3\u7801\uff0c\u5e76\u5efa\u7acb\u4e00\u4e2a\u601d\u7ef4\u5bfc\u56fe\u6a21\u578b\uff0c\u76ee\u7684\u5728\u4e8e\u4e86\u89e3 Vulkan \u4e2d\u6bcf\u4e00\u4e2a\u5bf9\u8c61\uff0c\u4ee5\u53ca\u5b83\u4eec\u7684\u4e92\u76f8\u7684\u5173\u7cfb\u3002\u4e4b\u540e\u6211\u4eec\u5c06\u4f1a\u57fa\u4e8e\u8fd9\u4e2a\u57fa\u7840\u6784\u5efa\u6269\u5c55\u7a0b\u5e8f\u529f\u80fd\u3002 \u5728\u4e0b\u4e00\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u7ec6\u5316 Vulkan \u7a0b\u5e8f\u4e2d\u7684\u4e00\u4e9b\u7ec6\u8282\uff0c\u4f7f\u5176\u8868\u73b0\u66f4\u7a33\u5b9a\u3002","title":"\u7ed3\u8bba"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_14","text":"Vulkan \u91cd\u6784\u4ea4\u6362\u94fe \uff0c\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6210\u529f\u7684\u5728\u5c4f\u5e55\u4e0a\u7ed8\u5236\u51fa\u4e09\u89d2\u5f62\uff0c\u4f46\u662f\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5b83\u4f1a\u51fa\u73b0\u5f02\u5e38\u60c5\u51b5\u3002\u7a97\u4f53 surface \u4f1a\u53d1\u751f\u6539\u53d8\uff0c\u4f7f\u5f97\u4ea4\u6362\u94fe\u4e0d\u5728\u4e0e\u5176\u517c\u5bb9\u3002\u53ef\u80fd\u5bfc\u81f4\u8fd9\u79cd\u60c5\u51b5\u53d1\u751f\u7684\u539f\u56e0\u4e4b\u4e00\u662f\u7a97\u4f53\u7684\u5927\u5c0f\u53d8\u5316\u3002\u6211\u4eec\u5fc5\u987b\u5728\u8fd9\u4e2a\u65f6\u673a\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe 2 \u7a97\u53e3\u5927\u5c0f\u8c03\u6574 3 \u6b21\u4f18\u6216\u8fc7\u671f\u7684\u4ea4\u6362\u94fe","title":"Vulkan \u91cd\u6784\u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_56","text":"\u6dfb\u52a0\u65b0\u7684\u51fd\u6570 recreateSwapChain \u5e76\u8c03\u7528 createSwapChain \u53ca\u4f9d\u8d56\u4e8e\u4ea4\u6362\u94fe\u6216\u8005\u7a97\u4f53\u5927\u5c0f\u7684\u5bf9\u8c61\u76f8\u5173\u7684\u6240\u6709\u521b\u5efa\u51fd\u6570\u3002 void recreateSwapChain() { vkDeviceWaitIdle(device); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers(); } \u6211\u4eec\u9996\u5148\u8c03\u7528 vkDeviceIdle ,\u5c31\u50cf\u524d\u4e00\u4e2a\u7ae0\u8282\u63d0\u5230\u7684\uff0c\u6211\u4eec\u4e0d\u80fd\u89e6\u78b0\u6b63\u5728\u4f7f\u7528\u4e2d\u7684\u8d44\u6e90\u3002\u5f88\u660e\u663e\uff0c\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u672c\u8eab\u3002\u56fe\u50cf\u89c6\u56fe\u4e5f\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4eec\u76f4\u63a5\u5efa\u7acb\u5728\u4ea4\u6362\u94fe\u56fe\u50cf\u57fa\u7840\u4e0a\u3002\u6e32\u67d3\u901a\u9053\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4f9d\u8d56\u4ea4\u6362\u94fe\u56fe\u50cf\u7684\u683c\u5f0f\u3002\u5728\u7a97\u4f53\u8c03\u6574\u5927\u5c0f\u7684\u64cd\u4f5c\u671f\u95f4\uff0c\u4ea4\u6362\u94fe\u56fe\u50cf\u683c\u5f0f\u5f88\u5c11\u53d1\u751f\u53d8\u5316\uff0c\u4f46\u4ecd\u5e94\u8be5\u88ab\u5904\u7406\u3002\u5728\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u671f\u95f4\u6307\u5b9a Viewport \u548c scissor \u77e9\u5f62\u5927\u5c0f\uff0c\u6240\u4ee5\u7ba1\u7ebf\u9700\u8981\u91cd\u65b0\u6784\u5efa\u3002\u53ef\u4ee5\u4f7f\u7528\u52a8\u6001\u72b6\u6001\u6539\u53d8 viewports \u548c scissor rectangles \uff0c\u907f\u514d\u91cd\u65b0\u521b\u5efa\u3002\u6700\u540e\u5e27\u7f13\u51b2\u533a\u548c\u547d\u4ee4\u7f13\u51b2\u533a\u4e5f\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4eec\u4e5f\u4f9d\u8d56\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u3002 \u4e3a\u4e86\u786e\u4fdd\u91cd\u65b0\u521b\u5efa\u76f8\u5173\u7684\u5bf9\u8c61\u4e4b\u524d\uff0c\u8001\u7248\u672c\u7684\u5bf9\u8c61\u88ab\u7cfb\u7edf\u6b63\u786e\u56de\u6536\u6e05\u7406\uff0c\u6211\u4eec\u9700\u8981\u79fb\u52a8\u4e00\u4e9bcleanup\u4ee3\u7801\u5230\u4e0d\u540c\u7684\u51fd\u6570\u4e2d\uff0c\u8fd9\u6837\u53ef\u4ee5\u5728 recreateSwapChain \u51fd\u6570\u8c03\u7528\u3002\u8be5\u51fd\u6570\u5b9a\u4e49\u4e3a cleanupSwapChain : void cleanupSwapChain() { } void recreateSwapChain() { vkDeviceWaitIdle(device); cleanupSwapChain() createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers(); } \u6211\u4eec\u4ece cleanup \u4e2d\u5c06\u9700\u8981\u88ab\u91cd\u65b0\u521b\u5efa\u7684\u5bf9\u8c61\u6240\u5bf9\u5e94\u7684\u6e05\u7406\u4ee3\u7801\u79fb\u52a8\u5230 cleanupSwapChain \u4e2d: void cleanupSwapChain() { for (size_t i = 0; i < swapChainFramebuffers.size(); i++) { vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); } vkFreeCommandBuffers(device, commandPool, static_cast<uint32_t>(commandBuffers.size()), commandBuffers.data()); vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); for (size_t i = 0; i < swapChainImageViews.size(); i++) { vkDestroyImageView(device, swapChainImageViews[i], nullptr); } vkDestroySwapchainKHR(device, swapChain, nullptr); } void cleanup() { cleanupSwapChain(); vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); vkDestroyCommandPool(device, commandPool, nullptr); vkDestroyDevice(device, nullptr); DestroyDebugReportCallbackEXT(instance, callback, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate(); } \u6211\u4eec\u91cd\u5934\u521b\u5efa\u547d\u4ee4\u5bf9\u8c61\u6c60 command pool \uff0c\u4f46\u662f\u6bd4\u8f83\u6d6a\u8d39\u770b\u8d77\u6765\u3002\u76f8\u53cd\u7684\uff0c\u6211\u4eec\u9009\u62e9\u501f\u52a9 vkFreeCommandBuffers \u51fd\u6570\u6e05\u7406\u5df2\u7ecf\u5b58\u5728\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u8fd9\u79cd\u65b9\u5f0f\u53ef\u4ee5\u91cd\u7528\u5bf9\u8c61\u6c60\u4e2d\u5df2\u7ecf\u5206\u914d\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002 \u4ee5\u4e0a\u90e8\u5206\u5c31\u662f\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u7684\u5de5\u4f5c\uff01\u7136\u800c\u8fd9\u6837\u505a\u7684\u7f3a\u70b9\u5c31\u662f\u5728\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u5b8c\u6bd5\u4e4b\u524d\uff0c\u4f1a\u9020\u6210\u6e32\u67d3\u505c\u6b62\u3002\u521b\u5efa\u65b0\u4ea4\u6362\u94fe\u7684\u540c\u65f6\u5141\u8bb8\u5728\u65e7\u7684\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u4e0a\u7ee7\u7eed\u7ed8\u5236\u547d\u4ee4\u3002\u9700\u8981\u5c06\u4e4b\u524d\u7684\u4ea4\u6362\u94fe\u4f20\u9012\u5230 VkSwapchainCreateInfoKHR \u7ed3\u6784\u4f53\u4e2d\u7684 oldSwapChain \u5b57\u6bb5\uff0c\u5e76\u5728\u4f7f\u7528\u4e4b\u540e\u7acb\u5373\u9500\u6bc1\u3002","title":"\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_57","text":"\u73b0\u5728\u6211\u4eec\u9700\u8981\u641e\u6e05\u695a\u54ea\u4e9b\u60c5\u51b5\u4e0b\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u662f\u5fc5\u8981\u7684\uff0c\u5e76\u8c03\u7528 recreateSwapChain \u51fd\u6570\u3002\u4e00\u4e2a\u901a\u5e38\u7684\u6761\u4ef6\u662f\u7a97\u4f53\u7684\u5927\u5c0f\u53d8\u5316\u3002\u8ba9\u6211\u4eec\u8c03\u6574\u7a97\u4f53\u7684\u5927\u5c0f\uff0c\u5e76\u89c2\u5bdf\u6355\u6349\u5230\u7684\u4e8b\u4ef6\u3002\u4fee\u6539 initWindow \u51fd\u6570\u4e0d\u518d\u5305\u542b GLFW_RESIZABLE \u884c\uff0c\u6216\u8005\u5c06\u5176\u53c2\u6570\u4ece GLFW_FALSE \u4fee\u6539\u4e3a GLFW_TRUE \u3002 void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); glfwSetWindowUserPointer(window, this); glfwSetWindowSizeCallback(window, HelloTriangleApplication::onWindowResized); } ... static void onWindowResized(GLFWwindow* window, int width, int height) { if (width == 0 || height == 0) return; HelloTriangleApplication* app = reinterpret_cast<HelloTriangleApplication*>(glfwGetWindowUserPointer(window)); app->recreateSwapChain(); } C++ glfwSetWindowSizeCallback \u51fd\u6570\u4f1a\u5728\u7a97\u4f53\u53d1\u751f\u5927\u5c0f\u53d8\u5316\u7684\u65f6\u5019\u88ab\u4e8b\u4ef6\u56de\u8c03\u3002\u9057\u61be\u7684\u662f\uff0c\u5b83\u53ea\u80fd\u63a5\u53d7\u4e00\u4e2a\u6307\u9488\u4f5c\u4e3a\u53c2\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u76f4\u63a5\u4f7f\u7528\u6210\u5458\u51fd\u6570\u3002\u4f46\u5e78\u8fd0\u7684\u662f\uff0cGLFW\u5141\u8bb8\u6211\u4eec\u4f7f\u7528 glfwSetWindowUserPointer \u5c06\u4efb\u610f\u6307\u9488\u5b58\u50a8\u5728\u7a97\u4f53\u5bf9\u8c61\u4e2d\uff0c\u56e0\u6b64\u53ef\u4ee5\u6307\u5b9a\u9759\u6001\u7c7b\u6210\u5458\u8c03\u7528 glfwGetWindowUserPointer \u8fd4\u56de\u539f\u59cb\u7684\u5b9e\u4f8b\u5bf9\u8c61\u3002\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528 recreateSwapChain \uff0c\u8fd9\u79cd\u60c5\u51b5\u901a\u5e38\u53d1\u751f\u5728\uff0c\u7a97\u4f53\u6700\u5c0f\u5316\u5e76\u4e14\u5bfc\u81f4\u4ea4\u6362\u94fe\u521b\u5efa\u5931\u8d25\u65f6. chooseSwapExtent \u51fd\u6570\u5e94\u8be5\u589e\u52a0\u66f4\u65b0\u903b\u8f91\uff0c\u4f7f\u7528\u7a97\u4f53\u6700\u65b0\u7684 width \u548c height \u4ee3\u66ff\u6700\u521d\u7684 WIDTH \u548c HEIGHT : int width, height; glfwGetWindowSize(window, &width, &height); VkExtent2D actualExtent = {width, height}; C++","title":"\u7a97\u53e3\u5927\u5c0f\u8c03\u6574"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_58","text":"\u6709\u4e9b\u65f6\u5019 Vulkan \u53ef\u80fd\u544a\u8bc9\u6211\u4eec\u5f53\u524d\u7684\u4ea4\u6362\u94fe\u5728 presentation \u65f6\u4e0d\u518d\u517c\u5bb9\u3002 vkAcquireNextImageKHR \u548c vkQueuePresentKHR \u51fd\u6570\u53ef\u4ee5\u8fd4\u56de\u5177\u4f53\u7684\u503c\u660e\u786e\u3002 VK_ERROR_OUT_DATE_KHR : \u4ea4\u6362\u94fe\u4e0esurface\u4e0d\u518d\u517c\u5bb9\uff0c\u4e0d\u53ef\u8fdb\u884c\u6e32\u67d3 VK_SUBOPTIMAL_KHR : \u4ea4\u6362\u94fe\u4ecd\u7136\u53ef\u4ee5\u5411surface\u63d0\u4ea4\u56fe\u50cf\uff0c\u4f46\u662fsurface\u7684\u5c5e\u6027\u4e0d\u518d\u5339\u914d\u51c6\u786e\u3002\u6bd4\u5982\u5e73\u53f0\u53ef\u80fd\u91cd\u65b0\u8c03\u6574\u56fe\u50cf\u7684\u5c3a\u5bf8\u9002\u5e94\u7a97\u4f53\u5927\u5c0f\u3002 VkResult result = vkAcquireNextImageKHR(device, swapChain, std::numeric_limits<uint64_t>::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex); if (result == VK_ERROR_OUT_OF_DATE_KHR) { recreateSwapChain(); return; } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) { throw std::runtime_error(\"failed to acquire swap chain image!\"); } C++ \u5982\u679c\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf timeout \uff0c\u8868\u660e\u4e0d\u518d\u53ef\u7528\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u7acb\u5373\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\uff0c\u5e76\u5728\u4e0b\u4e00\u6b21 drawFrame \u8c03\u7528\u4e2d\u5c1d\u8bd5\u83b7\u53d6\u3002 \u4f60\u4e5f\u53ef\u4ee5\u9009\u62e9\u5728\u4ea4\u6362\u94fe\u4e0d\u662f\u6700\u4f73\u72b6\u6001\u7684\u65f6\u5019\uff0c\u9009\u62e9\u91cd\u65b0\u521b\u5efa\uff0c\u6bd4\u5982\u521a\u624d\u8bf4\u7684\u5927\u5c0f\u4e0d\u5339\u914d\u95ee\u9898\u3002\u5728\u8fd9\u91cc\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u83b7\u5f97\u4e86\u4e00\u4e2a\u56fe\u50cf\uff0c\u6240\u4ee5\u7ee7\u7eed\u8fdb\u884c\u3002 VK_SUCCESS \u548c VK_SUBOPTIMAL_KHR \u90fd\u88ab\u8ba4\u4e3a\u662f\u201c\u6210\u529f\u201d\u8fd4\u56de\u7801\u3002 result = vkQueuePresentKHR(presentQueue, &presentInfo); if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) { recreateSwapChain(); } else if (result != VK_SUCCESS) { throw std::runtime_error(\"failed to present swap chain image!\"); } vkQueueWaitIdle(presentQueue); vkQueuePresentKHR \u51fd\u6570\u8fd4\u56de\u540c\u6837\u7684\u503c\u3002\u5728\u6211\u4eec\u7684\u6848\u4f8b\u4e2d\u6211\u4eec\uff0c\u5982\u679c\u662f\u975e\u6700\u4f73\u72b6\u6001\uff0c\u4e5f\u9009\u62e9\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u3002\u56e0\u4e3a\u6211\u4eec\u9700\u8981\u6700\u597d\u7684\u6548\u679c\u3002\u5c1d\u8bd5\u8c03\u6574\u7a97\u4f53\u7684\u5927\u5c0f\uff0c\u5e27\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u53d8\u5316\u4e0e\u7a97\u4f53\u5339\u914d\u3002 Congratulations \uff0c\u6211\u4eec\u5b8c\u7ed3\u4e86\u7b2c\u4e00\u4e2a\u8fd0\u884c\u6bd4\u8f83\u5b8c\u6574\u7684 Vulkan \u7a0b\u5e8f\uff0c\u5728\u4e0b\u9762\u7684\u7ae0\u8282\u4e2d\u6211\u4eec\u5c1d\u8bd5\u6446\u8131\u4e4b\u524d\u7684\u786c\u7f16\u7801\uff0c\u4f7f\u7528\u9876\u70b9\u7f13\u51b2\u533a\u4ee3\u66ff vertex shader \u4e2d\u5199\u6b7b\u9876\u70b9\u6570\u636e\u3002","title":"\u6b21\u4f18\u6216\u8fc7\u671f\u7684\u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_59","text":"","title":"\u7b2c\u4e8c\u7ae0"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_15","text":"","title":"Vulkan \u9876\u70b9\u8f93\u5165"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_16","text":"","title":"Vulkan \u521b\u5efa\u9876\u70b9\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_17","text":"","title":"Vulkan \u4e34\u65f6\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_18","text":"","title":"Vulkan \u7d22\u5f15\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_19","text":"","title":"Vulkan \u63cf\u8ff0\u7b26\u5e03\u5c40\u548c\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_20","text":"","title":"Vulkan \u63cf\u8ff0\u7b26\u6c60\u548c\u96c6\u5408"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan-images","text":"","title":"Vulkan \u56fe\u50cf(Images)"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_21","text":"","title":"Vulkan \u56fe\u50cf\u89c6\u56fe\u548c\u91c7\u6837\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_22","text":"","title":"Vulkan \u7ec4\u5408\u56fe\u50cf\u53d6\u6837\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_23","text":"","title":"Vulkan \u6df1\u5ea6\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_24","text":"","title":"Vulkan \u52a0\u8f7d\u6a21\u578b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan-mipmap","text":"","title":"Vulkan \u751f\u6210\u8d34\u56fe(mipmap)"}]}
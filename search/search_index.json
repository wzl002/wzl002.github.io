{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"\u9996\u9875"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/","text":"Vulkan \u6269\u5c55 (\u672c\u7ae0\u6587\u672c\u5185\u5bb9\u7684\u66f4\u591a\u7ec6\u8282, \u53c2\u89c1 Vulkan Specification 1.1 , \u4ee3\u7801\u4e3a\u793a\u4f8b\u7528\u4f2a\u7801) \u5bf9\u4e8e\u4e0d\u540c\u7684\u5e73\u53f0, \u9a71\u52a8, \u64cd\u4f5c\u7cfb\u7edf\u7b49, \u5f53Vulkan\u7684\u5e95\u5c42\u5b9e\u73b0\u4e0d\u540c\u65f6, Vulkan \u53ef\u7528\u7684\u529f\u80fd\u96c6\u4e5f\u6709\u5f88\u591a\u533a\u522b. \u672c\u7ae0\u63cf\u8ff0\u4e86 Vulkan \u5982\u4f55\u5b9a\u4e49\u548c\u6269\u5c55\u529f\u80fd\u96c6, \u4e3b\u8981\u4ecb\u7ecd\u4e86\u56db\u4e2a\u6982\u5ff5: Extension, Feature, Limitation, \u548c Format. Vulkan \u521d\u59cb\u5316\u6d41\u7a0b \u5728\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u65f6, \u9700\u8981\u542f\u7528\u7684 Vulkan \u529f\u80fd\u96c6\u9700\u8981\u5728\u521d\u59cb\u5316 Device \u524d\u786e\u5b9a\u4e0b\u6765. \u5bf9\u5e94 vk \u521d\u59cb\u5316\u7684\u524d\u4e09\u6b65: Instance --> Physical Device --> Device \u4ee5\u4e0b\u662f\u521d\u59cb\u5316\u8fc7\u7a0b\u4e2d\u4e0e\u529f\u80fd\u76f8\u5173\u7684\u8fc7\u7a0b: \u679a\u4e3e vk \u652f\u6301\u7684 Instance-level Extensions \u521b\u5efa Instance \u679a\u4e3e \u7269\u7406\u8bbe\u5907, \u9009\u62e9 GPU, \u679a\u4e3e GPU \u652f\u6301\u7684 Device Extensions, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u200b \u67e5\u8be2\u652f\u6301\u7684 Extensions \u7684 Features \u7ed3\u6784\u4f53, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u200b \u67e5\u8be2\u652f\u6301\u7684 Extensions \u7684 Properties \u7ed3\u6784\u4f53 \u67e5\u8be2 GPU \u652f\u6301\u7684 Feature, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u67e5\u8be2 GPU \u7684 Properties \u5c06\u542f\u7528\u7684 Extensions \u548c Features \u5217\u8868\u653e\u5165 CreateInfo \u7ed3\u6784\u4f53, \u521b\u5efa\u903b\u8f91\u8bbe\u5907 Device, Extension: \u529f\u80fd\u96c6\u7684\u62bd\u8c61\u6982\u5ff5, \u7528\u6765\u4e3a Vulkan \u6dfb\u52a0\u65b0\u7684 Commands\uff0cStructures \u548c Enumerants. \u540c\u65f6\u53ef\u80fd\u65b0\u589e Features, Limitations, \u548c Format. Feature: bool \u503c\u96c6\u5408, \u53ef\u9009\u529f\u80fd\u7684\u5f00\u5173. \u53ef\u4ee5\u7528\u6765\u67e5\u8be2\u8bbe\u5907\u652f\u6301\u7684\u529f\u80fd, Limitation \u548c Format \u662f\u4e24\u4e2a\u53ea\u8bfb\u53c2\u6570\u96c6, Limitation \u53c8\u79f0\u505a Properties, \u8868\u793a\u8bbe\u5907\u7279\u5f81\u503c; Format \u8868\u793a\u652f\u6301\u7684\u683c\u5f0f. \u672c\u7ae0\u540e\u9762\u5404\u7ae0\u8282\u5bf9\u6b64\u6d41\u7a0b\u5404\u6b65\u9aa4\u8fdb\u884c\u89e3\u91ca, \u5e76\u5305\u542b\u793a\u4f8b\u4ee3\u7801. Extensions: \u6269\u5c55 \u6269\u5c55 (Extensions) \u53ef\u7528\u6765\u4e3a Vk \u6dfb\u52a0\u65b0\u529f\u80fd. Vk \u6838\u5fc3\u7684\u65b0\u7248\u672c (\u5982: VK_VERSION_1_1) \u4e5f\u53ef\u4ee5\u89c6\u4e3a\u4e00\u4e2a\u6269\u5c55. \u6269\u5c55\u53ef\u4ee5\u5b9a\u4e49\u65b0\u7684 \u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784. ( Commands\uff0cStructures \u548c Enumerants) \u6269\u5c55\u5206\u4e3a\u5b9e\u4f8b\u7ea7\u548c\u8bbe\u5907\u7ea7 (Instance-level \u548c Device-level) \u5f53 Commands \u7528\u6765\u679a\u4e3e\u5b9e\u4f8b\u5c5e\u6027 (instance properties), \u6216\u63a5\u53d7 VkInstance \u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570, \u5219\u88ab\u89c6\u4e3a\u5b9e\u4f8b\u7ea7\u529f\u80fd\u3002 \u5f53 Commands \u7528\u6765\u679a\u4e3e\u7269\u7406\u8bbe\u5907\u5c5e\u6027 (physical device properties), \u6216\u63a5\u53d7 VkDevice \u53ca\u5176\u5b50\u7c7b\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\uff0c\u5219\u88ab\u89c6\u4e3a\u8bbe\u5907\u7ea7\u529f\u80fd\u3002 \u4e3a\u4e86\u65b9\u4fbf\u7f16\u8bd1\uff0c\u5728 Khronos \u63d0\u4f9b\u7684 vulkan_core.h \u4e2d\u9664\u4e86\u6838\u5fc3API, \u8fd8\u5b9a\u4e49\u4e86\u5df2\u6ce8\u518c Extensions \u5b9a\u4e49\u7684\u63a5\u53e3\uff0c\u5305\u62ec\u65b0 \u7ed3\u6784, \u679a\u4e3e, \u548c\u547d\u4ee4\u7684\u51fd\u6570\u6307\u9488\u7c7b\u578b\u3002\u6269\u5c55\u7684\u5b9e\u73b0\u901a\u8fc7 Layers \u548c Vulkan\u5b9e\u73b0\u6765\u63d0\u4f9b\u3002 \u542f\u7528 Vk Extensions Vk Extensions \u9700\u8981\u5728\u521d\u59cb\u5316\u9636\u6bb5\u663e\u5f0f\u542f\u7528. \u542f\u7528 instance extension, \u8981\u5728\u521b\u5efa VKInstance \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkInstanceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. \u542f\u7528 device extension, \u8981\u5728 \u521b\u5efa VkDevice \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkDeviceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. Physical-Device-Level \u529f\u80fd\u6ca1\u6709\u542f\u7528\u673a\u5236\uff0c\u53ea\u8981 VkPhysicalDevice \u7684\u529f\u80fd\u5bf9\u5e94\u7684 Extensions \u5728\u679a\u4e3e\u51fd\u6570 vkEnumerateDeviceExtensionProperties \u4e2d\u88ab\u5217\u51fa. \u4ec5 \u542f\u7528 \u6269\u5c55\u64cd\u4f5c\u800c\u8a00, \u9664\u4e86 \u542f\u7528 \u8be5\u6269\u5c55\u81ea\u8eab\u5b9a\u4e49\u7684\u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784\u5916, \u4e0d\u4f1a\u66f4\u6539\u6838\u5fc3Vulkan API \u6216\u5176\u4ed6\u6269\u5c55\u7684\u529f\u80fd\u3002 \u793a\u4f8b: \u521b\u5efa VkInstance \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> extensions(); extensions.push_back(VK_KHR_WIN32_SURFACE_EXTENSION_NAME); VkInstanceCreateInfo inst_info = {}; inst_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; ... // Enable Instance Extensions inst_info.enabledExtensionCount = extensions.size(); inst_info.ppEnabledExtensionNames = extensions.data(); VkInstance instance; VkResult res = vkCreateInstance(&inst_info, NULL, &instance); \u5bf9 VkPhysicalDevice, \u679a\u4e3e\u5176\u652f\u6301\u7684 Extensions: // \u679a\u4e3e\u8bbe\u5907 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); // \u9009\u62e9\u8bbe\u5907 VkPhysicalDevice physicalDevice = devices[0]; // \u4ec5\u793a\u4f8b,\u6b63\u786e\u4ee3\u7801\u5e94\u9009\u62e9\u5bf9\u5e94 GPU \u8bbe\u5907 // \u679a\u4e3e Extensions uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, availableExtensions.data()); \u521b\u5efa VkDevice \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> device_extension_names(); // check if physicalDevice support extension: for (const auto& extension : availableExtensions) { if(strcmp(extension.extensionName, VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0) device_extension_names.push_back(extension.extensionName); } } VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; device_info.pNext = NULL; ... // Enable Device Extensions device_info.enabledExtensionCount = device_extension_names.size(); device_info.ppEnabledExtensionNames = enabledExtensionCount ? device_extension_names.data() : NULL; VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device); Features: \u529f\u80fd Features \u7528\u6765\u8bbe\u7f6e\u6216\u67e5\u8be2 \u975e\u6240\u6709\u5b9e\u73b0\u90fd\u652f\u6301 \u7684\u529f\u80fd\u3002 Feature \u5747\u4e3a bool \u503c. Features \u662f\u7269\u7406\u8bbe\u5907\u7684\u5c5e\u6027\u3002(physical device properties) \u8fd9\u4e9b\u529f\u80fd\u662f\u201c\u53ef\u9009\u201d\u7684\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u4f7f\u7528\u524d\u660e\u786e\u542f\u7528\u3002 \u6838\u5fc3 Features Vk \u6838\u5fc3\u4e2d\u5b9a\u4e49\u7684 Features, \u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceFeatures \u67e5\u8be2. VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); \u67e5\u8be2\u7ed3\u679c VkPhysicalDeviceFeatures \u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceFeatures { VkBool32 robustBufferAccess; VkBool32 fullDrawIndexUint32; VkBool32 imageCubeArray; VkBool32 independentBlend; VkBool32 geometryShader; VkBool32 tessellationShader; VkBool32 sampleRateShading; .... // \u603b\u8ba150+\u4e2a Bool \u503c } VkPhysicalDeviceFeatures \u5176\u4e2d\u6bcf\u4e2a Feature \u7684\u542b\u4e49 \u5728 Vulkan Specification 1.1/Features \u4e2d\u90fd\u6709\u89e3\u91ca. \u4f8b\u5982: IndependentBlend \u6307\u5b9a: \u662f\u5426\u6bcf\u4e2a attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u4e92\u76f8\u72ec\u7acb\u3002 \u672a\u542f\u7528\u6b64 Feature\uff0c\u5219\u6240\u6709 color attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u5fc5\u987b\u76f8\u540c\u3002 \u82e5\u542f\u7528\u6b64 Feature\uff0c\u5219\u53ef\u4ee5\u4e3a\u6bcf\u4e2a\u7ed1\u5b9a\u7684 color attachment \u63d0\u4f9b\u4e0d\u540c\u7684 VkPipelineColorBlendAttachmentState \u3002 \u6269\u5c55\u63d0\u4f9b\u7684Features \u67e5\u8be2\u51fd\u6570: vkGetPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 physicalDeviceFeatures2; vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &physicalDeviceFeatures2); \u67e5\u8be2\u7ed3\u679c: VkPhysicalDeviceFeatures2 \u7ed3\u6784: // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; sType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 pNext: \u6307\u9488\u94fe. VkPhysicalDeviceFeatures: Vulkan 1.0 \u63d0\u4f9b\u7684\u6838\u5fc3 Features \u6ce8: VkPhysicalDeviceFeatures2 \u7b49\u4ef7 VkPhysicalDeviceFeatures2KHR, vkGetPhysicalDeviceFeatures2 \u7b49\u4ef7 vkGetPhysicalDeviceFeatures2KHR \u901a\u8fc7 pNext , \u53ef\u4ee5\u83b7\u5f97\u6269\u5c55\u6240\u5b9a\u4e49\u7684 Features \u7ed3\u6784\u4f53, \u6709\u7684\u7531 Vulkan \u6838\u5fc3\u65b0\u7248\u672c\u63d0\u4f9b, \u6709\u7684\u7531\u5176\u4ed6 Extension\u63d0\u4f9b. \u4f8b\u5982: Vulkan 1.1 \u63d0\u4f9b\u7684 samplerYcbcrConversion. // Provided by VK_VERSION_1_1: VK_KHR_sampler_ycbcr_conversion typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures { VkStructureType sType; void* pNext; VkBool32 samplerYcbcrConversion; } VkPhysicalDeviceSamplerYcbcrConversionFeatures; VK_EXT_transform_feedback \u63d0\u4f9b\u7684 transformFeedback \u548c geometryStreams. // Provided by VK_EXT_transform_feedback typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 transformFeedback; VkBool32 geometryStreams; } VkPhysicalDeviceTransformFeedbackFeaturesEXT; \u67e5\u8be2\u793a\u4f8b: // \u6269\u5c55\u7684 Feature \u7ed3\u6784\u4f53 VkPhysicalDeviceSamplerYcbcrConversionFeatures mSamplerYcbcrConversionFeatures = {}; mSamplerYcbcrConversionFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; // vk1.1 \u7684 VkPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 deviceFeatures = {}; deviceFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; deviceFeatures.pNext = mVertexAttributeDivisorFeatures // \u67e5\u8be2 vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &deviceFeatures); // \u4f7f\u7528 if (mVertexAttributeDivisorFeatures.vertexAttributeInstanceRateDivisor) { ... } \u542f\u7528 Features Features \u9ed8\u8ba4\u7686\u4e3a\u4e0d\u542f\u7528\u72b6\u6001. \u5fc5\u987b\u5728 VkDevice \u521b\u5efa\u65f6\u663e\u5f0f\u542f\u7528\u3002\u5982\u679c\u542f\u7528\u4e86\u7269\u7406\u8bbe\u5907\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5219 VkDevice \u521b\u5efa\u5c06\u5931\u8d25\uff0c\u5e76\u8fd4\u56deVK_ERROR_FEATURE_NOT_PRESENT\u3002 \u542f\u7528\u65b9\u6cd5: \u521b\u5efa VkPhysicalDeviceFeatures \u7ed3\u6784\u7684\u6307\u9488 (\u62161.1\u7684 VkPhysicalDeviceFeatures2\u7ed3\u6784) \u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \u6216 VK_FALSE, eg: physicalDeviceFeatures.independentBlend = VK_TRUE \u901a\u8fc7\u4f20\u9012\u7ed9 vkCreateDevice \u7528\u7684 VkDeviceCreateInfo\u7ed3\u6784\u7684 pEnabledFeatures \u6210\u5458. \u8981\u542f\u52a8\u6240\u6709\u8bbe\u5907\u7684\u529f\u80fd (\u614e\u7528)\uff0c\u5219\u53ea\u9700\u4f20\u5165\u67e5\u8be2\u51fd\u6570 vkGetPhysicalDeviceFeatures \u8fd4\u56de\u7684 VkPhysicalDeviceFeatures \u7ed3\u6784\u5373\u53ef\u3002\u8981\u7981\u7528\u5355\u4e2a\u529f\u80fd\uff0c\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728\u76f8\u540c\u7ed3\u6784\u4e2d\u5c06\u6240\u9700\u6210\u5458\u8bbe\u7f6e\u4e3aVK_FALSE\u3002 \u7528\u8fc7\u7ed9 pNext\u94fe\u6dfb\u52a0 Extensions \u63d0\u4f9b\u7684 Features \u7ed3\u6784\u4f53, \u6765\u542f\u7528\u6269\u5c55\u7684 Features. // \u67e5\u8be2\u6838\u5fc3 Features \u662f\u5426\u652f\u6301 VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); // \u8bbe\u7f6e\u542f\u7528 Features VkPhysicalDeviceFeatures2KHR enabledFeatures = {}; enabledFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; enabledFeatures.features.imageCubeArray = mPhysicalDeviceFeatures.imageCubeArray; enabledFeatures.features.independentBlend = mPhysicalDeviceFeatures.independentBlend; // Create Device VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; // \u6307\u5411 Features \u7ed3\u6784\u4f53\u4ee5\u8bbe\u7f6e Extensions \u63d0\u4f9b\u7684 Features // mSamplerYcbcrConversionFeatures : \u524d\u9762\u67e5\u8be2\u793a\u4f8b\u4e2d\u7684\u7ed3\u6784\u4f53. device_info.pNext = mSamplerYcbcrConversionFeatures; // Enable Physical Device Features device_info.pEnabledFeatures = &enabledFeatures.features; ... VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device); Limitations Limits \u63d0\u4f9b\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u53ef\u80fd\u9700\u8981\u660e\u786e\u7684\u4e00\u4e9b\u8bbe\u5907\u7279\u5f81\u503c, \u8fd9\u4e9b\u7279\u5f81\u7684\u6700\u5c0f\u503c\uff0c\u6700\u5927\u503c\u7b49\u4f1a\u968f\u5e95\u5c42\u5b9e\u73b0\u7684\u4e0d\u540c\u800c\u5f02. \u901a\u8fc7 VkPhysicalDeviceLimits \u7ed3\u6784\u4f53\u83b7\u53d6\u6838\u5fc31.0\u7684 Limits, \u6216\u5229\u7528 vk1.1 \u4e2d\u52a0\u5165\u7684 VkPhysicalDeviceProperties2 \u7684 pNext \u94fe \u83b7\u53d6\u5404 Extension \u65b0\u589e\u7684 Limits . \u7ed3\u6784\u4f53 VkPhysicalDeviceLimits \u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7701\u7565\u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd: \u4f8b\u5982: maxUniformBufferRange : \u5f53\u5c06\u7ed3\u6784\u4f53 VkDescriptorBufferInfo \u4f5c\u4e3a\u53c2\u6570\u8c03\u7528 vkUpdateDescriptorSets , \u5e76\u4e14 descriptors \u7c7b\u578b\u4e3a VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER \u6216 VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC \u65f6, \u5176\u7ed3\u6784\u4f53\u6210\u5458 range \u53ef\u8bbe\u7684\u6700\u5927\u503c. \u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684Limits \u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684\u7ed3\u6784\u4f53\u5747\u4ee5 Properties \u800c\u975e Limits \u7ed3\u5c3e, \u5176\u67e5\u8be2\u65b9\u6cd5\u4e0e\u67e5\u8be2 \u6269\u5c55\u63d0\u4f9b\u7684 Feature \u4e00\u6837. \u67e5\u8be2\u51fd\u6570\u548c\u7ed3\u679c\u7ed3\u6784\u4f53\u5982\u4e0b: VkPhysicalDeviceProperties2 deviceProperties; vkGetPhysicalDeviceProperties2KHR(mPhysicalDevice, &deviceProperties); \u67e5\u8be2\u7ed3\u679c\u793a\u4f8b: \u7ed3\u6784\u4f53 VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT \u5305\u542b\u4e86\u6269\u5c55 VK_EXT_vertex_attribute_divisor \u63d0\u4f9b\u7684 limits \u503c maxVertexAttribDivisor : // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT; Formats \u5bf9\u4e8e\u4e0d\u540c\u7684 vk \u5b9e\u73b0, \u5176\u652f\u6301\u7684\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u683c\u5f0f\u53ef\u80fd\u4f1a\u4e0d\u540c\u3002\u867d\u7136 Vulkan \u89c4\u5b9a\u4e86\u4e00\u7ec4\u5fc5\u987b\u652f\u6301\u7684 Format \u7684\u6700\u5c0f\u96c6\uff0c\u4f46\u5728\u4f7f\u7528\u9664\u6b64\u4ee5\u5916\u7684 Format\u529f\u80fd\u4e4b\u524d, \u5fc5\u987b\u663e\u5f0f\u7684\u67e5\u8be2\uff0c\u4ee5\u786e\u4fdd\u5b9e\u73b0\u652f\u6301\u8fd9\u4e9b\u683c\u5f0f\u3002 \u67e5\u8be2\u547d\u4ee4: vkGetPhysicalDeviceFormatProperties , \u67e5\u8be2\u8fd4\u56de\u7684 VkFormat \u7ed3\u6784\u4f53\u7684\u5305\u542b\u4e86\u5f53\u524d\u5b9e\u73b0\u6240\u652f\u6301\u7684\u683c\u5f0f\u529f\u80fd\u3002 VkFormat \u7ed3\u6784\u4f53\u793a\u4f8b: // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d \u5173\u4e8e Format \u76f8\u5173\u7684\u5185\u5bb9\u6bd4\u8f83\u590d\u6742, \u672c\u7ae0\u8282\u4ee5\u53ca\u540e\u7eed\u7ae0\u8282\u90fd\u4e0d\u8fdb\u884c\u6df1\u5165. \u5982\u679c\u9700\u8981\u8003\u8651\u518d\u5355\u72ec\u8fdb\u884c\u7814\u7a76. 39. Extending Vulkan New functionality may be added to Vulkan via either new extensions or new versions of the core, or new versions of an extension in some cases. This chapter describes how Vulkan is versioned, how compatibility is affected between different versions, and compatibility rules that are followed by the Vulkan Working Group. 39.1. Instance and Device Functionality Commands that enumerate instance properties, or that accept a VkInstance object as a parameter, are considered instance-level functionality. Commands that enumerate physical device properties, or that accept a VkDevice object or any of a device\u2019s child objects as a parameter, are considered device-level functionality. 39.4. Extensions Extensions may define new Vulkan commands, structures, and enumerants. For compilation purposes, the interfaces defined by registered extensions, including new structures and enumerants as well as function pointer types for new commands, are defined in the Khronos-supplied vulkan_core.h together with the core API. However, commands defined by extensions may not be available for static linking - in which case function pointers to these commands should be queried at runtime as described in Command Function Pointers . Extensions may be provided by layers as well as by a Vulkan implementation. Because extensions may extend or change the behavior of the Vulkan API, extension authors should add support for their extensions to the Khronos validation layers. This is especially important for new commands whose parameters have been wrapped by the validation layers. See the \u201cVulkan Loader Specification and Architecture Overview\u201d document for additional information. 39.4.1. Instance Extensions Instance extensions add new instance-level functionality to the API, outside of the core specification. To query the available instance extensions, call: // Provided by VK_VERSION_1_0 VkResult vkEnumerateInstanceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties); pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, as described below. pProperties is either NULL or a pointer to an array of VkExtensionProperties structures. When pLayerName parameter is NULL , only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the instance extensions provided by that layer are returned. If pProperties is NULL , then the number of extensions properties available is returned in pPropertyCount . Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties . If pPropertyCount is less than the number of extension properties available, at most pPropertyCount structures will be written. If pPropertyCount is smaller than the number of extensions available, VK_INCOMPLETE will be returned instead of VK_SUCCESS , to indicate that not all the available properties were returned. Because the list of available layers may change externally between calls to vkEnumerateInstanceExtensionProperties , two calls may retrieve different results if a pLayerName is available in one call but not in another. The extensions supported by a layer may also change between two calls, e.g. if the layer implementation is replaced by a different version between those calls. Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version. 39.4.2. Device Extensions Device extensions add new device-level functionality to the API, outside of the core specification. To query the extensions available to a given physical device, call: // Provided by VK_VERSION_1_0 VkResult vkEnumerateDeviceExtensionProperties( VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties); physicalDevice is the physical device that will be queried. pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, and is treated in the same fashion as the vkEnumerateInstanceExtensionProperties :: pPropertyCount parameter. pProperties is either NULL or a pointer to an array of VkExtensionProperties structures. When pLayerName parameter is NULL , only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the device extensions provided by that layer are returned. Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version. 40. Features Features describe functionality which is not supported on all implementations. Features are properties of the physical device. Features are optional , and must be explicitly enabled before use. Support for features is reported and enabled on a per-feature basis. NoteFeatures are reported via the basic VkPhysicalDeviceFeatures structure, as well as the extensible structure VkPhysicalDeviceFeatures2 , which was added in the VK_KHR_get_physical_device_properties2 extension and included in Vulkan 1.1. When new features are added in future Vulkan versions or extensions, each extension should introduce one new feature structure, if needed. This structure can be added to the pNext chain of the VkPhysicalDeviceFeatures2 structure. For convenience, new core versions of Vulkan may introduce new unified features structures for features promoted from extensions. At the same time, the extension\u2019s original features structure (if any) is also promoted to the core API, and is an alias of the extension\u2019s structure. This results in multiple names for the same feature: in the original extension\u2019s feature structure and the promoted structure alias, in the unified feature structure. When a feature was implicitly supported and enabled in the extension, but an explicit name was added during promotion, then the extension itself acts as an alias for the feature as listed in the table below. All aliases of the same feature in the core API must be reported consistently: either all must be reported as supported, or none of them. When a promoted extension is available, any corresponding feature aliases must be supported. // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; The pNext chain of this structure is used to extend the structure with features defined by extensions. Fine-grained features used by a logical device must be enabled at VkDevice creation time. If a feature is enabled that the physical device does not support, VkDevice creation will fail and return VK_ERROR_FEATURE_NOT_PRESENT . The fine-grained features are enabled by passing a pointer to the VkPhysicalDeviceFeatures structure via the pEnabledFeatures member of the VkDeviceCreateInfo structure that is passed into the vkCreateDevice call. If a member of pEnabledFeatures is set to VK_TRUE or VK_FALSE , then the device will be created with the indicated feature enabled or disabled, respectively. Features can also be enabled by using the VkPhysicalDeviceFeatures2 structure. If an application wishes to enable all features supported by a device, it can simply pass in the VkPhysicalDeviceFeatures structure that was previously returned by vkGetPhysicalDeviceFeatures . To disable an individual feature, the application can set the desired member to VK_FALSE in the same structure. Setting pEnabledFeatures to NULL and not including a VkPhysicalDeviceFeatures2 in the pNext chain of VkDeviceCreateInfo is equivalent to setting all members of the structure to VK_FALSE . To query support for atomic operations on floating-point numbers, call vkGetPhysicalDeviceFeatures2 with a VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure included in the pNext chain of its pFeatures parameter. The VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure is defined as: // Provided by VK_EXT_shader_atomic_float typedef struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 shaderBufferFloat32Atomics; VkBool32 shaderBufferFloat32AtomicAdd; VkBool32 shaderBufferFloat64Atomics; VkBool32 shaderBufferFloat64AtomicAdd; VkBool32 shaderSharedFloat32Atomics; VkBool32 shaderSharedFloat32AtomicAdd; VkBool32 shaderSharedFloat64Atomics; VkBool32 shaderSharedFloat64AtomicAdd; VkBool32 shaderImageFloat32Atomics; VkBool32 shaderImageFloat32AtomicAdd; VkBool32 sparseImageFloat32Atomics; VkBool32 sparseImageFloat32AtomicAdd; } VkPhysicalDeviceShaderAtomicFloatFeaturesEXT; 41. Limits Limits are implementation-dependent minimums, maximums, and other device characteristics that an application may need to be aware of. NoteLimits are reported via the basic VkPhysicalDeviceLimits structure, as well as the extensible structure VkPhysicalDeviceProperties2 , which was added in VK_KHR_get_physical_device_properties2 and included in Vulkan 1.1. When limits are added in future Vulkan versions or extensions, each extension should introduce one new limit structure, if needed. This structure can be added to the pNext chain of the VkPhysicalDeviceProperties2 structure. The VkPhysicalDeviceLimits structure is defined as: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd The VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure is defined as: // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT; 42. Formats Supported buffer and image formats may vary across implementations. A minimum set of format features are guaranteed, but others must be explicitly queried before use to ensure they are supported by the implementation. The features for the set of formats ( VkFormat ) supported by the implementation are queried individually using the vkGetPhysicalDeviceFormatProperties command. 42.1. Format Definition The following image formats can be passed to, and may be returned from Vulkan commands. The memory required to store each format is discussed with that format, and also summarized in the Representation and Texel Block Size section and the Compatible formats table. // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d 43. Additional Capabilities This chapter describes additional capabilities beyond the minimum capabilities described in the ( Limits and Formats chapters, including: Additional Image Capabilities Additional Buffer Capabilities Optional Semaphore Capabilities Optional Fence Capabilities Timestamp Calibration Capabilities","title":"0.1. Vulkan \u6269\u5c55"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#vulkan","text":"(\u672c\u7ae0\u6587\u672c\u5185\u5bb9\u7684\u66f4\u591a\u7ec6\u8282, \u53c2\u89c1 Vulkan Specification 1.1 , \u4ee3\u7801\u4e3a\u793a\u4f8b\u7528\u4f2a\u7801) \u5bf9\u4e8e\u4e0d\u540c\u7684\u5e73\u53f0, \u9a71\u52a8, \u64cd\u4f5c\u7cfb\u7edf\u7b49, \u5f53Vulkan\u7684\u5e95\u5c42\u5b9e\u73b0\u4e0d\u540c\u65f6, Vulkan \u53ef\u7528\u7684\u529f\u80fd\u96c6\u4e5f\u6709\u5f88\u591a\u533a\u522b. \u672c\u7ae0\u63cf\u8ff0\u4e86 Vulkan \u5982\u4f55\u5b9a\u4e49\u548c\u6269\u5c55\u529f\u80fd\u96c6, \u4e3b\u8981\u4ecb\u7ecd\u4e86\u56db\u4e2a\u6982\u5ff5: Extension, Feature, Limitation, \u548c Format.","title":"Vulkan \u6269\u5c55"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#vulkan_1","text":"\u5728\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u65f6, \u9700\u8981\u542f\u7528\u7684 Vulkan \u529f\u80fd\u96c6\u9700\u8981\u5728\u521d\u59cb\u5316 Device \u524d\u786e\u5b9a\u4e0b\u6765. \u5bf9\u5e94 vk \u521d\u59cb\u5316\u7684\u524d\u4e09\u6b65: Instance --> Physical Device --> Device \u4ee5\u4e0b\u662f\u521d\u59cb\u5316\u8fc7\u7a0b\u4e2d\u4e0e\u529f\u80fd\u76f8\u5173\u7684\u8fc7\u7a0b: \u679a\u4e3e vk \u652f\u6301\u7684 Instance-level Extensions \u521b\u5efa Instance \u679a\u4e3e \u7269\u7406\u8bbe\u5907, \u9009\u62e9 GPU, \u679a\u4e3e GPU \u652f\u6301\u7684 Device Extensions, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u200b \u67e5\u8be2\u652f\u6301\u7684 Extensions \u7684 Features \u7ed3\u6784\u4f53, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u200b \u67e5\u8be2\u652f\u6301\u7684 Extensions \u7684 Properties \u7ed3\u6784\u4f53 \u67e5\u8be2 GPU \u652f\u6301\u7684 Feature, \u4ece\u4e2d\u9009\u62e9\u8981\u542f\u7528\u7684 \u67e5\u8be2 GPU \u7684 Properties \u5c06\u542f\u7528\u7684 Extensions \u548c Features \u5217\u8868\u653e\u5165 CreateInfo \u7ed3\u6784\u4f53, \u521b\u5efa\u903b\u8f91\u8bbe\u5907 Device, Extension: \u529f\u80fd\u96c6\u7684\u62bd\u8c61\u6982\u5ff5, \u7528\u6765\u4e3a Vulkan \u6dfb\u52a0\u65b0\u7684 Commands\uff0cStructures \u548c Enumerants. \u540c\u65f6\u53ef\u80fd\u65b0\u589e Features, Limitations, \u548c Format. Feature: bool \u503c\u96c6\u5408, \u53ef\u9009\u529f\u80fd\u7684\u5f00\u5173. \u53ef\u4ee5\u7528\u6765\u67e5\u8be2\u8bbe\u5907\u652f\u6301\u7684\u529f\u80fd, Limitation \u548c Format \u662f\u4e24\u4e2a\u53ea\u8bfb\u53c2\u6570\u96c6, Limitation \u53c8\u79f0\u505a Properties, \u8868\u793a\u8bbe\u5907\u7279\u5f81\u503c; Format \u8868\u793a\u652f\u6301\u7684\u683c\u5f0f. \u672c\u7ae0\u540e\u9762\u5404\u7ae0\u8282\u5bf9\u6b64\u6d41\u7a0b\u5404\u6b65\u9aa4\u8fdb\u884c\u89e3\u91ca, \u5e76\u5305\u542b\u793a\u4f8b\u4ee3\u7801.","title":"Vulkan \u521d\u59cb\u5316\u6d41\u7a0b"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#extensions","text":"\u6269\u5c55 (Extensions) \u53ef\u7528\u6765\u4e3a Vk \u6dfb\u52a0\u65b0\u529f\u80fd. Vk \u6838\u5fc3\u7684\u65b0\u7248\u672c (\u5982: VK_VERSION_1_1) \u4e5f\u53ef\u4ee5\u89c6\u4e3a\u4e00\u4e2a\u6269\u5c55. \u6269\u5c55\u53ef\u4ee5\u5b9a\u4e49\u65b0\u7684 \u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784. ( Commands\uff0cStructures \u548c Enumerants) \u6269\u5c55\u5206\u4e3a\u5b9e\u4f8b\u7ea7\u548c\u8bbe\u5907\u7ea7 (Instance-level \u548c Device-level) \u5f53 Commands \u7528\u6765\u679a\u4e3e\u5b9e\u4f8b\u5c5e\u6027 (instance properties), \u6216\u63a5\u53d7 VkInstance \u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570, \u5219\u88ab\u89c6\u4e3a\u5b9e\u4f8b\u7ea7\u529f\u80fd\u3002 \u5f53 Commands \u7528\u6765\u679a\u4e3e\u7269\u7406\u8bbe\u5907\u5c5e\u6027 (physical device properties), \u6216\u63a5\u53d7 VkDevice \u53ca\u5176\u5b50\u7c7b\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\uff0c\u5219\u88ab\u89c6\u4e3a\u8bbe\u5907\u7ea7\u529f\u80fd\u3002 \u4e3a\u4e86\u65b9\u4fbf\u7f16\u8bd1\uff0c\u5728 Khronos \u63d0\u4f9b\u7684 vulkan_core.h \u4e2d\u9664\u4e86\u6838\u5fc3API, \u8fd8\u5b9a\u4e49\u4e86\u5df2\u6ce8\u518c Extensions \u5b9a\u4e49\u7684\u63a5\u53e3\uff0c\u5305\u62ec\u65b0 \u7ed3\u6784, \u679a\u4e3e, \u548c\u547d\u4ee4\u7684\u51fd\u6570\u6307\u9488\u7c7b\u578b\u3002\u6269\u5c55\u7684\u5b9e\u73b0\u901a\u8fc7 Layers \u548c Vulkan\u5b9e\u73b0\u6765\u63d0\u4f9b\u3002","title":"Extensions: \u6269\u5c55"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#vk-extensions","text":"Vk Extensions \u9700\u8981\u5728\u521d\u59cb\u5316\u9636\u6bb5\u663e\u5f0f\u542f\u7528. \u542f\u7528 instance extension, \u8981\u5728\u521b\u5efa VKInstance \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkInstanceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. \u542f\u7528 device extension, \u8981\u5728 \u521b\u5efa VkDevice \u65f6, \u5c06\u6269\u5c55\u540d\u6dfb\u52a0\u5230 VkDeviceCreateInfo \u7684\u6210\u5458 ppEnabledExtensionNames \u4e2d. Physical-Device-Level \u529f\u80fd\u6ca1\u6709\u542f\u7528\u673a\u5236\uff0c\u53ea\u8981 VkPhysicalDevice \u7684\u529f\u80fd\u5bf9\u5e94\u7684 Extensions \u5728\u679a\u4e3e\u51fd\u6570 vkEnumerateDeviceExtensionProperties \u4e2d\u88ab\u5217\u51fa. \u4ec5 \u542f\u7528 \u6269\u5c55\u64cd\u4f5c\u800c\u8a00, \u9664\u4e86 \u542f\u7528 \u8be5\u6269\u5c55\u81ea\u8eab\u5b9a\u4e49\u7684\u547d\u4ee4, \u679a\u4e3e, \u548c\u7ed3\u6784\u5916, \u4e0d\u4f1a\u66f4\u6539\u6838\u5fc3Vulkan API \u6216\u5176\u4ed6\u6269\u5c55\u7684\u529f\u80fd\u3002 \u793a\u4f8b: \u521b\u5efa VkInstance \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> extensions(); extensions.push_back(VK_KHR_WIN32_SURFACE_EXTENSION_NAME); VkInstanceCreateInfo inst_info = {}; inst_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; ... // Enable Instance Extensions inst_info.enabledExtensionCount = extensions.size(); inst_info.ppEnabledExtensionNames = extensions.data(); VkInstance instance; VkResult res = vkCreateInstance(&inst_info, NULL, &instance); \u5bf9 VkPhysicalDevice, \u679a\u4e3e\u5176\u652f\u6301\u7684 Extensions: // \u679a\u4e3e\u8bbe\u5907 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); // \u9009\u62e9\u8bbe\u5907 VkPhysicalDevice physicalDevice = devices[0]; // \u4ec5\u793a\u4f8b,\u6b63\u786e\u4ee3\u7801\u5e94\u9009\u62e9\u5bf9\u5e94 GPU \u8bbe\u5907 // \u679a\u4e3e Extensions uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, availableExtensions.data()); \u521b\u5efa VkDevice \u65f6, \u542f\u7528 Extensions: // add Target Extension Names std::vector<const char*> device_extension_names(); // check if physicalDevice support extension: for (const auto& extension : availableExtensions) { if(strcmp(extension.extensionName, VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0) device_extension_names.push_back(extension.extensionName); } } VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; device_info.pNext = NULL; ... // Enable Device Extensions device_info.enabledExtensionCount = device_extension_names.size(); device_info.ppEnabledExtensionNames = enabledExtensionCount ? device_extension_names.data() : NULL; VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device);","title":"\u542f\u7528 Vk Extensions"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#features","text":"Features \u7528\u6765\u8bbe\u7f6e\u6216\u67e5\u8be2 \u975e\u6240\u6709\u5b9e\u73b0\u90fd\u652f\u6301 \u7684\u529f\u80fd\u3002 Feature \u5747\u4e3a bool \u503c. Features \u662f\u7269\u7406\u8bbe\u5907\u7684\u5c5e\u6027\u3002(physical device properties) \u8fd9\u4e9b\u529f\u80fd\u662f\u201c\u53ef\u9009\u201d\u7684\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u4f7f\u7528\u524d\u660e\u786e\u542f\u7528\u3002","title":"Features: \u529f\u80fd"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#features_1","text":"Vk \u6838\u5fc3\u4e2d\u5b9a\u4e49\u7684 Features, \u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceFeatures \u67e5\u8be2. VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); \u67e5\u8be2\u7ed3\u679c VkPhysicalDeviceFeatures \u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceFeatures { VkBool32 robustBufferAccess; VkBool32 fullDrawIndexUint32; VkBool32 imageCubeArray; VkBool32 independentBlend; VkBool32 geometryShader; VkBool32 tessellationShader; VkBool32 sampleRateShading; .... // \u603b\u8ba150+\u4e2a Bool \u503c } VkPhysicalDeviceFeatures \u5176\u4e2d\u6bcf\u4e2a Feature \u7684\u542b\u4e49 \u5728 Vulkan Specification 1.1/Features \u4e2d\u90fd\u6709\u89e3\u91ca. \u4f8b\u5982: IndependentBlend \u6307\u5b9a: \u662f\u5426\u6bcf\u4e2a attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u4e92\u76f8\u72ec\u7acb\u3002 \u672a\u542f\u7528\u6b64 Feature\uff0c\u5219\u6240\u6709 color attachments \u7684 VkPipelineColorBlendAttachmentState \u8bbe\u7f6e\u5fc5\u987b\u76f8\u540c\u3002 \u82e5\u542f\u7528\u6b64 Feature\uff0c\u5219\u53ef\u4ee5\u4e3a\u6bcf\u4e2a\u7ed1\u5b9a\u7684 color attachment \u63d0\u4f9b\u4e0d\u540c\u7684 VkPipelineColorBlendAttachmentState \u3002","title":"\u6838\u5fc3 Features"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#features_2","text":"\u67e5\u8be2\u51fd\u6570: vkGetPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 physicalDeviceFeatures2; vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &physicalDeviceFeatures2); \u67e5\u8be2\u7ed3\u679c: VkPhysicalDeviceFeatures2 \u7ed3\u6784: // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; sType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 pNext: \u6307\u9488\u94fe. VkPhysicalDeviceFeatures: Vulkan 1.0 \u63d0\u4f9b\u7684\u6838\u5fc3 Features \u6ce8: VkPhysicalDeviceFeatures2 \u7b49\u4ef7 VkPhysicalDeviceFeatures2KHR, vkGetPhysicalDeviceFeatures2 \u7b49\u4ef7 vkGetPhysicalDeviceFeatures2KHR \u901a\u8fc7 pNext , \u53ef\u4ee5\u83b7\u5f97\u6269\u5c55\u6240\u5b9a\u4e49\u7684 Features \u7ed3\u6784\u4f53, \u6709\u7684\u7531 Vulkan \u6838\u5fc3\u65b0\u7248\u672c\u63d0\u4f9b, \u6709\u7684\u7531\u5176\u4ed6 Extension\u63d0\u4f9b. \u4f8b\u5982: Vulkan 1.1 \u63d0\u4f9b\u7684 samplerYcbcrConversion. // Provided by VK_VERSION_1_1: VK_KHR_sampler_ycbcr_conversion typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures { VkStructureType sType; void* pNext; VkBool32 samplerYcbcrConversion; } VkPhysicalDeviceSamplerYcbcrConversionFeatures; VK_EXT_transform_feedback \u63d0\u4f9b\u7684 transformFeedback \u548c geometryStreams. // Provided by VK_EXT_transform_feedback typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 transformFeedback; VkBool32 geometryStreams; } VkPhysicalDeviceTransformFeedbackFeaturesEXT; \u67e5\u8be2\u793a\u4f8b: // \u6269\u5c55\u7684 Feature \u7ed3\u6784\u4f53 VkPhysicalDeviceSamplerYcbcrConversionFeatures mSamplerYcbcrConversionFeatures = {}; mSamplerYcbcrConversionFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; // vk1.1 \u7684 VkPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2 deviceFeatures = {}; deviceFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; deviceFeatures.pNext = mVertexAttributeDivisorFeatures // \u67e5\u8be2 vkGetPhysicalDeviceFeatures2(mPhysicalDevice, &deviceFeatures); // \u4f7f\u7528 if (mVertexAttributeDivisorFeatures.vertexAttributeInstanceRateDivisor) { ... }","title":"\u6269\u5c55\u63d0\u4f9b\u7684Features"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#features_3","text":"Features \u9ed8\u8ba4\u7686\u4e3a\u4e0d\u542f\u7528\u72b6\u6001. \u5fc5\u987b\u5728 VkDevice \u521b\u5efa\u65f6\u663e\u5f0f\u542f\u7528\u3002\u5982\u679c\u542f\u7528\u4e86\u7269\u7406\u8bbe\u5907\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5219 VkDevice \u521b\u5efa\u5c06\u5931\u8d25\uff0c\u5e76\u8fd4\u56deVK_ERROR_FEATURE_NOT_PRESENT\u3002 \u542f\u7528\u65b9\u6cd5: \u521b\u5efa VkPhysicalDeviceFeatures \u7ed3\u6784\u7684\u6307\u9488 (\u62161.1\u7684 VkPhysicalDeviceFeatures2\u7ed3\u6784) \u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \u6216 VK_FALSE, eg: physicalDeviceFeatures.independentBlend = VK_TRUE \u901a\u8fc7\u4f20\u9012\u7ed9 vkCreateDevice \u7528\u7684 VkDeviceCreateInfo\u7ed3\u6784\u7684 pEnabledFeatures \u6210\u5458. \u8981\u542f\u52a8\u6240\u6709\u8bbe\u5907\u7684\u529f\u80fd (\u614e\u7528)\uff0c\u5219\u53ea\u9700\u4f20\u5165\u67e5\u8be2\u51fd\u6570 vkGetPhysicalDeviceFeatures \u8fd4\u56de\u7684 VkPhysicalDeviceFeatures \u7ed3\u6784\u5373\u53ef\u3002\u8981\u7981\u7528\u5355\u4e2a\u529f\u80fd\uff0c\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728\u76f8\u540c\u7ed3\u6784\u4e2d\u5c06\u6240\u9700\u6210\u5458\u8bbe\u7f6e\u4e3aVK_FALSE\u3002 \u7528\u8fc7\u7ed9 pNext\u94fe\u6dfb\u52a0 Extensions \u63d0\u4f9b\u7684 Features \u7ed3\u6784\u4f53, \u6765\u542f\u7528\u6269\u5c55\u7684 Features. // \u67e5\u8be2\u6838\u5fc3 Features \u662f\u5426\u652f\u6301 VkPhysicalDeviceFeatures mPhysicalDeviceFeatures; vkGetPhysicalDeviceFeatures(mPhysicalDevice, &mPhysicalDeviceFeatures); // \u8bbe\u7f6e\u542f\u7528 Features VkPhysicalDeviceFeatures2KHR enabledFeatures = {}; enabledFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; enabledFeatures.features.imageCubeArray = mPhysicalDeviceFeatures.imageCubeArray; enabledFeatures.features.independentBlend = mPhysicalDeviceFeatures.independentBlend; // Create Device VkDeviceCreateInfo device_info = {}; device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; // \u6307\u5411 Features \u7ed3\u6784\u4f53\u4ee5\u8bbe\u7f6e Extensions \u63d0\u4f9b\u7684 Features // mSamplerYcbcrConversionFeatures : \u524d\u9762\u67e5\u8be2\u793a\u4f8b\u4e2d\u7684\u7ed3\u6784\u4f53. device_info.pNext = mSamplerYcbcrConversionFeatures; // Enable Physical Device Features device_info.pEnabledFeatures = &enabledFeatures.features; ... VkDevice device; res = vkCreateDevice(physicalDevice, &device_info, NULL, &device);","title":"\u542f\u7528 Features"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#limitations","text":"Limits \u63d0\u4f9b\u5f00\u53d1\u5e94\u7528\u7a0b\u5e8f\u53ef\u80fd\u9700\u8981\u660e\u786e\u7684\u4e00\u4e9b\u8bbe\u5907\u7279\u5f81\u503c, \u8fd9\u4e9b\u7279\u5f81\u7684\u6700\u5c0f\u503c\uff0c\u6700\u5927\u503c\u7b49\u4f1a\u968f\u5e95\u5c42\u5b9e\u73b0\u7684\u4e0d\u540c\u800c\u5f02. \u901a\u8fc7 VkPhysicalDeviceLimits \u7ed3\u6784\u4f53\u83b7\u53d6\u6838\u5fc31.0\u7684 Limits, \u6216\u5229\u7528 vk1.1 \u4e2d\u52a0\u5165\u7684 VkPhysicalDeviceProperties2 \u7684 pNext \u94fe \u83b7\u53d6\u5404 Extension \u65b0\u589e\u7684 Limits . \u7ed3\u6784\u4f53 VkPhysicalDeviceLimits \u5b9a\u4e49\u5982\u4e0b: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7701\u7565\u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd: \u4f8b\u5982: maxUniformBufferRange : \u5f53\u5c06\u7ed3\u6784\u4f53 VkDescriptorBufferInfo \u4f5c\u4e3a\u53c2\u6570\u8c03\u7528 vkUpdateDescriptorSets , \u5e76\u4e14 descriptors \u7c7b\u578b\u4e3a VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER \u6216 VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC \u65f6, \u5176\u7ed3\u6784\u4f53\u6210\u5458 range \u53ef\u8bbe\u7684\u6700\u5927\u503c.","title":"Limitations"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#limits","text":"\u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684\u7ed3\u6784\u4f53\u5747\u4ee5 Properties \u800c\u975e Limits \u7ed3\u5c3e, \u5176\u67e5\u8be2\u65b9\u6cd5\u4e0e\u67e5\u8be2 \u6269\u5c55\u63d0\u4f9b\u7684 Feature \u4e00\u6837. \u67e5\u8be2\u51fd\u6570\u548c\u7ed3\u679c\u7ed3\u6784\u4f53\u5982\u4e0b: VkPhysicalDeviceProperties2 deviceProperties; vkGetPhysicalDeviceProperties2KHR(mPhysicalDevice, &deviceProperties); \u67e5\u8be2\u7ed3\u679c\u793a\u4f8b: \u7ed3\u6784\u4f53 VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT \u5305\u542b\u4e86\u6269\u5c55 VK_EXT_vertex_attribute_divisor \u63d0\u4f9b\u7684 limits \u503c maxVertexAttribDivisor : // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;","title":"\u67e5\u8be2\u6269\u5c55\u63d0\u4f9b\u7684Limits"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#formats","text":"\u5bf9\u4e8e\u4e0d\u540c\u7684 vk \u5b9e\u73b0, \u5176\u652f\u6301\u7684\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u683c\u5f0f\u53ef\u80fd\u4f1a\u4e0d\u540c\u3002\u867d\u7136 Vulkan \u89c4\u5b9a\u4e86\u4e00\u7ec4\u5fc5\u987b\u652f\u6301\u7684 Format \u7684\u6700\u5c0f\u96c6\uff0c\u4f46\u5728\u4f7f\u7528\u9664\u6b64\u4ee5\u5916\u7684 Format\u529f\u80fd\u4e4b\u524d, \u5fc5\u987b\u663e\u5f0f\u7684\u67e5\u8be2\uff0c\u4ee5\u786e\u4fdd\u5b9e\u73b0\u652f\u6301\u8fd9\u4e9b\u683c\u5f0f\u3002 \u67e5\u8be2\u547d\u4ee4: vkGetPhysicalDeviceFormatProperties , \u67e5\u8be2\u8fd4\u56de\u7684 VkFormat \u7ed3\u6784\u4f53\u7684\u5305\u542b\u4e86\u5f53\u524d\u5b9e\u73b0\u6240\u652f\u6301\u7684\u683c\u5f0f\u529f\u80fd\u3002 VkFormat \u7ed3\u6784\u4f53\u793a\u4f8b: // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d \u5173\u4e8e Format \u76f8\u5173\u7684\u5185\u5bb9\u6bd4\u8f83\u590d\u6742, \u672c\u7ae0\u8282\u4ee5\u53ca\u540e\u7eed\u7ae0\u8282\u90fd\u4e0d\u8fdb\u884c\u6df1\u5165. \u5982\u679c\u9700\u8981\u8003\u8651\u518d\u5355\u72ec\u8fdb\u884c\u7814\u7a76.","title":"Formats"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#39-extending-vulkan","text":"New functionality may be added to Vulkan via either new extensions or new versions of the core, or new versions of an extension in some cases. This chapter describes how Vulkan is versioned, how compatibility is affected between different versions, and compatibility rules that are followed by the Vulkan Working Group.","title":"39. Extending Vulkan"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#391-instance-and-device-functionality","text":"Commands that enumerate instance properties, or that accept a VkInstance object as a parameter, are considered instance-level functionality. Commands that enumerate physical device properties, or that accept a VkDevice object or any of a device\u2019s child objects as a parameter, are considered device-level functionality.","title":"39.1. Instance and Device Functionality"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#394-extensions","text":"Extensions may define new Vulkan commands, structures, and enumerants. For compilation purposes, the interfaces defined by registered extensions, including new structures and enumerants as well as function pointer types for new commands, are defined in the Khronos-supplied vulkan_core.h together with the core API. However, commands defined by extensions may not be available for static linking - in which case function pointers to these commands should be queried at runtime as described in Command Function Pointers . Extensions may be provided by layers as well as by a Vulkan implementation. Because extensions may extend or change the behavior of the Vulkan API, extension authors should add support for their extensions to the Khronos validation layers. This is especially important for new commands whose parameters have been wrapped by the validation layers. See the \u201cVulkan Loader Specification and Architecture Overview\u201d document for additional information.","title":"39.4. Extensions"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#3941-instance-extensions","text":"Instance extensions add new instance-level functionality to the API, outside of the core specification. To query the available instance extensions, call: // Provided by VK_VERSION_1_0 VkResult vkEnumerateInstanceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties); pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, as described below. pProperties is either NULL or a pointer to an array of VkExtensionProperties structures. When pLayerName parameter is NULL , only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the instance extensions provided by that layer are returned. If pProperties is NULL , then the number of extensions properties available is returned in pPropertyCount . Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties . If pPropertyCount is less than the number of extension properties available, at most pPropertyCount structures will be written. If pPropertyCount is smaller than the number of extensions available, VK_INCOMPLETE will be returned instead of VK_SUCCESS , to indicate that not all the available properties were returned. Because the list of available layers may change externally between calls to vkEnumerateInstanceExtensionProperties , two calls may retrieve different results if a pLayerName is available in one call but not in another. The extensions supported by a layer may also change between two calls, e.g. if the layer implementation is replaced by a different version between those calls. Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version.","title":"39.4.1. Instance Extensions"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#3942-device-extensions","text":"Device extensions add new device-level functionality to the API, outside of the core specification. To query the extensions available to a given physical device, call: // Provided by VK_VERSION_1_0 VkResult vkEnumerateDeviceExtensionProperties( VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties); physicalDevice is the physical device that will be queried. pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, and is treated in the same fashion as the vkEnumerateInstanceExtensionProperties :: pPropertyCount parameter. pProperties is either NULL or a pointer to an array of VkExtensionProperties structures. When pLayerName parameter is NULL , only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the device extensions provided by that layer are returned. Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version.","title":"39.4.2. Device Extensions"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#40-features","text":"Features describe functionality which is not supported on all implementations. Features are properties of the physical device. Features are optional , and must be explicitly enabled before use. Support for features is reported and enabled on a per-feature basis. NoteFeatures are reported via the basic VkPhysicalDeviceFeatures structure, as well as the extensible structure VkPhysicalDeviceFeatures2 , which was added in the VK_KHR_get_physical_device_properties2 extension and included in Vulkan 1.1. When new features are added in future Vulkan versions or extensions, each extension should introduce one new feature structure, if needed. This structure can be added to the pNext chain of the VkPhysicalDeviceFeatures2 structure. For convenience, new core versions of Vulkan may introduce new unified features structures for features promoted from extensions. At the same time, the extension\u2019s original features structure (if any) is also promoted to the core API, and is an alias of the extension\u2019s structure. This results in multiple names for the same feature: in the original extension\u2019s feature structure and the promoted structure alias, in the unified feature structure. When a feature was implicitly supported and enabled in the extension, but an explicit name was added during promotion, then the extension itself acts as an alias for the feature as listed in the table below. All aliases of the same feature in the core API must be reported consistently: either all must be reported as supported, or none of them. When a promoted extension is available, any corresponding feature aliases must be supported. // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceFeatures2 { VkStructureType sType; void* pNext; VkPhysicalDeviceFeatures features; } VkPhysicalDeviceFeatures2; The pNext chain of this structure is used to extend the structure with features defined by extensions. Fine-grained features used by a logical device must be enabled at VkDevice creation time. If a feature is enabled that the physical device does not support, VkDevice creation will fail and return VK_ERROR_FEATURE_NOT_PRESENT . The fine-grained features are enabled by passing a pointer to the VkPhysicalDeviceFeatures structure via the pEnabledFeatures member of the VkDeviceCreateInfo structure that is passed into the vkCreateDevice call. If a member of pEnabledFeatures is set to VK_TRUE or VK_FALSE , then the device will be created with the indicated feature enabled or disabled, respectively. Features can also be enabled by using the VkPhysicalDeviceFeatures2 structure. If an application wishes to enable all features supported by a device, it can simply pass in the VkPhysicalDeviceFeatures structure that was previously returned by vkGetPhysicalDeviceFeatures . To disable an individual feature, the application can set the desired member to VK_FALSE in the same structure. Setting pEnabledFeatures to NULL and not including a VkPhysicalDeviceFeatures2 in the pNext chain of VkDeviceCreateInfo is equivalent to setting all members of the structure to VK_FALSE . To query support for atomic operations on floating-point numbers, call vkGetPhysicalDeviceFeatures2 with a VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure included in the pNext chain of its pFeatures parameter. The VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure is defined as: // Provided by VK_EXT_shader_atomic_float typedef struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT { VkStructureType sType; void* pNext; VkBool32 shaderBufferFloat32Atomics; VkBool32 shaderBufferFloat32AtomicAdd; VkBool32 shaderBufferFloat64Atomics; VkBool32 shaderBufferFloat64AtomicAdd; VkBool32 shaderSharedFloat32Atomics; VkBool32 shaderSharedFloat32AtomicAdd; VkBool32 shaderSharedFloat64Atomics; VkBool32 shaderSharedFloat64AtomicAdd; VkBool32 shaderImageFloat32Atomics; VkBool32 shaderImageFloat32AtomicAdd; VkBool32 sparseImageFloat32Atomics; VkBool32 sparseImageFloat32AtomicAdd; } VkPhysicalDeviceShaderAtomicFloatFeaturesEXT;","title":"40. Features"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#41-limits","text":"Limits are implementation-dependent minimums, maximums, and other device characteristics that an application may need to be aware of. NoteLimits are reported via the basic VkPhysicalDeviceLimits structure, as well as the extensible structure VkPhysicalDeviceProperties2 , which was added in VK_KHR_get_physical_device_properties2 and included in Vulkan 1.1. When limits are added in future Vulkan versions or extensions, each extension should introduce one new limit structure, if needed. This structure can be added to the pNext chain of the VkPhysicalDeviceProperties2 structure. The VkPhysicalDeviceLimits structure is defined as: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceLimits { uint32_t maxImageDimension1D; uint32_t maxImageDimension2D; uint32_t maxImageDimension3D; uint32_t maxImageDimensionCube; uint32_t maxImageArrayLayers; uint32_t maxTexelBufferElements; uint32_t maxUniformBufferRange; uint32_t maxStorageBufferRange; uint32_t maxPushConstantsSize; uint32_t maxMemoryAllocationCount; uint32_t maxSamplerAllocationCount; VkDeviceSize bufferImageGranularity; VkDeviceSize sparseAddressSpaceSize; ... // \u7ea6 100+ \u4e2a\u503c } VkPhysicalDeviceLimits; specs \u6587\u6863\u5bf9\u6bcf\u4e2a\u503c\u90fd\u6709\u4ecb\u7ecd The VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure is defined as: // Provided by VK_EXT_vertex_attribute_divisor typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT { VkStructureType sType; void* pNext; uint32_t maxVertexAttribDivisor; } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;","title":"41. Limits"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#42-formats","text":"Supported buffer and image formats may vary across implementations. A minimum set of format features are guaranteed, but others must be explicitly queried before use to ensure they are supported by the implementation. The features for the set of formats ( VkFormat ) supported by the implementation are queried individually using the vkGetPhysicalDeviceFormatProperties command.","title":"42. Formats"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#421-format-definition","text":"The following image formats can be passed to, and may be returned from Vulkan commands. The memory required to store each format is discussed with that format, and also summarized in the Representation and Texel Block Size section and the Compatible formats table. // Provided by VK_VERSION_1_0 typedef enum VkFormat { VK_FORMAT_UNDEFINED = 0, VK_FORMAT_R4G4_UNORM_PACK8 = 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3, VK_FORMAT_R5G6B5_UNORM_PACK16 = 4, VK_FORMAT_B5G6R5_UNORM_PACK16 = 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8, ... // \u7ea6 300+, \u5176\u4e2d","title":"42.1. Format Definition"},{"location":"Vulkan/0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/#43-additional-capabilities","text":"This chapter describes additional capabilities beyond the minimum capabilities described in the ( Limits and Formats chapters, including: Additional Image Capabilities Additional Buffer Capabilities Optional Semaphore Capabilities Optional Fence Capabilities Timestamp Calibration Capabilities","title":"43. Additional Capabilities"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/","text":"1. \u6d41\u7a0b\u603b\u89c8 2. \u521d\u59cb\u5316\u65f6, \u6d89\u53ca\u7684 API 2. \u7406\u89e3 Vulkan\u00ae Objects 1. Instance 2. PhysicalDevice 3. Device 4. Queue 5. CommandPool 6. CommandBuffer 7. Sampler 8. Image & Buffer TODO 9. DeviceMemory \u5bf9\u8c61\u7ec4 \u8bbe\u5907 \u56fe\u50cf \u7ba1\u9053 3. Pipeline 4. \u8be6\u7ec6 1. \u6d41\u7a0b\u603b\u89c8 \u521d\u59cb\u8bbe\u7f6e Instance \u5b9e\u4f8b [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 \u5448\u73b0 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b \u7ed8\u5236 Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe \u6ce8: []: \u975e Vulkan \u6838\u5fc3 init_global_layer_properties(info); init_instance_extension_names(info); init_device_extension_names(info); init_instance(info, sample_title); init_enumerate_device(info); init_window_size(info, 500, 500); init_connection(info); init_window(info); init_swapchain_extension(info); init_device(info); init_command_pool(info); init_command_buffer(info); execute_begin_command_buffer(info); init_device_queue(info); init_swap_chain(info); init_depth_buffer(info); init_uniform_buffer(info); init_descriptor_and_pipeline_layouts(info, false); init_renderpass(info, depthPresent); #include \"15-draw_cube.vert.h\" #include \"15-draw_cube.frag.h\" VkShaderModuleCreateInfo vert_info = {}; VkShaderModuleCreateInfo frag_info = {}; vert_info.sType = frag_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; vert_info.codeSize = sizeof(__draw_cube_vert); vert_info.pCode = __draw_cube_vert; frag_info.codeSize = sizeof(__draw_cube_frag); frag_info.pCode = __draw_cube_frag; init_shaders(info, &vert_info, &frag_info); init_framebuffers(info, depthPresent); init_vertex_buffer(info, g_vb_solid_face_colors_Data, sizeof(g_vb_solid_face_colors_Data), sizeof(g_vb_solid_face_colors_Data[0]), false); init_descriptor_pool(info, false); init_descriptor_set(info, false); init_pipeline_cache(info); init_pipeline(info, depthPresent); 2. \u521d\u59cb\u5316\u65f6, \u6d89\u53ca\u7684 API \u521d\u59cb\u8bbe\u7f6e Instance \u5b9e\u4f8b vkCreateInstance [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf vkEnumeratePhysicalDevices vkGetPhysicalDeviceQueueFamilyProperties Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 \u5448\u73b0 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b \u7ed8\u5236 Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe 2. \u7406\u89e3 Vulkan\u00ae Objects \u7eff\u8272\u6846: \u65e0\u7c7b\u578b, \u4ee5 uint32_t \u8868\u793a \u5b9e\u7ebf+\u7bad\u5934: \u521b\u5efa\u987a\u5e8f \u5b9e\u7ebf+\u83f1\u5f62: \u7ec4\u5408 (\u88ab\u5305\u542b) \u865a\u7ebf: \u901a\u4fe1 \u4e09\u4e2a\u533a\u57df\u4e2d, \u7ea2\u8272\u4e3a\u4e3b Object, \u5176\u4ed6\u5bf9\u8c61\u90fd\u76f4\u63a5\u6216\u95f4\u63a5\u7684\u7531\u6b64\u5bf9\u8c61\u521b\u5efa. \u8868\u73b0\u4e3a vkCreateSwapchainKHR \u9700\u8981 Device \u4e3a\u53c2\u6570. 1. Instance Instance \u662f\u521b\u5efa\u7684\u7b2c\u4e00\u4e2a\u5bf9\u8c61\u3002 \u5b83\u8868\u793a\u4ece\u5e94\u7528\u7a0b\u5e8f\u5230 Vulkan \u8fd0\u884c\u65f6\u7684 \u8fde\u63a5 \uff0c\u56e0\u6b64\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u4ec5\u5e94 \u5b58\u5728\u4e00\u6b21 \u3002 \u5b83\u8fd8\u5b58\u50a8\u4f7f\u7528 Vulkan \u6240\u9700\u7684\u6240\u6709\u7279\u5b9a\u4e8e \u5e94\u7528\u7a0b\u5e8f \u7684\u72b6\u6001\u3002 \u56e0\u6b64\uff0c\u60a8\u5fc5\u987b\u6307\u5b9a\u521b\u5efa\u5b9e\u4f8b\u65f6\u8981\u542f\u7528\u7684\u6240\u6709\u5c42 Layers \uff08\u4f8b\u5982\u9a8c\u8bc1\u5c42\uff09\u548c\u6240\u6709\u6269\u5c55 Extensions\u3002 2. PhysicalDevice \u8868\u793a\u7279\u5b9a\u7684 Vulkan \u517c\u5bb9\u8bbe\u5907\uff0c\u4f8b\u5982\u56fe\u5f62\u5361\u3002 vkEnumeratePhysicalDevices \u60a8\u53ef\u4ee5\u4ece Instance \u4e2d \u679a\u4e3e \u5b83\u4eec\uff0c\u7136\u540e\u53ef\u4ee5\u67e5\u8be2\u5b83\u4eec\u7684 vendorID\uff0cdeviceID \u548c\u652f\u6301\u7684\u529f\u80fd\u4ee5\u53ca\u5176\u4ed6\u5c5e\u6027\u548c\u9650\u5236\u3002 vkGetPhysicalDeviceQueueFamilyProperties PhysicalDevice \u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u53ef\u7528\u7684 Queue Families \u7c7b\u578b\u3002 \u56fe\u5f62\u961f\u5217 Graphics Queue \u662f\u6700\u4e3b\u8981\u7684\u961f\u5217\uff0c\u4f46\u662f\u60a8\u53ef\u80fd\u8fd8\u6709\u5176\u4ed6\u4ec5\u652f\u6301\u8ba1\u7b97Compute \u6216\u4f20\u8f93 Transfer\u7684\u961f\u5217\u3002 PhysicalDevice\u8fd8\u53ef\u4ee5\u679a\u4e3e\u5176\u5185\u90e8\u7684\u5185\u5b58\u5806 Memory Heaps \u548c\u5185\u5b58\u7c7b\u578b Memory Types \u3002 Memory Heaps \u4ee3\u8868\u7279\u5b9a\u7684RAM\u6c60\u3002 \u5b83\u53ef\u80fd\u4f1a\u63d0\u53d6 \u4e3b\u677f\u4e0a\u7684\u7cfb\u7edfRAM, \u6216\u4e13\u7528\u56fe\u5f62\u5361\u4e0a\u7684\u89c6\u9891RAM\u4e2d\u7684\u7279\u5b9a\u5185\u5b58\u7a7a\u95f4\uff0c\u6216\u8005\u5b9e\u73b0\u8981\u516c\u5f00\u7684\u4efb\u4f55\u5176\u4ed6\u7279\u5b9a\u4e8e\u4e3b\u673a\u6216\u8bbe\u5907\u7684\u5185\u5b58\u3002 \u5206\u914d\u5185\u5b58 Allocate Memory \u65f6\u5fc5\u987b\u6307\u5b9a Memory Types \u3002 \u5b83\u5177\u6709\u5bf9 Memory Blob \u7684\u7279\u5b9a\u8981\u6c42\uff0c\u4f8b\u5982\u5bf9 host \u53ef\u89c1\uff0c\u4e00\u81f4\u6027 coherent\uff08\u5728CPU\u548cGPU\u4e4b\u95f4\uff09\u548c\u5df2\u7f13\u5b58 cached\u3002\u8fd9\u4e9b\u53ef\u80fd\u4f1a\u4efb\u610f\u7ec4\u5408\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f\u3002 3. Device \u53c8\u88ab\u89c6\u4e3a \u903b\u8f91\u8bbe\u5907 Logical Device \u6216 Opened Device. \u5b83\u4ee3\u8868\u4e86\u4e00\u4e2a\u5df2\u7ecf\u521d\u59cb\u5316\u7684 Vulkan \u8bbe\u5907, \u51c6\u5907\u597d\u521b\u5efa\u5176\u4ed6\u5bf9\u8c61 \u521b\u5efa\u8bbe\u5907\u65f6, \u9700\u6307\u5b9a\u542f\u7528\u54ea\u4e9b Features , \u5e76\u58f0\u660e\u6240\u6709\u4f7f\u7528\u7684 Queue , \u5176\u7f16\u53f7 \u548c\u5176 Queue Family 4. Queue Device \u4e0a\u6267\u884c\u7684\u547d\u4ee4\u961f\u5217 Queue of Commands\u3002 \u901a\u8fc7\u4f7f\u7528 vkQueueSubmit \u586b\u5145 CommandBuffer \u5e76\u5c06\u5176\u63d0\u4ea4\u5230 Queue\uff0c\u6765\u8bf7\u6c42 GPU \u5b8c\u6210\u7684\u6240\u6709\u5b9e\u9645\u5de5\u4f5c\u3002 \u5982\u679c\u6709\u591a\u4e2a\u961f\u5217\uff0c\u4f8b\u5982 Graphic Queue \u548c Compute Queue\uff0c\u5219\u53ef\u4ee5\u5411\u6bcf\u4e2a\u961f\u5217\u63d0\u4ea4\u4e0d\u540c\u7684CommandBuffer\u3002\u8fd9\u6837\uff0c\u60a8\u5c31\u53ef\u4ee5\u542f\u7528\u5f02\u6b65\u8ba1\u7b97\uff0c\u5982\u679c\u6267\u884c\u6b63\u786e\u7684\u8bdd\uff0c\u53ef\u4ee5\u5927\u5927\u63d0\u9ad8\u901f\u5ea6\u3002 5. CommandPool \u7528\u4e8e\u5206\u914d CommandBuffer \u3002\u5b83\u5df2\u8fde\u63a5\u5230\u7279\u5b9a\u7684 Queue Family \u3002 6. CommandBuffer \u4ece\u6307\u5b9a\u7684 CommandPool \u5206\u914d\u3002\u5b83\u4ee3\u8868 Device \u8981\u6267\u884c\u7684\u5404\u79cd\u547d\u4ee4\u7684\u7f13\u51b2\u533a\u3002 \u53ef\u4ee5\u5728 Command Buffer \u4e0a\u8c03\u7528\u5404 vkCmd \u5f00\u5934\u7684\u51fd\u6570\uff0c\u7528\u4e8e\u6307\u5b9a \u6267\u884c\u7684\u4efb\u52a1\u7684\u987a\u5e8f\uff0c\u7c7b\u578b\u548c\u53c2\u6570\u3002 \u4e4b\u540e CommandBuffer \u63d0\u4ea4\u5230 Queue \u5e76\u6700\u7ec8\u7531 Device \u6267\u884c 7. Sampler \u91c7\u6837\u5668 Sampler \u672a\u7ed1\u5b9a\u5230\u4efb\u4f55\u7279\u5b9a\u56fe\u50cf Image\u3002\u5b83\u53ea\u662f\u4e00\u7ec4\u72b6\u6001\u53c2\u6570 state parameters \uff0c \u4f8b\u5982\u8fc7\u6ee4\u6a21\u5f0f (filtering mode)\uff08\u6700\u8fd1\u6216\u7ebf\u6027 nearest or linear\uff09,\u6216\u5bfb\u5740\u6a21\u5f0f (addressing mode)\uff08\u91cd\u590d\uff0c\u94b3\u4f4d\u5230\u8fb9\u7f18\uff0c\u94b3\u4f4d\u5230\u8fb9\u754c\u7b49 repeat, clamp-to-edge, clamp-to-border\uff09\u3002 8. Image & Buffer TODO \u7f13\u51b2\u533a\u548c\u56fe\u50cf\u662f\u5360\u7528\u8bbe\u5907\u5185\u5b58\u7684\u4e24\u79cd\u8d44\u6e90\u3002 \u7f13\u51b2\u533a\u6bd4\u8f83\u7b80\u5355\u3002 \u5b83\u662f\u4efb\u4f55\u5177\u6709\u957f\u5ea6\u7684\u4e8c\u8fdb\u5236\u6570\u636e\u7684\u5bb9\u5668, \u4ee5\u5b57\u8282\u8868\u793a\u3002 \u53e6\u4e00\u65b9\u9762\uff0c\u56fe\u50cf\u4ee3\u8868\u4e00\u7ec4\u50cf\u7d20\u3002 \u8fd9\u662f\u5176\u4ed6\u56fe\u5f62API\u4e2d\u79f0\u4e3a\u7eb9\u7406\u7684\u5bf9\u8c61\u3002 \u9700\u8981\u66f4\u591a\u53c2\u6570\u6765\u6307\u5b9a\u56fe\u50cf\u7684\u521b\u5efa\u3002 \u5b83\u53ef\u4ee5\u662f1D\uff0c2D\u62163D\uff0c\u5177\u6709\u5404\u79cd\u50cf\u7d20\u683c\u5f0f\uff08\u5982R8G8B8A8_UNORM\u6216R32_SFLOAT\uff09\uff0c \u5e76\u4e14\u8fd8\u53ef\u4ee5\u5305\u542b\u8bb8\u591a\u79bb\u6563\u56fe\u50cf\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u5177\u6709\u591a\u4e2a\u9635\u5217\u5c42\u6216MIP\u7ea7\u522b\uff08\u6216\u4e24\u8005\uff09\u3002 \u56fe\u7247\u662f\u4e00\u79cd\u72ec\u7acb\u7684\u5bf9\u8c61\u7c7b\u578b\uff0c\u56e0\u4e3a\u5b83\u4e0d\u4e00\u5b9a\u53ea\u5305\u542b\u53ef\u4ee5\u76f4\u63a5\u8bbf\u95ee\u7684\u7ebf\u6027\u50cf\u7d20\u96c6\u3002 \u56fe\u50cf\u53ef\u4ee5\u5177\u6709\u7531\u56fe\u5f62\u9a71\u52a8\u7a0b\u5e8f\u7ba1\u7406\u7684\u4e0d\u540c\u7684\u7279\u5b9a\u4e8e\u5b9e\u73b0\u7684\u5185\u90e8\u683c\u5f0f\uff08\u5e73\u94fa\u548c\u5e03\u5c40\uff09\u3002 9. DeviceMemory \u521b\u5efa\u4e00\u5b9a\u957f\u5ea6\u7684\u7f13\u51b2\u533a\u6216\u5177\u6709\u7279\u5b9a\u5c3a\u5bf8\u7684\u56fe\u50cf\u4e0d\u4f1a\u81ea\u52a8\u4e3a\u5176\u5206\u914d\u5185\u5b58\u3002 \u8fd9\u662f\u4e00\u4e2a\u4e09\u6b65\u8fc7\u7a0b\uff0c\u5fc5\u987b\u7531\u60a8\u624b\u52a8\u6267\u884c\u3002 \u60a8\u4e5f\u53ef\u4ee5\u9009\u62e9\u4f7f\u7528\u6211\u4eec\u7684Vulkan\u5185\u5b58\u5206\u914d\u5668\u5e93\uff0c\u8be5\u5e93\u5c06\u4e3a\u60a8\u5206\u914d\u8d44\u6e90\u3002 1.\u5206\u914dDeviceMemory\uff0c 2.\u521b\u5efa\u7f13\u51b2\u533a\u6216\u56fe\u50cf\uff0c 3.\u4f7f\u7528\u529f\u80fdvkBindBufferMemory\u6216vkBindImageMemory\u5c06\u5b83\u4eec\u7ed1\u5b9a\u5728\u4e00\u8d77\u3002 \u56e0\u6b64\uff0c\u60a8\u8fd8\u5fc5\u987b\u521b\u5efa\u4e00\u4e2aDeviceMemory\u5bf9\u8c61\u3002 \u5b83\u4ee3\u8868\u4ece\u7279\u5b9a\u5185\u5b58\u7c7b\u578b\uff08\u7531PhysicalDevice\u652f\u6301\uff09\u5206\u914d\u7684\u5185\u5b58\u5757\uff0c\u5177\u6709\u7279\u5b9a\u7684\u5b57\u8282\u957f\u5ea6\u3002 \u60a8\u4e0d\u5e94\u8be5\u4e3a\u6bcf\u4e2a\u7f13\u51b2\u533a\u6216\u6620\u50cf\u5206\u914d\u5355\u72ec\u7684DeviceMemory\u3002 \u76f8\u53cd\uff0c\u60a8\u5e94\u8be5\u5206\u914d\u66f4\u5927\u7684\u5185\u5b58\u5757\uff0c\u5e76\u5c06\u5176\u4e2d\u7684\u4e00\u90e8\u5206\u5206\u914d\u7ed9\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u3002 \u5206\u914d\u662f\u4e00\u9879\u6602\u8d35\u7684\u64cd\u4f5c\uff0c\u5e76\u4e14\u6700\u5927\u5206\u914d\u6570\u91cf\u4e5f\u53d7\u5230\u9650\u5236\uff0c\u6240\u6709\u8fd9\u4e9b\u90fd\u53ef\u4ee5\u4ecePhysicalDevice\u4e2d\u67e5\u8be2\u3002 \u5bf9\u8c61\u7ec4 \u8bbe\u5907 Instance PhysicalDevice Queue Family Memory Heap Memory Type --> Device Memory Device Queue <-- Queue Family \u56fe\u50cf Surface Swapchain Image ImageView Framebuffer <--RenderPass \u7ba1\u9053 DescriptorSetLayout PipelineLayout ShaderModule Pipeline Cache PipeLine DescriptorSet <-- DescriptorSetLayout, DescriptorPool 3. Pipeline 4. \u8be6\u7ec6 Instance \u5b9e\u4f8b [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe","title":"1. Vulkan \u521d\u59cb\u5316 \u4e09\u89d2"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#1","text":"\u521d\u59cb\u8bbe\u7f6e Instance \u5b9e\u4f8b [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 \u5448\u73b0 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b \u7ed8\u5236 Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe \u6ce8: []: \u975e Vulkan \u6838\u5fc3 init_global_layer_properties(info); init_instance_extension_names(info); init_device_extension_names(info); init_instance(info, sample_title); init_enumerate_device(info); init_window_size(info, 500, 500); init_connection(info); init_window(info); init_swapchain_extension(info); init_device(info); init_command_pool(info); init_command_buffer(info); execute_begin_command_buffer(info); init_device_queue(info); init_swap_chain(info); init_depth_buffer(info); init_uniform_buffer(info); init_descriptor_and_pipeline_layouts(info, false); init_renderpass(info, depthPresent); #include \"15-draw_cube.vert.h\" #include \"15-draw_cube.frag.h\" VkShaderModuleCreateInfo vert_info = {}; VkShaderModuleCreateInfo frag_info = {}; vert_info.sType = frag_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; vert_info.codeSize = sizeof(__draw_cube_vert); vert_info.pCode = __draw_cube_vert; frag_info.codeSize = sizeof(__draw_cube_frag); frag_info.pCode = __draw_cube_frag; init_shaders(info, &vert_info, &frag_info); init_framebuffers(info, depthPresent); init_vertex_buffer(info, g_vb_solid_face_colors_Data, sizeof(g_vb_solid_face_colors_Data), sizeof(g_vb_solid_face_colors_Data[0]), false); init_descriptor_pool(info, false); init_descriptor_set(info, false); init_pipeline_cache(info); init_pipeline(info, depthPresent);","title":"1. \u6d41\u7a0b\u603b\u89c8"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#2-api","text":"\u521d\u59cb\u8bbe\u7f6e Instance \u5b9e\u4f8b vkCreateInstance [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf vkEnumeratePhysicalDevices vkGetPhysicalDeviceQueueFamilyProperties Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 \u5448\u73b0 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b \u7ed8\u5236 Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe","title":"2. \u521d\u59cb\u5316\u65f6, \u6d89\u53ca\u7684 API"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#2-vulkan-objects","text":"\u7eff\u8272\u6846: \u65e0\u7c7b\u578b, \u4ee5 uint32_t \u8868\u793a \u5b9e\u7ebf+\u7bad\u5934: \u521b\u5efa\u987a\u5e8f \u5b9e\u7ebf+\u83f1\u5f62: \u7ec4\u5408 (\u88ab\u5305\u542b) \u865a\u7ebf: \u901a\u4fe1 \u4e09\u4e2a\u533a\u57df\u4e2d, \u7ea2\u8272\u4e3a\u4e3b Object, \u5176\u4ed6\u5bf9\u8c61\u90fd\u76f4\u63a5\u6216\u95f4\u63a5\u7684\u7531\u6b64\u5bf9\u8c61\u521b\u5efa. \u8868\u73b0\u4e3a vkCreateSwapchainKHR \u9700\u8981 Device \u4e3a\u53c2\u6570.","title":"2. \u7406\u89e3 Vulkan\u00ae Objects"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#1-instance","text":"Instance \u662f\u521b\u5efa\u7684\u7b2c\u4e00\u4e2a\u5bf9\u8c61\u3002 \u5b83\u8868\u793a\u4ece\u5e94\u7528\u7a0b\u5e8f\u5230 Vulkan \u8fd0\u884c\u65f6\u7684 \u8fde\u63a5 \uff0c\u56e0\u6b64\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u4ec5\u5e94 \u5b58\u5728\u4e00\u6b21 \u3002 \u5b83\u8fd8\u5b58\u50a8\u4f7f\u7528 Vulkan \u6240\u9700\u7684\u6240\u6709\u7279\u5b9a\u4e8e \u5e94\u7528\u7a0b\u5e8f \u7684\u72b6\u6001\u3002 \u56e0\u6b64\uff0c\u60a8\u5fc5\u987b\u6307\u5b9a\u521b\u5efa\u5b9e\u4f8b\u65f6\u8981\u542f\u7528\u7684\u6240\u6709\u5c42 Layers \uff08\u4f8b\u5982\u9a8c\u8bc1\u5c42\uff09\u548c\u6240\u6709\u6269\u5c55 Extensions\u3002","title":"1. Instance"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#2-physicaldevice","text":"\u8868\u793a\u7279\u5b9a\u7684 Vulkan \u517c\u5bb9\u8bbe\u5907\uff0c\u4f8b\u5982\u56fe\u5f62\u5361\u3002 vkEnumeratePhysicalDevices \u60a8\u53ef\u4ee5\u4ece Instance \u4e2d \u679a\u4e3e \u5b83\u4eec\uff0c\u7136\u540e\u53ef\u4ee5\u67e5\u8be2\u5b83\u4eec\u7684 vendorID\uff0cdeviceID \u548c\u652f\u6301\u7684\u529f\u80fd\u4ee5\u53ca\u5176\u4ed6\u5c5e\u6027\u548c\u9650\u5236\u3002 vkGetPhysicalDeviceQueueFamilyProperties PhysicalDevice \u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u53ef\u7528\u7684 Queue Families \u7c7b\u578b\u3002 \u56fe\u5f62\u961f\u5217 Graphics Queue \u662f\u6700\u4e3b\u8981\u7684\u961f\u5217\uff0c\u4f46\u662f\u60a8\u53ef\u80fd\u8fd8\u6709\u5176\u4ed6\u4ec5\u652f\u6301\u8ba1\u7b97Compute \u6216\u4f20\u8f93 Transfer\u7684\u961f\u5217\u3002 PhysicalDevice\u8fd8\u53ef\u4ee5\u679a\u4e3e\u5176\u5185\u90e8\u7684\u5185\u5b58\u5806 Memory Heaps \u548c\u5185\u5b58\u7c7b\u578b Memory Types \u3002 Memory Heaps \u4ee3\u8868\u7279\u5b9a\u7684RAM\u6c60\u3002 \u5b83\u53ef\u80fd\u4f1a\u63d0\u53d6 \u4e3b\u677f\u4e0a\u7684\u7cfb\u7edfRAM, \u6216\u4e13\u7528\u56fe\u5f62\u5361\u4e0a\u7684\u89c6\u9891RAM\u4e2d\u7684\u7279\u5b9a\u5185\u5b58\u7a7a\u95f4\uff0c\u6216\u8005\u5b9e\u73b0\u8981\u516c\u5f00\u7684\u4efb\u4f55\u5176\u4ed6\u7279\u5b9a\u4e8e\u4e3b\u673a\u6216\u8bbe\u5907\u7684\u5185\u5b58\u3002 \u5206\u914d\u5185\u5b58 Allocate Memory \u65f6\u5fc5\u987b\u6307\u5b9a Memory Types \u3002 \u5b83\u5177\u6709\u5bf9 Memory Blob \u7684\u7279\u5b9a\u8981\u6c42\uff0c\u4f8b\u5982\u5bf9 host \u53ef\u89c1\uff0c\u4e00\u81f4\u6027 coherent\uff08\u5728CPU\u548cGPU\u4e4b\u95f4\uff09\u548c\u5df2\u7f13\u5b58 cached\u3002\u8fd9\u4e9b\u53ef\u80fd\u4f1a\u4efb\u610f\u7ec4\u5408\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f\u3002","title":"2. PhysicalDevice"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#3-device","text":"\u53c8\u88ab\u89c6\u4e3a \u903b\u8f91\u8bbe\u5907 Logical Device \u6216 Opened Device. \u5b83\u4ee3\u8868\u4e86\u4e00\u4e2a\u5df2\u7ecf\u521d\u59cb\u5316\u7684 Vulkan \u8bbe\u5907, \u51c6\u5907\u597d\u521b\u5efa\u5176\u4ed6\u5bf9\u8c61 \u521b\u5efa\u8bbe\u5907\u65f6, \u9700\u6307\u5b9a\u542f\u7528\u54ea\u4e9b Features , \u5e76\u58f0\u660e\u6240\u6709\u4f7f\u7528\u7684 Queue , \u5176\u7f16\u53f7 \u548c\u5176 Queue Family","title":"3. Device"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#4-queue","text":"Device \u4e0a\u6267\u884c\u7684\u547d\u4ee4\u961f\u5217 Queue of Commands\u3002 \u901a\u8fc7\u4f7f\u7528 vkQueueSubmit \u586b\u5145 CommandBuffer \u5e76\u5c06\u5176\u63d0\u4ea4\u5230 Queue\uff0c\u6765\u8bf7\u6c42 GPU \u5b8c\u6210\u7684\u6240\u6709\u5b9e\u9645\u5de5\u4f5c\u3002 \u5982\u679c\u6709\u591a\u4e2a\u961f\u5217\uff0c\u4f8b\u5982 Graphic Queue \u548c Compute Queue\uff0c\u5219\u53ef\u4ee5\u5411\u6bcf\u4e2a\u961f\u5217\u63d0\u4ea4\u4e0d\u540c\u7684CommandBuffer\u3002\u8fd9\u6837\uff0c\u60a8\u5c31\u53ef\u4ee5\u542f\u7528\u5f02\u6b65\u8ba1\u7b97\uff0c\u5982\u679c\u6267\u884c\u6b63\u786e\u7684\u8bdd\uff0c\u53ef\u4ee5\u5927\u5927\u63d0\u9ad8\u901f\u5ea6\u3002","title":"4. Queue"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#5-commandpool","text":"\u7528\u4e8e\u5206\u914d CommandBuffer \u3002\u5b83\u5df2\u8fde\u63a5\u5230\u7279\u5b9a\u7684 Queue Family \u3002","title":"5. CommandPool"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#6-commandbuffer","text":"\u4ece\u6307\u5b9a\u7684 CommandPool \u5206\u914d\u3002\u5b83\u4ee3\u8868 Device \u8981\u6267\u884c\u7684\u5404\u79cd\u547d\u4ee4\u7684\u7f13\u51b2\u533a\u3002 \u53ef\u4ee5\u5728 Command Buffer \u4e0a\u8c03\u7528\u5404 vkCmd \u5f00\u5934\u7684\u51fd\u6570\uff0c\u7528\u4e8e\u6307\u5b9a \u6267\u884c\u7684\u4efb\u52a1\u7684\u987a\u5e8f\uff0c\u7c7b\u578b\u548c\u53c2\u6570\u3002 \u4e4b\u540e CommandBuffer \u63d0\u4ea4\u5230 Queue \u5e76\u6700\u7ec8\u7531 Device \u6267\u884c","title":"6. CommandBuffer"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#7-sampler","text":"\u91c7\u6837\u5668 Sampler \u672a\u7ed1\u5b9a\u5230\u4efb\u4f55\u7279\u5b9a\u56fe\u50cf Image\u3002\u5b83\u53ea\u662f\u4e00\u7ec4\u72b6\u6001\u53c2\u6570 state parameters \uff0c \u4f8b\u5982\u8fc7\u6ee4\u6a21\u5f0f (filtering mode)\uff08\u6700\u8fd1\u6216\u7ebf\u6027 nearest or linear\uff09,\u6216\u5bfb\u5740\u6a21\u5f0f (addressing mode)\uff08\u91cd\u590d\uff0c\u94b3\u4f4d\u5230\u8fb9\u7f18\uff0c\u94b3\u4f4d\u5230\u8fb9\u754c\u7b49 repeat, clamp-to-edge, clamp-to-border\uff09\u3002","title":"7. Sampler"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#8-image-buffer","text":"","title":"8. Image &amp; Buffer"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#todo","text":"\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u662f\u5360\u7528\u8bbe\u5907\u5185\u5b58\u7684\u4e24\u79cd\u8d44\u6e90\u3002 \u7f13\u51b2\u533a\u6bd4\u8f83\u7b80\u5355\u3002 \u5b83\u662f\u4efb\u4f55\u5177\u6709\u957f\u5ea6\u7684\u4e8c\u8fdb\u5236\u6570\u636e\u7684\u5bb9\u5668, \u4ee5\u5b57\u8282\u8868\u793a\u3002 \u53e6\u4e00\u65b9\u9762\uff0c\u56fe\u50cf\u4ee3\u8868\u4e00\u7ec4\u50cf\u7d20\u3002 \u8fd9\u662f\u5176\u4ed6\u56fe\u5f62API\u4e2d\u79f0\u4e3a\u7eb9\u7406\u7684\u5bf9\u8c61\u3002 \u9700\u8981\u66f4\u591a\u53c2\u6570\u6765\u6307\u5b9a\u56fe\u50cf\u7684\u521b\u5efa\u3002 \u5b83\u53ef\u4ee5\u662f1D\uff0c2D\u62163D\uff0c\u5177\u6709\u5404\u79cd\u50cf\u7d20\u683c\u5f0f\uff08\u5982R8G8B8A8_UNORM\u6216R32_SFLOAT\uff09\uff0c \u5e76\u4e14\u8fd8\u53ef\u4ee5\u5305\u542b\u8bb8\u591a\u79bb\u6563\u56fe\u50cf\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u5177\u6709\u591a\u4e2a\u9635\u5217\u5c42\u6216MIP\u7ea7\u522b\uff08\u6216\u4e24\u8005\uff09\u3002 \u56fe\u7247\u662f\u4e00\u79cd\u72ec\u7acb\u7684\u5bf9\u8c61\u7c7b\u578b\uff0c\u56e0\u4e3a\u5b83\u4e0d\u4e00\u5b9a\u53ea\u5305\u542b\u53ef\u4ee5\u76f4\u63a5\u8bbf\u95ee\u7684\u7ebf\u6027\u50cf\u7d20\u96c6\u3002 \u56fe\u50cf\u53ef\u4ee5\u5177\u6709\u7531\u56fe\u5f62\u9a71\u52a8\u7a0b\u5e8f\u7ba1\u7406\u7684\u4e0d\u540c\u7684\u7279\u5b9a\u4e8e\u5b9e\u73b0\u7684\u5185\u90e8\u683c\u5f0f\uff08\u5e73\u94fa\u548c\u5e03\u5c40\uff09\u3002","title":"TODO"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#9-devicememory","text":"\u521b\u5efa\u4e00\u5b9a\u957f\u5ea6\u7684\u7f13\u51b2\u533a\u6216\u5177\u6709\u7279\u5b9a\u5c3a\u5bf8\u7684\u56fe\u50cf\u4e0d\u4f1a\u81ea\u52a8\u4e3a\u5176\u5206\u914d\u5185\u5b58\u3002 \u8fd9\u662f\u4e00\u4e2a\u4e09\u6b65\u8fc7\u7a0b\uff0c\u5fc5\u987b\u7531\u60a8\u624b\u52a8\u6267\u884c\u3002 \u60a8\u4e5f\u53ef\u4ee5\u9009\u62e9\u4f7f\u7528\u6211\u4eec\u7684Vulkan\u5185\u5b58\u5206\u914d\u5668\u5e93\uff0c\u8be5\u5e93\u5c06\u4e3a\u60a8\u5206\u914d\u8d44\u6e90\u3002 1.\u5206\u914dDeviceMemory\uff0c 2.\u521b\u5efa\u7f13\u51b2\u533a\u6216\u56fe\u50cf\uff0c 3.\u4f7f\u7528\u529f\u80fdvkBindBufferMemory\u6216vkBindImageMemory\u5c06\u5b83\u4eec\u7ed1\u5b9a\u5728\u4e00\u8d77\u3002 \u56e0\u6b64\uff0c\u60a8\u8fd8\u5fc5\u987b\u521b\u5efa\u4e00\u4e2aDeviceMemory\u5bf9\u8c61\u3002 \u5b83\u4ee3\u8868\u4ece\u7279\u5b9a\u5185\u5b58\u7c7b\u578b\uff08\u7531PhysicalDevice\u652f\u6301\uff09\u5206\u914d\u7684\u5185\u5b58\u5757\uff0c\u5177\u6709\u7279\u5b9a\u7684\u5b57\u8282\u957f\u5ea6\u3002 \u60a8\u4e0d\u5e94\u8be5\u4e3a\u6bcf\u4e2a\u7f13\u51b2\u533a\u6216\u6620\u50cf\u5206\u914d\u5355\u72ec\u7684DeviceMemory\u3002 \u76f8\u53cd\uff0c\u60a8\u5e94\u8be5\u5206\u914d\u66f4\u5927\u7684\u5185\u5b58\u5757\uff0c\u5e76\u5c06\u5176\u4e2d\u7684\u4e00\u90e8\u5206\u5206\u914d\u7ed9\u7f13\u51b2\u533a\u548c\u56fe\u50cf\u3002 \u5206\u914d\u662f\u4e00\u9879\u6602\u8d35\u7684\u64cd\u4f5c\uff0c\u5e76\u4e14\u6700\u5927\u5206\u914d\u6570\u91cf\u4e5f\u53d7\u5230\u9650\u5236\uff0c\u6240\u6709\u8fd9\u4e9b\u90fd\u53ef\u4ee5\u4ecePhysicalDevice\u4e2d\u67e5\u8be2\u3002","title":"9. DeviceMemory"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#_1","text":"","title":"\u5bf9\u8c61\u7ec4"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#_2","text":"Instance PhysicalDevice Queue Family Memory Heap Memory Type --> Device Memory Device Queue <-- Queue Family","title":"\u8bbe\u5907"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#_3","text":"Surface Swapchain Image ImageView Framebuffer <--RenderPass","title":"\u56fe\u50cf"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#_4","text":"DescriptorSetLayout PipelineLayout ShaderModule Pipeline Cache PipeLine DescriptorSet <-- DescriptorSetLayout, DescriptorPool","title":"\u7ba1\u9053"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#3-pipeline","text":"","title":"3. Pipeline"},{"location":"Vulkan/1.%20Vulkan_%E5%88%9D%E5%A7%8B%E5%8C%96_%E4%B8%89%E8%A7%92/#4","text":"Instance \u5b9e\u4f8b [Validation Layer \u6821\u9a8c\u5c42] Physical Device & Queue Family \u7269\u7406\u8bbe\u5907 \u4e0e \u961f\u5217\u65cf Device & Queue \u903b\u8f91\u8bbe\u5907 \u4e0e \u961f\u5217 [Surface \u7a97\u53e3] Swapchain \u4ea4\u6362\u94fe ImageView \u56fe\u50cf\u89c6\u56fe Pipeline \u7ba1\u9053 Shader Modules \u7740\u8272\u5668 Fixed Function \u56fa\u5b9a\u65b9\u6cd5 Renderpass \u6e32\u67d3\u6d41\u7a0b Framebuffers \u5e27\u7f13\u51b2 Commandbuffers \u6307\u4ee4\u7f13\u51b2 Rendering and presentation \u6e32\u67d3\u4e0e\u5448\u73b0 Recreation Swapchain \u91cd\u7ed8\u4ea4\u6362\u94fe","title":"4. \u8be6\u7ec6"},{"location":"Vulkan/Pipeline/","text":"Pipeline \u5728 Vulkan \u4e2d, \u6e32\u67d3\u7ba1\u7ebf\u9700\u8981\u624b\u52a8\u521b\u5efa. Vulkan\u4e2d\u521b\u5efa\u5bf9\u8c61\u7684\u8fc7\u7a0b\u5927\u591a\u90fd\u901a\u8fc7\u4f7f\u7528 VkXXXCreateInfo \u7ed3\u6784\u4f53, \u4e3a\u7ed3\u6784\u4f53\u5404\u5c5e\u6027\u8d4b\u503c\u540e\u8c03\u7528 vk API\u521b\u5efa. \u5bf9\u5e94Pipeline\u7684\u521b\u5efa\u7ed3\u6784\u4f53\u4e3a VkGraphicsPipelineCreateInfo , \u5176\u9664\u4e86\u6240\u6709\u7ed3\u6784\u4f53\u7684\u5171\u6709\u5c5e\u6027(sType, pNext)\u5916, \u8fd8\u5305\u62ec\u4e86 10\u4e2a\u5b50\u7ed3\u6784\u4f53\u5c5e\u6027, \u5206\u522b\u5bf9\u5e94\u6e32\u67d3\u7ba1\u7ebf\u7684\u5341\u4e2a\u56fa\u5b9a\u6d41\u7a0b. \u4ee5\u53ca 3\u4e2a\u5bf9\u8c61: PipelineLayout, RenderPass, subpass Pipeline Fixed Functions: VkPipeline Shader StageCreateInfo* pStages; VkPipeline VertexInput StateCreateInfo* pVertexInputState; VkPipeline InputAssembly StateCreateInfo* pInputAssemblyState; VkPipeline Tessellation StateCreateInfo* pTessellationState; VkPipeline Viewport StateCreateInfo* pViewportState; VkPipeline Rasterization StateCreateInfo* pRasterizationState; VkPipeline Multisample StateCreateInfo* pMultisampleState; VkPipeline DepthStencil StateCreateInfo* pDepthStencilState; VkPipeline ColorBlend StateCreateInfo* pColorBlendState; VkPipeline Dynamic StateCreateInfo* pDynamicState; Objects: PipelineLayout layout; RenderPass renderPass; int subpass; // Shader Stages <-- Shader Modules VkPipelineShaderStageCreateInfo vertShaderStageInfo{}; vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; vertShaderStageInfo.module = vertShaderModule; vertShaderStageInfo.pName = \"main\"; VkPipelineShaderStageCreateInfo fragShaderStageInfo{}; fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; fragShaderStageInfo.module = fragShaderModule; fragShaderStageInfo.pName = \"main\"; VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo }; // Vertex Input State VkPipelineVertexInputStateCreateInfo vertexInputInfo{}; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.vertexAttributeDescriptionCount = 0; // Input Assembly State VkPipelineInputAssemblyStateCreateInfo inputAssembly{}; inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; inputAssembly.primitiveRestartEnable = VK_FALSE; VkViewport viewport{}; viewport.x = 0.0f; viewport.y = 0.0f; viewport.width = (float)swapChainExtent.width; viewport.height = (float)swapChainExtent.height; viewport.minDepth = 0.0f; viewport.maxDepth = 1.0f; VkRect2D scissor{}; scissor.offset = { 0, 0 }; scissor.extent = VkExtent2D; // Viewport State <-- viewport extent, scissor extent VkPipelineViewportStateCreateInfo viewportState{}; viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; viewportState.pScissors = &scissor; // Rasterization State VkPipelineRasterizationStateCreateInfo rasterizer{}; rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterizer.depthClampEnable = VK_FALSE; rasterizer.rasterizerDiscardEnable = VK_FALSE; rasterizer.polygonMode = VK_POLYGON_MODE_FILL; rasterizer.lineWidth = 1.0f; rasterizer.cullMode = VK_CULL_MODE_BACK_BIT; rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; rasterizer.depthBiasEnable = VK_FALSE; // Multisample State VkPipelineMultisampleStateCreateInfo multisampling{}; multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampling.sampleShadingEnable = VK_FALSE; multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; // Color Blend Attachment State VkPipelineColorBlendAttachmentState colorBlendAttachment{}; colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; colorBlendAttachment.blendEnable = VK_FALSE; VkPipelineColorBlendStateCreateInfo colorBlending{}; colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; colorBlending.logicOpEnable = VK_FALSE; colorBlending.logicOp = VK_LOGIC_OP_COPY; colorBlending.attachmentCount = 1; colorBlending.pAttachments = &colorBlendAttachment; colorBlending.blendConstants[0] = 0.0f; colorBlending.blendConstants[1] = 0.0f; colorBlending.blendConstants[2] = 0.0f; colorBlending.blendConstants[3] = 0.0f; // Pipeline Layout VkPipelineLayoutCreateInfo pipelineLayoutInfo{}; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; pipelineLayoutInfo.pushConstantRangeCount = 0; if (vkCreatePipelineLayout(mDevice, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) { throw std::runtime_error(\"failed to create pipeline layout!\"); } //------ Pipeline Layout & Render Pass are ready, setup finish // ----- Create Graphics Pipeline ---------- VkGraphicsPipelineCreateInfo pipelineInfo{}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 2; pipelineInfo.pStages = shaderStages; // shaders pipelineInfo.pVertexInputState = &vertexInputInfo; // vertex input pipelineInfo.pInputAssemblyState = &inputAssembly; // input assembly pipelineInfo.pViewportState = &viewportState; // viewport pipelineInfo.pRasterizationState = &rasterizer; // rasterizer pipelineInfo.pMultisampleState = &multisampling; // multisampling pipelineInfo.pColorBlendState = &colorBlending; // colorBlending pipelineInfo.layout = pipelineLayout; pipelineInfo.renderPass = renderPass; // render pass pipelineInfo.subpass = 0; pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; Pipeline Fixed Function Properties: // \u7701\u7565\u4e86\u6240\u6709 CreateInfo \u7684 sType, pNext, \u548c xxxxflags Graphics_Pipeline { stageCount = 2; // create infos pStages = [ // shader modules vertShaderStageInfo = { stage = VK_SHADER_STAGE_VERTEX_BIT; module = vertShaderModule; // VkShaderModule pName = \"main\"; // const VkSpecializationInfo* pSpecializationInfo; } fragShaderStageInfo = { stage = VK_SHADER_STAGE_FRAGMENT_BIT; module = fragShaderModule; // VkShaderModule pName = \"main\"; // const VkSpecializationInfo* pSpecializationInfo; } ], pVertexInputState = Vertex_Input_State { // vertex input vertexBindingDescriptionCount = 0; pVertexBindingDescriptions = null; vertexAttributeDescriptionCount = 0; pVertexAttributeDescriptions = null; }; pInputAssemblyState = { // input assembly topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; primitiveRestartEnable = VK_FALSE; }; pTessellationState = null; // Tessellation pViewportState = { // Viewport viewportCount = 1; pViewports = { x = 0.0f; y = 0.0f; width = (float)swapChainExtent.width; // VkExtent2D height = (float)swapChainExtent.height; minDepth = 0.0f; maxDepth = 1.0f; }; scissorCount = 1; pScissors = { offset: { 0, 0 }; extent = swapChainExtent; // VkExtent2D }; }; pRasterizationState = { // Rasterizer depthClampEnable = VK_FALSE; rasterizerDiscardEnable = VK_FALSE; polygonMode = VK_POLYGON_MODE_FILL; lineWidth = 1.0f; cullMode = VK_CULL_MODE_BACK_BIT; frontFace = VK_FRONT_FACE_CLOCKWISE; depthBiasEnable = VK_FALSE; //float depthBiasConstantFactor; //float depthBiasClamp; //float depthBiasSlopeFactor; }; pMultisampleState = { // multisampling sampleShadingEnable = VK_FALSE; rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; // float minSampleShading; // const VkSampleMask* pSampleMask; // VkBool32 alphaToCoverageEnable; // VkBool32 alphaToOneEnable; }; pDepthStencilState : null, pColorBlendState = { // colorBlending logicOpEnable = VK_FALSE; logicOp = VK_LOGIC_OP_COPY; attachmentCount = 1; pAttachments = &colorBlendAttachment; blendConstants[0] = 0.0f; blendConstants[1] = 0.0f; blendConstants[2] = 0.0f; blendConstants[3] = 0.0f; }; pDynamicState : null, // vars layout = { setLayoutCount = 0; // const VkDescriptorSetLayout* pSetLayouts; pushConstantRangeCount = 0; //const VkPushConstantRange* pPushConstantRanges; }; renderPass = renderPass; // render pass subpass = 0; basePipelineHandle = VK_NULL_HANDLE; basePipelineIndex = 0, } Render Pass VkAttachmentDescription colorAttachment{}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; VkAttachmentReference colorAttachmentRef{}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkSubpassDescription subpass{}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; // \u540e\u52a0\u7684?? VkSubpassDependency dependency{}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; VkRenderPassCreateInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; if (vkCreateRenderPass(mDevice, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } Json RenderPass { attachmentCount = 1; pAttachments = { // VkAttachmentDescription colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; }; subpassCount = 1; pSubpasses = { // VkSubpassDescription pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; colorAttachmentCount = 1; pColorAttachments = { // VkAttachmentReference colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; }; // uint32_t inputAttachmentCount; // const VkAttachmentReference* pInputAttachments; // const VkAttachmentReference* pResolveAttachments; // const VkAttachmentReference* pDepthStencilAttachment; // uint32_t preserveAttachmentCount; // const uint32_t* pPreserveAttachments; }; dependencyCount = 1; pDependencies = { srcSubpass = VK_SUBPASS_EXTERNAL; dstSubpass = 0; srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; srcAccessMask = 0; dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; }; // VkSubpassDependency }","title":"Pipeline"},{"location":"Vulkan/Pipeline/#pipeline","text":"\u5728 Vulkan \u4e2d, \u6e32\u67d3\u7ba1\u7ebf\u9700\u8981\u624b\u52a8\u521b\u5efa. Vulkan\u4e2d\u521b\u5efa\u5bf9\u8c61\u7684\u8fc7\u7a0b\u5927\u591a\u90fd\u901a\u8fc7\u4f7f\u7528 VkXXXCreateInfo \u7ed3\u6784\u4f53, \u4e3a\u7ed3\u6784\u4f53\u5404\u5c5e\u6027\u8d4b\u503c\u540e\u8c03\u7528 vk API\u521b\u5efa. \u5bf9\u5e94Pipeline\u7684\u521b\u5efa\u7ed3\u6784\u4f53\u4e3a VkGraphicsPipelineCreateInfo , \u5176\u9664\u4e86\u6240\u6709\u7ed3\u6784\u4f53\u7684\u5171\u6709\u5c5e\u6027(sType, pNext)\u5916, \u8fd8\u5305\u62ec\u4e86 10\u4e2a\u5b50\u7ed3\u6784\u4f53\u5c5e\u6027, \u5206\u522b\u5bf9\u5e94\u6e32\u67d3\u7ba1\u7ebf\u7684\u5341\u4e2a\u56fa\u5b9a\u6d41\u7a0b. \u4ee5\u53ca 3\u4e2a\u5bf9\u8c61: PipelineLayout, RenderPass, subpass Pipeline Fixed Functions: VkPipeline Shader StageCreateInfo* pStages; VkPipeline VertexInput StateCreateInfo* pVertexInputState; VkPipeline InputAssembly StateCreateInfo* pInputAssemblyState; VkPipeline Tessellation StateCreateInfo* pTessellationState; VkPipeline Viewport StateCreateInfo* pViewportState; VkPipeline Rasterization StateCreateInfo* pRasterizationState; VkPipeline Multisample StateCreateInfo* pMultisampleState; VkPipeline DepthStencil StateCreateInfo* pDepthStencilState; VkPipeline ColorBlend StateCreateInfo* pColorBlendState; VkPipeline Dynamic StateCreateInfo* pDynamicState; Objects: PipelineLayout layout; RenderPass renderPass; int subpass; // Shader Stages <-- Shader Modules VkPipelineShaderStageCreateInfo vertShaderStageInfo{}; vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; vertShaderStageInfo.module = vertShaderModule; vertShaderStageInfo.pName = \"main\"; VkPipelineShaderStageCreateInfo fragShaderStageInfo{}; fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; fragShaderStageInfo.module = fragShaderModule; fragShaderStageInfo.pName = \"main\"; VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo }; // Vertex Input State VkPipelineVertexInputStateCreateInfo vertexInputInfo{}; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.vertexAttributeDescriptionCount = 0; // Input Assembly State VkPipelineInputAssemblyStateCreateInfo inputAssembly{}; inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; inputAssembly.primitiveRestartEnable = VK_FALSE; VkViewport viewport{}; viewport.x = 0.0f; viewport.y = 0.0f; viewport.width = (float)swapChainExtent.width; viewport.height = (float)swapChainExtent.height; viewport.minDepth = 0.0f; viewport.maxDepth = 1.0f; VkRect2D scissor{}; scissor.offset = { 0, 0 }; scissor.extent = VkExtent2D; // Viewport State <-- viewport extent, scissor extent VkPipelineViewportStateCreateInfo viewportState{}; viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; viewportState.pScissors = &scissor; // Rasterization State VkPipelineRasterizationStateCreateInfo rasterizer{}; rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterizer.depthClampEnable = VK_FALSE; rasterizer.rasterizerDiscardEnable = VK_FALSE; rasterizer.polygonMode = VK_POLYGON_MODE_FILL; rasterizer.lineWidth = 1.0f; rasterizer.cullMode = VK_CULL_MODE_BACK_BIT; rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; rasterizer.depthBiasEnable = VK_FALSE; // Multisample State VkPipelineMultisampleStateCreateInfo multisampling{}; multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampling.sampleShadingEnable = VK_FALSE; multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; // Color Blend Attachment State VkPipelineColorBlendAttachmentState colorBlendAttachment{}; colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; colorBlendAttachment.blendEnable = VK_FALSE; VkPipelineColorBlendStateCreateInfo colorBlending{}; colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; colorBlending.logicOpEnable = VK_FALSE; colorBlending.logicOp = VK_LOGIC_OP_COPY; colorBlending.attachmentCount = 1; colorBlending.pAttachments = &colorBlendAttachment; colorBlending.blendConstants[0] = 0.0f; colorBlending.blendConstants[1] = 0.0f; colorBlending.blendConstants[2] = 0.0f; colorBlending.blendConstants[3] = 0.0f; // Pipeline Layout VkPipelineLayoutCreateInfo pipelineLayoutInfo{}; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; pipelineLayoutInfo.pushConstantRangeCount = 0; if (vkCreatePipelineLayout(mDevice, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) { throw std::runtime_error(\"failed to create pipeline layout!\"); } //------ Pipeline Layout & Render Pass are ready, setup finish // ----- Create Graphics Pipeline ---------- VkGraphicsPipelineCreateInfo pipelineInfo{}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 2; pipelineInfo.pStages = shaderStages; // shaders pipelineInfo.pVertexInputState = &vertexInputInfo; // vertex input pipelineInfo.pInputAssemblyState = &inputAssembly; // input assembly pipelineInfo.pViewportState = &viewportState; // viewport pipelineInfo.pRasterizationState = &rasterizer; // rasterizer pipelineInfo.pMultisampleState = &multisampling; // multisampling pipelineInfo.pColorBlendState = &colorBlending; // colorBlending pipelineInfo.layout = pipelineLayout; pipelineInfo.renderPass = renderPass; // render pass pipelineInfo.subpass = 0; pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; Pipeline Fixed Function Properties: // \u7701\u7565\u4e86\u6240\u6709 CreateInfo \u7684 sType, pNext, \u548c xxxxflags Graphics_Pipeline { stageCount = 2; // create infos pStages = [ // shader modules vertShaderStageInfo = { stage = VK_SHADER_STAGE_VERTEX_BIT; module = vertShaderModule; // VkShaderModule pName = \"main\"; // const VkSpecializationInfo* pSpecializationInfo; } fragShaderStageInfo = { stage = VK_SHADER_STAGE_FRAGMENT_BIT; module = fragShaderModule; // VkShaderModule pName = \"main\"; // const VkSpecializationInfo* pSpecializationInfo; } ], pVertexInputState = Vertex_Input_State { // vertex input vertexBindingDescriptionCount = 0; pVertexBindingDescriptions = null; vertexAttributeDescriptionCount = 0; pVertexAttributeDescriptions = null; }; pInputAssemblyState = { // input assembly topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; primitiveRestartEnable = VK_FALSE; }; pTessellationState = null; // Tessellation pViewportState = { // Viewport viewportCount = 1; pViewports = { x = 0.0f; y = 0.0f; width = (float)swapChainExtent.width; // VkExtent2D height = (float)swapChainExtent.height; minDepth = 0.0f; maxDepth = 1.0f; }; scissorCount = 1; pScissors = { offset: { 0, 0 }; extent = swapChainExtent; // VkExtent2D }; }; pRasterizationState = { // Rasterizer depthClampEnable = VK_FALSE; rasterizerDiscardEnable = VK_FALSE; polygonMode = VK_POLYGON_MODE_FILL; lineWidth = 1.0f; cullMode = VK_CULL_MODE_BACK_BIT; frontFace = VK_FRONT_FACE_CLOCKWISE; depthBiasEnable = VK_FALSE; //float depthBiasConstantFactor; //float depthBiasClamp; //float depthBiasSlopeFactor; }; pMultisampleState = { // multisampling sampleShadingEnable = VK_FALSE; rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; // float minSampleShading; // const VkSampleMask* pSampleMask; // VkBool32 alphaToCoverageEnable; // VkBool32 alphaToOneEnable; }; pDepthStencilState : null, pColorBlendState = { // colorBlending logicOpEnable = VK_FALSE; logicOp = VK_LOGIC_OP_COPY; attachmentCount = 1; pAttachments = &colorBlendAttachment; blendConstants[0] = 0.0f; blendConstants[1] = 0.0f; blendConstants[2] = 0.0f; blendConstants[3] = 0.0f; }; pDynamicState : null, // vars layout = { setLayoutCount = 0; // const VkDescriptorSetLayout* pSetLayouts; pushConstantRangeCount = 0; //const VkPushConstantRange* pPushConstantRanges; }; renderPass = renderPass; // render pass subpass = 0; basePipelineHandle = VK_NULL_HANDLE; basePipelineIndex = 0, } Render Pass VkAttachmentDescription colorAttachment{}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; VkAttachmentReference colorAttachmentRef{}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkSubpassDescription subpass{}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; // \u540e\u52a0\u7684?? VkSubpassDependency dependency{}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; VkRenderPassCreateInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; if (vkCreateRenderPass(mDevice, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } Json RenderPass { attachmentCount = 1; pAttachments = { // VkAttachmentDescription colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; }; subpassCount = 1; pSubpasses = { // VkSubpassDescription pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; colorAttachmentCount = 1; pColorAttachments = { // VkAttachmentReference colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; }; // uint32_t inputAttachmentCount; // const VkAttachmentReference* pInputAttachments; // const VkAttachmentReference* pResolveAttachments; // const VkAttachmentReference* pDepthStencilAttachment; // uint32_t preserveAttachmentCount; // const uint32_t* pPreserveAttachments; }; dependencyCount = 1; pDependencies = { srcSubpass = VK_SUBPASS_EXTERNAL; dstSubpass = 0; srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; srcAccessMask = 0; dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; }; // VkSubpassDependency }","title":"Pipeline"},{"location":"Vulkan/VkFramebuffer/","text":"Vulken Framebuffer Vulkan_\u5c4f\u5e55\u7a7a\u95f4\u53cd\u5c04(SSR) \u5ef6\u8fdf\u6e32\u67d3 VkRenderPass \u5728\u8fdb\u884c\u7ba1\u7ebf\u521b\u5efa\u4e4b\u524d\uff0c\u9700\u8981\u8bbe\u7f6e\u7528\u4e8e\u6e32\u67d3\u7684\u5e27\u7f13\u51b2\u9644\u7740\u3002\u6211\u4eec \u9700\u8981\u6307\u5b9a\u4f7f\u7528\u7684\u989c\u8272\u548c\u6df1\u5ea6\u7f13\u51b2\uff0c\u4ee5\u53ca\u91c7\u6837\u6570\uff0c\u6e32\u67d3\u64cd\u4f5c\u5982\u4f55\u5904\u7406\u7f13\u51b2\u7684 \u5185\u5bb9\u3002\u6240\u6709\u8fd9\u4e9b\u4fe1\u606f\u88abVulkan \u5305\u88c5\u4e3a\u4e00\u4e2a\u6e32\u67d3\u6d41\u7a0b\u5bf9\u8c61\uff0c void createRenderPass() { VkAttachmentDescription colorAttachment{}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; VkAttachmentReference colorAttachmentRef{}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkSubpassDescription subpass{}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; VkSubpassDependency dependency{}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; VkRenderPassCreateInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } } Draw \u591a\u4e2a Framebuffer \u4e0e ES FBO\u5bf9\u6bd4 \u9ed8\u8ba4fbo \u9644\u7740 \u79bb\u5c4f\u6e32\u67d3 \u62f7\u8d1d","title":"Vulken Framebuffer"},{"location":"Vulkan/VkFramebuffer/#vulken-framebuffer","text":"Vulkan_\u5c4f\u5e55\u7a7a\u95f4\u53cd\u5c04(SSR) \u5ef6\u8fdf\u6e32\u67d3","title":"Vulken Framebuffer"},{"location":"Vulkan/VkFramebuffer/#vkrenderpass","text":"\u5728\u8fdb\u884c\u7ba1\u7ebf\u521b\u5efa\u4e4b\u524d\uff0c\u9700\u8981\u8bbe\u7f6e\u7528\u4e8e\u6e32\u67d3\u7684\u5e27\u7f13\u51b2\u9644\u7740\u3002\u6211\u4eec \u9700\u8981\u6307\u5b9a\u4f7f\u7528\u7684\u989c\u8272\u548c\u6df1\u5ea6\u7f13\u51b2\uff0c\u4ee5\u53ca\u91c7\u6837\u6570\uff0c\u6e32\u67d3\u64cd\u4f5c\u5982\u4f55\u5904\u7406\u7f13\u51b2\u7684 \u5185\u5bb9\u3002\u6240\u6709\u8fd9\u4e9b\u4fe1\u606f\u88abVulkan \u5305\u88c5\u4e3a\u4e00\u4e2a\u6e32\u67d3\u6d41\u7a0b\u5bf9\u8c61\uff0c void createRenderPass() { VkAttachmentDescription colorAttachment{}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; VkAttachmentReference colorAttachmentRef{}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; VkSubpassDescription subpass{}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; VkSubpassDependency dependency{}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; VkRenderPassCreateInfo renderPassInfo{}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } }","title":"VkRenderPass"},{"location":"Vulkan/VkFramebuffer/#draw","text":"","title":"Draw"},{"location":"Vulkan/VkFramebuffer/#framebuffer","text":"","title":"\u591a\u4e2a Framebuffer"},{"location":"Vulkan/VkFramebuffer/#es-fbo","text":"\u9ed8\u8ba4fbo \u9644\u7740 \u79bb\u5c4f\u6e32\u67d3 \u62f7\u8d1d","title":"\u4e0e ES FBO\u5bf9\u6bd4"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/","text":"Vulkan \u521b\u5efaVulkan\u5b9e\u4f8b Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217\u7c07 Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b Vulkan \u9a8c\u8bc1\u5c42 Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217 Vulkan \u4ea4\u6362\u94fe Vulkan Window Surface Vulkan \u56fe\u5f62\u7ba1\u7ebf Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe Vulkan \u7740\u8272\u5668\u6a21\u5757 Vulkan \u56fa\u6709\u529f\u80fd Vulkan \u5e27\u7f13\u51b2\u533a Vulkan \u96c6\u6210\u7ba1\u7ebf Vulkan \u6e32\u67d3\u901a\u9053 Vulkan \u547d\u4ee4\u7f13\u51b2\u533a Vulkan \u6e32\u67d3\u548c\u663e\u793a Vulkan \u91cd\u6784\u4ea4\u6362\u94fe Vulkan \u9876\u70b9\u8f93\u5165 Vulkan \u521b\u5efa\u9876\u70b9\u7f13\u51b2\u533a Vulkan \u4e34\u65f6\u7f13\u51b2\u533a Vulkan \u7d22\u5f15\u7f13\u51b2\u533a Vulkan \u63cf\u8ff0\u7b26\u5e03\u5c40\u548c\u7f13\u51b2\u533a Vulkan \u63cf\u8ff0\u7b26\u6c60\u548c\u96c6\u5408 Vulkan \u56fe\u50cf(Images) Vulkan \u56fe\u50cf\u89c6\u56fe\u548c\u91c7\u6837\u5668 Vulkan \u7ec4\u5408\u56fe\u50cf\u53d6\u6837\u5668 Vulkan \u6df1\u5ea6\u7f13\u51b2\u533a Vulkan \u52a0\u8f7d\u6a21\u578b Vulkan \u751f\u6210\u8d34\u56fe(mipmap) \u7b2c\u4e00\u7ae0 Vulkan \u521b\u5efaVulkan\u5b9e\u4f8b \u521b\u5efaVulkan\u5b9e\u4f8b \uff0c\u4e0e Vulkan \u6253\u4ea4\u9053\uff0c\u901a\u5e38\u7684\u6b65\u9aa4\u662f\u521b\u5efa\u4e00\u4e2a intance \u53bb\u521d\u59cb\u5316 Vulkan library \u3002\u8fd9\u4e2a instance \u662f\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u4e0e Vulkan \u5e93\u4e4b\u95f4\u7684\u8fde\u63a5\u6865\u6881,\u901a\u5e38\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u9700\u8981\u5411\u9a71\u52a8\u7a0b\u5e8f\u63d0\u4f9b\u4e00\u4e9b\u5e94\u7528\u5c42\u7684\u4fe1\u606f\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b 2 \u68c0\u67e5\u53ef\u9009\u529f\u80fd 3 \u9000\u51fa 4 \u6e90\u4ee3\u7801 \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b Vulkan API \u4f7f\u7528 vkInstance \u5bf9\u8c61\u6765\u5b58\u50a8\u6240\u6709\u6bcf\u4e2a\u5e94\u7528\u7684\u72b6\u6001\u3002\u5e94\u7528\u7a0b\u5e8f\u5fc5\u987b\u5728\u6267\u884c\u4efb\u4f55\u5176\u4ed6 Vulkan \u64cd\u4f5c\u4e4b\u524d\u521b\u5efa\u4e00\u4e2a Vulkan \u5b9e\u4f8b\uff0c\u57fa\u672c\u7684 Vulkan \u67b6\u6784\u770b\u8d77\u6765\u662f\u8fd9\u6837\u7684\uff1a \u8bf7\u6ce8\u610f\uff0c\u56fe\u4e2d\u6709\u4e00\u4e9b\u5c42\uff08 Layer )\uff0c\u8fd9\u4e9b\u5c42\u4e5f\u88ab\u52a0\u8f7d\u5668\u52a0\u8f7d\u3002\u5c42\u901a\u5e38\u7528\u4e8e\u9a8c\u8bc1\uff0c\u901a\u5e38\u662f\u7531\u9a71\u52a8\u6267\u884c\u7684\u9519\u8bef\u68c0\u67e5\u3002\u5728 Vulkan \u4e2d\uff0c\u9a71\u52a8\u7a0b\u5e8f\u6bd4 OpenGL \u7b49\u5176\u4ed6 API \u8981\u8f7b\u91cf\u5f97\u591a\uff0c\u90e8\u5206\u539f\u56e0\u662f\u5b83\u5c06\u529f\u80fd\u9a8c\u8bc1\u59d4\u6258\u7ed9\u9a8c\u8bc1\u5c42\u3002\u5c42\u662f\u53ef\u9009\u7684\uff0c\u6bcf\u6b21\u5e94\u7528\u7a0b\u5e8f\u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u65f6\u90fd\u53ef\u4ee5\u9009\u62e9\u6027\u5730\u88c5\u8f7d\u3002 Vulkan Layer \u8d85\u51fa\u4e86\u672c\u7ae0\u7684\u8303\u56f4\uff0c\u4e0b\u9762\u5f00\u59cb\u521b\u5efavulkan\u5b9e\u4f8b\uff0c\u9996\u5148\u6dfb\u52a0\u4e00\u4e2a createInstance \u51fd\u6570\uff0c\u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\u3002 void initVulkan() { createInstance(); } C++ \u53e6\u5916\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u6765\u4fdd\u5b58 instance \u53e5\u67c4: private: VkInstance instance; C++ \u73b0\u5728\u6211\u4eec\u521b\u5efa\u4e00\u4e2a instance \uff0c\u5e76\u4e14\u4e3a\u8be5\u6570\u636e\u7ed3\u6784\u8d4b\u4e88\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u4fe1\u606f\u3002\u8fd9\u4e9b\u6570\u636e\u4ece\u6280\u672f\u89d2\u5ea6\u662f\u53ef\u9009\u62e9\u7684\uff0c\u4f46\u662f\u5b83\u53ef\u4ee5\u4e3a\u9a71\u52a8\u7a0b\u5e8f\u63d0\u4f9b\u4e00\u4e9b\u6709\u7528\u7684\u4fe1\u606f\u6765\u4f18\u5316\u7a0b\u5e8f\u7279\u6b8a\u7684\u4f7f\u7528\u60c5\u666f\uff0c\u6bd4\u5982\u9a71\u52a8\u7a0b\u5e8f\u4f7f\u7528\u4e00\u4e9b\u56fe\u5f62\u5f15\u64ce\u7684\u7279\u6b8a\u884c\u4e3a\u3002\u8fd9\u4e2a\u6570\u636e\u7ed3\u6784\u79f0\u4e3a VkApplicationInfo : VkApplicationInfo appInfo = {}; appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;appInfo.pNext = nullptr; appInfo.pApplicationName = \"Hello Triangle\"; appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.pEngineName = \"No Engine\"; appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.apiVersion = VK_API_VERSION_1_0; C++ \u5982\u524d\u6240\u8ff0\uff0c Vulkan \u4e2d\u7684\u8bb8\u591a\u6570\u636e\u7ed3\u6784\u8981\u6c42\u5728 sType \u6210\u5458\u4e2d\u660e\u786e\u7684\u6307\u5b9a\u7c7b\u578b\u3002 pNext \u6210\u5458\u53ef\u7528\u4e8e\u6307\u5411\u7279\u5b9a\u7684\u6269\u5c55\u7ed3\u6784\u3002\u6211\u4eec\u5728\u8fd9\u91cc\u4f7f\u7528\u9ed8\u8ba4\u521d\u59cb\u5316\uff0c\u5c06\u5176\u8bbe\u7f6e\u4e3a nullptr \u3002 Vulkan \u4e2d\u7684\u5927\u91cf\u4fe1\u606f\u901a\u8fc7\u7ed3\u6784\u4f53\u800c\u4e0d\u662f\u51fd\u6570\u53c2\u6570\u4f20\u9012\uff0c\u6211\u4eec\u5c06\u586b\u5145\u4e00\u4e2a\u7ed3\u6784\u4f53\u4ee5\u63d0\u4f9b\u8db3\u591f\u7684\u4fe1\u606f\u521b\u5efa instance \u3002\u4e0b\u4e00\u4e2a\u7ed3\u6784\u4f53\u4e0d\u662f\u53ef\u9009\u7684\uff0c\u5b83\u9700\u8981\u544a\u77e5 Vulkan \u9a71\u52a8\u7a0b\u5e8f\u6211\u4eec\u9700\u8981\u4f7f\u7528\u54ea\u4e9b\u5168\u5c40\u7684 extensions \u548c validation layers \u3002\u8fd9\u91cc\u7684\u5168\u5c40\u610f\u5473\u7740\u5b83\u9002\u7528\u4e8e\u6574\u4e2a\u7a0b\u5e8f\uff0c\u800c\u4e0d\u662f\u7279\u5b9a\u7684\u8bbe\u5907\uff0c\u8fd9\u4e9b\u5185\u5bb9\u5c06\u5728\u63a5\u4e0b\u6765\u7684\u5c0f\u8282\u4e2d\u8bf4\u660e\u3002 VkInstanceCreateInfo \u7ed3\u6784\u4f53\u4fe1\u606f\u5982\u4e0b\uff1a VkInstanceCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pApplicationInfo = &appInfo; C++ \u524d\u51e0\u4e2a\u53c2\u6570\u6bd4\u8f83\u7b80\u5355\u3002\u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u6307\u5b9a\u9700\u8981\u7684\u5168\u5c40\u6269\u5c55\uff0c Vulakn \u5bf9\u4e8e\u5e73\u53f0\u7279\u6027\u662f\u96f6 API \u652f\u6301\u7684(\u81f3\u5c11\u6682\u65f6\u8fd9\u6837)\uff0c\u8fd9\u610f\u5473\u7740\u9700\u8981\u4e00\u4e2a\u6269\u5c55\u624d\u80fd\u4e0e\u4e0d\u540c\u5e73\u53f0\u7684\u7a97\u4f53\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002 GLFW \u6709\u4e00\u4e2a\u65b9\u4fbf\u7684\u5185\u7f6e\u51fd\u6570\uff0c\u8fd4\u56de\u5b83\u6709\u5173\u7684\u6269\u5c55\u4fe1\u606f\uff0c\u6211\u4eec\u53ef\u4ee5\u4f20\u9012\u7ed9 struct : unsigned int glfwExtensionCount = 0; const char** glfwExtensions; glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount); createInfo.enabledExtensionCount = glfwExtensionCount; createInfo.ppEnabledExtensionNames = glfwExtensions; C++ \u7ed3\u6784\u4f53\u7684\u6700\u540e\u4e24\u4e2a\u6210\u5458\u786e\u5b9a\u9700\u8981\u5f00\u542f\u7684\u5168\u5c40\u7684 validation layers \u3002\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u4e00\u8282\u4e2d\u6df1\u5165\u63a2\u8ba8\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u5728\u8fd9\u4e00\u8282\u8bbe\u7f6e\u4e3a\u7a7a\u3002 createInfo.enabledLayerCount = 0; C++ \u6211\u4eec\u73b0\u5728\u5df2\u7ecf\u6307\u5b9a\u4e86 Vulkan \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u9700\u8981\u7684\u4e00\u5207\u4fe1\u606f\uff0c\u8c03\u7528 vkCreateInstance \u521b\u5efa\u5c5e\u4e8e\u6211\u4eec\u7684\u7b2c\u4e00\u4e2a instance : VkResult result = vkCreateInstance(&createInfo, nullptr, &instance); C++ \u5982\u4f60\u6240\u89c1\uff0c Vulkan \u4e2d\u521b\u5efa\u3001\u5b9e\u4f8b\u5316\u76f8\u5173\u7684\u51fd\u6570\u53c2\u6570\u4e00\u822c\u9075\u5faa\u5982\u4e0b\u539f\u5219\u5b9a\u4e49: \u4f7f\u7528\u6709\u5173creation info \u7684\u7ed3\u6784\u4f53\u6307\u9488 \u4f7f\u7528\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u56de\u8c03\u7684\u6307\u9488 \u4f7f\u7528\u4fdd\u5b58\u65b0\u5bf9\u8c61\u53e5\u67c4\u7684\u6307\u9488 \u5982\u679c\u4e00\u5207\u987a\u5229\uff0c\u6b64\u523binstance\u7684\u53e5\u67c4\u5e94\u8be5\u5b58\u50a8\u5728 VkInstance \u7c7b\u6210\u5458\u4e2d\u4e86\u3002\u51e0\u4e4e\u6240\u6709\u7684Vulkan\u51fd\u6570\u90fd\u8fd4\u56de\u4e00\u4e2a\u503c\u4e3a VK_SUCCESS \u6216\u9519\u8bef\u4ee3\u7801\u7684 VkResult \u7c7b\u578b\u7684\u503c\u3002\u8981\u68c0\u67e5 instance \u662f\u5426\u5df2\u7ecf\u6210\u529f\u521b\u5efa\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u4fdd\u5b58\u7ed3\u679c\uff0c\u4ec5\u4ec5\u4f7f\u7528 VK_SUCCESS \u503c\u6765\u68c0\u6d4b\u5373\u53ef\uff1a if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) { throw std::runtime_error(\"failed to create instance!\"); } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\uff0c\u786e\u8ba4\u6211\u4eec\u7684 instance \u521b\u5efa\u6210\u529f\u3002 \u68c0\u67e5\u53ef\u9009\u529f\u80fd \u5982\u679c\u4f60\u67e5\u770b vkCreateInstance \u7684\u6587\u6863\uff0c\u4f60\u4f1a\u770b\u5230\u4e00\u4e2a\u53ef\u80fd\u51fa\u73b0\u7684\u9519\u8bef\u4ee3\u7801\u662f VK_ERROR_EXTENSION_NOT_PRESENT \u3002\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u5730\u6307\u5b9a\u6211\u4eec\u9700\u8981\u7684\u6269\u5c55\uff0c\u5982\u679c\u8be5\u9519\u8bef\u4ee3\u7801\u8fd4\u56de\uff0c\u5219\u7ec8\u6b62\u5b83\u4eec\u3002\u8fd9\u5bf9\u4e8e\u7a97\u4f53\u7cfb\u7edf\u6216\u8005\u8bf8\u5982\u6b64\u7c7b\u7684\u6269\u5c55\u662f\u6709\u610f\u4e49\u7684\uff0c\u90a3\u4e48\u5982\u4f55\u68c0\u67e5\u53ef\u9009\u529f\u80fd\u5462\uff1f \u5728\u521b\u5efa instance \u4e4b\u524d\u68c0\u7d22\u652f\u6301\u7684\u6269\u5c55\u5217\u8868\uff0c\u901a\u8fc7 vkEnumerateInstanceExtensionProperties \u51fd\u6570\u3002\u5b83\u6307\u5411\u4e00\u4e2a\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u5b58\u50a8\u6269\u5c55\u6570\u91cf\u548c\u4e00\u4e2a VkExtensionProperties \u6570\u7ec4\u6765\u5b58\u50a8\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f\u3002\u5b83\u4e5f\u63a5\u53d7\u4e00\u4e2a\u53ef\u9009\u62e9\u7684\u53c2\u6570\uff0c\u5141\u8bb8\u6211\u4eec\u901a\u8fc7\u7279\u5b9a\u7684 validation layers \u8fc7\u6ee4\u6269\u5c55\uff0c\u73b0\u5728\u6211\u4eec\u6682\u65f6\u5ffd\u7565\u8fd9\u4e9b\u3002 \u8981\u5206\u914d\u4e00\u4e2a\u6570\u7ec4\u6765\u4fdd\u5b58\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u77e5\u9053\u6709\u591a\u5c11\u4e2a\u6269\u5c55\u5b58\u5728\u3002\u53ef\u4ee5\u901a\u8fc7\u5c06\u540e\u4e00\u4e2a\u53c2\u6570\u7f6e\u7a7a\u6765\u83b7\u53d6\u6269\u5c55\u6570\u91cf: uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr); C++ \u73b0\u5728\u6211\u4eec\u5206\u914d\u4e00\u4e2a\u96c6\u5408\u53bb\u6301\u6709\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f( include ) std::vector<VkExtensionProperties> extensions(extensionCount); C++ \u6700\u540e\u6211\u4eec\u53ef\u4ee5\u904d\u5386\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f: vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data()); C++ \u6bcf\u4e2a VkExtensionProperties \u7ed3\u6784\u4f53\u5305\u542b\u6269\u5c55\u7684\u540d\u79f0\u548c\u7248\u672c\u3002\u6211\u4eec\u53ef\u4ee5\u7528\u7b80\u5355\u7684for\u5faa\u73af\u6253\u5370\u4ed6\u4eec(\\t\u662f\u7f29\u8fdb) std::cout << \"available extensions:\" << std::endl; for (const auto& extension : extensions) { std::cout << \"\\t\" << extension.extensionName << std::endl; } C++ \u5982\u679c\u9700\u8981\u83b7\u53d6\u6709\u5173 Vulkan \u652f\u6301\u7684\u4e00\u4e9b\u8be6\u7ec6\u4fe1\u606f\uff0c\u53ef\u4ee5\u5c06\u6b64\u4ee3\u7801\u6dfb\u52a0\u5230 createInstance \u51fd\u6570\u3002\u4f5c\u4e3a\u4e00\u4e2a\u5c1d\u8bd5\uff0c\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\uff0c\u68c0\u67e5 glfwGetRequiredInstanceExtensions \u8fd4\u56de\u7684\u6240\u6709\u6269\u5c55\u662f\u5426\u90fd\u5305\u542b\u5728\u53d7\u652f\u6301\u7684\u6269\u5c55\u5217\u8868\u4e2d\u3002 \u9000\u51fa \u5728\u7a0b\u5e8f\u9000\u51fa\u524d\uff0c\u8bf7\u6b63\u786e\u9500\u6bc1 VkInstance \u3002\u8fd9\u90e8\u5206\u53ef\u4ee5\u5b9a\u4e49\u5728cleanup\u51fd\u6570\u4e2d\uff0c\u8c03\u7528 vkDestroyInstance \u51fd\u6570\u5b8c\u6210\u3002 void cleanup() { vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate(); } C++ vkDestroyInstance \u51fd\u6570\u7684\u53c2\u6570\u5f88\u7b80\u5355\u3002\u50cf\u4e4b\u524d\u5c0f\u8282\u63d0\u5230\u7684\uff0cVulkan\u4e2d\u7684\u5206\u914d\u548c\u91ca\u653e\u529f\u80fd\u6709\u4e00\u4e2a\u53ef\u9009\u7684\u5206\u914d\u5668\u56de\u8c03\uff0c\u6211\u4eec\u901a\u8fc7\u5c06 nullptr \u8bbe\u7f6e\u5ffd\u7565\u3002\u540e\u7eed\u5c0f\u8282\u4e2d\u521b\u5efa\u7684\u6240\u6709Vulkan\u76f8\u5173\u8d44\u6e90\uff0c\u96c6\u4e2d\u5728cleanup\u51fd\u6570\u4e2d\u8fdb\u884c\u6e05\u7406\uff0c\u4e14\u786e\u4fdd\u5728\u9500\u6bc1 instance \u4e4b\u524d\u9500\u6bc1\u3002 \u5728\u8fdb\u884c\u66f4\u590d\u6742\u7684\u5185\u5bb9\u4e4b\u524d\uff0c\u662f\u65f6\u5019\u4e86\u89e3 validation layers \u4e86\u3002 Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217\u7c07 Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217 \uff0c\u901a\u8fc7 VkInstance \u521d\u59cb\u5316 Vulkan \u540e\uff0c\u6211\u4eec\u9700\u8981\u5728\u7cfb\u7edf\u4e2d\u67e5\u627e\u5e76\u9009\u62e9\u4e00\u4e2a\u652f\u6301\u6211\u4eec\u6240\u9700\u529f\u80fd\u7684\u663e\u5361\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u6570\u91cf\u7684\u663e\u5361\u5e76\u540c\u65f6\u4f7f\u7528\u4ed6\u4eec\uff0c\u4f46\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u5355\u7684\u8bbe\u5b9a\u9009\u62e9\u89c4\u5219\uff0c\u5373\u5c06\u67e5\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u56fe\u5f62\u5361\u4f5c\u4e3a\u6211\u4eec\u9002\u5408\u7684\u7269\u7406\u8bbe\u5907\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9009\u62e9\u7269\u7406\u8bbe\u5907 2 \u8bbe\u5907\u9700\u6c42\u68c0\u6d4b 3 \u961f\u5217\u65cf 4 \u6e90\u4ee3\u7801 \u9009\u62e9\u7269\u7406\u8bbe\u5907 \u901a\u8fc7 VkInstance \u521d\u59cb\u5316Vulkan\u540e\uff0c\u6211\u4eec\u9700\u8981\u5728\u7cfb\u7edf\u4e2d\u67e5\u627e\u5e76\u9009\u62e9\u4e00\u4e2a\u652f\u6301\u6211\u4eec\u6240\u9700\u529f\u80fd\u7684\u663e\u5361\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u6570\u91cf\u7684\u663e\u5361\u5e76\u540c\u65f6\u4f7f\u7528\u4ed6\u4eec\uff0c\u4f46\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u5355\u7684\u8bbe\u5b9a\u9009\u62e9\u89c4\u5219\uff0c\u5373\u5c06\u67e5\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u56fe\u5f62\u5361\u4f5c\u4e3a\u6211\u4eec\u9002\u5408\u7684\u7269\u7406\u8bbe\u5907\u3002 \u6211\u4eec\u6dfb\u52a0\u51fd\u6570 pickPhysicalDevice \u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); pickPhysicalDevice(); } void pickPhysicalDevice() { } C++ \u6700\u7ec8\u6211\u4eec\u9009\u62e9\u7684\u56fe\u5f62\u663e\u5361\u5b58\u50a8\u5728\u7c7b\u6210\u5458 VkPhysicalDevice \u53e5\u67c4\u4e2d\u3002\u5f53 VkInstance \u9500\u6bc1\u65f6\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u5c06\u4f1a\u88ab\u9690\u5f0f\u9500\u6bc1\uff0c\u6240\u4ee5\u6211\u4eec\u5e76\u4e0d\u9700\u8981\u5728 cleanup \u51fd\u6570\u4e2d\u505a\u4efb\u4f55\u64cd\u4f5c\u3002 VkPhysicalDevice physicalDevice = VK_NULL_HANDLE; C++ \u5173\u4e8e\u83b7\u53d6\u56fe\u5f62\u5361\u5217\u8868\u7684\u65b9\u5f0f\u4e0e\u83b7\u5f97\u6269\u5c55\u5217\u8868\u7684\u65b9\u5f0f\u7c7b\u4f3c\u3002 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); C++ \u5982\u679c Vulkan \u652f\u6301\u7684\u8bbe\u5907\u6570\u4e3a0\uff0c\u90a3\u4e48\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u8fdb\u884c\u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u9009\u62e9\u629b\u51fa\u5f02\u5e38\u3002 if (deviceCount == 0) { throw std::runtime_error(\"failed to find GPUs with Vulkan support!\"); } C++ \u5426\u5219\u6211\u4eec\u5206\u914d\u6570\u7ec4\u5b58\u50a8\u6240\u6709 VkPhysicalDevice \u7684\u53e5\u67c4\u3002 std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); C++ \u73b0\u5728\u6211\u4eec\u9700\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u8bc4\u4f30\uff0c\u68c0\u67e5\u5b83\u4eec\u662f\u5426\u9002\u5408\u6211\u4eec\u8981\u6267\u884c\u7684\u64cd\u4f5c\uff0c\u56e0\u4e3a\u5e76\u4e0d\u662f\u6240\u6709\u7684\u663e\u5361\u529f\u80fd\u4e00\u81f4\u3002\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u51fd\u6570: bool isDeviceSuitable(VkPhysicalDevice device) { return true; } C++ \u6211\u4eec\u5c06\u68c0\u67e5\u662f\u5426\u6709\u4efb\u4f55\u7269\u7406\u8bbe\u5907\u7b26\u5408\u6211\u4eec\u7684\u529f\u80fd\u9700\u6c42\u3002 for (const auto& device : devices) { if (isDeviceSuitable(device)) { physicalDevice = device; break; } } if (physicalDevice == VK_NULL_HANDLE) { throw std::runtime_error(\"failed to find a suitable GPU!\"); } C++ \u4e0b\u4e00\u8282\u6211\u4eec\u4ecb\u7ecd isDeviceSuitable \u51fd\u6570\uff0c\u5e76\u68c0\u67e5\u7b2c\u4e00\u4e2a\u9700\u8981\u6ee1\u8db3\u7684\u529f\u80fd\u3002\u5728\u540e\u7eed\u7684\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u5f00\u59cb\u4f7f\u7528\u66f4\u591a\u7684 Vulkan \u529f\u80fd\uff0c\u6211\u4eec\u4f1a\u6269\u5c55\u6b64\u529f\u80fd\u51fd\u6570\u4ee5\u6ee1\u8db3\u66f4\u591a\u7684\u68c0\u67e5\u6761\u4ef6\u3002 \u8bbe\u5907\u9700\u6c42\u68c0\u6d4b \u8bc4\u4f30\u5408\u9002\u7684\u8bbe\u5907\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u904d\u5386\u4e00\u4e9b\u7ec6\u8282\u6765\u5b8c\u6210\u3002\u57fa\u672c\u7684\u8bbe\u5907\u5c5e\u6027\u50cfname, type\u4ee5\u53ca Vulkan \u7248\u672c\u90fd\u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceProperties \u6765\u904d\u5386\u5f97\u5230\u3002 VkPhysicalDeviceProperties deviceProperties; vkGetPhysicalDeviceProperties(device, &deviceProperties); C++ \u53ef\u4ee5\u4f7f\u7528 vkGetPhysicalDeviceFeatures \u67e5\u8be2\u5bf9\u7eb9\u7406\u538b\u7f29\uff0c64\u4f4d\u6d6e\u70b9\u6570\u548c\u591a\u89c6\u56fe\u6e32\u67d3(VR\u975e\u5e38\u6709\u7528)\u7b49\u53ef\u9009\u529f\u80fd\u7684\u652f\u6301: VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceFeatures(device, &deviceFeatures); C++ \u66f4\u591a\u904d\u5386\u7269\u7406\u8bbe\u5907\u7ec6\u8282\u7684\u4fe1\u606f\uff0c\u8bf8\u5982\u8bbe\u5907\u5185\u5b58\u3001\u961f\u5217\u7c07\u6211\u4eec\u5c06\u4f1a\u5728\u540e\u7eed\u5c0f\u8282\u8ba8\u8bba\u3002 \u4f8b\u5982\uff0c\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u4ec5\u9002\u7528\u4e8e\u652f\u6301 geometry shaders \u7684\u4e13\u7528\u663e\u5361\u3002\u90a3\u4e48 isDeviceSuitable \u51fd\u6570\u5c06\u5982\u4e0b\u6240\u793a: bool isDeviceSuitable(VkPhysicalDevice device) { VkPhysicalDeviceProperties deviceProperties; VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceProperties(device, &deviceProperties); vkGetPhysicalDeviceFeatures(device, &deviceFeatures); return deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU && deviceFeatures.geometryShader; } C++ \u4e3a\u4e86\u907f\u514d\u7eaf\u7cb9\u7684\u5355\u4e00\u7684\u5224\u65ad\u4e00\u4e2a\u8bbe\u5907\u662f\u5426\u5408\u9002\uff0c\u5c24\u5176\u662f\u5f53\u4f60\u53d1\u73b0\u591a\u4e2a\u8bbe\u5907\u90fd\u5408\u9002\u7684\u6761\u4ef6\u4e0b\uff0c\u4f60\u4e5f\u53ef\u4ee5\u7ed9\u6bcf\u4e00\u4e2a\u8bbe\u5907\u505a\u6743\u503c\uff0c\u9009\u62e9\u6700\u9ad8\u7684\u4e00\u4e2a\u3002\u8fd9\u6837\uff0c\u53ef\u4ee5\u901a\u8fc7\u7ed9\u4e88\u66f4\u9ad8\u6743\u503c\u83b7\u53d6\u5b9a\u5236\u5316\u7684\u56fe\u5f62\u8bbe\u5907\uff0c\u4f46\u5982\u679c\u6ca1\u6709\u4e00\u4e2a\u53ef\u7528\u7684\u8bbe\u5907\uff0c\u53ef\u4ee5\u56de\u6eda\u5230\u96c6\u6210\u56fe\u5f62\u8bbe\u5907\u3002\u4f60\u53ef\u4ee5\u6309\u7167\u5982\u4e0b\u65b9\u5f0f\u5b9e\u73b0: #include <map> ... void pickPhysicalDevice() { ... // Use an ordered map to automatically sort candidates by increasing score std::multimap<int, VkPhysicalDevice> candidates; for (const auto& device : devices) { int score = rateDeviceSuitability(device); candidates.insert(std::make_pair(score, device)); } // Check if the best candidate is suitable at all if (candidates.rbegin()->first > 0) { physicalDevice = candidates.rbegin()->second; } else { throw std::runtime_error(\"failed to find a suitable GPU!\"); } } int rateDeviceSuitability(VkPhysicalDevice device) { ... int score = 0; // Discrete GPUs have a significant performance advantage if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) { score += 1000; } // Maximum possible size of textures affects graphics quality score += deviceProperties.limits.maxImageDimension2D; // Application can't function without geometry shaders if (!deviceFeatures.geometryShader) { return 0; } return score; } C++ \u6211\u4eec\u4e0d\u9700\u8981\u5728\u5c0f\u8282\u5185\u5b9e\u73b0\u6240\u6709\u5185\u5bb9\uff0c\u4f46\u6211\u4eec\u53ef\u4ee5\u4e86\u89e3\u5982\u4f55\u9009\u62e9\u56fe\u5f62\u8bbe\u5907\u7684\u8fc7\u7a0b\u3002\u5f53\u7136\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u793a\u56fe\u5f62\u8bbe\u5907\u7684\u540d\u79f0\u5217\u8868\uff0c\u8ba9\u7528\u6237\u9009\u62e9\u3002 \u56e0\u4e3a\u6211\u4eec\u521a\u521a\u5f00\u59cb\uff0c Vulkan \u7684\u652f\u6301\u662f\u6211\u4eec\u552f\u4e00\u9700\u8981\u7684\uff0c\u5728\u8fd9\u91cc\u5047\u8bbe\u4efb\u4f55GPU\u90fd\u53ef\u4ee5: bool isDeviceSuitable(VkPhysicalDevice device) { return true; } C++ \u5728\u4e0b\u4e00\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u8ba8\u8bba\u7b2c\u4e00\u4e2a\u771f\u6b63\u9700\u8981\u68c0\u67e5\u7684\u8bbe\u5907\u529f\u80fd\u3002 \u961f\u5217\u65cf \u4e4b\u524d\u5df2\u7ecf\u7b80\u8981\u7684\u4ecb\u7ecd\u8fc7\uff0c\u51e0\u4e4e\u6240\u6709\u7684 Vulkan \u64cd\u4f5c\uff0c\u4ece\u7ed8\u56fe\u5230\u4e0a\u4f20\u7eb9\u7406\uff0c\u90fd\u9700\u8981\u5c06\u547d\u4ee4\u63d0\u4ea4\u5230\u961f\u5217\u4e2d\u3002\u6709\u4e0d\u540c\u7c7b\u578b\u7684\u961f\u5217\u6765\u6e90\u4e8e\u4e0d\u540c\u7684\u961f\u5217\u7c07\uff0c\u6bcf\u4e2a\u961f\u5217\u7c07\u53ea\u5141\u8bb8\u90e8\u5206 commands \u3002\u4f8b\u5982\uff0c\u53ef\u4ee5\u6709\u4e00\u4e2a\u961f\u5217\u7c07\uff0c\u53ea\u5141\u8bb8\u5904\u7406\u8ba1\u7b97 commands \u6216\u8005\u53ea\u5141\u8bb8\u5185\u5b58\u4f20\u8f93 commands : \u6211\u4eec\u9700\u8981\u68c0\u6d4b\u8bbe\u5907\u4e2d\u652f\u6301\u7684\u961f\u5217\u7c07\uff0c\u5176\u4e2d\u54ea\u4e00\u4e2a\u961f\u5217\u7c07\u652f\u6301\u6211\u4eec\u60f3\u8981\u7684 commands \u3002\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u51fd\u6570 findQueueFamilies \u6765\u67e5\u627e\u6211\u4eec\u9700\u8981\u7684\u961f\u5217\u7c07\u3002\u73b0\u5728\u6211\u4eec\u53ea\u4f1a\u5bfb\u627e\u4e00\u4e2a\u652f\u6301\u56fe\u5f62 commands \u961f\u5217\u7c07\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u5728\u7a0d\u540e\u7684\u5c0f\u8282\u4e2d\u6269\u5c55\u66f4\u591a\u7684\u5185\u5bb9\u3002 \u6b64\u51fd\u6570\u8fd4\u56de\u6ee1\u8db3\u67d0\u4e2a\u5c5e\u6027\u7684\u961f\u5217\u7c07\u7d22\u5f15\u3002\u5b9a\u4e49\u7ed3\u6784\u4f53\uff0c\u5176\u4e2d\u7d22\u5f15 -1 \u8868\u793a\u201d\u672a\u627e\u5230\u201d: struct QueueFamilyIndices { int graphicsFamily = -1; bool isComplete() { return graphicsFamily >= 0; } }; C++ \u73b0\u5728\u6211\u4eec\u5b9e\u73b0 findQueueFamilies \u51fd\u6570: QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) { QueueFamilyIndices indices; ... return indices; } C++ \u83b7\u53d6\u961f\u5217\u7c07\u7684\u5217\u8868\u51fd\u6570\u4e3a vkGetPhysicalDeviceQueueFamilyProperties : uint32_t queueFamilyCount = 0; vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr); std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount); vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data()); C++ \u6709\u5173\u961f\u5217\u7c07\uff0c\u7ed3\u6784\u4f53 VkQueueFamilyProperties \u5305\u542b\u4e86\u5177\u4f53\u4fe1\u606f\uff0c\u5305\u62ec\u652f\u6301\u7684\u64cd\u4f5c\u7c7b\u578b\u548c\u57fa\u4e8e\u5f53\u524d\u961f\u5217\u7c07\u53ef\u4ee5\u521b\u5efa\u7684\u6709\u6548\u961f\u5217\u6570\u3002\u6211\u4eec\u81f3\u5c11\u9700\u8981\u627e\u5230\u4e00\u4e2a\u652f\u6301 VK_QUEUE_GRAPHICS_BIT \u7684\u961f\u5217\u7c07\u3002 int i = 0; for (const auto& queueFamily : queueFamilies) { if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) { indices.graphicsFamily = i; } if (indices.isComplete()) { break; } i++; } C++ \u73b0\u5728\u6211\u4eec\u6709\u4e86\u6bd4\u8f83\u7406\u60f3\u7684\u961f\u5217\u7c07\u67e5\u8be2\u529f\u80fd\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 isDeviceSuitable \u51fd\u6570\u4e2d\u4f7f\u7528\uff0c\u786e\u4fdd\u7269\u7406\u8bbe\u5907\u53ef\u4ee5\u5904\u7406\u6211\u4eec\u9700\u8981\u7684\u547d\u4ee4: bool isDeviceSuitable(VkPhysicalDevice device) { QueueFamilyIndices indices = findQueueFamilies(device); return indices.isComplete(); } C++ \u5f88\u597d\uff0c\u6211\u4eec\u5df2\u7ecf\u627e\u5230\u4e86\u6211\u4eec\u9700\u8981\u7684\u7269\u7406\u8bbe\u5907\uff0c\u5728 \u4e0b\u4e00\u4e2a\u5c0f\u8282 \u6211\u4eec\u4f1a\u8ba8\u8bba\u903b\u8f91\u8bbe\u5907\u3002 Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b \uff0c \u4e0a\u4e00\u8282 \u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6b63\u786e\u914d\u7f6e\u3001\u53ef\u8fd0\u884c\u7684\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u4f7f\u7528\u6d4b\u8bd5\u4ee3\u7801\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u672c\u8282\u4e2d\u6211\u4eec\u4ece\u5934\u5f00\u59cb\uff0c\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u6784\u5efa\u4e00\u4e2a\u57fa\u4e8e GLFW \u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\u539f\u578b\u6846\u67b6\u7684\u96cf\u5f62\u3002 \u64cd\u4f5c\u7cfb\u7edf: Windows8.1 \u663e\u5361:Nivida GTX965M \u5f00\u53d1\u5de5\u5177\uff1aVisual Studio 2017 \u6587\u7ae0\u76ee\u5f55 1 \u603b\u4f53\u7ed3\u6784 2 \u8d44\u6e90\u7ba1\u7406 3 \u6574\u5408GLFW \u603b\u4f53\u7ed3\u6784 \u5728\u4e0a\u4e00\u8282\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6b63\u786e\u914d\u7f6e\u3001\u53ef\u8fd0\u884c\u7684\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u4f7f\u7528\u6d4b\u8bd5\u4ee3\u7801\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u672c\u8282\u4e2d\u6211\u4eec\u4ece\u5934\u5f00\u59cb\uff0c\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u6784\u5efa\u4e00\u4e2a\u57fa\u4e8eGLFW\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\u539f\u578b\u6846\u67b6\u7684\u96cf\u5f62\u3002 #include <vulkan/vulkan.h> #include <iostream> #include <stdexcept> #include <functional> class HelloTriangleApplication { public: void run() { initVulkan(); mainLoop(); cleanup(); } private: void initVulkan() { } void mainLoop() { } void cleanup() { } }; int main() { HelloTriangleApplication app; try { app.run(); } catch (const std::runtime_error& e) { std::cerr << e.what() << std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; } C++ \u9996\u5148\u4ece LunarG SDK \u4e2d\u6dfb\u52a0 Vulkan \u5934\u6587\u4ef6\uff0c\u5b83\u63d0\u4f9b\u4e86\u8d2d\u673a\u7231\u4f60 Vulkan \u5e94\u7528\u7a0b\u5e8f\u9700\u8981\u7684\u51fd\u6570\u3001\u7ed3\u6784\u4f53\u3001\u548c\u679a\u4e3e\u3002\u6211\u4eec\u5305\u542b stdexcept \u548c iostream \u5934\u6587\u4ef6\u7528\u4e8e\u629b\u51fa\u5f02\u5e38\u4fe1\u606f\uff0c\u800c functional \u5934\u6587\u4ef6\u7528\u4e8e\u8d44\u6e90\u7ba1\u7406\u90e8\u5206\u652f\u6301 lambda \u8868\u8fbe\u5f0f\u3002 \u7a0b\u5e8f\u88ab\u5c01\u88c5\u5230\u4e00\u4e2a\u7c7b\u4e2d\uff0c\u8be5\u7c7b\u7ed3\u6784\u5c06\u4f1a\u5b58\u50a8Vulkan\u79c1\u6709\u6210\u5458\u5bf9\u8c61\uff0c\u5e76\u6dfb\u52a0\u57fa\u672c\u7684\u51fd\u6570\u6765\u521d\u59cb\u5316\u4ed6\u4eec\u3002\u9996\u5148\u4f1a\u4ece initVulkan \u51fd\u6570\u5f00\u59cb\u8c03\u7528\u3002\u5f53\u4e00\u5207\u51c6\u5907\u597d\uff0c\u6211\u4eec\u8fdb\u5165\u4e3b\u5faa\u73af\u5f00\u59cb\u6e32\u67d3\u5e27\u3002\u6211\u4eec\u5c06\u4f1a\u52a0\u5165 mainLoop \u51fd\u6570\u5305\u542bloop\u5faa\u73af\u8c03\u7528\uff0c\u8be5\u5faa\u73af\u8c03\u7528\u76f4\u5230GLFW\u7a97\u4f53\u7ba1\u7406\u624d\u4f1a\u505c\u6b62\u3002\u5f53\u7a97\u4f53\u5173\u95ed\u5e76\u4e14 mainLoop \u8fd4\u56de\u65f6\uff0c\u6211\u4eec\u9700\u8981\u91ca\u653e\u6211\u4eec\u5df2\u7ecf\u7533\u8bf7\u8fc7\u7684\u4efb\u4f55\u8d44\u6e90\uff0c\u8be5\u6e05\u7406\u903b\u8f91\u5728 cleanup \u51fd\u6570\u4e2d\u53bb\u5b9a\u4e49\u3002 \u7a0b\u5e8f\u8fd0\u884c\u671f\u95f4\uff0c\u5982\u679c\u53d1\u751f\u4e86\u4efb\u4f55\u4e25\u91cd\u7684\u9519\u8bef\u5f02\u5e38\uff0c\u6211\u4eec\u4f1a\u629b\u51fa std::runtime_error \u5e76\u6ce8\u660e\u5f02\u5e38\u63cf\u8ff0\u4fe1\u606f,\u8fd9\u4e2a\u5f02\u5e38\u4fe1\u606f\u4f1a\u88ab main \u51fd\u6570\u6355\u83b7\u53ca\u6253\u5370\u63d0\u793a\u3002\u5f88\u5feb\u4f60\u5c06\u4f1a\u9047\u5230\u4e00\u4e2a\u629b\u51faerror\u7684\u4f8b\u5b50\uff0c\u662f\u5173\u4e8e Vulkan \u5e94\u7528\u7a0b\u5e8f\u4e0d\u652f\u6301\u67d0\u4e2a\u5fc5\u8981\u7684\u6269\u5c55\u529f\u80fd\u3002 \u57fa\u672c\u4e0a\u5728\u4e4b\u540e\u7684\u6bcf\u4e00\u4e2a\u5c0f\u8282\u4e2d\u90fd\u4f1a\u4ece initVulkan \u51fd\u6570\u4e2d\u589e\u52a0\u4e00\u4e2a\u65b0\u7684 Vulkan \u51fd\u6570\u8c03\u7528,\u589e\u52a0\u7684\u51fd\u6570\u4f1a\u4ea7\u751f Vulkan objects \u5e76\u4fdd\u5b58\u4e3a\u7c7b\u7684\u79c1\u6709\u6210\u5458\uff0c\u8bf7\u8bb0\u5f97\u5728 cleanup \u4e2d\u8fdb\u884c\u8d44\u6e90\u7684\u6e05\u7406\u548c\u91ca\u653e\u3002 \u8d44\u6e90\u7ba1\u7406 \u6211\u4eec\u77e5\u9053\u901a\u8fc7 malloc \u5206\u914d\u7684\u6bcf\u4e00\u4e2a\u5185\u5b58\u5feb\u5728\u4f7f\u7528\u5b8c\u4e4b\u540e\u90fd\u9700\u8981 free \u5185\u5b58\u8d44\u6e90\uff0c\u6bcf\u4e00\u4e2a\u6211\u4eec\u521b\u5efa\u7684 Vulkan object \u4e0d\u5728\u4f7f\u7528\u65f6\u90fd\u9700\u8981\u660e\u786e\u7684\u9500\u6bc1\u3002\u5728 C++ \u4e2d\u53ef\u4ee5\u5229\u7528 \u5b8c\u6210auto\u8d44\u6e90\u7ba1\u7406\uff0c\u4f46\u662f\u5728\u672c\u8282\u4e2d\uff0c\u9009\u62e9\u660e\u786e\u7f16\u5199\u6240\u6709\u7684\u5185\u5b58\u7684\u5206\u914d\u548c\u91ca\u653e\u64cd\u4f5c\uff0c\u5176\u4e3b\u8981\u539f\u56e0\u662f`\u7684\u8bbe\u8ba1\u7406\u5ff5\u5c31\u662f\u660e\u786e\u6bcf\u4e00\u6b65\u64cd\u4f5c\uff0c\u6e05\u695a\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f\uff0c\u907f\u514d\u53ef\u80fd\u5b58\u5728\u7684\u672a\u77e5\u4ee3\u7801\u9020\u6210\u7684\u5f02\u5e38\u3002 \u5f53\u7136\u5728\u672c\u8282\u4e4b\u540e,\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u91cd\u8f7d std::shared_ptr \u6765\u5b9e\u73b0auto \u8d44\u6e90\u7ba1\u7406\u3002\u5bf9\u4e8e\u66f4\u5927\u4f53\u91cf\u7684Vulkan\u7a0b\u5e8f,\u5efa\u8bae\u9075\u5faa RAII \u7684\u539f\u5219\u7ef4\u62a4\u8d44\u6e90\u7684\u7ba1\u7406\u3002 Vulkan \u5bf9\u8c61\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 vkCreateXXX \u7cfb\u51fd\u6570\u521b\u5efa\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u5177\u6709 vkAllocateXXX \u7b49\u529f\u80fd\u7684\u4e00\u4e2a\u5bf9\u8c61\u8fdb\u884c\u5206\u914d\u3002\u786e\u4fdd\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u5728\u4e0d\u4f7f\u7528\u7684\u65f6\u5019\u8c03\u7528 vkDestroyXXX \u548c vkFreeXXX \u9500\u6bc1\u3001\u91ca\u653e\u5bf9\u5e94\u7684\u8d44\u6e90\u3002\u8fd9\u4e9b\u51fd\u6570\u7684\u53c2\u6570\u901a\u5e38\u56e0\u4e0d\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u800c\u4e0d\u540c\uff0c\u4f46\u662f\u4ed6\u4eec\u5171\u4eab\u4e00\u4e2a\u53c2\u6570:pAllocator\u3002\u8fd9\u662f\u4e00\u4e2a\u53ef\u9009\u7684\u53c2\u6570\uff0c Vulkan \u5141\u8bb8\u6211\u4eec\u81ea\u5b9a\u4e49\u5185\u5b58\u5206\u914d\u5668\u3002\u6211\u4eec\u5c06\u5728\u672c\u6559\u7a0b\u5ffd\u7565\u6b64\u53c2\u6570\uff0c\u59cb\u7ec8\u4ee5 nullptr \u4f5c\u4e3a\u53c2\u6570\u3002 \u6574\u5408GLFW \u5982\u679c\u6211\u4eec\u5f00\u53d1\u4e00\u4e9b\u4e0d\u9700\u8981\u57fa\u4e8e\u5c4f\u5e55\u663e\u793a\u7684\u7a0b\u5e8f\uff0c\u90a3\u4e48\u7eaf\u7cb9\u7684 Vulkan \u672c\u8eab\u53ef\u4ee5\u5b8c\u7f8e\u7684\u652f\u6301\u5f00\u53d1\u3002\u4f46\u662f\u5982\u679c\u521b\u5efa\u4e00\u4e9b\u8ba9\u4eba\u5174\u594b\u7684\u53ef\u89c6\u5316\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u5c31\u9700\u8981\u5f15\u5165\u7a97\u4f53\u7cfb\u7edf GLFW \uff0c\u5e76\u5c06 #include \u8fdb\u884c\u76f8\u5e94\u7684\u66ff\u6362\u3002 #define GLFW_INCLUDE_VULKAN #include <GLFW/glfw3.h> C++ \u5728\u65b0\u7248\u672c\u7684 GLFW \u4e2d\u5df2\u7ecf\u63d0\u4f9b\u4e86 Vulkan \u76f8\u5173\u7684\u652f\u6301\uff0c\u8be6\u7ec6\u7684\u4f7f\u7528\u5efa\u8bae\u53c2\u9605\u5b98\u65b9\u8d44\u6599\u3002 \u901a\u8fc7\u66ff\u6362\uff0c\u5c06\u4f1a\u4f7f\u7528 GLFW \u5bf9 Vulkan \u7684\u652f\u6301\uff0c\u5e76\u81ea\u52a8\u52a0\u8f7d Vulkan \u7684\u5934\u6587\u4ef6\u3002\u5728 run \u51fd\u6570\u4e2d\u6dfb\u52a0\u4e00\u4e2a initWindow \u51fd\u6570\u8c03\u7528\uff0c\u5e76\u786e\u4fdd\u5728\u5176\u4ed6\u51fd\u6570\u8c03\u7528\u524d\u4f18\u5148\u8c03\u7528\u3002\u6211\u4eec\u5c06\u4f1a\u901a\u8fc7\u8be5\u51fd\u6570\u5b8c\u6210 GLFW \u7684\u7a97\u4f53\u521d\u59cb\u5316\u5de5\u4f5c\u3002 void run() { initWindow(); initVulkan(); mainLoop(); cleanup(); } private: void initWindow() { } C++ initWindow \u4e2d\u7684\u7b2c\u4e00\u4e2a\u8c03\u7528\u662f glfwInit() ,\u5b83\u4f1a\u521d\u59cb\u5316 GLFW \u5e93\u3002\u56e0\u4e3a\u6700\u521d GLFW \u662f\u4e3a OpenGL \u521b\u5efa\u4e0a\u4e0b\u6587\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u4eec\u9700\u8981\u544a\u8bc9\u5b83\u4e0d\u8981\u8c03\u7528 OpenGL \u76f8\u5173\u7684\u521d\u59cb\u5316\u64cd\u4f5c\u3002 glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); C++ \u7279\u522b\u6ce8\u610f\u7a97\u53e3\u5927\u5c0f\u7684\u8bbe\u7f6e\uff0c\u7a0d\u540e\u6211\u4eec\u4f1a\u8c03\u7528\uff0c\u73b0\u5728\u4f7f\u7528\u53e6\u4e00\u4e2a\u7a97\u53e3\u63d0\u793a\u6765\u4ec5\u7528\u5b83\u3002 glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); C++ \u73b0\u5728\u5269\u4e0b\u7684\u5c31\u662f\u521b\u5efa\u5b9e\u9645\u7684\u7a97\u4f53\u3002\u6dfb\u52a0\u4e00\u4e2a GLFWwindow* \u7a97\u4f53\uff0c\u79c1\u6709\u7c7b\u6210\u5458\u5b58\u50a8\u5176\u5f15\u7528\u5e76\u521d\u59cb\u5316\u7a97\u4f53: window = glfwCreateWindow(800, 600, \"Vulkan\", nullptr, nullptr); C++ \u524d\u4e09\u4e2a\u53c2\u6570\u5b9a\u4e49\u7a97\u4f53\u7684\u5bbd\u5ea6\u3001\u9ad8\u5ea6\u548c Title \u3002\u7b2c\u56db\u4e2a\u53c2\u6570\u5141\u8bb8\u5236\u5b9a\u4e00\u4e2a\u76d1\u542c\u5668\u6765\u6253\u5f00\u7a97\u4f53\uff0c\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u4e0e OpenGL \u6709\u5173\uff0c\u6211\u4eec\u9009\u62e9 nullptr \u3002 \u4f7f\u7528\u5e38\u91cf\u4ee3\u66ff\u786c\u7f16\u7801\u5bbd\u5ea6\u548c\u9ad8\u5ea6\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u540e\u7eed\u7684\u5185\u5bb9\u4e2d\u4f1a\u5f15\u7528\u8be5\u6570\u503c\u591a\u6b21\u3002\u5728 HelloTriangleApplication \u7c7b\u5b9a\u4e49\u4e4b\u4e0a\u6dfb\u52a0\u4ee5\u4e0b\u51e0\u884c: const int WIDTH = 800; const int HEIGHT = 600; C++ \u5e76\u66ff\u6362\u7a97\u4f53\u521b\u5efa\u7684\u4ee3\u7801\u8bed\u53e5\u4e3a: window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); C++ \u4f60\u73b0\u5728\u5e94\u8be5\u6709\u4e00\u4e2a\u5982\u4e0b\u6240\u793a\u7684initWindow\u51fd\u6570: void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); } C++ \u4fdd\u6301\u7a0b\u5e8f\u8fd0\u884c\uff0c\u76f4\u5230\u53d1\u751f\u9519\u8bef\u6216\u8005\u7a97\u4f53\u5173\u95ed\uff0c\u6211\u4eec\u9700\u8981\u5411 mainLoop \u51fd\u6570\u6dfb\u52a0\u4e8b\u4ef6\u5faa\u73af\uff0c\u5982\u4e0b\u6240\u793a: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); } } C++ \u8fd9\u6bb5\u4ee3\u7801\u5e94\u8be5\u5f88\u5bb9\u6613\u770b\u61c2\u3002\u5b83\u5faa\u73af\u5e76\u68c0\u67e5 GLFW \u4e8b\u4ef6\uff0c\u76f4\u5230\u6309\u4e0b X \u6309\u94ae\uff0c\u6216\u8005\u5173\u95ed\u7a97\u4f53\u3002\u8be5\u5faa\u73af\u7ed3\u6784\u7a0d\u540e\u4f1a\u8c03\u7528\u6e32\u67d3\u51fd\u6570\u3002 \u4e00\u65e6\u7a97\u4f53\u5173\u95ed\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7 cleanup \u51fd\u6570\u6e05\u7406\u8d44\u6e90\u3001\u7ed3\u675f GLFW \u672c\u8eab\u3002 void cleanup() { glfwDestroyWindow(window); glfwTerminate(); } C++ \u8fd0\u884c\u7a0b\u5e8f\uff0c\u6211\u4eec\u5e94\u8be5\u4f1a\u770b\u5230\u4e00\u4e2a\u540d\u4e3a Vulkan \u7684\u767d\u8272\u7a97\u4f53\uff0c\u76f4\u5230\u5173\u95ed\u7a97\u4f53\u7ec8\u6b62\u5e94\u7528\u7a0b\u5e8f\u3002 ok\uff0c\u5230\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86\u4e00\u4e2a Vulkan \u7a0b\u5e8f\u7684\u9aa8\u67b6\u539f\u578b\uff0c\u5728 \u4e0b\u4e00\u8282 \u6211\u4eec\u4f1a\u521b\u5efa\u7b2c\u4e00\u4e2a Vulkan Object ! [Vulkan \u9a8c\u8bc1\u5c42] PASS Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217 Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217 \uff0c\u5728\u9009\u62e9\u8981\u4f7f\u7528\u7684\u7269\u7406\u8bbe\u5907\u4e4b\u540e\uff0c\u6211\u4eec\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u903b\u8f91\u8bbe\u5907\u7528\u4e8e\u4ea4\u4e92\u3002\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u8fc7\u7a0b\u4e0einstance\u521b\u5efa\u8fc7\u7a0b\u7c7b\u4f3c\uff0c\u4e5f\u9700\u8981\u63cf\u8ff0\u6211\u4eec\u9700\u8981\u4f7f\u7528\u7684\u529f\u80fd\u3002\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u67e5\u8be2\u8fc7\u54ea\u4e9b\u961f\u5217\u7c07\u53ef\u7528\uff0c\u5728\u8fd9\u91cc\u9700\u8981\u8fdb\u4e00\u6b65\u4e3a\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u5177\u4f53\u7c7b\u578b\u7684\u547d\u4ee4\u961f\u5217\u3002\u5982\u679c\u6709\u4e0d\u540c\u7684\u9700\u6c42\uff0c\u4e5f\u53ef\u4ee5\u57fa\u4e8e\u540c\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u521b\u5efa\u591a\u4e2a\u903b\u8f91\u8bbe\u5907\u3002 \u9996\u5148\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u7c7b\u6210\u5458\u6765\u5b58\u50a8\u903b\u8f91\u8bbe\u5907\u53e5\u67c4\u3002 VkDevice device; C++ \u63a5\u4e0b\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u51fd\u6570 createLogicalDevice \uff0c\u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\uff0c\u4ee5\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u3002 void initVulkan() { createInstance(); setupDebugCallback(); pickPhysicalDevice(); createLogicalDevice(); } void createLogicalDevice() { } C++ https://geek-docs.com/vulkan/vulkan-tutorial/vulkan-logical-devices-and-queues.html#i-5) \u6307\u5b9a\u521b\u5efa\u7684\u961f\u5217 \u521b\u5efa\u903b\u8f91\u8bbe\u5907\u9700\u8981\u5728\u7ed3\u6784\u4f53\u4e2d\u660e\u786e\u5177\u4f53\u7684\u4fe1\u606f\uff0c\u9996\u5148\u7b2c\u4e00\u4e2a\u7ed3\u6784\u4f53 VkDeviceQueueCreateInfo \u3002\u8fd9\u4e2a\u7ed3\u6784\u4f53\u63cf\u8ff0\u961f\u5217\u7c07\u4e2d\u9884\u8981\u7533\u8bf7\u4f7f\u7528\u7684\u961f\u5217\u6570\u91cf\u3002\u73b0\u5728\u6211\u4eec\u4ec5\u5173\u5fc3\u5177\u5907\u56fe\u5f62\u80fd\u529b\u7684\u961f\u5217\u3002 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); VkDeviceQueueCreateInfo queueCreateInfo = {}; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = indices.graphicsFamily; queueCreateInfo.queueCount = 1; C++ \u5f53\u524d\u53ef\u7528\u7684\u9a71\u52a8\u7a0b\u5e8f\u6240\u63d0\u4f9b\u7684\u961f\u5217\u7c07\u53ea\u5141\u8bb8\u521b\u5efa\u5c11\u91cf\u7684\u961f\u5217\uff0c\u5e76\u4e14\u5f88\u591a\u65f6\u5019\u6ca1\u6709\u5fc5\u8981\u521b\u5efa\u591a\u4e2a\u961f\u5217\u3002\u8fd9\u662f\u56e0\u4e3a\u53ef\u4ee5\u5728\u591a\u4e2a\u7ebf\u7a0b\u4e0a\u521b\u5efa\u6240\u6709\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u7136\u540e\u5728\u4e3b\u7ebf\u7a0b\u4e00\u6b21\u6027\u7684\u4ee5\u8f83\u4f4e\u5f00\u9500\u7684\u8c03\u7528\u63d0\u4ea4\u961f\u5217\u3002 Vulkan \u5141\u8bb8\u4f7f\u75280.0\u52301.0\u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u5206\u914d\u961f\u5217\u4f18\u5148\u7ea7\u6765\u5f71\u54cd\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u7684\u8c03\u7528\u3002\u5373\u4f7f\u53ea\u6709\u4e00\u4e2a\u961f\u5217\u4e5f\u662f\u5fc5\u987b\u7684: float queuePriority = 1.0f; queueCreateInfo.pQueuePriorities = &queuePriority; C++ \u6307\u5b9a\u4f7f\u7528\u7684\u8bbe\u5907\u7279\u6027 \u4e0b\u4e00\u4e2a\u8981\u660e\u786e\u7684\u4fe1\u606f\u6709\u5173\u8bbe\u5907\u8981\u4f7f\u7528\u7684\u529f\u80fd\u7279\u6027\u3002\u8fd9\u4e9b\u662f\u6211\u4eec\u5728\u4e0a\u4e00\u8282\u4e2d\u7528 vkGetPhysicalDeviceFeatures \u67e5\u8be2\u652f\u6301\u7684\u529f\u80fd\uff0c\u6bd4\u5982geometry shaders\u3002\u73b0\u5728\u6211\u4eec\u4e0d\u9700\u8981\u4efb\u4f55\u7279\u6b8a\u7684\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7684\u5b9a\u4e49\u5b83\u5e76\u5c06\u6240\u6709\u5185\u5bb9\u4fdd\u7559\u5230 VK_FALSE \u3002\u4e00\u65e6\u6211\u4eec\u8981\u5f00\u59cb\u7528Vulkan\u505a\u66f4\u591a\u7684\u4e8b\u60c5\uff0c\u6211\u4eec\u4f1a\u56de\u5230\u8fd9\u4e2a\u7ed3\u6784\u4f53\uff0c\u8fdb\u4e00\u6b65\u8bbe\u7f6e\u3002 VkPhysicalDeviceFeatures deviceFeatures = {}; C++ \u521b\u5efa\u903b\u8f91\u8bbe\u5907 \u4f7f\u7528\u524d\u9762\u7684\u4e24\u4e2a\u7ed3\u6784\u4f53\uff0c\u6211\u4eec\u53ef\u4ee5\u586b\u5145 VkDeviceCreateInfo \u7ed3\u6784\u3002 VkDeviceCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; C++ \u9996\u5148\u6dfb\u52a0\u6307\u5411\u961f\u5217\u521b\u5efa\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\u548c\u8bbe\u5907\u529f\u80fd\u7ed3\u6784\u4f53: createInfo.pQueueCreateInfos = &queueCreateInfo; createInfo.queueCreateInfoCount = 1; createInfo.pEnabledFeatures = &deviceFeatures; C++ \u7ed3\u6784\u4f53\u5176\u4f59\u7684\u90e8\u5206\u4e0e VkInstanceCreateInfo \u76f8\u4f3c\uff0c\u9700\u8981\u6307\u5b9a\u6269\u5c55\u548c validation layers \uff0c\u603b\u800c\u8a00\u4e4b\u8fd9\u6b21\u4e0d\u540c\u4e4b\u5904\u662f\u4e3a\u5177\u4f53\u7684\u8bbe\u5907\u8bbe\u7f6e\u4fe1\u606f\u3002 \u8bbe\u7f6e\u5177\u4f53\u6269\u5c55\u7684\u4e00\u4e2a\u6848\u4f8b\u662f VK_KHR_swapchain \uff0c\u5b83\u5141\u8bb8\u5c06\u6765\u81ea\u8bbe\u5907\u7684\u6e32\u67d3\u56fe\u5f62\u5448\u73b0\u5230 Windows \u3002\u7cfb\u7edf\u4e2d\u7684 Vulkan \u8bbe\u5907\u53ef\u80fd\u7f3a\u5c11\u8be5\u529f\u80fd\uff0c\u4f8b\u5982\u4ec5\u4ec5\u652f\u6301\u8ba1\u7b97\u64cd\u4f5c\u3002\u6211\u4eec\u5c06\u5728\u4ea4\u6362\u94fe\u7ae0\u8282\u4e2d\u5c55\u5f00\u8fd9\u4e2a\u6269\u5c55\u3002 \u5c31\u50cf\u4e4b\u524d validation layers \u5c0f\u8282\u4e2d\u63d0\u5230\u7684\uff0c\u5141\u8bb8\u4e3a instance \u5f00\u542f validation layers \uff0c\u73b0\u5728\u6211\u4eec\u5c06\u4e3a\u8bbe\u5907\u5f00\u542f validation layers \uff0c\u800c\u4e0d\u9700\u8981\u4e3a\u8bbe\u5907\u6307\u5b9a\u4efb\u4f55\u6269\u5c55\u3002 createInfo.enabledExtensionCount = 0; if (enableValidationLayers) { createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size()); createInfo.ppEnabledLayerNames = validationLayers.data(); } else { createInfo.enabledLayerCount = 0; } C++ \u5c31\u8fd9\u6837\uff0c\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 vkCreateDevice \u51fd\u6570\u6765\u521b\u5efa\u5b9e\u4f8b\u5316\u903b\u8f91\u8bbe\u5907\u3002 if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) { throw std::runtime_error(\"failed to create logical device!\"); } C++ \u8fd9\u4e9b\u53c2\u6570\u5206\u522b\u662f\u5305\u542b\u5177\u4f53\u961f\u5217\u4f7f\u7528\u4fe1\u606f\u7684\u7269\u7406\u8bbe\u5907\uff0c\u53ef\u9009\u7684\u5206\u914d\u5668\u56de\u8c03\u6307\u9488\u4ee5\u53ca\u7528\u4e8e\u5b58\u50a8\u903b\u8f91\u8bbe\u5907\u7684\u53e5\u67c4\u3002\u4e0e instance \u521b\u5efa\u7c7b\u4f3c\uff0c\u6b64\u8c03\u7528\u53ef\u80fd\u7531\u4e8e\u542f\u7528\u4e0d\u5b58\u5728\u7684\u6269\u5c55\u6216\u8005\u6307\u5b9a\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5bfc\u81f4\u8fd4\u56de\u9519\u8bef\u3002 \u5728 cleanup \u51fd\u6570\u4e2d\u903b\u8f91\u8bbe\u5907\u9700\u8981\u8c03\u7528 vkDestroyDevice \u9500\u6bc1: void cleanup() { vkDestroyDevice(device, nullptr); ... } C++ \u903b\u8f91\u8bbe\u5907\u4e0d\u4e0e instance \u4ea4\u4e92\uff0c\u6240\u4ee5\u53c2\u6570\u4e2d\u4e0d\u5305\u542b instance \u3002 \u68c0\u7d22\u961f\u5217\u5904\u7406 \u8fd9\u4e9b\u961f\u5217\u4e0e\u903b\u8f91\u8bbe\u5907\u81ea\u52a8\u7684\u4e00\u540c\u521b\u5efa\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u4e00\u4e2a\u4e0e\u5b83\u4eec\u8fdb\u884c\u4ea4\u4e92\u7684\u53e5\u67c4\u3002\u5728\u8fd9\u91cc\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u7c7b\u6210\u5458\u6765\u5b58\u50a8\u56fe\u5f62\u961f\u5217\u53e5\u67c4: VkQueue graphicsQueue; C++ \u8bbe\u5907\u961f\u5217\u5728\u8bbe\u5907\u88ab\u9500\u6bc1\u7684\u65f6\u5019\u9690\u5f0f\u6e05\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u5728 cleanup \u51fd\u6570\u4e2d\u505a\u4efb\u4f55\u64cd\u4f5c\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 vkGetDeviceQueue \u51fd\u6570\u6765\u68c0\u6d4b\u6bcf\u4e2a\u961f\u5217\u7c07\u4e2d\u961f\u5217\u7684\u53e5\u67c4\u3002\u53c2\u6570\u662f\u903b\u8f91\u8bbe\u5907\uff0c\u961f\u5217\u7c07\uff0c\u961f\u5217\u7d22\u5f15\u548c\u5b58\u50a8\u83b7\u53d6\u961f\u5217\u53d8\u91cf\u53e5\u67c4\u7684\u6307\u9488\u3002\u56e0\u4e3a\u6211\u4eec\u53ea\u662f\u4ece\u8fd9\u4e2a\u961f\u5217\u7c07\u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u6240\u4ee5\u9700\u8981\u4f7f\u7528\u7d22\u5f15 0 \u3002 vkGetDeviceQueue(device, indices.graphicsFamily, 0, &graphicsQueue); C++ \u5728\u6210\u529f\u83b7\u53d6\u903b\u8f91\u8bbe\u5907\u548c\u961f\u5217\u53e5\u67c4\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u663e\u5361\u505a\u4e00\u4e9b\u5b9e\u9645\u7684\u4e8b\u60c5\u4e86\uff0c\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u4f1a\u8bbe\u7f6e\u8d44\u6e90\u5e76\u5c06\u76f8\u5e94\u7684\u7ed3\u679c\u63d0\u4ea4\u5230\u7a97\u4f53\u7cfb\u7edf\u3002 Vulkan \u4ea4\u6362\u94fe Vulkan \u4ea4\u6362\u94fe \uff0c\u5728\u8fd9\u4e00\u7ae0\u8282\uff0c\u6211\u4eec\u4e86\u89e3\u4e00\u4e0b\u5c06\u6e32\u67d3\u56fe\u50cf\u63d0\u4ea4\u5230\u5c4f\u5e55\u7684\u57fa\u672c\u673a\u5236\u3002\u8fd9\u79cd\u673a\u5236\u79f0\u4e3a\u4ea4\u6362\u94fe\uff0c\u5e76\u4e14\u9700\u8981\u5728 Vulkan \u4e0a\u4e0b\u6587\u4e2d\u88ab\u660e\u786e\u521b\u5efa\u3002\u4ece\u5c4f\u5e55\u7684\u89d2\u5ea6\u89c2\u5bdf\uff0c\u4ea4\u6362\u94fe\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u56fe\u50cf\u961f\u5217\u3002\u5e94\u7528\u7a0b\u5e8f\u4f5c\u4e3a\u751f\u4ea7\u8005\u4f1a\u83b7\u53d6\u56fe\u50cf\u8fdb\u884c\u7ed8\u5236\uff0c\u7136\u540e\u5c06\u5176\u8fd4\u8fd8\u7ed9\u4ea4\u6362\u94fe\u56fe\u50cf\u961f\u5217\uff0c\u7b49\u5f85\u5c4f\u5e55\u6d88\u8d39\u3002\u4ea4\u6362\u94fe\u7684\u5177\u4f53\u914d\u7f6e\u4fe1\u606f\u51b3\u5b9a\u4e86\u5e94\u7528\u7a0b\u5e8f\u63d0\u4ea4\u7ed8\u5236\u56fe\u50cf\u5230\u961f\u5217\u7684\u6761\u4ef6\u4ee5\u53ca\u56fe\u50cf\u961f\u5217\u8868\u73b0\u7684\u6548\u679c\uff0c\u4f46\u4ea4\u6362\u94fe\u7684\u901a\u5e38\u4f7f\u7528\u76ee\u7684\u662f\u4f7f\u7ed8\u5236\u56fe\u50cf\u7684\u6700\u7ec8\u5448\u73b0\u4e0e\u5c4f\u5e55\u7684\u5237\u65b0\u9891\u7387\u540c\u6b65\u3002\u53ef\u4ee5\u7b80\u5355\u5c06\u4ea4\u6362\u94fe\u7406\u89e3\u4e3a\u4e00\u4e2a\u961f\u5217\uff0c\u540c\u6b65\u4ece\u751f\u4ea7\u8005\uff0c\u5373\u5e94\u7528\u7a0b\u5e8f\u7ed8\u5236\u56fe\u50cf\uff0c\u5230\u6d88\u8d39\u8005\uff0c\u5c4f\u5e55\u5237\u65b0\u7684 Produce-Consume \u5173\u7cfb\u3002\u5728\u6df1\u5165\u5185\u5bb9\u524d\u770b\u4e00\u4e0b\u5b98\u65b9\u7ed9\u51fa\u7684\u6574\u4f53\u4ea4\u6362\u94fe\u793a\u4f8b\u56fe\u3002 \u5f53\u7136\u56fe\u793a\u4e0a\u6709\u4e00\u4e9b\u964c\u751f\u7684\u5173\u952e\u5b57\u4f1a\u5728\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\u4e2d\u9010\u4e00\u4ecb\u7ecd\uff0c\u5728\u6b64\u6709\u4e00\u4e2a\u6574\u4f53\u6982\u5ff5\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u68c0\u67e5\u4ea4\u6362\u94fe\u652f\u6301 2 \u67e5\u8be2\u4ea4\u6362\u94fe\u652f\u6301\u7684\u8be6\u60c5 3 \u4e3a\u4ea4\u6362\u94fe\u9009\u62e9\u6b63\u786e\u7684\u8bbe\u7f6e 4 Surface \u683c\u5f0f 5 \u6f14\u793a\u6a21\u5f0f 6 \u4ea4\u6362\u8303\u56f4 7 \u521b\u5efa\u4ea4\u6362\u94fe 8 \u83b7\u53d6\u4ea4\u6362\u94fe\u56fe\u50cf \u68c0\u67e5\u4ea4\u6362\u94fe\u652f\u6301 \u5e76\u4e0d\u662f\u6240\u6709\u7684\u56fe\u5f62\u5361\u5177\u5907\u80fd\u529b\u5c06\u7ed8\u5236\u7684\u56fe\u50cf\u76f4\u63a5\u663e\u793a\u5230\u5c4f\u5e55\u4e0a\u3002\u6bd4\u5982\u4e00\u4e2aGPU\u5361\u662f\u4e3a\u670d\u52a1\u5668\u8bbe\u8ba1\u7684\uff0c\u90a3\u5c31\u4e0d\u4f1a\u5177\u5907\u4efb\u4f55\u6709\u5173\u663e\u793a\u7684\u8f93\u51fa\u3002\u5176\u6b21\uff0c\u56fe\u50cf\u5448\u73b0\u662f\u4e0e surface \u6253\u4ea4\u9053\uff0c\u800c surface \u53c8\u4e0e\u5177\u4f53\u7684\u7a97\u4f53\u7cfb\u7edf\u5f3a\u5173\u8054\uff0c\u4ece\u8fd9\u4e2a\u89d2\u5ea6\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u5b83\u4e0d\u662f Vulkan \u6838\u5fc3\u7684\u90e8\u5206\u3002\u5728\u67e5\u8be2\u56fe\u5f62\u5361\u662f\u5426\u652f\u6301\u540e\uff0c\u9700\u8981\u542f\u7528 VK_KHR_swapchain \u8bbe\u5907\u7ea7\u522b\u7684\u6269\u5c55\u3002 \u6240\u4ee5\u5462\uff0c\u6211\u4eec\u9996\u5148\u6269\u5c55\u4e4b\u524d\u7684 isDeviceSuitable \u51fd\u6570\uff0c\u786e\u8ba4\u8bbe\u5907\u662f\u5426\u652f\u6301\u3002\u4e4b\u524d\u6211\u4eec\u5df2\u7ecf\u4e86\u89e3\u5982\u4f55\u5217\u51fa VkPhysicalDevice \u652f\u6301\u7684\u6269\u5c55\u5217\u8868\uff0c\u5728\u6b64\u5c31\u4e0d\u5c55\u5f00\u5177\u4f53\u7ec6\u8282\u4e86\u3002\u8bf7\u6ce8\u610f\u7684\u662f\uff0cVulkan\u5934\u6587\u4ef6\u63d0\u4f9b\u7ed9\u4e86\u4e00\u4e2a\u65b9\u4fbf\u7684\u5b8f VK_KHR_SWAPCHAIN_EXTENSION_NAME \uff0c\u8be5\u5b8f\u5b9a\u4e49\u4e3a VK_KHR_swapchain \u3002\u4f7f\u7528\u5b8f\u7684\u4f18\u70b9\u5c31\u662f\u907f\u514d\u62fc\u5199\u9519\u8bef\u3002 \u9996\u5148\u58f0\u660e\u9700\u8981\u7684\u8bbe\u5907\u6269\u5c55\u6e05\u5355\uff0c\u4e0e\u4e4b\u524d\u5f00\u542f validation layers \u7684\u5217\u8868\u662f\u76f8\u4f3c\u7684\u3002 const std::vector<const char*> deviceExtensions = { VK_KHR_SWAPCHAIN_EXTENSION_NAME }; C++ \u63a5\u4e0b\u6765\uff0c\u521b\u5efa\u4e00\u4e2a\u4ece isDeviceSuitable \u8c03\u7528\u7684\u65b0\u51fd\u6570 checkDeviceExtensionSupport \u4f5c\u4e3a\u989d\u5916\u7684\u68c0\u67e5\u903b\u8f91: bool isDeviceSuitable(VkPhysicalDevice device) { QueueFamilyIndices indices = findQueueFamilies(device); bool extensionsSupported = checkDeviceExtensionSupport(device); return indices.isComplete() && extensionsSupported; } bool checkDeviceExtensionSupport(VkPhysicalDevice device) { return true; } C++ \u4fee\u6539\u51fd\u6570\u4f53\u4ee5\u4fbf\u4e8e\u679a\u4e3e\u8bbe\u5907\u6240\u6709\u96c6\u5408\uff0c\u5e76\u68c0\u6d4b\u662f\u5426\u6240\u6709\u9700\u8981\u7684\u6269\u5c55\u5728\u5176\u4e2d\u3002 bool checkDeviceExtensionSupport(VkPhysicalDevice device) { uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availableExtensions.data()); std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end()); for (const auto& extension : availableExtensions) { requiredExtensions.erase(extension.extensionName); } return requiredExtensions.empty(); } C++ \u9009\u62e9\u4e00\u7ec4\u5b57\u7b26\u4e32\u6765\u8868\u793a\u672a\u7ecf\u786e\u8ba4\u8fc7\u7684\u6269\u5c55\u540d\u3002\u8fd9\u6837\u505a\u53ef\u4ee5\u6bd4\u8f83\u5bb9\u6613\u7684\u8fdb\u884c\u589e\u5220\u53ca\u904d\u5386\u7684\u6b21\u5e8f\u3002\u5f53\u7136\u4e5f\u53ef\u4ee5\u50cf CheckValidationLayerSupport \u51fd\u6570\u90a3\u6837\u505a\u5d4c\u5957\u7684\u5faa\u73af\u3002\u6027\u80fd\u7684\u5dee\u5f02\u5728\u8fd9\u91cc\u662f\u4e0d\u5173\u7d27\u8981\u7684\u3002\u73b0\u5728\u8fd0\u884c\u4ee3\u7801\u9a8c\u8bc1\u56fe\u5f62\u5361\u662f\u5426\u80fd\u591f\u987a\u5229\u521b\u5efa\u4e00\u4e2a\u4ea4\u6362\u94fe\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u524d\u4e00\u4e2a\u7ae0\u8282\u4e2d\u9a8c\u8bc1\u8fc7\u7684 presentation \u961f\u5217\u6709\u6548\u6027\uff0c\u5e76\u6ca1\u6709\u660e\u786e\u6307\u51fa\u4ea4\u6362\u94fe\u6269\u5c55\u4e5f\u5fc5\u987b\u6709\u6548\u652f\u6301\u3002\u597d\u5728\u6269\u5c55\u5fc5\u987b\u660e\u786e\u7684\u5f00\u542f\u3002 \u542f\u7528\u6269\u5c55\u9700\u8981\u5bf9\u903b\u8f91\u8bbe\u5907\u7684\u521b\u5efa\u7ed3\u6784\u4f53\u505a\u4e00\u4e9b\u5c0f\u7684\u6539\u52a8: createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size()); createInfo.ppEnabledExtensionNames = deviceExtensions.data(); C++ \u67e5\u8be2\u4ea4\u6362\u94fe\u652f\u6301\u7684\u8be6\u60c5 \u5982\u679c\u4ec5\u4ec5\u662f\u4e3a\u4e86\u6d4b\u8bd5\u4ea4\u6362\u94fe\u7684\u6709\u6548\u6027\u662f\u8fdc\u8fdc\u4e0d\u591f\u7684\uff0c\u56e0\u4e3a\u5b83\u8fd8\u4e0d\u80fd\u5f88\u597d\u7684\u4e0e\u7a97\u4f53 surface \u517c\u5bb9\u3002\u521b\u5efa\u4ea4\u6362\u94fe\u540c\u6837\u4e5f\u9700\u8981\u5f88\u591a\u8bbe\u7f6e\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4e86\u89e3\u4e00\u4e9b\u6709\u5173\u8bbe\u7f6e\u7684\u7ec6\u8282\u3002 \u57fa\u672c\u4e0a\u6709\u4e09\u5927\u7c7b\u5c5e\u6027\u9700\u8981\u8bbe\u7f6e: \u57fa\u672c\u7684surface\u529f\u80fd\u5c5e\u6027(min/max number of images in swap chain, min/max width and height of images) Surface\u683c\u5f0f(pixel format, color space) \u6709\u6548\u7684presentation\u6a21\u5f0f \u4e0e findQueueFamilies \u7c7b\u4f3c\uff0c\u6211\u4eec\u4f7f\u7528\u7ed3\u6784\u4f53\u4e00\u6b21\u6027\u7684\u4f20\u9012\u8be6\u7ec6\u7684\u4fe1\u606f\u3002\u4e09\u7c7b\u5c5e\u6027\u5c01\u88c5\u5728\u5982\u4e0b\u7ed3\u6784\u4f53\u4e2d\uff1a struct SwapChainSupportDetails { VkSurfaceCapabilitiesKHR capabilities; std::vector<VkSurfaceFormatKHR> formats; std::vector<VkPresentModeKHR> presentModes; }; C++ \u73b0\u5728\u521b\u5efa\u65b0\u7684\u51fd\u6570 querySwapChainSupport \u586b\u5145\u8be5\u7ed3\u6784\u4f53\u3002 SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) { SwapChainSupportDetails details; return details; } C++ \u672c\u5c0f\u8282\u6d89\u53ca\u5982\u4f55\u67e5\u8be2\u5305\u542b\u6b64\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\uff0c\u8fd9\u4e9b\u7ed3\u6784\u4f53\u7684\u542b\u4e49\u53ca\u5305\u542b\u7684\u6570\u636e\u5c06\u5728\u4e0b\u4e00\u8282\u8ba8\u8bba\u3002 \u6211\u4eec\u73b0\u5728\u5f00\u59cb\u57fa\u672c\u7684 surface \u529f\u80fd\u8bbe\u7f6e\u90e8\u5206\u3002\u8fd9\u4e9b\u5c5e\u6027\u53ef\u4ee5\u901a\u8fc7\u7b80\u5355\u7684\u51fd\u6570\u8c03\u7528\u67e5\u8be2\uff0c\u5e76\u8fd4\u56de\u5230\u5355\u4e2a VkSurfaceCapabilitiesKHR \u7ed3\u6784\u4f53\u4e2d\u3002 vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &details.capabilities); C++ \u8fd9\u4e2a\u51fd\u6570\u9700\u8981 VkPhysicalDevice \u548c VkSurfaceKHR \u7a97\u4f53 surface \u51b3\u5b9a\u652f\u6301\u54ea\u4e9b\u5177\u4f53\u529f\u80fd\u3002\u6240\u6709\u7528\u4e8e\u67e5\u770b\u652f\u6301\u529f\u80fd\u7684\u51fd\u6570\u90fd\u9700\u8981\u8fd9\u4e24\u4e2a\u53c2\u6570\uff0c\u56e0\u4e3a\u5b83\u4eec\u662f\u4ea4\u6362\u94fe\u7684\u6838\u5fc3\u7ec4\u4ef6\u3002 \u4e0b\u4e00\u6b65\u67e5\u8be2\u652f\u6301\u7684 surface \u683c\u5f0f\u3002\u56e0\u4e3a\u83b7\u53d6\u5230\u7684\u662f\u4e00\u4e2a\u7ed3\u6784\u4f53\u5217\u8868\uff0c\u5177\u4f53\u5e94\u7528\u5f62\u5f0f\u5982\u4e0b: uint32_t formatCount; vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, nullptr); if (formatCount != 0) { details.formats.resize(formatCount); vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, details.formats.data()); } C++ \u786e\u4fdd\u96c6\u5408\u5bf9\u4e8e\u6240\u6709\u6709\u6548\u7684\u683c\u5f0f\u53ef\u6269\u5145\u3002\u6700\u540e\u67e5\u8be2\u652f\u6301\u7684 presentation \u6a21\u5f0f\uff0c\u540c\u6837\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528 vkGetPhysicalDeviceSurfacePresentModesKHR : uint32_t presentModeCount; vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, nullptr); if (presentModeCount != 0) { details.presentModes.resize(presentModeCount); vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, details.presentModes.data()); } C++ \u73b0\u5728\u7ed3\u6784\u4f53\u7684\u76f8\u5173\u7ec6\u8282\u4ecb\u7ecd\u5b8c\u6bd5\uff0c\u8ba9\u6211\u4eec\u6269\u5145 isDeviceSuitable \u51fd\u6570\uff0c\u4ece\u800c\u5229\u7528\u8be5\u51fd\u6570\u9a8c\u8bc1\u4ea4\u6362\u94fe\u8db3\u591f\u7684\u652f\u6301\u3002\u5728\u672c\u7ae0\u8282\u4e2d\u4ea4\u6362\u94fe\u7684\u652f\u6301\u662f\u8db3\u591f\u7684\uff0c\u56e0\u4e3a\u5bf9\u4e8e\u7ed9\u5b9a\u7684\u7a97\u4f53 surface \uff0c\u5b83\u81f3\u5c11\u652f\u6301\u4e00\u4e2a\u56fe\u50cf\u683c\u5f0f\uff0c\u4e00\u4e2a presentaion \u6a21\u5f0f\u3002 bool swapChainAdequate = false; if (extensionsSupported) { SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device); swapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty(); } C++ \u6bd4\u8f83\u91cd\u8981\u7684\u662f\u5c1d\u8bd5\u67e5\u8be2\u4ea4\u6362\u94fe\u7684\u652f\u6301\u662f\u5728\u9a8c\u8bc1\u5b8c\u6269\u5c55\u6709\u6548\u6027\u4e4b\u540e\u8fdb\u884c\u3002\u51fd\u6570\u7684\u6700\u540e\u4e00\u884c\u4ee3\u7801\u4fee\u6539\u4e3a: return indices.isComplete() && extensionsSupported && swapChainAdequate; C++ \u4e3a\u4ea4\u6362\u94fe\u9009\u62e9\u6b63\u786e\u7684\u8bbe\u7f6e \u5982\u679c swapChainAdequate \u6761\u4ef6\u8db3\u591f\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u652f\u6301\u7684\u8db3\u591f\u7684\uff0c\u4f46\u662f\u6839\u636e\u4e0d\u540c\u7684\u6a21\u5f0f\u4ecd\u7136\u6709\u4e0d\u540c\u7684\u6700\u4f73\u9009\u62e9\u3002\u6211\u4eec\u7f16\u5199\u4e00\u7ec4\u51fd\u6570\uff0c\u901a\u8fc7\u8fdb\u4e00\u6b65\u7684\u8bbe\u7f6e\u67e5\u627e\u6700\u5339\u914d\u7684\u4ea4\u6362\u94fe\u3002\u8fd9\u91cc\u6709\u4e09\u79cd\u7c7b\u578b\u7684\u8bbe\u7f6e\u53bb\u786e\u5b9a: Surface\u683c\u5f0f (color depth) Presentation mode (conditions for \u201cswapping\u201d image to the screen) Swap extent (resolution of images in swap chain) \u9996\u5148\u5728\u8111\u6d77\u4e2d\u5bf9\u6bcf\u4e00\u4e2a\u8bbe\u7f6e\u90fd\u6709\u4e00\u4e2a\u7406\u60f3\u7684\u6570\u503c\uff0c\u5982\u679c\u8fbe\u6210\u4e00\u81f4\u6211\u4eec\u5c31\u4f7f\u7528\uff0c\u5426\u5219\u6211\u4eec\u4e00\u8d77\u521b\u5efa\u4e00\u4e9b\u903b\u8f91\u53bb\u627e\u5230\u66f4\u597d\u7684\u89c4\u5219\u3001\u6570\u503c\u3002 Surface \u683c\u5f0f \u8fd9\u4e2a\u51fd\u6570\u7528\u6765\u8bbe\u7f6esurface\u683c\u5f0f\u3002\u6211\u4eec\u4f20\u9012 formats \u4f5c\u4e3a\u51fd\u6570\u7684\u53c2\u6570\uff0c\u7c7b\u578b\u4e3a SwapChainSupportDetails \u3002 VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) { } C++ \u6bcf\u4e2a VkSurfaceFormatKHR \u7ed3\u6784\u90fd\u5305\u542b\u4e00\u4e2a format \u548c\u4e00\u4e2a colorSpace \u6210\u5458\u3002 format \u6210\u5458\u53d8\u91cf\u6307\u5b9a\u8272\u5f69\u901a\u9053\u548c\u7c7b\u578b\u3002\u6bd4\u5982\uff0c VK_FORMAT_B8G8R8A8_UNORM \u4ee3\u8868\u4e86\u6211\u4eec\u4f7f\u7528B,G,R\u548calpha\u6b21\u5e8f\u7684\u901a\u9053\uff0c\u4e14\u6bcf\u4e00\u4e2a\u901a\u9053\u4e3a\u65e0\u7b26\u53f78bit\u6574\u6570\uff0c\u6bcf\u4e2a\u50cf\u7d20\u603b\u8ba132bits\u3002 colorSpace \u6210\u5458\u63cf\u8ff0 SRGB \u989c\u8272\u7a7a\u95f4\u662f\u5426\u901a\u8fc7 VK_COLOR_SPACE_SRGB_NONLINEAR_KHR \u6807\u5fd7\u652f\u6301\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u5728\u8f83\u65e9\u7248\u672c\u7684\u89c4\u8303\u4e2d\uff0c\u8fd9\u4e2a\u6807\u5fd7\u540d\u4e3a VK_COLORSPACE_SRGB_NONLINEAR_KHR \u3002 \u5982\u679c\u53ef\u4ee5\u6211\u4eec\u5c3d\u53ef\u80fd\u4f7f\u7528SRGB(\u5f69\u8272\u8bed\u8a00\u534f\u8bae)\uff0c \u56e0\u4e3a\u5b83\u4f1a\u5f97\u5230\u66f4\u5bb9\u6613\u611f\u77e5\u7684\u3001\u7cbe\u786e\u7684\u8272\u5f69 \u3002\u76f4\u63a5\u4e0e SRGB \u989c\u8272\u6253\u4ea4\u9053\u662f\u6bd4\u8f83\u6709\u6311\u6218\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u4f7f\u7528\u6807\u51c6\u7684RGB\u4f5c\u4e3a\u989c\u8272\u683c\u5f0f\uff0c\u8fd9\u4e5f\u662f\u901a\u5e38\u4f7f\u7528\u7684\u4e00\u4e2a\u683c\u5f0f VK_FORMAT_B8G8R8A8_UNORM \u3002 \u6700\u7406\u60f3\u7684\u60c5\u51b5\u662fsurface\u6ca1\u6709\u8bbe\u7f6e\u4efb\u4f55\u504f\u5411\u6027\u7684\u683c\u5f0f\uff0c\u8fd9\u4e2a\u65f6\u5019Vulkan\u4f1a\u901a\u8fc7\u4ec5\u8fd4\u56de\u4e00\u4e2a VkSurfaceFormatKHR \u7ed3\u6784\u8868\u793a\uff0c\u4e14\u8be5\u7ed3\u6784\u7684 format \u6210\u5458\u8bbe\u7f6e\u4e3a VK_FORMAT_UNDEFINED \u3002 if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) { return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; } C++ \u5982\u679c\u4e0d\u80fd\u81ea\u7531\u7684\u8bbe\u7f6e\u683c\u5f0f\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u904d\u5386\u5217\u8868\u8bbe\u7f6e\u5177\u6709\u504f\u5411\u6027\u7684\u7ec4\u5408: for (const auto& availableFormat : availableFormats) { if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { return availableFormat; } } C++ \u5982\u679c\u4ee5\u4e0a\u4e24\u79cd\u65b9\u5f0f\u90fd\u5931\u6548\u4e86\uff0c\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u201c\u4f18\u826f\u201d\u8fdb\u884c\u6253\u5206\u6392\u5e8f\uff0c\u4f46\u662f\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4f1a\u9009\u62e9\u7b2c\u4e00\u4e2a\u683c\u5f0f\u4f5c\u4e3a\u7406\u60f3\u7684\u9009\u62e9\u3002 VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) { if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) { return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; } for (const auto& availableFormat : availableFormats) { if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { return availableFormat; } } return availableFormats[0]; } C++ \u6f14\u793a\u6a21\u5f0f presentation \u6a21\u5f0f\u5bf9\u4e8e\u4ea4\u6362\u94fe\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u56e0\u4e3a\u5b83\u4ee3\u8868\u4e86\u5728\u5c4f\u5e55\u5448\u73b0\u56fe\u50cf\u7684\u6761\u4ef6\u3002\u5728 Vulkan \u4e2d\u6709\u56db\u4e2a\u6a21\u5f0f\u53ef\u4ee5\u4f7f\u7528: VK_PRESENT_MODE_IMMEDIATE_KHR : \u5e94\u7528\u7a0b\u5e8f\u63d0\u4ea4\u7684\u56fe\u50cf\u88ab\u7acb\u5373\u4f20\u8f93\u5230\u5c4f\u5e55\u5448\u73b0\uff0c\u8fd9\u79cd\u6a21\u5f0f\u53ef\u80fd\u4f1a\u9020\u6210\u6495\u88c2\u6548\u679c\u3002 VK_PRESENT_MODE_FIFO_KHR : \u4ea4\u6362\u94fe\u88ab\u770b\u4f5c\u4e00\u4e2a\u961f\u5217\uff0c\u5f53\u663e\u793a\u5185\u5bb9\u9700\u8981\u5237\u65b0\u7684\u65f6\u5019\uff0c\u663e\u793a\u8bbe\u5907\u4ece\u961f\u5217\u7684\u524d\u9762\u83b7\u53d6\u56fe\u50cf\uff0c\u5e76\u4e14\u7a0b\u5e8f\u5c06\u6e32\u67d3\u5b8c\u6210\u7684\u56fe\u50cf\u63d2\u5165\u961f\u5217\u7684\u540e\u9762\u3002\u5982\u679c\u961f\u5217\u662f\u6ee1\u7684\u7a0b\u5e8f\u4f1a\u7b49\u5f85\u3002\u8fd9\u79cd\u89c4\u6a21\u4e0e\u89c6\u9891\u6e38\u620f\u7684\u5782\u76f4\u540c\u6b65\u5f88\u7c7b\u4f3c\u3002\u663e\u793a\u8bbe\u5907\u7684\u5237\u65b0\u65f6\u523b\u88ab\u6210\u4e3a\u201c\u5782\u76f4\u4e2d\u65ad\u201d\u3002 VK_PRESENT_MODE_FIFO_RELAXED_KHR : \u8be5\u6a21\u5f0f\u4e0e\u4e0a\u4e00\u4e2a\u6a21\u5f0f\u7565\u6709\u4e0d\u540c\u7684\u5730\u65b9\u4e3a\uff0c\u5982\u679c\u5e94\u7528\u7a0b\u5e8f\u5b58\u5728\u5ef6\u8fdf\uff0c\u5373\u63a5\u53d7\u6700\u540e\u4e00\u4e2a\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\u65f6\u961f\u5217\u7a7a\u4e86\uff0c\u5c06\u4e0d\u4f1a\u7b49\u5f85\u4e0b\u4e00\u4e2a\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\uff0c\u800c\u662f\u5c06\u56fe\u50cf\u76f4\u63a5\u4f20\u9001\u3002\u8fd9\u6837\u505a\u53ef\u80fd\u5bfc\u81f4\u53ef\u89c1\u7684\u6495\u88c2\u6548\u679c\u3002 VK_PRESENT_MODE_MAILBOX_KHR : \u8fd9\u662f\u7b2c\u4e8c\u79cd\u6a21\u5f0f\u7684\u53d8\u79cd\u3002\u5f53\u4ea4\u6362\u94fe\u961f\u5217\u6ee1\u7684\u65f6\u5019\uff0c\u9009\u62e9\u65b0\u7684\u66ff\u6362\u65e7\u7684\u56fe\u50cf\uff0c\u4ece\u800c\u66ff\u4ee3\u963b\u585e\u5e94\u7528\u7a0b\u5e8f\u7684\u60c5\u5f62\u3002\u8fd9\u79cd\u6a21\u5f0f\u901a\u5e38\u7528\u6765\u5b9e\u73b0\u4e09\u91cd\u7f13\u51b2\u533a\uff0c\u4e0e\u6807\u51c6\u7684\u5782\u76f4\u540c\u6b65\u53cc\u7f13\u51b2\u76f8\u6bd4\uff0c\u5b83\u53ef\u4ee5\u6709\u6548\u907f\u514d\u5ef6\u8fdf\u5e26\u6765\u7684\u6495\u88c2\u6548\u679c\u3002 \u903b\u8f91\u4e0a\u770b\u4ec5\u4ec5 VR_PRESENT_MODE_FIFO_KHR \u6a21\u5f0f\u4fdd\u8bc1\u53ef\u7528\u6027\uff0c\u6240\u4ee5\u6211\u4eec\u518d\u6b21\u589e\u52a0\u4e00\u4e2a\u51fd\u6570\u67e5\u627e\u6700\u4f73\u7684\u6a21\u5f0f: VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { return VK_PRESENT_MODE_FIFO_KHR; } C++ \u6211\u4e2a\u4eba\u8ba4\u4e3a\u4e09\u7ea7\u7f13\u51b2\u662f\u4e00\u4e2a\u975e\u5e38\u597d\u7684\u7b56\u7565\u3002\u5b83\u5141\u8bb8\u6211\u4eec\u907f\u514d\u6495\u88c2\uff0c\u540c\u65f6\u4ecd\u7136\u4fdd\u6301\u76f8\u5bf9\u4f4e\u7684\u5ef6\u8fdf\uff0c\u901a\u8fc7\u6e32\u67d3\u5c3d\u53ef\u80fd\u65b0\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u63a5\u53d7\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\u3002\u6240\u4ee5\u6211\u4eec\u770b\u4e00\u4e0b\u5217\u8868\uff0c\u5b83\u662f\u5426\u53ef\u7528: VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { for (const auto& availablePresentMode : availablePresentModes) { if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { return availablePresentMode; } } return VK_PRESENT_MODE_FIFO_KHR; } C++ \u9057\u61be\u7684\u662f\uff0c\u4e00\u4e9b\u9a71\u52a8\u7a0b\u5e8f\u76ee\u524d\u5e76\u4e0d\u652f\u6301 VK_PRESENT_MODE_FIFO_KHR ,\u9664\u6b64\u4e4b\u5916\u5982\u679c VK_PRESENT_MODE_MAILBOX_KHR \u4e5f\u4e0d\u53ef\u7528\uff0c\u6211\u4eec\u66f4\u503e\u5411\u4f7f\u7528 VK_PRESENT_MODE_IMMEDIATE_KHR : VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { VkPresentModeKHR bestMode = VK_PRESENT_MODE_FIFO_KHR; for (const auto& availablePresentMode : availablePresentModes) { if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { return availablePresentMode; } else if (availablePresentMode == VK_PRESENT_MODE_IMMEDIATE_KHR) { bestMode = availablePresentMode; } } return bestMode; } C++ \u4ea4\u6362\u8303\u56f4 \u8fd8\u5269\u4e0b\u4e00\u4e2a\u5c5e\u6027\uff0c\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u51fd\u6570: VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) { } C++ \u4ea4\u6362\u8303\u56f4\u662f\u6307\u4ea4\u6362\u94fe\u56fe\u50cf\u7684\u5206\u8fa8\u7387\uff0c\u5b83\u51e0\u4e4e\u603b\u662f\u7b49\u4e8e\u6211\u4eec\u7ed8\u5236\u7a97\u4f53\u7684\u5206\u8fa8\u7387\u3002\u5206\u8fa8\u7387\u7684\u8303\u56f4\u88ab\u5b9a\u4e49\u5728 VkSurfaceCapabilitiesKHR \u7ed3\u6784\u4f53\u4e2d\u3002 Vulkan \u544a\u8bc9\u6211\u4eec\u901a\u8fc7\u8bbe\u7f6e currentExtent \u6210\u5458\u7684 width \u548c height \u6765\u5339\u914d\u7a97\u4f53\u7684\u5206\u8fa8\u7387\u3002\u7136\u800c\uff0c\u4e00\u4e9b\u7a97\u4f53\u7ba1\u7406\u5668\u5141\u8bb8\u4e0d\u540c\u7684\u8bbe\u7f6e\uff0c\u610f\u5473\u7740\u5c06 currentExtent \u7684width\u548cheight\u8bbe\u7f6e\u4e3a\u7279\u6b8a\u7684\u6570\u503c\u8868\u793a: uint32_t \u7684\u6700\u5927\u503c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53c2\u8003\u7a97\u4f53 minImageExtent \u548c maxImageExtent \u9009\u62e9\u6700\u5339\u914d\u7684\u5206\u8fa8\u7387\u3002 VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) { if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) { return capabilities.currentExtent; } else { VkExtent2D actualExtent = {WIDTH, HEIGHT}; actualExtent.width = std::max(capabilities.minImageExtent.width, std::min(capabilities.maxImageExtent.width, actualExtent.width)); actualExtent.height = std::max(capabilities.minImageExtent.height, std::min(capabilities.maxImageExtent.height, actualExtent.height)); return actualExtent; } } C++ max \u548c min \u51fd\u6570\u7528\u4e8e\u5c06 WIDTH \u548c HEIGHT \u6536\u655b\u5728\u5b9e\u9645\u652f\u6301\u7684 minimum \u548c maximum \u8303\u56f4\u4e2d\u3002\u5728\u8fd9\u91cc\u786e\u8ba4\u5305\u542b <algorithm> \u5934\u6587\u4ef6\u3002 \u521b\u5efa\u4ea4\u6362\u94fe \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6709\u4e86\u8fd9\u4e9b\u8f85\u52a9\u51fd\u6570\uff0c\u7528\u4ee5\u5728\u8fd0\u884c\u65f6\u5e2e\u52a9\u6211\u4eec\u505a\u51fa\u660e\u667a\u7684\u9009\u62e9\uff0c\u6700\u7ec8\u83b7\u5f97\u6709\u4e86\u521b\u5efa\u4ea4\u6362\u94fe\u6240\u9700\u8981\u7684\u6240\u6709\u4fe1\u606f\u3002 \u521b\u5efa\u4e00\u4e2a\u51fd\u6570 createSwapChain \uff0c\u5728 initVulkan \u51fd\u6570\u4e2d\uff0c\u8be5\u51fd\u6570\u4f1a\u5728\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u4e4b\u540e\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); } void createSwapChain() { SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice); VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats); VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes); VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities); } C++ \u5b9e\u9645\u4e0a\u8fd8\u6709\u4e00\u4e9b\u5c0f\u4e8b\u60c5\u9700\u8981\u786e\u5b9a\uff0c\u4f46\u662f\u6bd4\u8f83\u7b80\u5355\uff0c\u6240\u4ee5\u6ca1\u6709\u5355\u72ec\u521b\u5efa\u51fd\u6570\u3002\u7b2c\u4e00\u4e2a\u662f\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u53ef\u4ee5\u7406\u89e3\u4e3a\u961f\u5217\u7684\u957f\u5ea6\u3002\u5b83\u6307\u5b9a\u8fd0\u884c\u65f6\u56fe\u50cf\u7684\u6700\u5c0f\u6570\u91cf\uff0c\u6211\u4eec\u5c06\u5c1d\u8bd5\u5927\u4e8e1\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u4ee5\u5b9e\u73b0\u4e09\u91cd\u7f13\u51b2\u3002 uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1; if (swapChainSupport.capabilities.maxImageCount > 0 && imageCount > swapChainSupport.capabilities.maxImageCount) { imageCount = swapChainSupport.capabilities.maxImageCount; } C++ \u5bf9\u4e8e maxImageCount \u6570\u503c\u4e3a 0 \u4ee3\u8868\u9664\u4e86\u5185\u5b58\u4e4b\u5916\u6ca1\u6709\u9650\u5236\uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u9700\u8981\u68c0\u67e5\u3002 \u4e0eVulkan\u5176\u4ed6\u5bf9\u8c61\u7684\u521b\u5efa\u8fc7\u7a0b\u4e00\u6837\uff0c\u521b\u5efa\u4ea4\u6362\u94fe\u4e5f\u9700\u8981\u586b\u5145\u5927\u91cf\u7684\u7ed3\u6784\u4f53: VkSwapchainCreateInfoKHR createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; createInfo.surface = surface; C++ \u5728\u6307\u5b9a\u4ea4\u6362\u94fe\u7ed1\u5b9a\u5230\u5177\u4f53\u7684 surface \u4e4b\u540e\uff0c\u9700\u8981\u6307\u5b9a\u4ea4\u6362\u94fe\u56fe\u50cf\u6709\u5173\u7684\u8be6\u7ec6\u4fe1\u606f: createInfo.minImageCount = imageCount; createInfo.imageFormat = surfaceFormat.format; createInfo.imageColorSpace = surfaceFormat.colorSpace; createInfo.imageExtent = extent; createInfo.imageArrayLayers = 1; createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; C++ imageArrayLayers \u6307\u5b9a\u6bcf\u4e2a\u56fe\u50cf\u7ec4\u6210\u7684\u5c42\u6570\u3002\u9664\u975e\u6211\u4eec\u5f00\u53d13D\u5e94\u7528\u7a0b\u5e8f\uff0c\u5426\u5219\u59cb\u7ec8\u4e3a1\u3002 imageUsage \u4f4d\u5b57\u6bb5\u6307\u5b9a\u5728\u4ea4\u6362\u94fe\u4e2d\u5bf9\u56fe\u50cf\u8fdb\u884c\u7684\u5177\u4f53\u64cd\u4f5c\u3002\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u76f4\u63a5\u5bf9\u5b83\u4eec\u8fdb\u884c\u6e32\u67d3\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u4eec\u4f5c\u4e3a\u989c\u8272\u9644\u4ef6\u3002\u4e5f\u53ef\u4ee5\u9996\u5148\u5c06\u56fe\u50cf\u6e32\u67d3\u4e3a\u5355\u72ec\u7684\u56fe\u50cf\uff0c\u8fdb\u884c\u540e\u5904\u7406\u64cd\u4f5c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u53ef\u4ee5\u4f7f\u7528\u50cf VK_IMAGE_USAGE_TRANSFER_DST_BIT \u8fd9\u6837\u7684\u503c\uff0c\u5e76\u4f7f\u7528\u5185\u5b58\u64cd\u4f5c\u5c06\u6e32\u67d3\u7684\u56fe\u50cf\u4f20\u8f93\u5230\u4ea4\u6362\u94fe\u56fe\u50cf\u961f\u5217\u3002 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); uint32_t queueFamilyIndices[] = {(uint32_t) indices.graphicsFamily, (uint32_t) indices.presentFamily}; if (indices.graphicsFamily != indices.presentFamily) { createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT; createInfo.queueFamilyIndexCount = 2; createInfo.pQueueFamilyIndices = queueFamilyIndices; } else { createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; createInfo.queueFamilyIndexCount = 0; // Optional createInfo.pQueueFamilyIndices = nullptr; // Optional } C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u6307\u5b9a\u5982\u4f55\u5904\u7406\u8de8\u591a\u4e2a\u961f\u5217\u7c07\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u3002\u5982\u679cgraphics\u961f\u5217\u7c07\u4e0epresentation\u961f\u5217\u7c07\u4e0d\u540c\uff0c\u4f1a\u51fa\u73b0\u5982\u4e0b\u60c5\u5f62\u3002\u6211\u4eec\u5c06\u4ecegraphics\u961f\u5217\u4e2d\u7ed8\u5236\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\uff0c\u7136\u540e\u5728\u53e6\u4e00\u4e2apresentation\u961f\u5217\u4e2d\u63d0\u4ea4\u4ed6\u4eec\u3002\u591a\u961f\u5217\u5904\u7406\u56fe\u50cf\u6709\u4e24\u79cd\u65b9\u6cd5: VK_SHARING_MODE_EXCLUSIVE : \u540c\u4e00\u65f6\u95f4\u56fe\u50cf\u53ea\u80fd\u88ab\u4e00\u4e2a\u961f\u5217\u7c07\u5360\u7528\uff0c\u5982\u679c\u5176\u4ed6\u961f\u5217\u7c07\u9700\u8981\u5176\u6240\u6709\u6743\u9700\u8981\u660e\u786e\u6307\u5b9a\u3002\u8fd9\u79cd\u65b9\u5f0f\u63d0\u4f9b\u4e86\u6700\u597d\u7684\u6027\u80fd\u3002 VK_SHARING_MODE_CONCURRENT : \u56fe\u50cf\u53ef\u4ee5\u88ab\u591a\u4e2a\u961f\u5217\u7c07\u8bbf\u95ee\uff0c\u4e0d\u9700\u8981\u660e\u786e\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\u3002 \u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u5982\u679c\u961f\u5217\u7c07\u4e0d\u540c\uff0c\u5c06\u4f1a\u4f7f\u7528 concurrent \u6a21\u5f0f\uff0c\u907f\u514d\u5904\u7406\u56fe\u50cf\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\u7684\u5185\u5bb9\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u4f1a\u6d89\u53ca\u4e0d\u5c11\u6982\u5ff5\uff0c\u5efa\u8bae\u540e\u7eed\u7684\u7ae0\u8282\u8ba8\u8bba\u3002 Concurrent \u6a21\u5f0f\u9700\u8981\u9884\u5148\u6307\u5b9a\u961f\u5217\u7c07\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\uff0c\u901a\u8fc7 queueFamilyIndexCount \u548c pQueueFamilyIndices \u53c2\u6570\u8fdb\u884c\u5171\u4eab\u3002\u5982\u679c graphics \u961f\u5217\u7c07\u548cpresentation\u961f\u5217\u7c07\u76f8\u540c\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 exclusive \u6a21\u5f0f\uff0c\u56e0\u4e3a concurrent \u6a21\u5f0f\u9700\u8981\u81f3\u5c11\u4e24\u4e2a\u4e0d\u540c\u7684\u961f\u5217\u7c07\u3002 createInfo.preTransform = swapChainSupport.capabilities.currentTransform; C++ \u5982\u679c\u4ea4\u6362\u94fe\u652f\u6301( supportedTransforms in capabilities ),\u6211\u4eec\u53ef\u4ee5\u4e3a\u4ea4\u6362\u94fe\u56fe\u50cf\u6307\u5b9a\u67d0\u4e9b\u8f6c\u6362\u903b\u8f91\uff0c\u6bd4\u598290\u5ea6\u987a\u65f6\u9488\u65cb\u8f6c\u6216\u8005\u6c34\u5e73\u53cd\u8f6c\u3002\u5982\u679c\u4e0d\u9700\u8981\u4efb\u4f55 transoform \u64cd\u4f5c\uff0c\u53ef\u4ee5\u7b80\u5355\u7684\u8bbe\u7f6e\u4e3a currentTransoform \u3002 createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR; C++ \u6df7\u5408Alpha\u5b57\u6bb5\u6307\u5b9aalpha\u901a\u9053\u662f\u5426\u5e94\u7528\u4e0e\u4e0e\u5176\u4ed6\u7684\u7a97\u4f53\u7cfb\u7edf\u8fdb\u884c\u6df7\u5408\u64cd\u4f5c\u3002\u5982\u679c\u5ffd\u7565\u8be5\u529f\u80fd\uff0c\u7b80\u5355\u7684\u586b VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR \u3002 createInfo.presentMode = presentMode; createInfo.clipped = VK_TRUE; C++ presentMode \u6307\u5411\u81ea\u5df1\u3002\u5982\u679c clipped \u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u610f\u5473\u7740\u6211\u4eec\u4e0d\u5173\u5fc3\u88ab\u906e\u853d\u7684\u50cf\u7d20\u6570\u636e\uff0c\u6bd4\u5982\u7531\u4e8e\u5176\u4ed6\u7684\u7a97\u4f53\u7f6e\u4e8e\u524d\u65b9\u65f6\u6216\u8005\u6e32\u67d3\u7684\u90e8\u5206\u5185\u5bb9\u5b58\u5728\u4e8e\u53ef\u662f\u533a\u57df\u4e4b\u5916\uff0c\u9664\u975e\u771f\u7684\u9700\u8981\u8bfb\u53d6\u8fd9\u4e9b\u50cf\u7d20\u83b7\u6570\u636e\u8fdb\u884c\u5904\u7406\uff0c\u5426\u5219\u53ef\u4ee5\u5f00\u542f\u88c1\u526a\u83b7\u5f97\u6700\u4f73\u6027\u80fd\u3002 createInfo.oldSwapchain = VK_NULL_HANDLE; C++ \u6700\u540e\u4e00\u4e2a\u5b57\u6bb5 oldSwapChain \u3002Vulkan\u8fd0\u884c\u65f6\uff0c\u4ea4\u6362\u94fe\u53ef\u80fd\u5728\u67d0\u4e9b\u6761\u4ef6\u4e0b\u88ab\u66ff\u6362\uff0c\u6bd4\u5982\u7a97\u53e3\u8c03\u6574\u5927\u5c0f\u6216\u8005\u4ea4\u6362\u94fe\u9700\u8981\u91cd\u65b0\u5206\u914d\u66f4\u5927\u7684\u56fe\u50cf\u961f\u5217\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4ea4\u6362\u94fe\u5b9e\u9645\u4e0a\u9700\u8981\u91cd\u65b0\u5206\u914d\u521b\u5efa\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u6b64\u5b57\u6bb5\u4e2d\u6307\u5b9a\u5bf9\u65e7\u7684\u5f15\u7528\uff0c\u7528\u4ee5\u56de\u6536\u8d44\u6e90\u3002\u8fd9\u662f\u4e00\u4e2a\u6bd4\u8f83\u590d\u6742\u7684\u8bdd\u9898\uff0c\u6211\u4eec\u4f1a\u5728\u540e\u9762\u7684\u7ae0\u8282\u4e2d\u8be6\u7ec6\u4ecb\u7ecd\u3002\u73b0\u5728\u5047\u8bbe\u6211\u4eec\u53ea\u4f1a\u521b\u5efa\u4e00\u4e2a\u4ea4\u6362\u94fe\u3002 \u73b0\u5728\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u53d8\u91cf\u5b58\u50a8 VkSwapchainKHR \u5bf9\u8c61: VkSwapchainKHR swapChain; C++ \u521b\u5efa\u4ea4\u6362\u94fe\u53ea\u9700\u8981\u7b80\u5355\u7684\u8c03\u7528\u51fd\u6570: vkCreateSwapchainKHR : if (vkCreateSwapchainKHR(device, &createInfo, nullptr, &swapChain) != VK_SUCCESS) { throw std::runtime_error(\"failed to create swap chain!\"); } C++ \u53c2\u6570\u662f\u903b\u8f91\u8bbe\u5907\uff0c\u4ea4\u6362\u94fe\u521b\u5efa\u7684\u4fe1\u606f\uff0c\u53ef\u9009\u62e9\u7684\u5206\u914d\u5668\u548c\u4e00\u4e2a\u5b58\u50a8\u4ea4\u6362\u540e\u7684\u53e5\u67c4\u6307\u9488\u3002\u5b83\u4e5f\u9700\u8981\u5728\u8bbe\u5907\u88ab\u6e05\u7406\u524d\uff0c\u8fdb\u884c\u9500\u6bc1\u64cd\u4f5c\uff0c\u901a\u8fc7\u8c03\u7528 vkDestroySwapchainKHR \u3002 void cleanup() { vkDestroySwapchainKHR(device, swapChain, nullptr); ... } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\u786e\u4fdd\u4ea4\u6362\u94fe\u521b\u5efa\u6210\u529f\uff01 \u5c1d\u8bd5\u79fb\u9664 createInfo.imageExtent = extent; \u5e76\u5728validation layers\u5f00\u542f\u7684\u6761\u4ef6\u4e0b\uff0cvalidation layers\u4f1a\u7acb\u523b\u6355\u83b7\u5230\u6709\u5e2e\u52a9\u7684\u5f02\u5e38\u4fe1\u606f: \u83b7\u53d6\u4ea4\u6362\u94fe\u56fe\u50cf \u4ea4\u6362\u94fe\u521b\u5efa\u540e\uff0c\u9700\u8981\u83b7\u53d6 VkImage \u76f8\u5173\u7684\u53e5\u67c4\u3002\u5b83\u4f1a\u5728\u540e\u7eed\u6e32\u67d3\u7684\u7ae0\u8282\u4e2d\u5f15\u7528\u3002\u6dfb\u52a0\u7c7b\u6210\u5458\u53d8\u91cf\u5b58\u50a8\u8be5\u53e5\u67c4: std::vector<VkImage> swapChainImages; C++ \u56fe\u50cf\u88ab\u4ea4\u6362\u94fe\u521b\u5efa\uff0c\u4e5f\u4f1a\u5728\u4ea4\u6362\u94fe\u9500\u6bc1\u7684\u540c\u65f6\u81ea\u52a8\u6e05\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u6dfb\u52a0\u4efb\u4f55\u6e05\u7406\u4ee3\u7801\u3002 \u6211\u4eec\u5728 createSwapChain \u51fd\u6570\u4e0b\u9762\u6dfb\u52a0\u4ee3\u7801\u83b7\u53d6\u53e5\u67c4\uff0c\u5728 vkCreateSwapchainKHR \u540e\u8c03\u7528\u3002\u83b7\u53d6\u53e5\u67c4\u7684\u64cd\u4f5c\u540c\u4e4b\u524d\u83b7\u53d6\u6570\u7ec4\u96c6\u5408\u7684\u64cd\u4f5c\u975e\u5e38\u7c7b\u4f3c\u3002\u9996\u5148\u901a\u8fc7\u8c03\u7528 vkGetSwapchainImagesKHR \u83b7\u53d6\u4ea4\u6362\u94fe\u4e2d\u56fe\u50cf\u7684\u6570\u91cf\uff0c\u5e76\u6839\u636e\u6570\u91cf\u8bbe\u7f6e\u5408\u9002\u7684\u5bb9\u5668\u5927\u5c0f\u4fdd\u5b58\u83b7\u53d6\u5230\u7684\u53e5\u67c4\u96c6\u5408\u3002 vkGetSwapchainImagesKHR(device, swapChain, &imageCount, nullptr); swapChainImages.resize(imageCount); vkGetSwapchainImagesKHR(device, swapChain, &imageCount, swapChainImages.data()); C++ \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e4b\u524d\u521b\u5efa\u4ea4\u6362\u94fe\u6b65\u9aa4\u4e2d\u6211\u4eec\u4f20\u9012\u4e86\u671f\u671b\u7684\u56fe\u50cf\u5927\u5c0f\u5230\u5b57\u6bb5 minImageCount \u3002\u800c\u5b9e\u9645\u7684\u8fd0\u884c\uff0c\u5141\u8bb8\u6211\u4eec\u521b\u5efa\u66f4\u591a\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u9700\u8981\u518d\u4e00\u6b21\u83b7\u53d6\u6570\u91cf\u3002 \u6700\u540e\uff0c\u5b58\u50a8\u4ea4\u6362\u94fe\u683c\u5f0f\u548c\u8303\u56f4\u5230\u6210\u5458\u53d8\u91cf\u4e2d\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7ae0\u8282\u4f7f\u7528\u3002 VkSwapchainKHR swapChain; std::vector<VkImage> swapChainImages; VkFormat swapChainImageFormat; VkExtent2D swapChainExtent; ... swapChainImageFormat = surfaceFormat.format; swapChainExtent = extent; C++ \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u56fe\u50cf\uff0c\u8fd9\u4e9b\u56fe\u50cf\u53ef\u4ee5\u88ab\u7ed8\u5236\uff0c\u5e76\u5448\u73b0\u5230\u7a97\u4f53\u3002 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u5f00\u59cb\u8ba8\u8bba\u5982\u4f55\u4e3a\u56fe\u50cf\u8bbe\u7f6e\u6e32\u67d3\u76ee\u6807\uff0c\u5e76\u4e86\u89e3\u5b9e\u9645\u7684\u56fe\u50cf\u7ba1\u7ebf\u548c\u7ed8\u5236\u547d\u4ee4\u3002 Vulkan Window Surface Vulkan Window Surface \uff0c\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u4e86\u89e3\u5230 Vulkan \u662f\u4e00\u4e2a\u4e0e\u5e73\u53f0\u7279\u6027\u65e0\u5173\u8054\u7684 API \u96c6\u5408\u3002\u5b83\u4e0d\u80fd\u76f4\u63a5\u4e0e\u7a97\u53e3\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002\u4e3a\u4e86\u5c06\u6e32\u67d3\u7ed3\u679c\u5448\u73b0\u5230\u5c4f\u5e55\uff0c\u9700\u8981\u5efa\u7acb Vulkan \u4e0e\u7a97\u4f53\u7cfb\u7edf\u4e4b\u95f4\u7684\u8fde\u63a5\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 WSI (\u7a97\u4f53\u7cfb\u7edf\u96c6\u6210)\u6269\u5c55\u3002\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u8ba8\u8bba\u7b2c\u4e00\u4e2a\uff0c\u5373 VK_KHR_surface \u3002\u5b83\u66b4\u9732\u4e86 VkSurfaceKHR \uff0c\u5b83\u4ee3\u8868 surface \u7684\u4e00\u4e2a\u62bd\u8c61\u7c7b\u578b\uff0c\u7528\u4ee5\u5448\u73b0\u6e32\u67d3\u56fe\u50cf\u4f7f\u7528\u3002\u6211\u4eec\u7a0b\u5e8f\u4e2d\u5c06\u8981\u4f7f\u7528\u5230\u7684 surface \u662f\u7531\u6211\u4eec\u5df2\u7ecf\u5f15\u5165\u7684 GLFW \u6269\u5c55\u53ca\u5176\u6253\u5f00\u7684\u76f8\u5173\u7a97\u4f53\u652f\u6301\u7684\u3002\u7b80\u5355\u6765\u8bf4surface\u5c31\u662fVulkan\u4e0e\u7a97\u4f53\u7cfb\u7edf\u7684\u8fde\u63a5\u6865\u6881\u3002 VK_KHR_surface \u6269\u5c55\u662f\u4e00\u4e2ainstance\u7ea7\u6269\u5c55\uff0c\u6211\u4eec\u76ee\u524d\u4e3a\u6b62\u5df2\u7ecf\u542f\u7528\u8fc7\u5b83\uff0c\u5b83\u5305\u542b\u5728 glfwGetRequiredInstanceExtensions \u8fd4\u56de\u7684\u5217\u8868\u4e2d\u3002\u8be5\u5217\u8868\u8fd8\u5305\u62ec\u5c06\u5728\u63a5\u4e0b\u6765\u51e0\u5c0f\u8282\u4e2d\u4f7f\u7528\u7684\u4e00\u4e9b\u5176\u4ed6WSI\u6269\u5c55\u3002 \u9700\u8981\u5728 instance \u521b\u5efa\u4e4b\u540e\u7acb\u5373\u521b\u5efa\u7a97\u4f53 surface \uff0c\u56e0\u4e3a\u5b83\u4f1a\u5f71\u54cd\u7269\u7406\u8bbe\u5907\u7684\u9009\u62e9\u3002\u4e4b\u6240\u4ee5\u5728\u672c\u5c0f\u8282\u5c06 surface \u521b\u5efa\u903b\u8f91\u7eb3\u5165\u8ba8\u8bba\u8303\u56f4\uff0c\u662f\u56e0\u4e3a\u7a97\u4f53 surface \u5bf9\u4e8e\u6e32\u67d3\u3001\u5448\u73b0\u65b9\u5f0f\u662f\u4e00\u4e2a\u6bd4\u8f83\u5927\u7684\u8bfe\u9898\uff0c\u5982\u679c\u8fc7\u65e9\u7684\u5728\u521b\u5efa\u7269\u7406\u8bbe\u5907\u52a0\u5165\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u4f1a\u6df7\u6dc6\u57fa\u672c\u7684\u7269\u7406\u8bbe\u5907\u8bbe\u7f6e\u5de5\u4f5c\u3002\u53e6\u5916\u7a97\u4f53 surface \u672c\u8eab\u5bf9\u4e8e Vulkan \u4e5f\u662f\u975e\u5f3a\u5236\u7684\u3002 Vulkan \u5141\u8bb8\u8fd9\u6837\u505a\uff0c\u4e0d\u9700\u8981\u540c OpenGL \u4e00\u6837\u5fc5\u987b\u8981\u521b\u5efa\u7a97\u4f53 surface \u3002 \u6587\u7ae0\u76ee\u5f55 1 \u521b\u5efa Window Surface 2 \u67e5\u8be2\u6f14\u793a\u652f\u6301 3 \u521b\u5efa\u6f14\u793a\u961f\u5217 \u521b\u5efa Window Surface \u73b0\u5728\u5f00\u59cb\u7740\u624b\u521b\u5efa\u7a97\u4f53 surface \uff0c\u5728\u7c7b\u6210\u5458 debugCallback \u4e0b\u52a0\u5165\u6210\u5458\u53d8\u91cf surface \u3002 VkSurfaceKHR surface; C++ \u867d\u7136 VkSurfaceKHR \u5bf9\u8c61\u53ca\u5176\u7528\u6cd5\u4e0e\u5e73\u53f0\u65e0\u5173\u8054\uff0c\u4f46\u521b\u5efa\u8fc7\u7a0b\u9700\u8981\u4f9d\u8d56\u5177\u4f53\u7684\u7a97\u4f53\u7cfb\u7edf\u7684\u7ec6\u8282\u3002\u6bd4\u5982\uff0c\u5728 Windows \u5e73\u53f0\u4e2d\uff0c\u5b83\u9700\u8981 WIndows \u4e0a\u7684 HWND \u548c HMODULE \u53e5\u67c4\u3002\u56e0\u6b64\u9488\u5bf9\u7279\u5b9a\u5e73\u53f0\u63d0\u4f9b\u76f8\u5e94\u7684\u6269\u5c55\uff0c\u5728 Windows \u4e0a\u4e3a VK_KHR_win32_surface \uff0c\u5b83\u81ea\u52a8\u5305\u542b\u5728 glfwGetRequiredInstanceExtensions \u5217\u8868\u4e2d\u3002 \u6211\u4eec\u5c06\u4f1a\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u7279\u5b9a\u5e73\u53f0\u7684\u6269\u5c55\u6765\u521b\u5efa Windows \u4e0a\u7684 surface \u6865\uff0c\u4f46\u662f\u4e0d\u4f1a\u5728\u6559\u7a0b\u4e2d\u5b9e\u9645\u4f7f\u7528\u5b83\u3002\u4f7f\u7528GLFW\u8fd9\u6837\u7684\u5e93\u907f\u514d\u4e86\u7f16\u5199\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u7684\u8de8\u5e73\u53f0\u76f8\u5173\u4ee3\u7801\u3002 GLFW \u5b9e\u9645\u4e0a\u901a\u8fc7 glfwCreateWindowSurface \u5f88\u597d\u7684\u5904\u7406\u4e86\u5e73\u53f0\u5dee\u5f02\u6027\u3002\u5f53\u7136\u4e86\uff0c\u6bd4\u8f83\u7406\u60f3\u662f\u5728\u4f9d\u8d56\u5b83\u4eec\u5e2e\u52a9\u6211\u4eec\u5b8c\u6210\u5177\u4f53\u5de5\u4f5c\u4e4b\u524d\uff0c\u4e86\u89e3\u4e00\u4e0b\u80cc\u540e\u7684\u5b9e\u73b0\u662f\u6709\u5e2e\u52a9\u7684\u3002 \u56e0\u4e3a\u4e00\u4e2a\u7a97\u4f53 surface \u662f\u4e00\u4e2a Vulkan \u5bf9\u8c61\uff0c\u5b83\u9700\u8981\u586b\u5145 VkWin32SurfaceCreateInfoKHR \u7ed3\u6784\u4f53\uff0c\u8fd9\u91cc\u6709\u4e24\u4e2a\u6bd4\u8f83\u91cd\u8981\u7684\u53c2\u6570: hwnd \u548c hinstance \u3002\u5982\u679c\u719f\u6089 windows \u4e0b\u5f00\u53d1\u5e94\u8be5\u77e5\u9053\uff0c\u8fd9\u4e9b\u662f\u7a97\u53e3\u548c\u8fdb\u7a0b\u7684\u53e5\u67c4\u3002 VkWin32SurfaceCreateInfoKHR createInfo; createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR; createInfo.hwnd = glfwGetWin32Window(window); createInfo.hinstance = GetModuleHandle(nullptr); C++ glfwGetWin32Window \u51fd\u6570\u7528\u4e8e\u4eceGLFW\u7a97\u4f53\u5bf9\u8c61\u83b7\u53d6\u539f\u59cb\u7684 HWND \u3002 GetModuleHandle \u51fd\u6570\u8fd4\u56de\u5f53\u524d\u8fdb\u7a0b\u7684 HINSTANCE \u53e5\u67c4\u3002 \u586b\u5145\u5b8c\u7ed3\u6784\u4f53\u4e4b\u540e\uff0c\u53ef\u4ee5\u5229\u7528 vkCreateWin32SurfaceKHR \u521b\u5efasurface\u6865\uff0c\u548c\u4e4b\u524d\u83b7\u53d6\u521b\u5efa\u3001\u9500\u6bc1 DebugReportCallEXT \u4e00\u6837\uff0c\u8fd9\u91cc\u540c\u6837\u9700\u8981\u901a\u8fc7 instance \u83b7\u53d6\u521b\u5efa surface \u7528\u5230\u7684\u51fd\u6570\u3002\u8fd9\u91cc\u6d89\u53ca\u5230\u7684\u53c2\u6570\u5206\u522b\u4e3a instance , surface \u521b\u5efa\u7684\u4fe1\u606f\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u6700\u7ec8\u4fdd\u5b58 surface \u7684\u53e5\u67c4\u53d8\u91cf\u3002 auto CreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) vkGetInstanceProcAddr(instance, \"vkCreateWin32SurfaceKHR\"); if (!CreateWin32SurfaceKHR || CreateWin32SurfaceKHR(instance, &createInfo, nullptr, &surface) != VK_SUCCESS) { throw std::runtime_error(\"failed to create window surface!\"); } C++ \u8be5\u8fc7\u7a0b\u4e0e\u5176\u4ed6\u5e73\u53f0\u7c7b\u4f3c\uff0c\u6bd4\u5982 Linux \uff0c\u4f7f\u7528X11\u754c\u9762\u7a97\u4f53\u7cfb\u7edf\uff0c\u53ef\u4ee5\u901a\u8fc7 vkCreateXcbSurfaceKHR \u51fd\u6570\u5efa\u7acb\u8fde\u63a5\u3002 glfwCreateWindowSurface \u51fd\u6570\u6839\u636e\u4e0d\u540c\u5e73\u53f0\u7684\u5dee\u5f02\u6027\uff0c\u5728\u5b9e\u73b0\u7ec6\u8282\u4e0a\u4f1a\u6709\u6240\u4e0d\u540c\u3002\u6211\u4eec\u73b0\u5728\u5c06\u5176\u6574\u5408\u5230\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\u3002\u4ece initVulkan \u4e2d\u6dfb\u52a0\u4e00\u4e2a\u51fd\u6570 createSurface ,\u5b89\u6392\u5728 createInstnace \u548c setupDebugCallback \u51fd\u6570\u4e4b\u540e\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); } void createSurface() { } C++ GLFW \u6ca1\u6709\u4f7f\u7528\u7ed3\u6784\u4f53\uff0c\u800c\u662f\u9009\u62e9\u975e\u5e38\u76f4\u63a5\u7684\u53c2\u6570\u4f20\u9012\u6765\u8c03\u7528\u51fd\u6570\u3002 void createSurface() { if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) { throw std::runtime_error(\"failed to create window surface!\"); } } C++ \u53c2\u6570\u662f VkInstance , GLFW \u7a97\u4f53\u7684\u6307\u9488\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u7528\u4e8e\u5b58\u50a8 VkSurfaceKHR \u53d8\u91cf\u7684\u6307\u9488\u3002\u5bf9\u4e8e\u4e0d\u540c\u5e73\u53f0\u7edf\u4e00\u8fd4\u56de VkResult \u3002 GLFW \u6ca1\u6709\u63d0\u4f9b\u4e13\u7528\u7684\u51fd\u6570\u9500\u6bc1 surface ,\u4f46\u662f\u53ef\u4ee5\u7b80\u5355\u7684\u901a\u8fc7 Vulkan \u539f\u59cb\u7684 API \u5b8c\u6210: void cleanup() { ... vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); ... } C++ \u6700\u540e\u8bf7\u786e\u4fddsurface\u7684\u6e05\u7406\u662f\u5728instance\u9500\u6bc1\u4e4b\u524d\u5b8c\u6210\u3002 \u67e5\u8be2\u6f14\u793a\u652f\u6301 \u867d\u7136 Vulkan \u7684\u5b9e\u73b0\u652f\u6301\u7a97\u4f53\u96c6\u6210\u529f\u80fd\uff0c\u4f46\u662f\u5e76\u4e0d\u610f\u5473\u7740\u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u90fd\u652f\u6301\u5b83\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u6269\u5c55 isDeviceSuitable \u51fd\u6570\uff0c\u786e\u4fdd\u8bbe\u5907\u53ef\u4ee5\u5c06\u56fe\u50cf\u5448\u73b0\u5230\u6211\u4eec\u521b\u5efa\u7684 surface \u3002\u7531\u4e8e presentation \u662f\u4e00\u4e2a\u961f\u5217\u7684\u7279\u6027\u529f\u80fd\uff0c\u56e0\u6b64\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6cd5\u5c31\u662f\u627e\u5230\u652f\u6301 presentation \u7684\u961f\u5217\u7c07\uff0c\u6700\u7ec8\u83b7\u53d6\u961f\u5217\u6ee1\u8db3 surface \u521b\u5efa\u7684\u9700\u8981\u3002 \u5b9e\u9645\u60c5\u51b5\u662f\uff0c\u652f\u6301 graphics \u547d\u4ee4\u7684\u7684\u961f\u5217\u7c07\u548c\u652f\u6301 presentation \u547d\u4ee4\u7684\u961f\u5217\u7c07\u53ef\u80fd\u4e0d\u662f\u540c\u4e00\u4e2a\u7c07\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u4fee\u6539 QueueFamilyIndices \u7ed3\u6784\u4f53\uff0c\u4ee5\u652f\u6301\u5dee\u5f02\u5316\u7684\u5b58\u50a8\u3002 struct QueueFamilyIndices { int graphicsFamily = -1; int presentFamily = -1; bool isComplete() { return graphicsFamily >= 0 && presentFamily >= 0; } }; C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4fee\u6539 findQueueFamilies \u51fd\u6570\u6765\u67e5\u627e\u5177\u5907 presentation \u529f\u80fd\u7684\u961f\u5217\u7c07\u3002\u51fd\u6570\u4e2d\u7528\u4e8e\u68c0\u67e5\u7684\u6838\u5fc3\u4ee3\u7801\u662f vkGetPhysicalDeviceSurfaceSupportKHR ,\u5b83\u5c06\u7269\u7406\u8bbe\u5907\u3001\u961f\u5217\u7c07\u7d22\u5f15\u548c surface \u4f5c\u4e3a\u53c2\u6570\u3002\u5728 VK_QUEUE_GRAPHICS_BIT \u76f8\u540c\u7684\u5faa\u73af\u4f53\u4e2d\u6dfb\u52a0\u51fd\u6570\u7684\u8c03\u7528: VkBool32 presentSupport = false; vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport); C++ \u7136\u540e\u4e4b\u9700\u8981\u68c0\u67e5\u5e03\u5c14\u503c\u5e76\u5b58\u50a8 presentation \u961f\u5217\u7c07\u7684\u7d22\u5f15: if (queueFamily.queueCount > 0 && presentSupport) { indices.presentFamily = i; } C++ \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e3a\u4e86\u652f\u6301 graphics \u548c presentation \u529f\u80fd\uff0c\u6211\u4eec\u5b9e\u9645\u73af\u5883\u4e2d\u5f97\u5230\u7684\u53ef\u80fd\u662f\u540c\u4e00\u4e2a\u961f\u5217\u7c07\uff0c\u4e5f\u53ef\u80fd\u4e0d\u540c\uff0c\u4e3a\u6b64\u5728\u6211\u4eec\u7684\u7a0b\u5e8f\u6570\u636e\u7ed3\u6784\u53ca\u9009\u62e9\u903b\u8f91\u4e2d\uff0c\u5c06\u6309\u7167\u5747\u6765\u81ea\u4e0d\u540c\u7684\u961f\u5217\u7c07\u5206\u522b\u5904\u7406\uff0c\u8fd9\u6837\u4fbf\u53ef\u4ee5\u7edf\u4e00\u5904\u7406\u4ee5\u4e0a\u4e24\u79cd\u60c5\u51b5\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u51fa\u4e8e\u6027\u80fd\u7684\u8003\u8651\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u903b\u8f91\u660e\u786e\u7684\u6307\u5b9a\u7269\u7406\u8bbe\u5907\u6240\u4f7f\u7528\u7684 graphics \u548c presentation \u529f\u80fd\u6765\u81ea\u540c\u4e00\u4e2a\u961f\u5217\u7c07\u3002 \u521b\u5efa\u6f14\u793a\u961f\u5217 \u5269\u4e0b\u7684\u4e8b\u60c5\u662f\u4fee\u6539\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u8fc7\u7a0b\uff0c\u5728\u4e8e\u521b\u5efa presentation \u961f\u5217\u5e76\u83b7\u53d6 VkQueue \u7684\u53e5\u67c4\u3002\u6dfb\u52a0\u4fdd\u5b58\u961f\u5217\u53e5\u67c4\u7684\u6210\u5458\u53d8\u91cf: VkQueue presentQueue; C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u591a\u4e2a VkDeviceQueueCreateInfo \u7ed3\u6784\u6765\u521b\u5efa\u4e0d\u540c\u529f\u80fd\u7684\u961f\u5217\u3002\u4e00\u4e2a\u4f18\u96c5\u7684\u65b9\u5f0f\u662f\u9488\u5bf9\u4e0d\u540c\u529f\u80fd\u7684\u961f\u5217\u7c07\u521b\u5efa\u4e00\u4e2aset\u96c6\u5408\u786e\u4fdd\u961f\u5217\u7c07\u7684\u552f\u4e00\u6027: #include <set> ... QueueFamilyIndices indices = findQueueFamilies(physicalDevice); std::vector<VkDeviceQueueCreateInfo> queueCreateInfos; std::set<int> uniqueQueueFamilies = {indices.graphicsFamily, indices.presentFamily}; float queuePriority = 1.0f; for (int queueFamily : uniqueQueueFamilies) { VkDeviceQueueCreateInfo queueCreateInfo = {}; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = queueFamily; queueCreateInfo.queueCount = 1; queueCreateInfo.pQueuePriorities = &queuePriority; queueCreateInfos.push_back(queueCreateInfo); } C++ \u540c\u65f6\u8fd8\u8981\u4fee\u6539 VkDeviceCreateInfo \u6307\u5411\u961f\u5217\u96c6\u5408: createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size()); createInfo.pQueueCreateInfos = queueCreateInfos.data(); C++ \u5982\u679c\u961f\u5217\u7c07\u76f8\u540c\uff0c\u90a3\u4e48\u6211\u4eec\u4e4b\u9700\u8981\u4f20\u9012\u4e00\u6b21\u7d22\u5f15\u3002\u6700\u540e\uff0c\u6dfb\u52a0\u4e00\u4e2a\u8c03\u7528\u68c0\u7d22\u961f\u5217\u53e5\u67c4: vkGetDeviceQueue(device, indices.presentFamily, 0, &presentQueue); C++ \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u961f\u5217\u7c07\u662f\u76f8\u540c\u7684\uff0c\u4e24\u4e2a\u53e5\u67c4\u53ef\u80fd\u4f1a\u6709\u76f8\u540c\u7684\u503c\u3002\u5728 \u4e0b\u4e00\u4e2a\u7ae0\u8282 \u4e2d\u6211\u4eec\u4f1a\u770b\u770b\u4ea4\u6362\u94fe\uff0c\u4ee5\u53ca\u5b83\u4eec\u5982\u4f55\u4f7f\u6211\u4eec\u80fd\u591f\u5c06\u56fe\u50cf\u5448\u73b0\u7ed9 surface \u3002 Vulkan \u56fe\u5f62\u7ba1\u7ebf Vulkan \u56fe\u5f62\u7ba1\u7ebf \uff0c\u901a\u8fc7\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\uff0c\u6211\u4eec\u5c06\u4f1a\u5f00\u542f\u6709\u5173\u56fe\u5f62\u7ba1\u7ebf\u7684\u8bdd\u9898\uff0c\u901a\u8fc7\u5bf9\u56fe\u5f62\u6e32\u67d3\u7ba1\u7ebf\u7684\u914d\u7f6e\u5b8c\u6210\u6700\u540e\u7684\u4e09\u89d2\u5f62\u7ed8\u753b\u3002\u6240\u8c13\u56fe\u5f62\u7ba1\u7ebf\u5c31\u662f\u5c06 mesh \u4f7f\u7528\u5230\u7684 vertices \u5b9a\u70b9\u6570\u636e\u548c\u8d34\u56fe\u6570\u636e\uff0c\u8f6c\u5316\u4e3a\u6e32\u67d3 targets \u50cf\u7d20\u7684\u64cd\u4f5c\u5e8f\u5217\u3002\u7b80\u8981\u7684\u6982\u8ff0\u5982\u4e0b\u56fe\u6240\u793a: Input assembler \u6536\u96c6\u6700\u539f\u59cb\u7684\u9876\u70b9\u6570\u636e\uff0c\u5e76\u4e14\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7d22\u5f15\u7f13\u51b2\u533a\u590d\u7528\u8fd9\u4e9b\u6570\u636e\u5143\u7d20\uff0c\u800c\u4e0d\u5fc5\u590d\u5236\u5197\u4f59\u7684\u9876\u70b9\u6570\u636e\u526f\u672c\u3002 vertex shader \u4f1a\u5e94\u7528\u5728\u6bcf\u4e00\u4e2a\u9876\u70b9\u6570\u636e\uff0c\u901a\u5e38\u5e94\u7528\u53d8\u6362\u64cd\u4f5c\uff0c\u4ece\u800c\u5c06\u9876\u70b9\u7684\u4f4d\u7f6e\u5750\u6807\u6570\u636e\u4ece\u6a21\u578b\u7a7a\u95f4\u8f6c\u6362\u4e3a\u5c4f\u5e55\u7a7a\u95f4\u3002\u5728\u5904\u7406\u5b8c\u6bd5\u4e4b\u540e\u4f1a\u5c06\u6570\u636e\u7ee7\u7eed\u5728\u7ba1\u7ebf\u4f20\u9012\u4e0b\u53bb\u3002 tessellation shader \u66f2\u9762\u7740\u8272\u5668\u5141\u8bb8\u57fa\u4e8e\u67d0\u4e9b\u89c4\u5219\u8fdb\u4e00\u6b65\u7ec6\u5206\u51e0\u4f55\u6570\u636e\u589e\u52a0\u7f51\u683c\u7684\u8d28\u91cf\u3002\u7ecf\u5e38\u5e94\u7528\u4e0e\u5899\u9762\u548c\u697c\u68af\u8868\u9762\uff0c\u4f7f\u9644\u8fd1\u770b\u8d77\u6765\u4e0d\u662f\u90a3\u4e48\u5e73\u5766\u3002 geometry shader \u96c6\u5408\u7740\u8272\u5668\u5e94\u7528\u5728\u6bcf\u4e00\u4e2a\u56fe\u5143\u4e0a\uff0c\u53ef\u7528\u4e8e\u589e\u51cf\u56fe\u5143\uff0c\u5b83\u4e0e\u66f2\u9762\u7740\u8272\u5668\u7c7b\u4f3c\uff0c\u4f46\u66f4\u52a0\u7075\u6d3b\u3002\u7136\u800c\uff0c\u5b83\u5728\u4eca\u5929\u7684\u5e94\u7528\u4e2d\u5e76\u6ca1\u6709\u592a\u591a\u7684\u5e94\u7528\u60c5\u666f\uff0c\u56e0\u4e3a\u9664\u4e86 Intel \u7684\u96c6\u6210\u663e\u5361\u5916\uff0c\u5927\u591a\u6570\u663e\u5361\u6027\u80fd\u652f\u6301\u90fd\u4e0d\u7406\u60f3\u3002 \u5149\u6805\u5316\u9636\u6bb5\u5c06\u56fe\u5143\u5206\u89e3\u4e3a\u7247\u5143\u3002\u8fd9\u4e9b\u662f\u586b\u5145\u5728\u5e27\u7f13\u51b2\u533a\u4e0a\u7684\u50cf\u7d20\u5143\u7d20\u3002\u5c4f\u5e55\u5916\u533a\u57df\u7684\u7247\u5143\u4f1a\u88ab\u4e22\u5f03\uff0c\u9876\u70b9\u7740\u8272\u5668\u8f93\u51fa\u7684\u6570\u636e\u5728\u4f20\u9012\u5230\u7247\u5143\u7740\u8272\u5668\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u5982\u56fe\u6240\u793a\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u6839\u636e\u6df1\u5ea6\u6d4b\u8bd5\u7684\u7ed3\u679c\u4e5f\u4f1a\u5bf9\u7247\u5143\u8fdb\u884c\u4e22\u5f03\u3002 fragment shader \u5e94\u7528\u4e8e\u6bcf\u4e2a\u7247\u5143\uff0c\u786e\u5b9a\u6bcf\u4e2a\u5e27\u7f13\u51b2\u533a\u4e2d\u5199\u5165\u7684\u7247\u5143\u6570\u636e\u7684\u989c\u8272\u548c\u6df1\u5ea6\u503c\u3002\u7247\u5143\u7740\u8272\u5668\u53ef\u4ee5\u4f7f\u7528\u9876\u70b9\u7740\u8272\u5668\u7684\u63d2\u503c\u6570\u636e\uff0c\u8d34\u56fe\u7684UV\u5750\u6807\u548c\u5149\u6e90\u6cd5\u7ebf\u6570\u636e\u3002 \u6df7\u8272\u64cd\u4f5c\u9636\u6bb5\u4f1a\u5bf9\u4e0d\u540c\u7247\u5143\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\uff0c\u6700\u7ec8\u6620\u5c04\u5230\u5e27\u7f13\u51b2\u533a\u7684\u540c\u4e00\u4e2a\u50cf\u7d20\u4e0a\u3002\u7247\u5143\u4e5f\u53ef\u4ee5\u7b80\u5355\u7684\u4e92\u76f8\u91cd\u5199\uff0c\u53e0\u52a0\u6216\u8005\u6839\u636e\u900f\u660e\u5ea6\u6df7\u5408\u3002 \u7eff\u8272\u7684\u9636\u6bb5\u88ab\u79f0\u4e3a\u56fa\u5b9a\u6d41\u6c34\u7ebf\u3002\u8fd9\u4e2a\u9636\u6bb5\u5141\u8bb8\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684\u53c2\u6570\u6570\u503c\uff0c\u4f46\u662f\u5b83\u5185\u90e8\u7684\u5de5\u4f5c\u903b\u8f91\u662f\u9884\u5236\u597d\u7684\u3002 \u6a59\u8272\u7684\u9636\u6bb5\u88ab\u79f0\u4e3a\u53ef\u7f16\u7a0b\u9636\u6bb5 programmable \uff0c\u6211\u4eec\u53ef\u4ee5\u5411GPU\u63d0\u4ea4\u81ea\u5df1\u7f16\u5199\u7684\u4ee3\u7801\u6267\u884c\u5177\u4f53\u7684\u903b\u8f91\u3002\u6bd4\u5982\u5728\u4f7f\u7528 fragment shader \u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u5b9e\u73b0\u4efb\u4f55\u4ece\u8d34\u56fe\u5230\u706f\u5149\u7684\u5149\u7ebf\u8ffd\u8e2a\u3002\u8fd9\u4e9b\u7a0b\u5e8f\u540c\u65f6\u8fd0\u884c\u5728\u591a\u6838GPU\u4e0a\u5904\u7406\u8bb8\u591a\u5bf9\u8c61\uff0c\u6bd4\u5982\u5e76\u884c\u7684\u9876\u70b9\u548c\u7247\u6bb5\u7a0b\u5e8f\u3002 \u5982\u679c\u4e4b\u524d\u4f7f\u7528\u8fc7\u65e7\u7684API( OpenGL \u548c Direct3D ),\u90a3\u4e48\u5c06\u53ef\u4ee5\u968f\u610f\u901a\u8fc7 glBlendFunc \u548c OMSetBlendState \u8c03\u7528\u66f4\u6539\u7ba1\u7ebf\u8bbe\u7f6e\u3002 Vulkan\u4e2d \u7684\u56fe\u5f62\u7ba1\u7ebf\u51e0\u4e4e\u4e0d\u53ef\u6539\u53d8\uff0c\u56e0\u6b64\u5982\u679c\u9700\u8981\u66f4\u6539\u7740\u8272\u5668\uff0c\u7ed1\u5b9a\u5230\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u533a\u6216\u8005\u66f4\u6539\u6df7\u5408\u51fd\u6570\uff0c\u5219\u5fc5\u987b\u4ece\u5934\u521b\u5efa\u7ba1\u7ebf\u3002\u7f3a\u70b9\u662f\u5fc5\u987b\u521b\u5efa\u4e00\u4e9b\u7ba1\u7ebf\uff0c\u8fd9\u4e9b\u7ba1\u7ebf\u4ee3\u8868\u5728\u6e32\u67d3\u64cd\u4f5c\u4e2d\u4f7f\u7528\u7684\u4e0d\u540c\u7684\u7ec4\u5408\u72b6\u6001\u3002\u4f46\u662f\u7531\u4e8e\u6240\u6709\u7ba1\u7ebf\u7684\u64cd\u4f5c\u90fd\u662f\u63d0\u524d\u77e5\u9053\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7\u9a71\u52a8\u7a0b\u5e8f\u66f4\u597d\u7684\u4f18\u5316\u5b83\u3002 \u4e00\u4e9b\u53ef\u7f16\u7a0b\u9636\u6bb5\u662f\u57fa\u4e8e\u6253\u7b97\u505a\u4ec0\u4e48\u800c\u51b3\u5b9a\u7684\u3002\u6bd4\u5982\uff0c\u5982\u679c\u53ea\u662f\u7b80\u5355\u7684\u7ed8\u5236\u51e0\u4f55\u56fe\u5f62\uff0c\u5219\u53ef\u4ee5\u7981\u7528 tessellation \u548c geometry \u7740\u8272\u5668\u3002\u5982\u679c\u53ea\u5bf9\u6df1\u5ea6\u503c\u611f\u5174\u8da3\uff0c\u5219\u53ef\u4ee5\u7981\u7528 fragment \u7740\u8272\u5668\uff0c\u8fd9\u5bf9\u4e8e\u751f\u6210 shadow map \u751f\u6210\u5f88\u6709\u7528\u3002 \u5728\u4e0b\u4e00\u4e2a\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u9996\u5148\u521b\u5efa\u5c06\u4e09\u89d2\u5f62\u653e\u5728\u5c4f\u5e55\u4e0a\u6240\u9700\u8981\u7684\u4e24\u4e2a\u53ef\u7f16\u7a0b\u9636\u6bb5: vertice shader \u548c fragment shader \u3002\u56fa\u5b9a\u529f\u80fd\u7684\u8bbe\u7f6e\u5305\u62ec blending mode , viewport , rasterization \u5c06\u5728\u4e4b\u540e\u7684\u7ae0\u8282\u4e2d\u8bbe\u7f6e\u3002\u5728 Vulkan \u4e2d\u8bbe\u7f6e\u56fe\u5f62\u6d41\u6c34\u7ebf\u7684\u6700\u540e\u4e00\u90e8\u5206\u5185\u5bb9\u6d89\u53ca\u8f93\u5165\u548c\u8f93\u51fa\u5e27\u7f13\u51b2\u533a\u3002 \u5728 initVulkan \u4e2d\u521b\u5efa\u51fd\u6570 createGraphicsPipeline \u5e76\u5728 createImageViews \u540e\u7acb\u5373\u8c03\u7528\u3002\u6211\u4eec\u5728\u4e0b\u4e00\u7ae0\u8282\u4ecb\u7ecd\u51fd\u6570\u529f\u80fd\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createGraphicsPipeline(); } ... void createGraphicsPipeline() { } C++ \u5728\u7ed3\u5c3e\u5904\u5206\u4eab\u4e00\u4e0b Vulkan \u5b98\u65b9\u7684\u56fe\u5f62\u7ba1\u7ebf\u7ed3\u6784\u56fe\uff0c\u5982\u4e0b: Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe \uff0c\u4f7f\u7528\u4efb\u4f55\u7684 VkImage \uff0c\u5305\u62ec\u5728\u4ea4\u6362\u94fe\u6216\u8005\u6e32\u67d3\u7ba1\u7ebf\u4e2d\u7684\uff0c\u6211\u4eec\u90fd\u9700\u8981\u521b\u5efa VkImageView \u5bf9\u8c61\u3002\u4ece\u5b57\u9762\u4e0a\u7406\u89e3\u5b83\u5c31\u662f\u4e00\u4e2a\u9488\u5bf9\u56fe\u50cf\u7684\u89c6\u56fe\u6216\u5bb9\u5668\uff0c\u901a\u8fc7\u5b83\u5177\u4f53\u7684\u6e32\u67d3\u7ba1\u7ebf\u624d\u80fd\u591f\u8bfb\u5199\u6e32\u67d3\u6570\u636e\uff0c\u6362\u53e5\u8bdd\u8bf4 VkImage \u4e0d\u80fd\u4e0e\u6e32\u67d3\u7ba1\u7ebf\u8fdb\u884c\u4ea4\u4e92\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u56fe\u50cf\u89c6\u56fe\u53ef\u4ee5\u8fdb\u4e00\u6b65\u5b9a\u4e49\u5177\u4f53 Image \u7684\u683c\u5f0f\uff0c\u6bd4\u5982\u5b9a\u4e49\u4e3a2D\u8d34\u56fe\uff0c\u90a3\u4e48\u672c\u8d28\u4e0a\u5c31\u4e0d\u9700\u8981\u4efb\u4f55\u7ea7\u522b\u7684 mipmapping \u3002 \u5728\u672c\u7ae0\u8282\u6211\u4eec\u4f1a\u65b0\u589e\u4e00\u4e2a createImageViews \u51fd\u6570\uff0c\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u521b\u5efa\u57fa\u672c\u7684\u89c6\u56fe\uff0c\u8fd9\u4e9b\u89c6\u56fe\u5728\u540e\u9762\u7684\u5185\u5bb9\u4e2d\u4f1a\u88ab\u4f5c\u4e3a\u989c\u8272\u76ee\u6807\u4e0e\u6e32\u67d3\u7ba1\u7ebf\u914d\u5408\u4f7f\u7528\u3002 \u9996\u5148\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u7528\u4e8e\u4fdd\u5b58\u56fe\u50cf\u89c6\u56fe\u7684\u53e5\u67c4\u96c6: std::vector<VkImageView> swapChainImageViews; C++ \u521b\u5efa createImagesViews \u51fd\u6570\uff0c\u5e76\u5728\u521b\u5efa\u4ea4\u6362\u94fe\u5b8c\u6210\u4e4b\u540e\u8c03\u7528: void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); } void createImageViews() { } C++ \u6211\u4eec\u9700\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u9700\u8981\u5b9a\u4e49\u4fdd\u5b58\u56fe\u50cf\u89c6\u56fe\u96c6\u5408\u7684\u5927\u5c0f: void createImageViews() { swapChainImageViews.resize(swapChainImages.size()); } C++ \u4e0b\u4e00\u6b65\uff0c\u5faa\u73af\u8fed\u4ee3\u6240\u6709\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u3002 for (size_t i = 0; i < swapChainImages.size(); i++) { } C++ \u521b\u5efa\u56fe\u50cf\u89c6\u56fe\u7684\u53c2\u6570\u88ab\u5b9a\u4e49\u5728 VkImageViewCreateInfo \u7ed3\u6784\u4f53\u4e2d\u3002\u524d\u51e0\u4e2a\u53c2\u6570\u7684\u586b\u5145\u975e\u5e38\u7b80\u5355\u3001\u76f4\u63a5\u3002 VkImageViewCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; createInfo.image = swapChainImages[i]; C++ \u5176\u4e2d viewType \u548c format \u5b57\u6bb5\u7528\u4e8e\u63cf\u8ff0\u56fe\u50cf\u6570\u636e\u8be5\u88ab\u5982\u4f55\u89e3\u91ca\u3002 viewType \u53c2\u6570\u5141\u8bb8\u5c06\u56fe\u50cf\u5b9a\u4e49\u4e3a 1D textures , 2D textures , 3D textures \u548c cube maps \u3002 createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; createInfo.format = swapChainImageFormat; C++ components \u5b57\u6bb5\u5141\u8bb8\u8c03\u6574\u989c\u8272\u901a\u9053\u7684\u6700\u7ec8\u7684\u6620\u5c04\u903b\u8f91\u3002\u6bd4\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6240\u6709\u989c\u8272\u901a\u9053\u6620\u5c04\u4e3a\u7ea2\u8272\u901a\u9053\uff0c\u4ee5\u5b9e\u73b0\u5355\u8272\u7eb9\u7406\u3002\u6211\u4eec\u4e5f\u53ef\u4ee5\u5c06\u901a\u9053\u6620\u5c04\u5177\u4f53\u7684\u5e38\u91cf\u6570\u503c 0 \u548c 1 \u3002\u5728\u7ae0\u8282\u4e2d\u6211\u4eec\u4f7f\u7528\u9ed8\u8ba4\u7684\u6620\u5c04\u7b56\u7565\u3002 createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY; C++ subresourceRangle \u5b57\u6bb5\u7528\u4e8e\u63cf\u8ff0\u56fe\u50cf\u7684\u4f7f\u7528\u76ee\u6807\u662f\u4ec0\u4e48\uff0c\u4ee5\u53ca\u53ef\u4ee5\u88ab\u8bbf\u95ee\u7684\u6709\u6548\u533a\u57df\u3002\u6211\u4eec\u7684\u56fe\u50cf\u5c06\u4f1a\u4f5c\u4e3a color targets \uff0c\u6ca1\u6709\u4efb\u4f55 mipmapping levels \u6216\u662f\u591a\u5c42 multiple layers \u3002 createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; createInfo.subresourceRange.baseMipLevel = 0; createInfo.subresourceRange.levelCount = 1; createInfo.subresourceRange.baseArrayLayer = 0; createInfo.subresourceRange.layerCount = 1; C++ \u5982\u679c\u5728\u7f16\u5199\u6c89\u6d78\u5f0f\u7684 3D \u5e94\u7528\u7a0b\u5e8f\uff0c\u6bd4\u5982 VR \uff0c\u5c31\u9700\u8981\u521b\u5efa\u652f\u6301\u591a\u5c42\u7684\u4ea4\u6362\u94fe\u3002\u5e76\u4e14\u901a\u8fc7\u4e0d\u540c\u7684\u5c42\u4e3a\u6bcf\u4e00\u4e2a\u56fe\u50cf\u521b\u5efa\u591a\u4e2a\u89c6\u56fe\uff0c\u4ee5\u6ee1\u8db3\u4e0d\u540c\u5c42\u7684\u56fe\u50cf\u5728\u5de6\u53f3\u773c\u6e32\u67d3\u65f6\u5bf9\u89c6\u56fe\u7684\u9700\u8981\u3002 \u521b\u5efa\u56fe\u50cf\u89c6\u56fe\u8c03\u7528 vkCreateImageView \u51fd\u6570: if (vkCreateImageView(device, &createInfo, nullptr, &swapChainImageViews[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to create image views!\"); } C++ \u4e0e\u56fe\u50cf\u4e0d\u540c\u7684\u662f\uff0c\u56fe\u50cf\u89c6\u56fe\u9700\u8981\u660e\u786e\u7684\u521b\u5efa\u8fc7\u7a0b\uff0c\u6240\u4ee5\u5728\u7a0b\u5e8f\u9000\u51fa\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a\u5faa\u73af\u53bb\u9500\u6bc1\u4ed6\u4eec\u3002 void cleanup() { for (size_t i = 0; i < swapChainImageViews.size(); i++) { vkDestroyImageView(device, swapChainImageViews[i], nullptr); } ... } C++ \u62e5\u6709\u4e86\u56fe\u50cf\u89c6\u56fe\u540e\uff0c\u4f7f\u7528\u56fe\u50cf\u4f5c\u4e3a\u8d34\u56fe\u5df2\u7ecf\u8db3\u591f\u4e86\uff0c\u4f46\u662f\u5b83\u8fd8\u6ca1\u6709\u51c6\u5907\u597d\u4f5c\u4e3a\u6e32\u67d3\u7684 target \u3002\u5b83\u9700\u8981\u66f4\u591a\u7684\u95f4\u63a5\u6b65\u9aa4\u53bb\u51c6\u5907\uff0c\u5176\u4e2d\u4e00\u4e2a\u5c31\u662f framebuffer \uff0c\u88ab\u79f0\u4f5c\u5e27\u7f13\u51b2\u533a\u3002\u4f46\u9996\u5148\u6211\u4eec\u8981\u8bbe\u7f6e\u56fe\u5f62\u7ba1\u7ebf\u3002 Vulkan \u7740\u8272\u5668\u6a21\u5757 Vulkan \u7740\u8272\u5668\u6a21\u5757 \uff0c\u4e0e\u4e4b\u524d\u7684\u56fe\u50cf API \u4e0d\u540c\uff0c Vulkan \u4e2d\u7684\u7740\u8272\u5668\u4ee3\u7801\u5fc5\u987b\u4ee5\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u7684\u683c\u5f0f\u4f7f\u7528\uff0c\u800c\u4e0d\u662f\u50cf GLSL \u548c HLSL \u8fd9\u6837\u5177\u6709\u6bd4\u8f83\u597d\u7684\u53ef\u8bfb\u6027\u7684\u8bed\u6cd5\u3002\u6b64\u5b57\u8282\u683c\u5f0f\u6210\u4e3a SPIR-V \uff0c\u5b83\u53ef\u4ee5\u4e0e Vulkan \u548c OpenCL \u4e00\u540c\u4f7f\u7528\u3002\u8fd9\u662f\u4e00\u79cd\u53ef\u4ee5\u7f16\u5199\u56fe\u5f62\u548c\u8ba1\u7b97\u7740\u8272\u5668\u7684\u683c\u5f0f\uff0c\u4f46\u6211\u4eec\u91cd\u70b9\u4ecb\u7ecd\u672c\u6559\u7a0b\u4e2d Vulkan \u56fe\u5f62\u6d41\u6c34\u7ebf\u4f7f\u7528\u7684\u7740\u8272\u5668\u3002 \u4f7f\u7528\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u683c\u5f0f\u7684\u4f18\u70b9\u4e4b\u4e00\u662f \u4f7f\u5f97 GPU \u5382\u5546\u7f16\u5199\u5c06\u7740\u8272\u5668\u4ee3\u7801\u8f6c\u6362\u4e3a\u672c\u5730\u4ee3\u7801\u7684\u7f16\u8bd1\u5668\u590d\u6742\u5ea6\u51cf\u5c11\u4e86\u5f88\u591a\u3002\u7ecf\u9a8c\u8868\u660e\u4f7f\u7528\u53ef\u8bfb\u6027\u6bd4\u8f83\u5f3a\u7684\u8bed\u6cd5\uff0c\u6bd4\u5982 GLSL \u4e00\u4e9b GPU \u5382\u5546\u76f8\u5f53\u7075\u6d3b\u5730\u7406\u89e3\u8fd9\u4e2a\u6807\u51c6\u3002\u8fd9\u5bfc\u81f4\u4e00\u79cd\u60c5\u51b5\u4f1a\u53d1\u751f\uff0c\u6bd4\u5982\u7f16\u5199\u597d\uff0c\u5e76\u5728\u4e00\u4e2a\u5382\u5546\u7684 GPU \u8fd0\u884c\u7684\u4e0d\u9519\u7684\u7740\u8272\u5668\u7a0b\u5e8f\uff0c\u53ef\u80fd\u5728\u5176\u4ed6\u7684 GPU \u5382\u5546\u7684 GPU \u9a71\u52a8\u7a0b\u5e8f\u8fd0\u884c\u5f02\u5e38\uff0c\u53ef\u80fd\u662f\u8bed\u6cd5\u7684\u95ee\u9898\uff0c\u6216\u8005\u66f4\u7cdf\u7684\u662f\u4e0d\u540c GPU \u5382\u5546\u7f16\u5199\u7684\u7f16\u8bd1\u5668\u5dee\u5f02\uff0c\u5bfc\u81f4\u7740\u8272\u5668\u8fd0\u884c\u9519\u8bef\u3002\u5982\u679c\u76f4\u63a5\u4f7f\u7528\u7f16\u8bd1\u597d\u7684\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u683c\u5f0f\uff0c\u53ef\u4ee5\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\u3002 \u4f46\u662f\uff0c\u5e76\u4e0d\u610f\u5473\u7740\u6211\u4eec\u8981\u624b\u5199\u5b57\u8282\u7801\u3002 Khronos \u53d1\u5e03\u4e86\u4e0e\u5382\u5546\u65e0\u5173\u7684\u7f16\u8bd1\u5668\uff0c\u5b83\u5c06 GLSL \u7f16\u8bd1\u6210 SPIR-V \u3002\u8be5\u7f16\u8bd1\u5668\u7528\u4e8e\u9a8c\u8bc1\u7740\u8272\u5668\u4ee3\u7801\u662f\u5426\u7b26\u5408\u6807\u51c6\uff0c\u5e76\u751f\u6210\u4e0e Vulkan \u529f\u80fd\u8fd0\u884c\u7684 SPRIR-V \u4e8c\u8fdb\u5236\u6587\u4ef6\u3002\u9664\u6b64\u4e4b\u5916\u8fd8\u53ef\u4ee5\u5c06\u6b64\u7f16\u8bd1\u5668\u4f5c\u4e3a\u5e93\u5728\u8fd0\u884c\u65f6\u7f16\u8bd1\u751f\u6210 SPRI-V \uff0c\u4f46\u5728\u672c\u6559\u7a0b\u4e2d\u4e0d\u4f1a\u8fd9\u6837\u64cd\u4f5c\u3002\u7f16\u8bd1\u5668 glslangValidator.exe \u5305\u542b\u5728 LunarG SDK \u4e2d\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u4e0b\u8f7d\u4efb\u4f55\u989d\u5916\u7684\u5185\u5bb9\u3002 GLSL \u662f\u5177\u6709C\u98ce\u683c\u8bed\u6cd5\u7684\u7740\u8272\u8bed\u8a00\u3002\u5728\u7a0b\u5e8f\u4e2d\u9700\u8981\u5b9a\u4e49\u7f16\u5199 main \u51fd\u6570\u4f5c\u4e3a\u5165\u53e3\u3002 GLSL \u4e0d\u4f1a\u4f7f\u7528\u8f93\u5165\u53c2\u6570\u548c\u8fd4\u56de\u503c\u4f5c\u4e3a\u8f93\u51fa\uff0c\u800c\u662f\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\u6765\u5904\u7406\u8f93\u5165\u548c\u8f93\u51fa\u3002\u8be5\u8bed\u8a00\u5305\u62ec\u5f88\u591a\u529f\u80fd\u7b80\u5316\u56fe\u5f62\u7f16\u7a0b\uff0c\u6bd4\u5982\u5185\u7f6e\u7684\u57fa\u4e8e\u5411\u91cf\u548c\u77e9\u9635\u7684\u53c9\u79ef\u64cd\u4f5c\u51fd\u6570\uff0c\u77e9\u9635\u548c\u77e2\u91cf\u4e58\u6cd5\u64cd\u4f5c\u51fd\u6570\u3002\u77e2\u91cf\u7c7b\u578b\u4e3a vec \uff0c\u6570\u5b57\u8868\u793a\u5206\u91cf\u7684\u6570\u91cf\u3002\u4f8b\u59823D\u4f4d\u7f6e\u5b58\u50a8\u5728 vec3 \u4e2d\u3002\u53ef\u4ee5\u901a\u8fc7\u8bf8\u5982 .x \u4e4b\u7c7b\u7684\u6210\u5458\u8bbf\u95ee\u5355\u4e2a\u5206\u91cf\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u591a\u4e2a\u5206\u91cf\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5411\u91cf\u3002\u6bd4\u5982\uff0c\u8868\u8fbe\u5f0f vec3(1.0, 2.0, 3.0).xy \u622a\u53d6\u524d\u4e24\u4e2a\u5206\u91cf\uff0c\u5e76\u8d4b\u4e88\u65b0\u7684 vec2 \u4e2d\u3002\u5411\u91cf\u7684\u6784\u9020\u51fd\u6570\u4e5f\u53ef\u4ee5\u91c7\u7528\u77e2\u91cf\u5bf9\u8c61\u548c\u6807\u91cf\u503c\u7684\u7ec4\u5408\u3002\u6bd4\u5982 vec3 \u53ef\u4ee5\u7528 vec3(vec2(1.0, 2.0), 3.0) \u6784\u9020\u3002 \u5982\u524d\u9762\u63d0\u5230\u7684\u4e00\u6837\uff0c\u6211\u4eec\u9700\u8981\u7f16\u5199\u4e00\u4e2a vertex shader \u548c\u4e00\u4e2a fragment shader \u7ed8\u5236\u4e09\u89d2\u5f62\u5728\u5c4f\u5e55\u3002\u4e0b\u9762\u4e24\u4e2a\u5c0f\u8282\u4f1a\u63a2\u8ba8\u4e0e\u4e4b\u76f8\u5173\u7684 GLSL \u4ee3\u7801\uff0c\u5e76\u5c55\u793a\u5982\u4f55\u751f\u6210\u4e24\u4e2a SPIR-V \u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u6700\u540e\u52a0\u8f7d\u5230\u7a0b\u5e8f\u4e2d\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9876\u70b9\u7740\u8272\u5668 2 \u7247\u5143\u7740\u8272\u5668 3 \u9876\u70b9\u989c\u8272\u7ec4 4 \u7f16\u8bd1\u7740\u8272\u5668 5 \u52a0\u8f7d\u7740\u8272\u5668 6 \u521b\u5efa\u7740\u8272\u5668\u6a21\u578b 7 \u7740\u8272\u5668\u9636\u6bb5\u521b\u5efa \u9876\u70b9\u7740\u8272\u5668 \u9876\u70b9\u7740\u8272\u5668\u5904\u7406\u6bcf\u4e00\u4e2a\u9876\u70b9\u6570\u636e\u3002\u5b83\u7684\u5c5e\u6027\uff0c\u5982\u4e16\u754c\u5750\u6807\uff0c\u989c\u8272\uff0c\u6cd5\u7ebf\u548c\u7eb9\u7406UV\u5750\u6807\u4f5c\u4e3a\u8f93\u5165\u3002\u8f93\u51fa\u7684\u662f\u6700\u7ec8\u7684clip coordinates \u88c1\u526a\u5750\u6807\u548c\u9700\u8981\u4f20\u9012\u5230\u7247\u5143\u7740\u8272\u5668\u7684\u5c5e\u6027\uff0c\u5305\u62ec\u989c\u8272\u548c\u7eb9\u7406UV\u5750\u6807\u3002\u8fd9\u4e9b\u503c\u4f1a\u5728\u5149\u6805\u5316\u9636\u6bb5\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u4ee5\u4ea7\u751f\u5e73\u6ed1\u7684\u8fc7\u5ea6\u3002 \u88c1\u526a\u5750\u6807 clip coordinate \u662f\u4e00\u4e2a\u6765\u6b64\u9876\u70b9\u7740\u8272\u5668\u7684\u601d\u7ef4\u5411\u91cf\uff0c\u968f\u540e\u901a\u8fc7\u77e2\u91cf\u6700\u540e\u4e00\u4e2a\u5206\u91cf\u8fdb\u884c\u6574\u4f53\u5f52\u4e00\u5316\u64cd\u4f5c\u3002\u8fd9\u4e9b\u5f52\u4e00\u5316\u540e\u7684\u8bbe\u5907\u5750\u6807\u662f homogeneous coordinates ****\u6700\u7ec8\u6620\u5c04\u5230\u7f13\u51b2\u533a\u8303\u56f4\u4e3a [-1, 1] \u7684 [-1, 1] \u5750\u6807\u7cfb\u7edf\uff0c\u5982\u4e0b\u6240\u793a: \u5982\u679c\u4e4b\u524d\u7684\u8ba1\u7b97\u673a\u56fe\u5f62\u6bd4\u8f83\u719f\u6089\u7684\u8bdd\uff0c\u5bf9\u8fd9\u90e8\u5206\u4f1a\u6bd4\u8f83\u719f\u6089\u3002\u5982\u679c\u4f60\u4e4b\u524d\u4f7f\u7528\u8fc7 OpenGL \uff0c\u4f60\u4f1a\u6ce8\u610f\u5230Y\u5750\u6807\u8f74\u662f\u53cd\u8f6c\u7684\uff0cZ\u5750\u6807\u8f74\u7684\u8303\u56f4\u4e0e Direct3D \u662f\u4e00\u81f4\u7684\u8303\u56f4\uff0c\u4ece0\u52301. \u5bf9\u4e8e\u7b2c\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u6211\u4eec\u4e0d\u4f1a\u505a\u4efb\u4f55\u8f6c\u6362\u64cd\u4f5c\uff0c\u6211\u4eec\u5c06\u4e09\u4e2a\u9876\u70b9\u7684\u4f4d\u7f6e\u6307\u5b9a\u4e3a\u5f52\u4e00\u5316\u8bbe\u5907\u5750\u6807\uff0c\u521b\u5efa\u5982\u4e0b\u56fe\u5f62: \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5c06\u5176\u8f93\u51fa\u4e3a\u88c1\u526a\u5750\u6807\u76f4\u63a5\u8f93\u51fa\u5f52\u4e00\u5316\u7684\u8bbe\u5907\u5750\u6807\uff0c\u9876\u70b9\u7740\u8272\u5668\u7684\u5750\u6807\u4e0e\u6700\u540e\u4e00\u4e2a\u5206\u91cf\u8bbe\u7f6e\u4e3a 1 \u3002\u5c06\u88c1\u526a\u5750\u6807\u8f6c\u6362\u4e3a\u5f52\u4e00\u5316\u7684\u8bbe\u5907\u5750\u6807\u6ca1\u6709\u6539\u53d8\u4efb\u4f55\u4e1c\u897f\u3002 \u901a\u5e38\u60c5\u51b5\u4e0b\u9876\u70b9\u5750\u6807\u6570\u636e\u662f\u5b58\u50a8\u5728\u4e00\u4e2a\u9876\u70b9\u7f13\u51b2\u533a\u4e2d\uff0c\u4f46\u662f\u5728 Vulkan \u4e2d\u521b\u5efa\u4e00\u4e2a\u9876\u70b9\u7f13\u51b2\u533a\u5e76\u586b\u5145\u6570\u636e\u7684\u8fc7\u7a0b\u5e76\u4e0d\u662f\u76f4\u63a5\u7684\u3002\u6240\u4ee5\u6211\u4eec\u540e\u7f6e\u8fd9\u4e9b\u6b65\u9aa4\uff0c\u76f4\u5230\u6211\u4eec\u6ee1\u610f\u7684\u770b\u5230\u4e00\u4e2a\u4e09\u89d2\u5f62\u51fa\u73b0\u5728\u5c4f\u5e55\u4e0a\u3002\u540c\u65f6\u6211\u4eec\u9700\u8981\u505a\u4e00\u4e9b\u975e\u6b63\u7edf\u7684\u4e8b\u60c5:\u5c06\u5750\u6807\u76f4\u63a5\u5305\u542b\u5728\u9876\u70b9\u7740\u8272\u5668\u7684\u5185\u90e8\u3002\u4ee3\u7801\u5982\u4e0b\u6240\u793a: #version 450 #extension GL_ARB_separate_shader_objects : enable out gl_PerVertex { vec4 gl_Position; }; vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); } C++ main \u51fd\u6570\u7684\u6267\u884c\u5e94\u7528\u4e8e\u6bcf\u4e2a\u9876\u70b9\uff0c\u5185\u7f6e\u7684 gl_VertexIndex \u53d8\u91cf\u5305\u542b\u4e86\u5f53\u524d\u9876\u70b9\u7684\u7d22\u5f15\u4fe1\u606f\u3002\u901a\u5e38\u662f\u9876\u70b9\u7f13\u51b2\u533a\u7684\u7d22\u5f15\uff0c\u4f46\u662f\u5728\u8fd9\u91cc\u6211\u4eec\u786c\u7f16\u7801\u5230\u9876\u70b9\u6570\u636e\u7684\u96c6\u5408\u4e2d\u3002\u6bcf\u4e2a\u9876\u70b9\u7684\u4f4d\u7f6e\u4ece\u5e38\u91cf\u6570\u7ec4\u4e2d\u8bbf\u95ee\uff0c\u5e76\u4e0e z \u548c w \u5206\u91cf\u7ec4\u5408\u4f7f\u7528\uff0c\u4ee5\u4ea7\u751f\u88c1\u526a\u5750\u6807\u4e2d\u7684\u6709\u6548\u4f4d\u7f6e\u4fe1\u606f\u3002\u5185\u7f6e\u7684 gl_Position \u53d8\u91cf\u4f5c\u4e3a\u8f93\u51fa\u3002\u6700\u540eVulkan\u4e2d\u4f7f\u7528shader\uff0c\u9700\u8981\u786e\u4fdd GL_ARG_separate_shader_objects \u6269\u5c55\u5f00\u542f\u3002 \u7247\u5143\u7740\u8272\u5668 \u7531\u9876\u70b9\u7740\u8272\u5668\u7684\u4f4d\u7f6e\u6570\u636e\u5f62\u6210\u7684\u4e09\u89d2\u5f62\u7528\u7247\u6bb5\u7740\u8272\u5668\u586b\u5145\u5c4f\u5e55\u4e0a\u7684\u533a\u57df\u4e2d\u3002\u7247\u6bb5\u7740\u8272\u5668\u9488\u5bf9\u4e00\u4e2a\u6216\u8005\u591a\u4e2aframebuffer\u5e27\u7f13\u51b2\u533a\u7684\u6bcf\u4e2a\u7247\u5143\u4ea7\u751f\u5177\u4f53\u7684\u989c\u8272\u548c\u6df1\u5ea6\u4fe1\u606f\u3002\u4e00\u4e2a\u7b80\u5355\u7684\u7247\u6bb5\u7740\u8272\u5668\u4e3a\u5b8c\u6210\u7684\u4e09\u89d2\u5f62\u8f93\u51fa\u7ea2\u8272\u4fe1\u606f\u7684\u4ee3\u7801\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable layout(location = 0) out vec4 outColor; void main() { outColor = vec4(1.0, 0.0, 0.0, 1.0); } C++ fragment sahder\u4e2d\u7684 main \u51fd\u6570\u4e0e vertex shader \u4e2d\u7684 main \u51fd\u6570\u7c7b\u4f3c\uff0c\u4f1a\u4e3a\u6bcf\u4e00\u4e2a\u7247\u5143\u8c03\u7528\u5904\u7406\u3002\u989c\u8272\u7684\u4fe1\u606f\u5728GLSL\u4e2d\u662f4\u4e2a\u5206\u91cf\u7ec4\u6210\u7684\u77e2\u91cf\uff0c\u5305\u62ecR,G,B\u548cAlpha\u901a\u9053\uff0c\u503c\u57df\u6536\u655b\u5728[0, 1]\u8303\u56f4\u5185\u3002\u4e0d\u50cf\u9876\u70b9\u7740\u8272\u5668\u7684 gl_Position \uff0c\u5b83\u6ca1\u6709\u5185\u7f6e\u7684\u53d8\u91cf\u4e3a\u5f53\u524d\u7247\u5143\u8f93\u51fa\u989c\u8272\u4fe1\u606f\u3002\u5728\u8fd9\u91cc\u5fc5\u987b\u4e3aframebuffer\u5b9a\u4e49\u8f93\u51fa\u53d8\u91cf\uff0c layout(location = 0) \u4fee\u9970\u7b26\u660e\u786eframebuffer\u7684\u7d22\u5f15\u3002\u7ea2\u8272\u4fe1\u606f\u5199\u8fdb outColor \u53d8\u91cf\u4e2d\uff0c\u8be5\u53d8\u91cf\u94fe\u63a5\u7b2c\u4e00\u4e2aframebuffer\u4e2d\uff0c\u7d22\u5f15\u4e3a 0 \u3002 \u9876\u70b9\u989c\u8272\u7ec4 \u4e00\u4e2a\u7eaf\u7ea2\u8272\u7684\u4e09\u89d2\u5f62\u770b\u8d77\u6765\u5e76\u4e0d\u662f\u5f88\u9177\u70ab\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u8bd5\u7740\u9177\u70ab\u4e00\u4e9b\u5462? \u6211\u4eec\u9488\u5bf9\u4e24\u4e2a\u7c7b\u578b\u7684\u7740\u8272\u5668\u5c1d\u8bd5\u505a\u4e00\u4e9b\u6539\u53d8\uff0c\u5b8c\u6210\u4e0a\u56fe\u7684\u6548\u679c\u3002\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u6bcf\u4e2a\u9876\u70b9\u8bbe\u7f6e\u5dee\u5f02\u5316\u7684\u989c\u8272\u3002\u9876\u70b9\u7740\u8272\u5668\u5e94\u8be5\u5305\u542b\u4e00\u4e2a\u989c\u8272\u6570\u7ec4\uff0c\u5c31\u50cf\u4f4d\u7f6e\u4fe1\u606f\u7684\u6570\u7ec4\u4e00\u6837: vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) ); C++ \u73b0\u5728\u6211\u4eec\u9700\u8981\u628a\u6bcf\u4e2a\u9876\u70b9\u7684\u989c\u8272\u4f20\u9012\u5230\u7247\u6bb5\u7740\u8272\u5668\u4e2d\uff0c\u4ece\u800c\u8f93\u51fa\u7ecf\u8fc7\u63d2\u503c\u540e\u7684\u989c\u8272\u4fe1\u606f\u5230 framebuffer \u4e2d\u3002\u4e3a\u9876\u70b9\u7740\u8272\u5668\u6dfb\u589e\u52a0\u8f93\u51fa\u989c\u8272\u652f\u6301\uff0c\u5728 main \u51fd\u6570\u4e2d\u5b9a\u4e49\u5982\u4e0b: layout(location = 0) out vec3 fragColor; void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex]; } C++ \u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u9700\u8981\u5c06\u7247\u6bb5\u7740\u8272\u5668\u7684\u8f93\u5165\u5339\u914d\u9876\u70b9\u7740\u8272\u5668\u7684\u8f93\u51fa: layout(location = 0) in vec3 fragColor; void main() { outColor = vec4(fragColor, 1.0); } C++ \u8f93\u5165\u7684\u53d8\u91cf\u4e0d\u4e00\u5b9a\u8981\u540c\u540d\uff0c\u5b83\u4eec\u5c06\u901a\u8fc7 location \u7d22\u5f15\u6307\u4ee4\u94fe\u63a5\u5728\u4e00\u8d77\u3002 main \u51fd\u6570\u4e2d\u4fee\u6539\u5c06\u8981\u8f93\u51fa\u7684\u989c\u8272alpha\u503c\u3002\u5c31\u50cf\u4e4b\u524d\u8ba8\u8bba\u7684\u4e00\u6837\uff0c fragColor \u5c06\u4f1a\u4e3a\u4e09\u4e2a\u9876\u70b9\u6240\u5c5e\u7684\u7247\u5143\u81ea\u52a8\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u5f62\u6210\u5e73\u6ed1\u7684\u989c\u8272\u8fc7\u5ea6\u3002 \u7f16\u8bd1\u7740\u8272\u5668 \u5728\u9879\u76ee\u6839\u76ee\u5f55\u4e0b\u521b\u5efa\u4e00\u4e2a\u5b50\u76ee\u5f55\uff0c\u540d shaders \u7528\u4e8e\u5b58\u50a8\u9876\u70b9\u7740\u8272\u5668\u6587\u4ef6 shader.vert \u548c\u7247\u6bb5\u7740\u8272\u5668\u6587\u4ef6 shader.frag \u3002GLSL\u7740\u8272\u5668\u5b98\u65b9\u6ca1\u6709\u7ea6\u5b9a\u7684\u6269\u5c55\u540d\uff0c\u4f46\u662f\u8fd9\u4e24\u4e2a\u6269\u5c55\u540d\u662f\u6bd4\u8f83\u666e\u904d\u901a\u7528\u7684\u3002 shader.vert \u5185\u5bb9\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable out gl_PerVertex { vec4 gl_Position; }; layout(location = 0) out vec3 fragColor; vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex]; } C++ shader.frag \u6587\u4ef6\u5185\u5bb9\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable layout(location = 0) in vec3 fragColor; layout(location = 0) out vec4 outColor; void main() { outColor = vec4(fragColor, 1.0); } C++ \u73b0\u5728\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 glslangValidator \u7a0b\u5e8f\u7f16\u8bd1SPIR-V\u4e8c\u8fdb\u5236\u7801\u3002 \u521b\u5efa\u4e00\u4e2acompile.bat\u6279\u5904\u7406\u6587\u4ef6\uff0c\u5185\u5bb9\u5982\u4e0b: C:/VulkanSDK/1.0.17.0/Bin32/glslangValidator.exe -V shader.vert C:/VulkanSDK/1.0.17.0/Bin32/glslangValidator.exe -V shader.frag pause C++ \u5c06 glslangValidator.exe \u7684path\u8def\u5f84\u66ff\u6362\u4e3a\u4f60\u7684VulkanSDK\u5b89\u88c5\u8def\u5f84\uff0c\u7136\u540e\u53cc\u51fb\u8be5\u6587\u4ef6\u8fd0\u884c\u3002 \u8fd9\u4e24\u4e2a\u547d\u4ee4\u4f7f\u7528 -V \u6807\u5fd7\u8c03\u7528\u7f16\u8bd1\u5668\uff0c\u8be5\u6807\u5fd7\u544a\u8bc9\u5b83\u5c06GLSL\u6e90\u6587\u4ef6\u7f16\u8bd1\u4e3aSPIR-V\u5b57\u8282\u7801\u3002\u8fd0\u884c\u7f16\u8bd1\u811a\u672c\u65f6\uff0c\u4f1a\u770b\u5230\u521b\u5efa\u4e86\u4e24\u4e2aSPIR-V\u4e8c\u8fdb\u5236\u6587\u4ef6: vert.spv \u548c frag.spv \u3002\u8fd9\u4e9b\u540d\u79f0\u4ece\u7740\u8272\u5668\u4e2d\u6d3e\u751f\u800c\u6765\uff0c\u4f46\u662f\u53ef\u4ee5\u91cd\u547d\u540d\u4e3a\u4efb\u4f55\u540d\u5b57\u3002\u5728\u7f16\u8bd1\u7740\u8272\u5668\u65f6\uff0c\u53ef\u80fd\u6536\u5230\u5173\u4e8e\u67d0\u4e9b\u529f\u80fd\u7f3a\u5931\u7684\u8b66\u544a\u4fe1\u606f\uff0c\u5728\u8fd9\u91cc\u653e\u5fc3\u7684\u5ffd\u7565\u5b83\u4eec\u3002 \u5982\u679c\u7740\u8272\u5668\u5305\u542b\u8bed\u6cd5\u9519\u8bef\uff0c\u90a3\u4e48\u7f16\u8bd1\u5668\u4f1a\u6309\u7167\u60a8\u7684\u9884\u671f\u544a\u8bc9\u5177\u4f53\u7684\u884c\u53f7\u548c\u95ee\u9898\u3002\u5c1d\u8bd5\u7701\u7565\u4e00\u4e2a\u5206\u53f7\uff0c\u7136\u540e\u91cd\u65b0\u8fd0\u884c\u7f16\u8bd1\u811a\u672c\u3002\u8fd8\u53ef\u4ee5\u5c1d\u8bd5\u8fd0\u884c\u7f16\u8bd1\u5668\uff0c\u800c\u65e0\u9700\u4efb\u4f55\u53c2\u6570\u6765\u67e5\u770b\u5b83\u652f\u6301\u54ea\u4e9b\u7c7b\u578b\u7684\u6807\u5fd7\u3002\u4f8b\u5982\uff0c\u5b83\u53ef\u4ee5\u5c06\u5b57\u8282\u7801\u8f93\u51fa\u4e3a\u53ef\u8bfb\u7684\u683c\u5f0f\uff0c\u4ee5\u4fbf\u51c6\u786e\u4e86\u89e3\u7740\u8272\u5668\u6b63\u5728\u6267\u884c\u7684\u64cd\u4f5c\u4ee5\u53ca\u5728\u6b64\u9636\u6bb5\u5e94\u7528\u7684\u4efb\u4f55\u4f18\u5316\u3002 \u52a0\u8f7d\u7740\u8272\u5668 \u73b0\u5728\u6211\u4eec\u6709\u4e00\u79cd\u4ea7\u751fSPIR-V\u7740\u8272\u5668\u7684\u65b9\u6cd5\uff0c\u662f\u65f6\u5019\u52a0\u8f7d\u5b83\u4eec\u5230\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\uff0c\u4ee5\u4fbf\u5728\u9002\u5f53\u7684\u65f6\u5019\u63d2\u5165\u5230\u56fe\u5f62\u7ba1\u7ebf\u4e2d\u3002\u9996\u5148\u6211\u4eec\u7f16\u5199\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\u7528\u4ee5\u52a0\u8f7d\u4e8c\u8fdb\u5236\u6570\u636e\u6587\u4ef6\u3002 #include <fstream> ... static std::vector<char> readFile(const std::string& filename) { std::ifstream file(filename, std::ios::ate | std::ios::binary); if (!file.is_open()) { throw std::runtime_error(\"failed to open file!\"); } } C++ readFile \u51fd\u6570\u5c06\u4f1a\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6240\u6709\u7684\u4e8c\u8fdb\u5236\u6570\u636e\uff0c\u5e76\u7528 std::vector \u5b57\u8282\u96c6\u5408\u7ba1\u7406\u3002\u6211\u4eec\u4f7f\u7528\u4e24\u4e2a\u6807\u5fd7\u7528\u4ee5\u6253\u5f00\u6587\u4ef6: ate :\u5728\u6587\u4ef6\u672b\u5c3e\u5f00\u59cb\u8bfb\u53d6 binary :\u4ee5\u4e8c\u8fdb\u5236\u683c\u5f0f\u53bb\u8bfb\u6587\u4ef6(\u907f\u514d\u5b57\u7b26\u683c\u5f0f\u7684\u8f6c\u4e49) \u4ece\u6587\u4ef6\u672b\u5c3e\u5f00\u59cb\u8bfb\u53d6\u7684\u4f18\u70b9\u662f\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u8bfb\u53d6\u4f4d\u7f6e\u6765\u786e\u5b9a\u6587\u4ef6\u7684\u5927\u5c0f\u5e76\u5206\u914d\u7f13\u51b2\u533a: size_t fileSize = (size_t) file.tellg(); std::vector<char> buffer(fileSize); C++ \u4e4b\u540e\u6211\u4eec\u53ef\u4ee5\u8ffd\u6eaf\u5230\u6587\u4ef6\u7684\u5f00\u5934\uff0c\u540c\u65f6\u8bfb\u53d6\u6240\u6709\u7684\u5b57\u8282: file.seekg(0); file.read(buffer.data(), fileSize); C++ \u6700\u540e\u5173\u95ed\u6587\u4ef6\uff0c\u8fd4\u56de\u5b57\u8282\u6570\u636e: file.close(); return buffer; C++ \u6211\u4eec\u8c03\u7528\u51fd\u6570createGraphicsPipeline\u52a0\u8f7d\u4e24\u4e2a\u7740\u8272\u5668\u7684\u4e8c\u8fdb\u5236\u7801: void createGraphicsPipeline() { auto vertShaderCode = readFile(\"shaders/vert.spv\"); auto fragShaderCode = readFile(\"shaders/frag.spv\"); } C++ \u786e\u4fdd\u7740\u8272\u5668\u6b63\u786e\u52a0\u8f7d\uff0c\u5e76\u6253\u5370\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u662f\u5426\u4e0e\u6587\u4ef6\u5b9e\u9645\u5927\u5c0f\u4e00\u81f4\u3002 \u521b\u5efa\u7740\u8272\u5668\u6a21\u578b \u5728\u5c06\u4ee3\u7801\u4f20\u9012\u7ed9\u6e32\u67d3\u7ba1\u7ebf\u4e4b\u524d\uff0c\u6211\u4eec\u5fc5\u987b\u5c06\u5176\u5c01\u88c5\u5230 VkShaderModule \u5bf9\u8c61\u4e2d\u3002\u8ba9\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570 createShaderModule \u5b9e\u73b0\u8be5\u903b\u8f91\u3002 VkShaderModule createShaderModule(const std::vector<char>& code) { } C++ \u8be5\u51fd\u6570\u9700\u8981\u5b57\u8282\u7801\u7684\u7f13\u51b2\u533a\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u901a\u8fc7\u7f13\u51b2\u533a\u521b\u5efa VkShaderModule \u3002 \u521b\u5efashader module\u662f\u6bd4\u8f83\u7b80\u5355\u7684\uff0c\u6211\u4eec\u4ec5\u4ec5\u9700\u8981\u6307\u5b9a\u4e8c\u8fdb\u5236\u7801\u7f13\u51b2\u533a\u7684\u6307\u9488\u548c\u5b83\u7684\u5177\u4f53\u957f\u5ea6\u3002\u8fd9\u4e9b\u4fe1\u606f\u88ab\u586b\u5145\u5728 VkShaderModuleCreateInfo \u7ed3\u6784\u4f53\u4e2d\u3002\u9700\u8981\u7559\u610f\u7684\u662f\u5b57\u8282\u7801\u7684\u5927\u5c0f\u662f\u4ee5\u5b57\u8282\u6307\u5b9a\u7684\uff0c\u4f46\u662f\u5b57\u8282\u7801\u6307\u9488\u662f\u4e00\u4e2a uint32_t \u7c7b\u578b\u7684\u6307\u9488\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a char \u6307\u9488\u3002\u6240\u4ee5\u6211\u4eec\u4f7f\u7528 reinterpret_cast \u8fdb\u884c\u8f6c\u6362\u6307\u9488\u3002\u5982\u4e0b\u6240\u793a\uff0c\u5f53\u9700\u8981\u8f6c\u6362\u65f6\uff0c\u8fd8\u9700\u8981\u786e\u4fdd\u6570\u636e\u6ee1\u8db3 uint32_t \u7684\u5bf9\u9f50\u8981\u6c42\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u6570\u636e\u5b58\u50a8\u5728 std::vector \u4e2d\uff0c\u9ed8\u8ba4\u5206\u914d\u5668\u5df2\u7ecf\u786e\u4fdd\u6570\u636e\u6ee1\u8db3\u6700\u5dee\u60c5\u51b5\u4e0b\u7684\u5bf9\u9f50\u8981\u6c42\u3002 VkShaderModuleCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; createInfo.codeSize = code.size(); createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data()); C++ \u8c03\u7528 vkCreateShaderMoudle \u521b\u5efa VkShaderModule : VkShaderModule shaderModule; if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) { throw std::runtime_error(\"failed to create shader module!\"); } C++ \u53c2\u6570\u4e0e\u4e4b\u524d\u521b\u5efa\u5bf9\u8c61\u529f\u80fd\u7c7b\u4f3c:\u903b\u8f91\u8bbe\u5907\uff0c\u521b\u5efa\u5bf9\u8c61\u4fe1\u606f\u7ed3\u6784\u4f53\u7684\u6307\u9488\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u4fdd\u5b58\u7ed3\u679c\u7684\u53e5\u67c4\u53d8\u91cf\u3002\u5728shader module\u521b\u5efa\u5b8c\u6bd5\u540e\uff0c\u53ef\u4ee5\u5bf9\u4e8c\u8fdb\u5236\u7801\u7684\u7f13\u51b2\u533a\u8fdb\u884c\u7acb\u5373\u7684\u91ca\u653e\u3002\u6700\u540e\u4e0d\u8981\u5fd8\u8bb0\u8fd4\u56de\u521b\u5efa\u597d\u7684shader module\u3002 return shaderModule; C++ shader module\u5bf9\u8c61\u4ec5\u4ec5\u5728\u6e32\u67d3\u7ba1\u7ebf\u5904\u7406\u8fc7\u7a0b\u4e2d\u9700\u8981\uff0c\u6240\u4ee5\u6211\u4eec\u4f1a\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u5b9a\u4e49\u672c\u5730\u53d8\u91cf\u4fdd\u5b58\u5b83\u4eec\uff0c\u800c\u4e0d\u662f\u5b9a\u4e49\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709\u5b83\u4eec\u7684\u53e5\u67c4: VkShaderModule vertShaderModule; VkShaderModule fragShaderModule; C++ \u8c03\u7528\u52a0\u8f7dshader module\u7684\u8f85\u52a9\u51fd\u6570: vertShaderModule = createShaderModule(vertShaderCode); fragShaderModule = createShaderModule(fragShaderCode); C++ \u5728\u56fe\u5f62\u7ba1\u7ebf\u521b\u5efa\u5b8c\u6210\u4e14 createGraphicsPipeline \u51fd\u6570\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u5b83\u4eec\u5e94\u8be5\u88ab\u6e05\u7406\u6389\uff0c\u6240\u4ee5\u5728\u8be5\u51fd\u6570\u540e\u5220\u9664\u5b83\u4eec: ... vkDestroyShaderModule(device, fragShaderModule, nullptr); vkDestroyShaderModule(device, vertShaderModule, nullptr); } C++ \u7740\u8272\u5668\u9636\u6bb5\u521b\u5efa VkShaderModule \u5bf9\u8c61\u53ea\u662f\u5b57\u8282\u7801\u7f13\u51b2\u533a\u7684\u4e00\u4e2a\u5305\u88c5\u5bb9\u5668\u3002\u7740\u8272\u5668\u5e76\u6ca1\u6709\u5f7c\u6b64\u94fe\u63a5\uff0c\u751a\u81f3\u6ca1\u6709\u7ed9\u51fa\u76ee\u7684\u3002\u901a\u8fc7 VkPipelineShaderStageCreateInfo \u7ed3\u6784\u5c06\u7740\u8272\u5668\u6a21\u5757\u5206\u914d\u5230\u7ba1\u7ebf\u4e2d\u7684\u9876\u70b9\u6216\u8005\u7247\u6bb5\u7740\u8272\u5668\u9636\u6bb5\u3002VkPipelineShaderStageCreateInfo\u7ed3\u6784\u4f53\u662f\u5b9e\u9645\u7ba1\u7ebf\u521b\u5efa\u8fc7\u7a0b\u7684\u4e00\u90e8\u5206\u3002 \u6211\u4eec\u9996\u5148\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u586b\u5199\u9876\u70b9\u7740\u8272\u5668\u7ed3\u6784\u4f53\u3002 VkPipelineShaderStageCreateInfo vertShaderStageInfo = {}; vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; C++ \u9664\u4e86\u5f3a\u5236\u7684 sType \u6210\u5458\u5916\uff0c\u7b2c\u4e00\u4e2a\u9700\u8981\u544a\u77e5Vulkan\u5c06\u5728\u54ea\u4e2a\u6d41\u6c34\u7ebf\u9636\u6bb5\u4f7f\u7528\u7740\u8272\u5668\u3002\u5728\u4e0a\u4e00\u4e2a\u7ae0\u8282\u7684\u6bcf\u4e2a\u53ef\u7f16\u7a0b\u9636\u6bb5\u90fd\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u679a\u4e3e\u503c\u3002 vertShaderStageInfo.module = vertShaderModule; vertShaderStageInfo.pName = \"main\"; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u6210\u5458\u6307\u5b9a\u5305\u542b\u4ee3\u7801\u7684\u7740\u8272\u5668\u6a21\u5757\u548c\u8c03\u7528\u7684\u4e3b\u51fd\u6570\u3002\u8fd9\u610f\u5473\u7740\u53ef\u4ee5\u5c06\u591a\u4e2a\u7247\u6bb5\u7740\u8272\u5668\u7ec4\u5408\u5230\u5355\u4e2a\u7740\u8272\u5668\u6a21\u5757\u4e2d\uff0c\u5e76\u4f7f\u7528\u4e0d\u540c\u7684\u5165\u53e3\u70b9\u6765\u533a\u5206\u5b83\u4eec\u7684\u884c\u4e3a\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u575a\u6301\u4f7f\u7528\u6807\u51c6 main \u51fd\u6570\u4f5c\u4e3a\u5165\u53e3\u3002 \u8fd8\u6709\u4e00\u4e2a\u53ef\u9009\u6210\u5458\uff0c pSpecializationInfo ,\u5728\u8fd9\u91cc\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u5b83\uff0c\u4f46\u662f\u503c\u5f97\u8ba8\u8bba\u4e00\u4e0b\u3002\u5b83\u5141\u8bb8\u4e3a\u7740\u8272\u5668\u6307\u5b9a\u5e38\u91cf\u503c\u3002\u4f7f\u7528\u5355\u4e2a\u7740\u8272\u5668\u6a21\u5757\uff0c\u901a\u8fc7\u4e3a\u5176\u4e2d\u4f7f\u7528\u4e0d\u540c\u7684\u5e38\u91cf\u503c\uff0c\u53ef\u4ee5\u5728\u6d41\u6c34\u7ebf\u521b\u5efa\u65f6\u5bf9\u884c\u4e3a\u8fdb\u884c\u914d\u7f6e\u3002\u8fd9\u6bd4\u5728\u6e32\u67d3\u65f6\u4f7f\u7528\u53d8\u91cf\u914d\u7f6e\u7740\u8272\u5668\u66f4\u6709\u6548\u7387\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u53ef\u4ee5\u8fdb\u884c\u4f18\u5316\uff0c\u4f8b\u5982\u6d88\u9664 if \u503c\u5224\u65ad\u7684\u8bed\u53e5\u3002\u5982\u679c\u6ca1\u6709\u8fd9\u6837\u7684\u5e38\u91cf\uff0c\u53ef\u4ee5\u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a nullptr \uff0c\u6211\u4eec\u7684struct\u7ed3\u6784\u4f53\u521d\u59cb\u5316\u81ea\u52a8\u8fdb\u884c\u3002 \u4fee\u6539\u7ed3\u6784\u4f53\u6ee1\u8db3\u7247\u6bb5\u7740\u8272\u5668\u7684\u9700\u8981: VkPipelineShaderStageCreateInfo fragShaderStageInfo = {}; fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; fragShaderStageInfo.module = fragShaderModule; fragShaderStageInfo.pName = \"main\"; C++ \u5b8c\u6210\u4e24\u4e2a\u7ed3\u6784\u4f53\u7684\u521b\u5efa\uff0c\u5e76\u901a\u8fc7\u6570\u7ec4\u4fdd\u5b58\uff0c\u8fd9\u90e8\u5206\u5f15\u7528\u5c06\u4f1a\u5728\u5b9e\u9645\u7684\u7ba1\u7ebf\u521b\u5efa\u5f00\u59cb\u3002 VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo}; C++ \u5230\u6b64\u4e3a\u6b62\uff0c\u5c31\u662f\u6240\u6709\u5173\u4e8e\u53ef\u7f16\u7a0b\u7ba1\u7ebf\u9636\u6bb5\u7684\u903b\u8f91\u3002\u5728 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u4f1a\u770b\u4e00\u4e0b\u56fa\u5b9a\u7ba1\u7ebf\u5404\u4e2a\u9636\u6bb5\u3002 Vulkan \u56fa\u6709\u529f\u80fd Vulkan \u56fa\u6709\u529f\u80fd \uff0c\u65e9\u8d77\u7684\u56fe\u5f62API\u5728\u56fe\u5f62\u6e32\u67d3\u7ba1\u7ebf\u7684\u8bb8\u591a\u9636\u6bb5\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u7684\u72b6\u6001\u3002\u5728 Vulkan \u4e2d\uff0c\u4ece viewport \u7684\u5927\u5c0f\u5230\u6df7\u8272\u51fd\u6570\uff0c\u9700\u8981\u51e1\u4e8b\u505a\u5230\u4eb2\u5386\u4eb2\u4e3a\u3002\u5728\u672c\u7ae0\u8282\u4e2d\u6211\u4eec\u4f1a\u586b\u5145\u6709\u5173\u56fa\u6709\u529f\u80fd\u64cd\u4f5c\u7684\u6240\u6709\u7ed3\u6784\u4f53\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9876\u70b9\u8f93\u5165 2 \u8f93\u5165\u7ec4\u4ef6 3 \u89c6\u7a97\u548c\u88c1\u526a 4 \u5149\u6805\u5316 5 \u91cd\u91c7\u6837 6 \u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5 7 \u989c\u8272\u6df7\u5408 8 \u52a8\u6001\u4fee\u6539 9 \u7ba1\u9053\u5e03\u5c40 10 \u7ed3\u8bba \u9876\u70b9\u8f93\u5165 VkPipelineVertexInputStateCreateInfo \u7ed3\u6784\u4f53\u63cf\u8ff0\u4e86\u9876\u70b9\u6570\u636e\u7684\u683c\u5f0f\uff0c\u8be5\u7ed3\u6784\u4f53\u6570\u636e\u4f20\u9012\u5230 vertex shader \u4e2d\u3002\u5b83\u4ee5\u4e24\u79cd\u65b9\u5f0f\u8fdb\u884c\u63cf\u8ff0: Bindings :\u6839\u636e\u6570\u636e\u7684\u95f4\u9699\uff0c\u786e\u5b9a\u6570\u636e\u662f\u6bcf\u4e2a\u9876\u70b9\u6216\u8005\u662f\u6bcf\u4e2ainstance( instancing ) Attribute \u63cf\u8ff0:\u63cf\u8ff0\u5c06\u8981\u8fdb\u884c\u7ed1\u5b9a\u53ca\u52a0\u8f7d\u5c5e\u6027\u7684\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684\u76f8\u5173\u5c5e\u6027\u7c7b\u578b\u3002 \u56e0\u4e3a\u6211\u4eec\u5c06\u9876\u70b9\u6570\u636e\u786c\u7f16\u7801\u5230 vertex shader \u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u5c06\u8981\u586b\u5145\u7684\u7ed3\u6784\u4f53\u6ca1\u6709\u9876\u70b9\u6570\u636e\u53bb\u52a0\u8f7d\u3002\u6211\u4eec\u5c06\u4f1a\u5728 vertex buffer \u7ae0\u8282\u4e2d\u56de\u6765\u64cd\u4f5c\u3002 VkPipelineVertexInputStateCreateInfo vertexInputInfo = {}; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.pVertexBindingDescriptions = nullptr; // Optional vertexInputInfo.vertexAttributeDescriptionCount = 0; vertexInputInfo.pVertexAttributeDescriptions = nullptr; // Optional C++ pVertexBindingDescriptions \u548c pVertexAttributeDescriptions \u6210\u5458\u6307\u5411\u7ed3\u6784\u4f53\u6570\u7ec4\uff0c\u7528\u4e8e\u8fdb\u4e00\u6b65\u63cf\u8ff0\u52a0\u8f7d\u7684\u9876\u70b9\u6570\u636e\u4fe1\u606f\u3002\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u7684 shaderStages \u6570\u7ec4\u540e\u6dfb\u52a0\u8be5\u7ed3\u6784\u4f53\u3002 \u8f93\u5165\u7ec4\u4ef6 VkPipelineInputAssemblyStateCreateInfo \u7ed3\u6784\u4f53\u63cf\u8ff0\u4e24\u4ef6\u4e8b\u60c5:\u9876\u70b9\u6570\u636e\u4ee5\u4ec0\u4e48\u7c7b\u578b\u7684\u51e0\u4f55\u56fe\u5143\u62d3\u6251\u8fdb\u884c\u7ed8\u5236\u53ca\u662f\u5426\u542f\u7528\u9876\u70b9\u7d22\u91cd\u65b0\u5f00\u59cb\u56fe\u5143\u3002\u56fe\u5143\u7684\u62d3\u6251\u7ed3\u6784\u7c7b\u578b topology \u679a\u4e3e\u503c\u5982\u4e0b: VK_PRIMITIVE_TOPOLOGY_POINT_LIST : \u9876\u70b9\u5230\u70b9 VK_PRIMITIVE_TOPOLOGY_LINE_LIST : \u4e24\u70b9\u6210\u7ebf\uff0c\u9876\u70b9\u4e0d\u5171\u7528 VK_PRIMITIVE_TOPOLOGY_LINE_STRIP : \u4e24\u70b9\u6210\u7ebf\uff0c\u6bcf\u4e2a\u7ebf\u6bb5\u7684\u7ed3\u675f\u9876\u70b9\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u7ebf\u6bb5\u7684\u5f00\u59cb\u9876\u70b9 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST : \u4e09\u70b9\u6210\u9762\uff0c\u9876\u70b9\u4e0d\u5171\u7528 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP : \u6bcf\u4e2a\u4f46\u6559\u8bad\u7684\u7b2c\u4e8c\u4e2a\u3001\u7b2c\u4e09\u4e2a\u9876\u70b9\u90fd\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u4e09\u89d2\u5f62\u7684\u524d\u4e24\u4e2a\u9876\u70b9 \u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u9876\u70b9\u6570\u636e\u6309\u7167\u7f13\u51b2\u533a\u4e2d\u7684\u5e8f\u5217\u4f5c\u4e3a\u7d22\u5f15\uff0c\u4f46\u662f\u4e5f\u53ef\u4ee5\u901a\u8fc7element buffer\u7f13\u51b2\u533a\u81ea\u884c\u6307\u5b9a\u9876\u70b9\u6570\u636e\u7684\u7d22\u5f15\u3002\u901a\u8fc7\u590d\u7528\u9876\u70b9\u6570\u636e\u63d0\u5347\u6027\u80fd\u3002\u5982\u679c\u8bbe\u7f6e primitiveRestartEnable \u6210\u5458\u4e3a VK_TRUE \uff0c\u53ef\u4ee5\u901a\u8fc7 0xFFFF \u6216\u8005 0xFFFFFFFF \u4f5c\u4e3a\u7279\u6b8a\u7d22\u5f15\u6765\u5206\u89e3\u7ebf\u548c\u4e09\u89d2\u5f62\u5728 _STRIP \u6a21\u5f0f\u4e0b\u7684\u56fe\u5143\u62d3\u6251\u7ed3\u6784\u3002 \u901a\u8fc7\u672c\u6559\u7a0b\u7ed8\u5236\u4e09\u89d2\u5f62\uff0c\u6240\u4ee5\u6211\u4eec\u575a\u6301\u6309\u7167\u5982\u4e0b\u683c\u5f0f\u586b\u5145\u6570\u636e\u7ed3\u6784: VkPipelineInputAssemblyStateCreateInfo inputAssembly = {}; inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; inputAssembly.primitiveRestartEnable = VK_FALSE; C++ \u89c6\u7a97\u548c\u88c1\u526a Viewport\u7528\u4e8e\u63cf\u8ff0framebuffer\u4f5c\u4e3a\u6e32\u67d3\u8f93\u51fa\u7ed3\u679c\u76ee\u6807\u533a\u57df\u3002\u5b83\u7684\u6570\u503c\u5728\u672c\u6559\u7a0b\u4e2d\u603b\u662f\u8bbe\u7f6e\u5728 (0, 0) \u548c (width, height) \u3002 VkViewport viewport = {}; viewport.x = 0.0f; viewport.y = 0.0f; viewport.width = (float) swapChainExtent.width; viewport.height = (float) swapChainExtent.height; viewport.minDepth = 0.0f; viewport.maxDepth = 1.0f; C++ \u8bb0\u5f97\u4ea4\u6362\u94fe\u548c\u5b83\u7684images\u56fe\u50cf\u5927\u5c0f WIDTH \u548c HEIGHT \u4f1a\u6839\u636e\u4e0d\u540c\u7684\u7a97\u4f53\u800c\u4e0d\u540c\u3002\u4ea4\u6362\u94fe\u56fe\u50cf\u5c06\u4f1a\u5728\u5e27\u7f13\u51b2\u533aframebuffers\u4f7f\u7528\uff0c\u6240\u4ee5\u6211\u4eec\u5e94\u8be5\u575a\u6301\u5b83\u4eec\u7684\u5927\u5c0f\u3002 minDepth \u548c maxDepth \u6570\u503c\u6307\u5b9aframebuffer\u4e2d\u6df1\u5ea6\u7684\u8303\u56f4\u3002\u8fd9\u4e9b\u6570\u503c\u5fc5\u987b\u6536\u655b\u5728 [0.0f, 1.0f] \u533a\u95f4\u51b2\uff0c\u4f46\u662f minDepth \u53ef\u80fd\u4f1a\u5927\u4e8e maxDepth \u3002\u5982\u679c\u4f60\u4e0d\u505a\u4efb\u4f55\u6307\u5b9a\uff0c\u5efa\u8bae\u4f7f\u7528\u6807\u51c6\u7684\u6570\u503c 0.0 f\u548c 1.0f \u3002 viewports \u5b9a\u4e49\u4e86image\u56fe\u50cf\u5230framebuffer\u5e27\u7f13\u51b2\u533a\u7684\u8f6c\u6362\u5173\u7cfb\uff0c\u88c1\u526a\u77e9\u5f62\u5b9a\u4e49\u4e86\u54ea\u4e9b\u533a\u57df\u7684\u50cf\u7d20\u88ab\u5b58\u50a8\u3002\u4efb\u4f55\u5728\u88c1\u526a\u5de8\u578b\u5916\u7684\u50cf\u7d20\u90fd\u4f1a\u5728\u5149\u6805\u5316\u9636\u6bb5\u4e22\u5f03\u3002\u5b83\u4eec\u7684\u529f\u80fd\u66f4\u50cf\u8fc7\u6ee4\u5668\u800c\u4e0d\u662f\u5b9a\u4e49\u8f6c\u6362\u5173\u7cfb\u3002\u8fd9\u4e2a\u533a\u522b\u5982\u4e0b\u56fe\u6240\u793a\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5bf9\u4e8e\u56fe\u50cf\u6bd4 viewport \u5c3a\u5bf8\u5927\u7684\u60c5\u5f62\uff0c\u5de6\u4fa7\u7684\u88c1\u526a\u77e9\u5f62\u53ea\u662f\u4f17\u591a\u53ef\u80fd\u7684\u4e00\u4e2a\u8868\u73b0\u3002 \u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u9700\u8981\u5c06\u56fe\u50cf\u7ed8\u5236\u5230\u5b8c\u6574\u7684\u5e27\u7f13\u51b2\u533a framebuffer \u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u5b9a\u4e49\u88c1\u526a\u77e9\u5f62\u8986\u76d6\u5230\u6574\u4f53\u56fe\u50cf: VkRect2D scissor = {}; scissor.offset = {0, 0}; scissor.extent = swapChainExtent; C++ viewport\u548c\u88c1\u526a\u77e9\u5f62\u9700\u8981\u501f\u52a9 VkPipelineViewportStateCreateInfo \u7ed3\u6784\u4f53\u8054\u5408\u4f7f\u7528\u3002\u53ef\u4ee5\u4f7f\u7528\u591a viewports \u548c\u88c1\u526a\u77e9\u5f62\u5728\u4e00\u4e9b\u56fe\u5f62\u5361\uff0c\u901a\u8fc7\u6570\u7ec4\u5f15\u7528\u3002\u4f7f\u7528\u8be5\u7279\u6027\u9700\u8981GPU\u652f\u6301\u8be5\u529f\u80fd\uff0c\u5177\u4f53\u770b\u903b\u8f91\u8bbe\u5907\u7684\u521b\u5efa\u3002 VkPipelineViewportStateCreateInfo viewportState = {}; viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; viewportState.pScissors = &scissor; C++ \u5149\u6805\u5316 \u5149\u6805\u5316\u901a\u8fc7\u9876\u70b9\u7740\u8272\u5668\u53ca\u5177\u4f53\u7684\u51e0\u4f55\u7b97\u6cd5\u5c06\u9876\u70b9\u8fdb\u884c\u5851\u5f62\uff0c\u5e76\u5c06\u56fe\u5f62\u4f20\u9012\u5230\u7247\u6bb5\u7740\u8272\u5668\u8fdb\u884c\u7740\u8272\u5de5\u4f5c\u3002\u5b83\u4e5f\u4f1a\u6267\u884c\u6df1\u5ea6\u6d4b\u8bd5 depth testing \u3001\u9762\u88c1\u5207 face culling \u548c\u88c1\u526a\u6d4b\u8bd5\uff0c\u5b83\u53ef\u4ee5\u5bf9\u8f93\u51fa\u7684\u7247\u5143\u8fdb\u884c\u914d\u7f6e\uff0c\u51b3\u5b9a\u662f\u5426\u8f93\u51fa\u6574\u4e2a\u56fe\u5143\u62d3\u6251\u6216\u8005\u662f\u8fb9\u6846(\u7ebf\u6846\u6e32\u67d3)\u3002\u6240\u6709\u7684\u914d\u7f6e\u901a\u8fc7 VkPipelineRasterizationStateCreateInfo \u7ed3\u6784\u4f53\u5b9a\u4e49\u3002 VkPipelineRasterizationStateCreateInfo rasterizer = {}; rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterizer.depthClampEnable = VK_FALSE; C++ \u5b83\u7684 depthClampEnable \u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u8d85\u8fc7\u8fdc\u8fd1\u88c1\u526a\u9762\u7684\u7247\u5143\u4f1a\u8fdb\u884c\u6536\u655b\uff0c\u800c\u4e0d\u662f\u4e22\u5f03\u5b83\u4eec\u3002\u5b83\u5728\u7279\u6b8a\u7684\u60c5\u51b5\u4e0b\u6bd4\u8f83\u6709\u7528\uff0c\u50cf\u9634\u5f71\u8d34\u56fe\u3002\u4f7f\u7528\u8be5\u529f\u80fd\u9700\u8981\u5f97\u5230 GPU \u7684\u652f\u6301\u3002 rasterizer.rasterizerDiscardEnable = VK_FALSE; C++ \u5982\u679c rasterizerDiscardEnable \u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u90a3\u4e48\u51e0\u4f55\u56fe\u5143\u6c38\u8fdc\u4e0d\u4f1a\u4f20\u9012\u5230\u5149\u6805\u5316\u9636\u6bb5\u3002\u8fd9\u662f\u57fa\u672c\u7684\u7981\u6b62\u4efb\u4f55\u8f93\u51fa\u5230framebuffer\u5e27\u7f13\u51b2\u533a\u7684\u65b9\u6cd5\u3002 rasterizer.polygonMode = VK_POLYGON_MODE_FILL; C++ polygonMode \u51b3\u5b9a\u51e0\u4f55\u4ea7\u751f\u56fe\u7247\u7684\u5185\u5bb9\u3002\u4e0b\u5217\u6709\u6548\u6a21\u5f0f: VK_POLYGON_MODE_FILL : \u591a\u8fb9\u5f62\u533a\u57df\u586b\u5145 VK_POLYGON_MODE_LINE : \u591a\u8fb9\u5f62\u8fb9\u7f18\u7ebf\u6846\u7ed8\u5236 VK_POLYGON_MODE_POINT : \u591a\u8fb9\u5f62\u9876\u70b9\u4f5c\u4e3a\u63cf\u70b9\u7ed8\u5236 \u4f7f\u7528\u4efb\u4f55\u6a21\u5f0f\u586b\u5145\u9700\u8981\u5f00\u542fGPU\u529f\u80fd\u3002 rasterizer.lineWidth = 1.0f; C++ lineWidth \u6210\u5458\u662f\u76f4\u63a5\u586b\u5145\u7684\uff0c\u6839\u636e\u7247\u5143\u7684\u6570\u91cf\u63cf\u8ff0\u7ebf\u7684\u5bbd\u5ea6\u3002\u6700\u5927\u7684\u7ebf\u5bbd\u652f\u6301\u53d6\u51b3\u4e8e\u786c\u4ef6\uff0c\u4efb\u4f55\u5927\u4e8e 1.0 \u7684\u7ebf\u5bbd\u9700\u8981\u5f00\u542fGPU\u7684 wideLines \u7279\u6027\u652f\u6301\u3002 rasterizer.cullMode = VK_CULL_MODE_BACK_BIT; rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; C++ cullMode \u53d8\u91cf\u7528\u4e8e\u51b3\u5b9a\u9762\u88c1\u526a\u7684\u7c7b\u578b\u65b9\u5f0f\u3002\u53ef\u4ee5\u7981\u6b62 culling \uff0c\u88c1\u526a front faces \uff0c cull back faces \u6216\u8005\u5168\u90e8\u3002 frontFace \u7528\u4e8e\u63cf\u8ff0\u4f5c\u4e3a front-facing \u9762\u7684\u9876\u70b9\u7684\u987a\u5e8f\uff0c\u53ef\u4ee5\u662f\u987a\u65f6\u9488\u4e5f\u53ef\u4ee5\u662f\u9006\u65f6\u9488\u3002 rasterizer.depthBiasEnable = VK_FALSE; rasterizer.depthBiasConstantFactor = 0.0f; // Optional rasterizer.depthBiasClamp = 0.0f; // Optional rasterizer.depthBiasSlopeFactor = 0.0f; // Optional C++ \u5149\u6805\u5316\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u5e38\u91cf\u6216\u8005\u57fa\u4e8e\u7247\u5143\u7684\u659c\u7387\u6765\u66f4\u6539\u6df1\u5ea6\u503c\u3002\u4e00\u4e9b\u65f6\u5019\u5bf9\u4e8e\u9634\u5f71\u8d34\u56fe\u662f\u6709\u7528\u7684\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u4f1a\u5728\u7ae0\u8282\u4e2d\u4f7f\u7528\uff0c\u8bbe\u7f6e depthBiasEnable \u4e3a VK_FALSE \u3002 \u91cd\u91c7\u6837 VkPipelineMultisampleStateCreateInfo \u7ed3\u6784\u4f53\u7528\u4e8e\u914d\u7f6e\u591a\u91cd\u91c7\u6837\u3002\u6240\u8c13\u591a\u91cd\u91c7\u6837\u662f\u6297\u952f\u9f7f anti-aliasing \u7684\u4e00\u79cd\u5b9e\u73b0\u3002\u5b83\u901a\u8fc7\u7ec4\u5408\u591a\u4e2a\u591a\u8fb9\u5f62\u7684\u7247\u6bb5\u7740\u8272\u5668\u7ed3\u679c\uff0c\u5149\u6805\u5316\u5230\u540c\u4e00\u4e2a\u50cf\u7d20\u3002\u8fd9\u4e3b\u8981\u53d1\u751f\u5728\u8fb9\u7f18\uff0c\u8fd9\u4e5f\u662f\u6700\u5f15\u4eba\u6ce8\u76ee\u7684\u952f\u9f7f\u51fa\u73b0\u7684\u5730\u65b9\u3002\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u591a\u8fb9\u5f62\u6620\u5c04\u5230\u50cf\u7d20\u662f\u4e0d\u9700\u8981\u591a\u6b21\u8fd0\u884c\u7247\u6bb5\u7740\u8272\u5668\u8fdb\u884c\u91c7\u6837\u7684\uff0c\u76f8\u6bd4\u9ad8\u5206\u8fa8\u7387\u6765\u8bf4\uff0c\u5b83\u4f1a\u82b1\u8d39\u8f83\u4f4e\u7684\u5f00\u9500\u3002\u5f00\u542f\u8be5\u529f\u80fd\u9700\u8981GPU\u652f\u6301\u3002 VkPipelineMultisampleStateCreateInfo multisampling = {}; multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampling.sampleShadingEnable = VK_FALSE; multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; multisampling.minSampleShading = 1.0f; // Optional multisampling.pSampleMask = nullptr; // Optional multisampling.alphaToCoverageEnable = VK_FALSE; // Optional multisampling.alphaToOneEnable = VK_FALSE; // Optional C++ \u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u591a\u91cd\u91c7\u6837\uff0c\u4f46\u662f\u53ef\u4ee5\u968f\u610f\u7684\u5c1d\u8bd5\uff0c\u5177\u4f53\u7684\u53c2\u6570\u8bf7\u53c2\u9605\u89c4\u8303\u3002 \u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5 \u5982\u679c\u4f7f\u7528depth \u6216\u8005 stencil\u7f13\u51b2\u533a\uff0c\u9700\u8981\u4f7f\u7528 VkPipelineDepthStencilStateCreateInfo \u914d\u7f6e\u3002\u6211\u4eec\u73b0\u5728\u4e0d\u9700\u8981\u4f7f\u7528\uff0c\u6240\u4ee5\u7b80\u5355\u7684\u4f20\u9012 nullptr \uff0c\u5173\u4e8e\u8fd9\u90e8\u5206\u4f1a\u4e13\u95e8\u5728\u6df1\u5ea6\u7f13\u51b2\u533a\u7ae0\u8282\u4e2d\u8ba8\u8bba\u3002 \u989c\u8272\u6df7\u5408 \u7247\u6bb5\u7740\u8272\u5668\u8f93\u51fa\u5177\u4f53\u7684\u989c\u8272\uff0c\u5b83\u9700\u8981\u4e0e\u5e27\u7f13\u51b2\u533a framebuffer \u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\u3002\u8fd9\u4e2a\u8f6c\u6362\u7684\u8fc7\u7a0b\u6210\u4e3a\u6df7\u8272\uff0c\u5b83\u6709\u4e24\u79cd\u65b9\u5f0f: \u5c06old\u548cnew\u989c\u8272\u8fdb\u884c\u6df7\u5408\u4ea7\u51fa\u4e00\u4e2a\u6700\u7ec8\u7684\u989c\u8272 \u4f7f\u7528\u6309\u4f4d\u64cd\u4f5c\u6df7\u5408old\u548cnew\u989c\u8272\u7684\u503c \u6709\u4e24\u4e2a\u7ed3\u6784\u4f53\u7528\u4e8e\u914d\u7f6e\u989c\u8272\u6df7\u5408\u3002\u7b2c\u4e00\u4e2a\u7ed3\u6784\u4f53 VkPipelineColorBlendAttachmentState \u5305\u62ec\u4e86\u6bcf\u4e2a\u9644\u52a0\u5230\u5e27\u7f13\u51b2\u533a\u7684\u914d\u7f6e\u3002\u7b2c\u4e8c\u4e2a\u7ed3\u6784\u4f53 VkPipelineColorBlendStateCreateInfo \u5305\u542b\u4e86\u5168\u5c40\u6df7\u8272\u7684\u8bbe\u7f6e\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u4ec5\u4f7f\u7528\u7b2c\u4e00\u79cd\u65b9\u5f0f: VkPipelineColorBlendAttachmentState colorBlendAttachment = {}; colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; colorBlendAttachment.blendEnable = VK_FALSE; colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; // Optional colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; // Optional colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; // Optional colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; // Optional C++ \u8fd9\u79cd\u9488\u5bf9\u6bcf\u4e2a\u5e27\u7f13\u51b2\u533a\u914d\u7f6e\u6df7\u8272\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528\u5982\u4e0b\u4f2a\u4ee3\u7801\u8fdb\u884c\u8bf4\u660e: if (blendEnable) { finalColor.rgb = (srcColorBlendFactor * newColor.rgb) <colorBlendOp> (dstColorBlendFactor * oldColor.rgb); finalColor.a = (srcAlphaBlendFactor * newColor.a) <alphaBlendOp> (dstAlphaBlendFactor * oldColor.a); } else { finalColor = newColor; } finalColor = finalColor & colorWriteMask; C++ \u5982\u679c blendEnable \u8bbe\u7f6e\u4e3a VK_FALSE ,\u90a3\u4e48\u4ece\u7247\u6bb5\u7740\u8272\u5668\u8f93\u51fa\u7684\u65b0\u989c\u8272\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u5426\u5219\u4e24\u4e2a\u6df7\u8272\u64cd\u4f5c\u4f1a\u8ba1\u7b97\u65b0\u7684\u989c\u8272\u3002\u6240\u5f97\u5230\u7684\u7ed3\u679c\u4e0e colorWriteMask \u8fdb\u884cAND\u8fd0\u7b97\uff0c\u4ee5\u786e\u5b9a\u5b9e\u9645\u4f20\u9012\u7684\u901a\u9053\u3002 \u5927\u591a\u6570\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u6df7\u8272\u7528\u4e8e\u5b9e\u73b0 alpha blending \uff0c\u65b0\u7684\u989c\u8272\u4e0e\u65e7\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\u4f1a\u57fa\u4e8e\u5b83\u4eec\u7684 opacity \u900f\u660e\u901a\u9053\u3002 finalColor \u4f5c\u4e3a\u6700\u7ec8\u7684\u8f93\u51fa: finalColor.rgb = newAlpha * newColor + (1 - newAlpha) * oldColor; finalColor.a = newAlpha.a; C++ \u53ef\u4ee5\u901a\u8fc7\u4e00\u4e0b\u53c2\u6570\u5b8c\u6210: colorBlendAttachment.blendEnable = VK_TRUE; colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA; colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; C++ \u53ef\u4ee5\u5728\u89c4\u8303\u4e2d\u627e\u5230\u6240\u6709\u6709\u5173 VkBlendFactor \u548c VkBlendOp \u7684\u679a\u4e3e\u503c\u3002 \u7b2c\u4e8c\u4e2a\u7ed3\u6784\u4f53\u6301\u6709\u6240\u6709\u5e27\u7f13\u51b2\u533a\u7684\u5f15\u7528\uff0c\u5b83\u5141\u8bb8\u8bbe\u7f6e\u6df7\u5408\u64cd\u4f5c\u7684\u5e38\u91cf\uff0c\u8be5\u5e38\u91cf\u53ef\u4ee5\u4f5c\u4e3a\u540e\u7eed\u8ba1\u7b97\u7684\u6df7\u5408\u56e0\u5b50: VkPipelineColorBlendStateCreateInfo colorBlending = {}; colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; colorBlending.logicOpEnable = VK_FALSE; colorBlending.logicOp = VK_LOGIC_OP_COPY; // Optional colorBlending.attachmentCount = 1; colorBlending.pAttachments = &colorBlendAttachment; colorBlending.blendConstants[0] = 0.0f; // Optional colorBlending.blendConstants[1] = 0.0f; // Optional colorBlending.blendConstants[2] = 0.0f; // Optional colorBlending.blendConstants[3] = 0.0f; // Optional C++ \u5982\u679c\u9700\u8981\u4f7f\u7528\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u8bbe\u7f6e\u6df7\u5408\u64cd\u4f5c( bitwise combination ), \u9700\u8981\u8bbe\u7f6e logicOpEnable \u4e3a VK_TURE \u3002\u4e8c\u8fdb\u5236\u4f4d\u64cd\u4f5c\u5728 logicOp \u5b57\u6bb5\u4e2d\u6307\u5b9a\u3002\u5728\u7b2c\u4e00\u79cd\u65b9\u5f0f\u4e2d\u4f1a\u81ea\u52a8\u7981\u6b62\uff0c\u7b49\u540c\u4e8e\u4e3a\u6bcf\u4e00\u4e2a\u9644\u52a0\u7684\u5e27\u7f13\u51b2\u533aframebuffer\u5173\u95ed\u6df7\u5408\u64cd\u4f5c\uff0c blendEnable \u4e3a VK_FALSE \u3002 colorWriteMask \u63a9\u7801\u4f1a\u7528\u786e\u5b9a\u5e27\u7f13\u51b2\u533a\u4e2d\u5177\u4f53\u54ea\u4e2a\u901a\u9053\u7684\u989c\u8272\u53d7\u5230\u5f71\u54cd\u3002\u5b83\u4e5f\u53ef\u4ee5\u5728\u4e24\u79cd\u65b9\u5f0f\u4e0b\u7981\u6b62\uff0c\u622a\u81f3\u76ee\u524d\uff0c\u7247\u6bb5\u7f13\u51b2\u533a\u5411\u5e27\u7f13\u51b2\u533a\u4e2d\u8f93\u51fa\u7684\u989c\u8272\u4e0d\u4f1a\u8fdb\u884c\u4efb\u4f55\u53d8\u5316\u3002 \u52a8\u6001\u4fee\u6539 \u4e4b\u524d\u521b\u5efa\u7684\u4e00\u4e9b\u7ed3\u6784\u4f53\u7684\u72b6\u6001\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u52a8\u6001\u4fee\u6539\uff0c\u800c\u4e0d\u5fc5\u91cd\u65b0\u521b\u5efa\u3002\u6bd4\u5982 viewport \u7684\u5927\u5c0f, line width \u548c blend constants \u3002\u5982\u679c\u9700\u8981\u8fdb\u884c\u8fd9\u6837\u7684\u64cd\u4f5c\uff0c\u9700\u8981\u586b\u5145 VkPipelineDynamicStateCreateInfo \u7ed3\u6784\u4f53: VkDynamicState dynamicStates[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_LINE_WIDTH }; VkPipelineDynamicStateCreateInfo dynamicState = {}; dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO; dynamicState.dynamicStateCount = 2; dynamicState.pDynamicStates = dynamicStates; C++ \u5728\u7ed8\u5236\u7684\u8fc7\u7a0b\u4e2d\u6307\u5b9a\u8fd9\u4e9b\u6570\u636e\uff0c\u8fd9\u4f1a\u5bfc\u81f4\u5ffd\u7565\u4e4b\u524d\u7684\u76f8\u5173\u6570\u503c\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7684\u7ae0\u8282\u4e2d\u56de\u8fc7\u5934\u6765\u8ba8\u8bba\u3002\u5982\u679c\u6ca1\u6709\u4efb\u4f55\u9700\u8981\u52a8\u6001\u4fee\u6539\u7684\u6570\u503c\u6e05\u8bbe\u7f6e\u4e3a nullptr \u3002 \u7ba1\u9053\u5e03\u5c40 \u53ef\u4ee5\u5728\u7740\u8272\u5668\u4e2d\u4f7f\u7528 uniform \uff0c\u5b83\u662f\u7c7b\u4f3c\u4e0e\u52a8\u6001\u72b6\u6001\u53d8\u91cf\u7684\u5168\u5c40\u53d8\u91cf\uff0c\u53ef\u4ee5\u5728\u7ed8\u753b\u65f6\u4fee\u6539\uff0c\u53ef\u4ee5\u66f4\u6539\u7740\u8272\u5668\u7684\u884c\u4e3a\u800c\u65e0\u9700\u91cd\u65b0\u521b\u5efa\u5b83\u4eec\u3002\u5b83\u4eec\u901a\u5e38\u7528\u4e8e\u5c06\u53d8\u6362\u77e9\u9635\u4f20\u9012\u5230\u9876\u70b9\u7740\u8272\u5668\u6216\u8005\u5728\u7247\u6bb5\u7740\u8272\u5668\u51b2\u521b\u5efa\u7eb9\u7406\u91c7\u6837\u5668\u3002 \u8fd9\u4e9b uniform \u6570\u503c\u9700\u8981\u5728\u7ba1\u7ebf\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u901a\u8fc7 VkPipelineLayout \u5bf9\u8c61\u6307\u5b9a\u3002\u5373\u4f7f\u5728\u540e\u7eed\u5185\u5bb9\u4e2d\u7528\u5230\uff0c\u6211\u4eec\u4e5f\u4ecd\u7136\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u7a7a\u7684 pipeline layout \u3002 \u521b\u5efa\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709\u8be5\u5bf9\u8c61\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u540e\u7eed\u7ae0\u8282\u4e2d\u7684\u51fd\u6570\u4e2d\u5f15\u7528\u5b83: VkPipelineLayout pipelineLayout; C++ \u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u521b\u5efa\u5bf9\u8c61: VkPipelineLayoutCreateInfo pipelineLayoutInfo = {}; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; // Optional pipelineLayoutInfo.pSetLayouts = nullptr; // Optional pipelineLayoutInfo.pushConstantRangeCount = 0; // Optional pipelineLayoutInfo.pPushConstantRanges = 0; // Optional if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) { throw std::runtime_error(\"failed to create pipeline layout!\"); } C++ \u8be5\u7ed3\u6784\u4f53\u8fd8\u6307\u5b9a\u4e86 push \u5e38\u91cf\uff0c\u8fd9\u662f\u5c06\u52a8\u6001\u503c\u4f20\u9012\u7ed9\u7740\u8272\u5668\u7684\u62ce\u4e00\u4e2a\u65b9\u5f0f\u3002 pipeline layout \u53ef\u4ee5\u5728\u6574\u4e2a\u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\u5185\u5f15\u7528\uff0c\u6240\u4ee5\u5b83\u5728\u7a0b\u5e8f\u9000\u51fa\u7684\u65f6\u5019\u8fdb\u884c\u9500\u6bc1\u3002 void cleanup() { vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ... } C++ \u7ed3\u8bba \u8fd9\u5c31\u662f\u6240\u6709\u6709\u5173 fixed-function \u7684\u5185\u5bb9\uff0c\u770b\u8d77\u6765\u6709\u5f88\u591a\u7684\u5de5\u4f5c\u53bb\u505a\uff0c\u503c\u5f97\u5e86\u5e78\u7684\u662f\u6211\u4eec\u51e0\u4e4e\u4e86\u89e3\u4e86\u6240\u6709\u6709\u5173\u6e32\u67d3\u7ba1\u7ebf\u7684\u5185\u5bb9\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u51cf\u5c11\u4e86\u56e0\u4e3a\u4e0d\u4e86\u89e3\u67d0\u4e9b\u7ec4\u4ef6\u7684\u9ed8\u8ba4\u72b6\u6001\uff0c\u800c\u9020\u6210\u8fd0\u884c\u65f6\u78b0\u5230\u672a\u77e5\u884c\u4e3a\u7684\u53ef\u80fd\u6027\u3002 \u7136\u800c\uff0c\u5728\u6211\u4eec\u53ef\u4ee5\u6700\u7ec8\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u4e4b\u524d\uff0c\u8fd8\u6709\u4e00\u4e2a\u5bf9\u8c61\u9700\u8981\u521b\u5efa\uff0c\u5b83\u5c31\u662f render pass \u3002 Vulkan \u5e27\u7f13\u51b2\u533a Vulkan \u5e27\u7f13\u51b2\u533a \uff0c\u6211\u4eec\u5728\u524d\u9762\u7684\u7ae0\u8282\u4e2d\u5df2\u7ecf\u8ba8\u8bba\u4e86\u5f88\u591a\u6b21 framebuffers \u5e27\u7f13\u51b2\u533a\uff0c\u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u914d\u7f6e\u4e86 render pass \u6e32\u67d3\u901a\u9053\u5e76\u5e0c\u671b\u8f93\u51fa\u4e00\u4e2a\u4e0e\u4ea4\u6362\u94fe\u56fe\u50cf\u683c\u5f0f\u4e00\u81f4\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u4f46\u662f\u6211\u4eec\u5b9e\u9645\u4e0a\u8fd8\u6ca1\u6709\u521b\u5efa\u3002 \u5728 render pass \u521b\u5efa\u9636\u6bb5\u6211\u4eec\u6307\u5b9a\u4e86\u5177\u4f53\u7684\u9644\u4ef6\uff0c\u5e76\u901a\u8fc7 VkFramebuffer \u5bf9\u8c61\u5305\u88c5\u7ed1\u5b9a\u3002\u5e27\u7f13\u51b2\u533a\u5bf9\u8c61\u5f15\u7528\u8868\u793a\u4e3a\u9644\u4ef6\u7684\u6240\u6709\u7684 VkImageView \u5bf9\u8c61\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u53ea\u4f1a\u4f7f\u7528\u4e00\u4e2a\u5e27\u7f13\u51b2\u533a: color attachment \u3002\u7136\u800c\u6211\u4eec\u4f5c\u4e3a\u9644\u4ef6\u7684\u56fe\u50cf\u4f9d\u8d56\u4ea4\u6362\u94fe\u7528\u4e8e\u5448\u73b0\u65f6\u8fd4\u56de\u7684\u56fe\u50cf\u3002\u8fd9\u610f\u5473\u7740\u6211\u4eec\u5fc5\u987b\u4e3a\u4ea4\u6362\u94fe\u4e2d\u7684\u6240\u6709\u56fe\u50cf\u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u5728\u7ed8\u5236\u7684\u65f6\u5019\u4f7f\u7528\u5bf9\u5e94\u7684\u56fe\u50cf\u3002 \u6700\u540e\uff0c\u5728\u7c7b\u6210\u5458\u4e2d\u521b\u5efa\u53e6\u4e00\u4e2a std::vector \u7528\u4e8e\u4fdd\u5b58 framebuffers : std::vector<VkFramebuffer> swapChainFramebuffers; C++ \u6211\u4eec\u5728\u65b0\u7684\u51fd\u6570 createFramebuffers \u4e2d\u4e3a\u6570\u7ec4\u521b\u5efa\u5bf9\u8c61\u96c6\u5408\uff0c\u8fd9\u4e2a\u51fd\u6570\u5728 initVulkan \u521b\u5efa\u5b8c\u7ba1\u7ebf\u540e\u8c03\u7528: void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); } ... void createFramebuffers() { } C++ \u52a8\u6001\u8c03\u6574\u7528\u4e8e\u4fdd\u5b58 framebuffers \u7684\u5bb9\u5668\u5927\u5c0f: void createFramebuffers() { swapChainFramebuffers.resize(swapChainImageViews.size()); } C++ \u6211\u4eec\u63a5\u4e0b\u6765\u8fed\u4ee3\u5de6\u53f3\u7684\u56fe\u50cf\u89c6\u56fe\u5e76\u901a\u8fc7\u5b83\u4eec\u521b\u5efa\u5bf9\u5e94\u7684 framebuffers : for (size_t i = 0; i < swapChainImageViews.size(); i++) { VkImageView attachments[] = { swapChainImageViews[i] }; VkFramebufferCreateInfo framebufferInfo = {}; framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; framebufferInfo.renderPass = renderPass; framebufferInfo.attachmentCount = 1; framebufferInfo.pAttachments = attachments; framebufferInfo.width = swapChainExtent.width; framebufferInfo.height = swapChainExtent.height; framebufferInfo.layers = 1; if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &swapChainFramebuffers[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to create framebuffer!\"); } } C++ \u5982\u4f60\u6240\u89c1\uff0c\u521b\u5efa framebuffers \u662f\u975e\u5e38\u76f4\u63a5\u7684\u3002\u9996\u5148\u9700\u8981\u6307\u5b9a framebuffer \u9700\u8981\u517c\u5bb9\u7684 renderPass \u3002\u6211\u4eec\u53ea\u80fd\u4f7f\u7528\u4e0e\u5176\u517c\u5bb9\u7684\u6e32\u67d3\u901a\u9053\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u8fd9\u5927\u4f53\u4e0a\u610f\u5473\u7740\u5b83\u4eec\u4f7f\u7528\u76f8\u540c\u7684\u9644\u4ef6\u6570\u91cf\u548c\u7c7b\u578b\u3002 attachmentCount \u548c pAttachments \u53c2\u6570\u6307\u5b9a\u5728\u6e32\u67d3\u901a\u9053\u7684 pAttachment \u6570\u7ec4\u4e2d\u7ed1\u5b9a\u5230\u76f8\u5e94\u7684\u9644\u4ef6\u63cf\u8ff0\u7684 VkImageView \u5bf9\u8c61\u3002 width \u548c height \u53c2\u6570\u662f\u5bb9\u6613\u7406\u89e3\u7684\uff0c layer \u662f\u6307\u5b9a\u56fe\u50cf\u6570\u7ec4\u4e2d\u7684\u5c42\u6570\u3002\u6211\u4eec\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u662f\u5355\u4e2a\u56fe\u50cf\uff0c\u56e0\u6b64\u5c42\u6570\u4e3a 1 \u3002 \u6211\u4eec\u5728\u56fe\u50cf\u89c6\u56fe\u548c\u6e32\u67d3\u901a\u9053\u6e32\u67d3\u5b8c\u6bd5\u4e4b\u540e\uff0c\u5220\u9664\u5bf9\u5e94\u7684\u5e27\u7f13\u51b2\u533a: void cleanup() { for (size_t i = 0; i < swapChainFramebuffers.size(); i++) { vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); } ... } C++ \u6211\u4eec\u5df2\u7ecf\u8fbe\u5230\u4e86\u4e00\u4e2a\u91cc\u7a0b\u7891\uff0c\u6211\u4eec\u62e5\u6709\u6e32\u67d3\u9700\u8981\u7684\u6240\u6709\u5bf9\u8c61\u3002\u5728\u4e0b\u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u7f16\u5199\u7b2c\u4e00\u4e2a\u5b9e\u9645\u7ed8\u5236\u7684\u547d\u4ee4\u3002 Vulkan \u6e32\u67d3\u901a\u9053 Vulkan \u6e32\u67d3\u901a\u9053 \uff0c\u5728\u6211\u4eec\u5b8c\u6210\u7ba1\u7ebf\u7684\u521b\u5efa\u5de5\u4f5c\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9 Vulkan \u6e32\u67d3\u65f6\u5019\u4f7f\u7528\u7684 framebuffer \u5e27\u7f13\u51b2\u533a\u9644\u4ef6\u76f8\u5173\u4fe1\u606f\u3002\u6211\u4eec\u9700\u8981\u6307\u5b9a\u591a\u5c11\u4e2a\u989c\u8272\u548c\u6df1\u5ea6\u7f13\u51b2\u533a\u5c06\u4f1a\u88ab\u4f7f\u7528\uff0c\u6307\u5b9a\u591a\u5c11\u4e2a\u91c7\u6837\u5668\u88ab\u7528\u5230\u53ca\u5728\u6574\u4e2a\u6e32\u67d3\u64cd\u4f5c\u4e2d\u76f8\u5173\u7684\u5185\u5bb9\u5982\u4f55\u5904\u7406\u3002\u6240\u6709\u7684\u8fd9\u4e9b\u4fe1\u606f\u90fd\u88ab\u5c01\u88c5\u5728\u4e00\u4e2a\u53eb\u505a render pass \u7684\u5bf9\u8c61\u4e2d\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u8bbe\u7f6e 2 \u9644\u4ef6\u63cf\u8ff0 3 \u5b50\u901a\u9053\u548c\u9644\u4ef6\u5f15\u7528 4 \u6e32\u67d3\u901a\u9053 \u8bbe\u7f6e \u6211\u4eec\u65b0\u6dfb\u52a0\u4e00\u4e2a createRenderPass \u51fd\u6570\uff0c\u5728 initVulkan \u51fd\u6570\u4e2d\u786e\u4fdd createGraphicsPipeline \u8c03\u7528\u4e4b\u524d\uff0c\u8c03\u7528\u5b83\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); } ... void createRenderPass() { } C++ \u9644\u4ef6\u63cf\u8ff0 \u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u5c06\u53ea\u6709\u4e00\u4e2a\u989c\u8272\u7f13\u51b2\u533a\u9644\u4ef6\uff0c\u5b83\u7531\u4ea4\u6362\u94fe\u4e2d\u7684\u4e00\u4e2a\u56fe\u50cf\u6240\u8868\u793a\u3002 void createRenderPass() { VkAttachmentDescription colorAttachment = {}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; } C++ format \u662f\u989c\u8272\u9644\u4ef6\u7684\u683c\u5f0f\uff0c\u5b83\u5e94\u8be5\u4e0e\u4ea4\u6362\u94fe\u4e2d\u56fe\u50cf\u7684\u683c\u5f0f\u76f8\u5339\u914d\uff0c\u540c\u65f6\u6211\u4eec\u4e0d\u4f1a\u505a\u4efb\u4f55\u591a\u91cd\u91c7\u6837\u7684\u5de5\u4f5c\uff0c\u6240\u4ee5\u91c7\u6837\u5668\u8bbe\u7f6e\u4e3a1\u3002 colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; C++ loadOp \u548c storeOp \u51b3\u5b9a\u4e86\u6e32\u67d3\u524d\u548c\u6e32\u67d3\u540e\u6570\u636e\u5728\u5bf9\u5e94\u9644\u4ef6\u7684\u64cd\u4f5c\u884c\u4e3a\u3002\u5bf9\u4e8e loadOp \u6211\u4eec\u6709\u5982\u4e0b\u9009\u9879\uff1a VK_ATTACHMENT_LOAD_OP_LOAD : \u4fdd\u5b58\u5df2\u7ecf\u5b58\u5728\u4e8e\u5f53\u524d\u9644\u4ef6\u7684\u5185\u5bb9 VK_ATTACHMENT_LOAD_OP_CLEAR : \u8d77\u59cb\u9636\u6bb5\u4ee5\u4e00\u4e2a\u5e38\u91cf\u6e05\u7406\u9644\u4ef6\u5185\u5bb9 VK_ATTACHMENT_LOAD_OP_DONT_CARE : \u5b58\u5728\u7684\u5185\u5bb9\u672a\u5b9a\u4e49\uff0c\u5ffd\u7565\u5b83\u4eec \u5728\u7ed8\u5236\u65b0\u7684\u4e00\u5e27\u5185\u5bb9\u4e4b\u524d\uff0c\u6211\u4eec\u8981\u505a\u7684\u662f\u4f7f\u7528\u6e05\u7406\u64cd\u4f5c\u6765\u6e05\u7406\u5e27\u7f13\u51b2\u533aframebuffer\u4e3a\u9ed1\u8272\u3002\u540c\u65f6\u5bf9\u4e8e storeOp \u4ec5\u6709\u4e24\u4e2a\u9009\u9879\uff1a VK_ATTACHMENT_STORE_OP_STORE : \u6e32\u67d3\u7684\u5185\u5bb9\u4f1a\u5b58\u50a8\u5728\u5185\u5b58\uff0c\u5e76\u5728\u4e4b\u540e\u8fdb\u884c\u8bfb\u53d6\u64cd\u4f5c VK_ATTACHMENT_STORE_OP_DONT_CARE : \u5e27\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u5728\u6e32\u67d3\u64cd\u4f5c\u5b8c\u6bd5\u540e\u8bbe\u7f6e\u4e3aundefined \u6211\u4eec\u8981\u505a\u7684\u662f\u6e32\u67d3\u4e00\u4e2a\u4e09\u89d2\u5f62\u5728\u5c4f\u5e55\u4e0a\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u5b58\u50a8\u64cd\u4f5c\u3002 colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; C++ loadOp \u548c storeOp \u5e94\u7528\u5728\u989c\u8272\u548c\u6df1\u5ea6\u6570\u636e\uff0c\u540c\u65f6 stencilLoadOp / stencilStoreOp \u5e94\u7528\u5728\u6a21\u7248\u6570\u636e\u3002\u6211\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u4e0d\u4f1a\u505a\u4efb\u4f55\u6a21\u7248\u7f13\u51b2\u533a\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u5b83\u7684loading\u548cstoring\u65e0\u5173\u7d27\u8981\u3002 colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; C++ \u7eb9\u7406\u548c\u5e27\u7f13\u51b2\u533a\u5728Vulkan\u4e2d\u901a\u5e38\u7528 VkImage \u5bf9\u8c61\u914d\u4ee5\u67d0\u79cd\u50cf\u7d20\u683c\u5f0f\u6765\u4ee3\u8868\u3002\u4f46\u662f\u50cf\u7d20\u5728\u5185\u5b58\u4e2d\u7684\u5e03\u5c40\u53ef\u4ee5\u57fa\u4e8e\u9884\u8981\u5bf9image\u56fe\u50cf\u8fdb\u884c\u7684\u64cd\u4f5c\u53d1\u751f\u5185\u5b58\u5e03\u5c40\u7684\u53d8\u5316\u3002 \u4e00\u4e9b\u5e38\u7528\u7684\u5e03\u5c40: VK_IMAGE_LAYOUT_COLOR_ATTACHMET_OPTIMAL : \u56fe\u50cf\u4f5c\u4e3a\u989c\u8272\u9644\u4ef6 VK_IMAGE_LAYOUT_PRESENT_SRC_KHR : \u56fe\u50cf\u5728\u4ea4\u6362\u94fe\u4e2d\u88ab\u5448\u73b0 VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL : \u56fe\u50cf\u4f5c\u4e3a\u76ee\u6807\uff0c\u7528\u4e8e\u5185\u5b58COPY\u64cd\u4f5c \u6211\u4eec\u4f1a\u6df1\u5165\u8ba8\u8bba\u8fd9\u4e9b\u5185\u5bb9\u5728\u7eb9\u7406\u7ae0\u8282\uff0c\u73b0\u5728\u6700\u91cd\u8981\u7684\u662f\u4e3a\u9700\u8981\u8f6c\u53d8\u7684\u56fe\u50cf\u6307\u5b9a\u5408\u9002\u7684layout\u5e03\u5c40\u8fdb\u884c\u64cd\u4f5c\u3002 initialLayout \u6307\u5b9a\u56fe\u50cf\u5728\u5f00\u59cb\u8fdb\u5165\u6e32\u67d3\u901a\u9053render pass\u524d\u5c06\u8981\u4f7f\u7528\u7684\u5e03\u5c40\u7ed3\u6784\u3002 finalLayout \u6307\u5b9a\u5f53\u6e32\u67d3\u901a\u9053\u7ed3\u675f\u81ea\u52a8\u53d8\u6362\u65f6\u4f7f\u7528\u7684\u5e03\u5c40\u3002\u4f7f\u7528 VK_IMAGE_LAYOUT_UNDEFINED \u8bbe\u7f6e initialLayout \uff0c\u610f\u4e3a\u4e0d\u5173\u5fc3\u56fe\u50cf\u4e4b\u524d\u7684\u5e03\u5c40\u3002\u7279\u6b8a\u503c\u8868\u660e\u56fe\u50cf\u7684\u5185\u5bb9\u4e0d\u786e\u5b9a\u4f1a\u88ab\u4fdd\u7559\uff0c\u4f46\u662f\u8fd9\u5e76\u4e0d\u603b\u8981\uff0c\u56e0\u4e3a\u65e0\u8bba\u5982\u4f55\u6211\u4eec\u90fd\u8981\u6e05\u7406\u5b83\u3002\u6211\u4eec\u5e0c\u671b\u56fe\u50cf\u6e32\u67d3\u5b8c\u6bd5\u540e\u4f7f\u7528\u4ea4\u6362\u94fe\u8fdb\u884c\u5448\u73b0\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48 finalLayout \u8981\u8bbe\u7f6e\u4e3a VK_IMAGE_LAYOUT_PRESENT_SRC_KHR \u3002 \u5982\u679c\u6ca1\u6709\u641e\u6e05\u695a\u5e03\u5c40\u5b58\u5728\u7684\u610f\u4e49\uff0c\u8fdb\u4e00\u6b65\u89e3\u91calayout\u8bf7\u770b\u5982\u4e0b\u56fe\u793a: \u4e00\u822c\u610f\u4e49\u4e0a\uff0c\u6211\u4eec\u7406\u89e3 CPU \u8fdb\u884c\u5185\u5b58\u4e2d\u7684\u6570\u636e\u8bfb\u5199\u5f80\u5f80\u90fd\u662f\u7ebf\u6027\u6392\u5e8f\u7684 linear memory layout \uff0c\u53ef\u4ee5\u770b\u5230 AB \u4e0e CD \u4f5c\u4e3a\u6765\u4e2a\u8fde\u7eed\u7684\u884c\u6765\u8fdb\u884c\u8bfb\u53d6\u3002\u4f46\u662f\u5728\u5f88\u591a\u65f6\u5019\u5bf9\u4e8e\u50cf\u7d20\u7eb9\u7406\u6570\u636e\u7684\u64cd\u4f5c\u662f\u975e\u7ebf\u6027\u8fde\u7eed\u7684\uff0c\u8fd9\u79cd\u60c5\u666f\u66f4\u591a\u53d1\u751f\u5728 GPU \u64cd\u4f5c\u4e2d\uff0c\u6240\u4ee5 GPU \u786c\u4ef6\u66f4\u591a\u7684\u652f\u6301\u57fa\u4e8e( Tiled )\u5e73\u94fa\u7684\u6216\u8005\u6210\u4e3a\u6700\u4f73\u7684\u5185\u5b58\u5e03\u5c40\u7ed3\u6784\uff0c\u6765\u63d0\u964d\u4f4e GPU \u5904\u7406\u6570\u636e\u7684\u5f00\u9500\u3002 \u6240\u4ee5\u4ece CPU linear layout \u5185\u5b58\u6570\u636e \u5230 GPU optimal layout \u663e\u5b58\u6570\u636e\u7684\u8bfb\u5199 \u5f80\u8fd4\u4e4b\u95f4\u5b58\u5728\u6570\u636e\u5b58\u50a8\u683c\u5f0f\u7684\u4f18\u5316\u8f6c\u53d8\u6b65\u9aa4\u3002 \u5b50\u901a\u9053\u548c\u9644\u4ef6\u5f15\u7528 \u4e00\u4e2a\u5355\u72ec\u7684\u6e32\u67d3\u901a\u9053\u53ef\u4ee5\u7531\u591a\u4e2a\u5b50\u901a\u9053\u7ec4\u6210\u3002\u5b50\u901a\u9053\u662f\u6e32\u67d3\u64cd\u4f5c\u7684\u4e00\u4e2a\u5e8f\u5217\u3002\u5b50\u901a\u9053\u4f5c\u7528\u4e0e\u540e\u7eed\u7684\u6e32\u67d3\u64cd\u4f5c\uff0c\u5e76\u4f9d\u8d56\u4e4b\u524d\u6e32\u67d3\u901a\u9053\u8f93\u51fa\u5230\u5e27\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u3002\u6bd4\u5982\u8bf4\u540e\u5904\u7406\u6548\u679c\u7684\u5e8f\u5217\u901a\u5e38\u6bcf\u4e00\u6b65\u90fd\u4f9d\u8d56\u4e4b\u524d\u7684\u64cd\u4f5c\u3002\u5982\u679c\u5c06\u8fd9\u4e9b\u6e32\u67d3\u64cd\u4f5c\u5206\u7ec4\u5230\u4e00\u4e2a\u6e32\u67d3\u901a\u9053\u4e2d\uff0c\u901a\u8fc7 Vulkan \u5c06\u901a\u9053\u4e2d\u7684\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u91cd\u6392\u5e8f\uff0c\u53ef\u4ee5\u8282\u7701\u5185\u5b58\u4ece\u800c\u83b7\u5f97\u66f4\u597d\u7684\u6027\u80fd\u3002\u5bf9\u4e8e\u6211\u4eec\u8981\u7ed8\u5236\u7684\u4e09\u89d2\u5f62\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4e00\u4e2a\u5b50\u901a\u9053\u3002 \u6bcf\u4e2a\u5b50\u901a\u9053\u5f15\u7528\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\u4e4b\u524d\u4f7f\u7528\u7ed3\u6784\u4f53\u63cf\u8ff0\u7684\u9644\u4ef6\u3002\u8fd9\u4e9b\u5f15\u7528\u672c\u8eab\u5c31\u662f VkAttachmentReference \u7ed3\u6784\u4f53: VkAttachmentReference colorAttachmentRef = {}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; C++ attachment \u9644\u4ef6\u53c2\u6570\u901a\u8fc7\u9644\u4ef6\u63cf\u8ff0\u7b26\u96c6\u5408\u4e2d\u7684\u7d22\u5f15\u6765\u6301\u6709\u3002\u6211\u4eec\u7684\u96c6\u5408\u662f\u7531\u4e00\u4e2a VkAttachmentDesription \u7ec4\u6210\u7684\uff0c\u6240\u4ee5\u5b83\u7684\u7d22\u5f15\u4e3a 0 \u3002 layout \u4e3a\u9644\u4ef6\u6307\u5b9a\u5b50\u901a\u9053\u5728\u6301\u6709\u5f15\u7528\u65f6\u5019\u7684layout\u3002\u5f53\u5b50\u901a\u9053\u5f00\u59cb\u7684\u65f6\u5019Vulkan\u4f1a\u81ea\u52a8\u8f6c\u53d8\u9644\u4ef6\u5230\u8fd9\u4e2alayout\u3002\u56e0\u4e3a\u6211\u4eec\u671f\u671b\u9644\u4ef6\u8d77\u5230\u989c\u8272\u7f13\u51b2\u533a\u7684\u4f5c\u7528\uff0clayout\u8bbe\u7f6e\u4e3a VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL \u4f1a\u7ed9\u6211\u4eec\u6700\u597d\u7684\u6027\u80fd\u3002 \u5b50\u901a\u9053\u4f7f\u7528 VkSubpassDescription \u7ed3\u6784\u4f53\u63cf\u8ff0: VkSubpassDescription subpass = {}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; C++ Vulkan\u5728\u672a\u6765\u53ef\u80fd\u4f1a\u652f\u6301\u5173\u4e8e compute subpasses \u7684\u529f\u80fd\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u4eec\u660e\u786e\u6307\u5b9a graphics subpass \u56fe\u5f62\u5b50\u901a\u9053\u3002\u4e0b\u4e00\u6b65\u4e3a\u5b83\u6307\u5b9a\u989c\u8272\u9644\u4ef6\u7684\u5f15\u7528: subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; C++ \u9644\u4ef6\u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15\u76f4\u63a5\u4ece\u7247\u6bb5\u7740\u8272\u5668\u5f15\u7528\uff0c\u5176 layout(location = 0) out vec4 outColor \u6307\u4ee4! \u53ef\u4ee5\u88ab\u5b50\u901a\u9053\u5f15\u7528\u7684\u9644\u4ef6\u7c7b\u578b\u5982\u4e0b: pInputAttachments : \u9644\u4ef6\u4ece\u7740\u8272\u5668\u4e2d\u8bfb\u53d6 pResolveAttachments : \u9644\u4ef6\u7528\u4e8e\u989c\u8272\u9644\u4ef6\u7684\u591a\u91cd\u91c7\u6837 pDepthStencilAttachment : \u9644\u4ef6\u7528\u4e8e\u6df1\u5ea6\u548c\u6a21\u7248\u6570\u636e pPreserveAttachments : \u9644\u4ef6\u4e0d\u88ab\u5b50\u901a\u9053\u4f7f\u7528\uff0c\u4f46\u662f\u6570\u636e\u88ab\u4fdd\u5b58 \u6e32\u67d3\u901a\u9053 \u73b0\u5728\u9644\u4ef6\u548c\u57fa\u672c\u7684\u5b50\u901a\u9053\u5df2\u7ecf\u4ecb\u7ecd\u8fc7\u4e86\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u6e32\u67d3\u901a\u9053\u4e86\u3002\u9996\u5148\u65b0\u5efa\u4e00\u4e2a\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709 VkRenderPass \u5bf9\u8c61\uff0c\u8be5\u53d8\u91cf\u5728 pipelineLayout \u4e0a\u5b9a\u4e49: VkRenderPass renderPass; VkPipelineLayout pipelineLayout; C++ \u6e32\u67d3\u901a\u9053\u5bf9\u8c61\u521b\u5efa\u901a\u8fc7\u586b\u5145 VkRenderPassCreateInfo \u7ed3\u6784\u4f53\uff0c\u5e76\u914d\u5408\u76f8\u5173\u9644\u4ef6\u548c\u5b50\u901a\u9053\u6765\u5b8c\u6210\u3002 VkAttachmentReference \u5bf9\u8c61\u5f15\u7528\u9644\u4ef6\u6570\u7ec4\u3002 VkRenderPassCreateInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } C++ \u5c31\u50cf pipeline layout \u4e00\u6837\uff0c\u6e32\u67d3\u901a\u9053\u5728\u6574\u4e2a\u7a0b\u5e8f\u751f\u547d\u5468\u671f\u5185\u90fd\u88ab\u4f7f\u7528\uff0c\u6240\u4ee5\u9700\u8981\u5728\u9000\u51fa\u9636\u6bb5\u8fdb\u884c\u6e05\u7406\uff1a void cleanup() { vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); ... } C++ \u8fd9\u770b\u8d77\u6765\u5f88\u591a\u5de5\u4f5c\u91cf\uff0c\u4f46\u662f\u5728 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u4f1a\u628a\u6240\u6709\u7684\u7ec4\u4ef6\u6574\u5408\u8d77\u6765\uff0c\u521b\u5efa\u6700\u7ec8\u7684\u56fe\u5f62\u7ba1\u7ebf\u5bf9\u8c61\u3002 Vulkan \u96c6\u6210\u7ba1\u7ebf ulkan \u96c6\u6210\u7ba1\u7ebf \uff0c\u6211\u4eec\u73b0\u5728\u6574\u5408\u524d\u51e0\u7ae0\u8282\u7684\u7ed3\u6784\u4f53\u548c \u5bf9\u8c61\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf \uff01\u4ee5\u4e0b\u662f\u6211\u4eec\u73b0\u5728\u7528\u5230\u7684\u5bf9\u8c61\u7c7b\u578b\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u5feb\u901f\u56de\u987e: Shader stages : \u7740\u8272\u5668\u6a21\u5757\u5b9a\u4e49\u4e86\u56fe\u5f62\u7ba1\u7ebf\u53ef\u7f16\u7a0b\u9636\u6bb5\u7684\u529f\u80fd Fixed-function state : \u7ed3\u6784\u4f53\u5b9a\u4e49\u56fa\u5b9a\u7ba1\u7ebf\u529f\u80fd\uff0c\u6bd4\u5982\u8f93\u5165\u88c5\u914d\u3001\u5149\u6805\u5316\u3001viewport\u548ccolor blending Pipeline layout : \u7ba1\u7ebf\u5e03\u5c40\u5b9a\u4e49uniform \u548c push values\uff0c\u88ab\u7740\u8272\u5668\u6bcf\u4e00\u6b21\u7ed8\u5236\u7684\u65f6\u5019\u5f15\u7528 Render pass : \u6e32\u67d3\u901a\u9053\u901a\u8fc7\u7ba1\u7ebf\u9636\u6bb5\u5f15\u7528\u9644\u4ef6\uff0c\u5e76\u5b9a\u4e49\u5b83\u7684\u4f7f\u7528\u65b9\u5f0f \u6240\u6709\u8fd9\u4e9b\u51b3\u5b9a\u4e86\u56fe\u5f62\u7ba1\u7ebf\u7684\u6700\u7ec8\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u5728 createGraphicsPipeline \u51fd\u6570\u7684\u6700\u540e\u586b\u5145 VkGraphicsPipelineCreateInfo \u7ed3\u6784\u4f53\u3002 VkGraphicsPipelineCreateInfo pipelineInfo = {}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 2; pipelineInfo.pStages = shaderStages; C++ \u73b0\u5728\u5f00\u59cb\u5f15\u7528\u4e4b\u524d\u7684 VkPipelineShaderStageCreateInfo \u7ed3\u6784\u4f53\u6570\u7ec4\u3002 pipelineInfo.pVertexInputState = &vertexInputInfo; pipelineInfo.pInputAssemblyState = &inputAssembly; pipelineInfo.pViewportState = &viewportState; pipelineInfo.pRasterizationState = &rasterizer; pipelineInfo.pMultisampleState = &multisampling; pipelineInfo.pDepthStencilState = nullptr; // Optional pipelineInfo.pColorBlendState = &colorBlending; pipelineInfo.pDynamicState = nullptr; // Optional C++ \u5e76\u5f15\u7528\u4e4b\u524d\u63cf\u8ff0\u56fa\u5b9a\u7ba1\u7ebf\u529f\u80fd\u7684\u7ed3\u6784\u4f53\u3002 pipelineInfo.layout = pipelineLayout; C++ \u5b8c\u6210\u4e4b\u540e\uff0c pipeline layout \u7ba1\u7ebf\u5e03\u5c40\uff0c\u5b83\u662f\u4e00\u4e2a Vulkan \u53e5\u67c4\u800c\u4e0d\u662f\u7ed3\u6784\u4f53\u6307\u9488\u3002 pipelineInfo.renderPass = renderPass; pipelineInfo.subpass = 0; C++ \u6700\u540e\u6211\u4eec\u9700\u8981\u5f15\u7528 render pass \u548c\u56fe\u5f62\u7ba1\u7ebf\u5c06\u8981\u4f7f\u7528\u7684\u5b50\u901a\u9053 sub pass \u7684\u7d22\u5f15\u3002 pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; // Optional pipelineInfo.basePipelineIndex = -1; // Optional C++ \u5b9e\u9645\u4e0a\u8fd8\u6709\u4e24\u4e2a\u53c2\u6570: basePipelineHandle \u548c basePipelineIndex \u3002Vulkan\u5141\u8bb8\u60a8\u901a\u8fc7\u5df2\u7ecf\u5b58\u5728\u7684\u7ba1\u7ebf\u521b\u5efa\u65b0\u7684\u56fe\u5f62\u7ba1\u7ebf\u3002\u8fd9\u79cd\u884d\u751f\u51fa\u65b0\u7ba1\u7ebf\u7684\u60f3\u6cd5\u5728\u4e8e\uff0c\u5f53\u8981\u521b\u5efa\u7684\u7ba1\u7ebf\u4e0e\u73b0\u6709\u7ba1\u9053\u529f\u80fd\u76f8\u540c\u65f6\uff0c\u83b7\u5f97\u8f83\u4f4e\u7684\u5f00\u9500\uff0c\u540c\u65f6\u4e5f\u53ef\u4ee5\u66f4\u5feb\u7684\u5b8c\u6210\u7ba1\u7ebf\u5207\u6362\uff0c\u5f53\u5b83\u4eec\u6765\u81ea\u540c\u4e00\u4e2a\u7236\u7ba1\u7ebf\u3002\u53ef\u4ee5\u901a\u8fc7 basePipelineHandle \u6307\u5b9a\u73b0\u6709\u7ba1\u7ebf\u7684\u53e5\u67c4\uff0c\u4e5f\u53ef\u4ee5\u5f15\u7528\u7531 basePipelineIndex \u6240\u4ee5\u521b\u5efa\u7684\u53e6\u4e00\u4e2a\u7ba1\u7ebf\u3002\u76ee\u524d\u53ea\u6709\u4e00\u4e2a\u7ba1\u7ebf\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u6307\u5b9a\u4e00\u4e2a\u7a7a\u53e5\u67c4\u548c\u4e00\u4e2a\u65e0\u6548\u7684\u7d22\u5f15\u3002\u53ea\u6709\u5728 VkGraphicsPipelineCreateInfo \u7684 flags \u5b57\u6bb5\u4e2d\u4e5f\u6307\u5b9a\u4e86 VK_PIPELINE_CREATE_DERIVATIVE_BIT \u6807\u5fd7\u65f6\uff0c\u624d\u9700\u8981\u4f7f\u7528\u8fd9\u4e9b\u503c\u3002 \u73b0\u5728\u51c6\u5907\u6700\u540e\u4e00\u6b65\uff0c\u521b\u5efa\u4e00\u4e2a\u7c7b\u6210\u5458\u4fdd\u5b58 VkPipeline \u5bf9\u8c61: VkPipeline graphicsPipeline; C++ \u6700\u540e\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf: if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline) != VK_SUCCESS) { throw std::runtime_error(\"failed to create graphics pipeline!\"); } C++ vkCreateGraphicsPipelines \u51fd\u6570\u5728Vulkan\u4e2d\u6bd4\u8d77\u4e00\u822c\u7684\u521b\u5efa\u5bf9\u8c61\u51fd\u6570\u9700\u8981\u66f4\u591a\u7684\u53c2\u6570\u3002\u5b83\u53ef\u4ee5\u7528\u6765\u4f20\u9012\u591a\u4e2a VkGraphicsPipelineCreateInfo \u5bf9\u8c61\u5e76\u521b\u5efa\u591a\u4e2a VkPipeline \u5bf9\u8c61\u3002 \u6211\u4eec\u4f20\u9012 VK_NULL_HANDLE \u53c2\u6570\u4f5c\u4e3a\u7b2c\u4e8c\u4e2a\u53c2\u6570\uff0c\u4f5c\u4e3a\u53ef\u9009 VkPipelineCache \u5bf9\u8c61\u7684\u5f15\u7528\u3002\u7ba1\u7ebf\u7f13\u5b58\u53ef\u4ee5\u7528\u4e8e\u5b58\u50a8\u548c\u590d\u7528\u4e0e\u901a\u8fc7\u591a\u6b21\u8c03\u7528 vkCreateGraphicsPipelines \u51fd\u6570\u76f8\u5173\u7684\u6570\u636e\uff0c\u751a\u81f3\u5728\u7a0b\u5e8f\u6267\u884c\u7684\u65f6\u5019\u7f13\u5b58\u5230\u4e00\u4e2a\u6587\u4ef6\u4e2d\u3002\u8fd9\u6837\u53ef\u4ee5\u52a0\u901f\u540e\u7eed\u7684\u7ba1\u7ebf\u521b\u5efa\u903b\u8f91\u3002\u5177\u4f53\u7684\u5185\u5bb9\u6211\u4eec\u4f1a\u5728\u7ba1\u7ebf\u7f13\u5b58\u7ae0\u8282\u4ecb\u7ecd\u3002 \u56fe\u5f62\u7ba1\u7ebf\u5bf9\u4e8e\u5e38\u89c1\u7684\u7ed8\u56fe\u64cd\u4f5c\u662f\u5fc5\u987b\u7684\uff0c\u6240\u4ee5\u5b83\u4e5f\u5e94\u8be5\u5728\u7a0b\u5e8f\u7ed3\u675f\u65f6\u9500\u6bc1: void cleanup() { vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ... } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\uff0c\u786e\u8ba4\u6240\u6709\u5de5\u4f5c\u6b63\u5e38\uff0c\u5e76\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u6210\u529f\uff01\u6211\u4eec\u5df2\u7ecf\u65e0\u6bd4\u63a5\u8fd1\u5728\u5c4f\u5e55\u4e0a\u7ed8\u5236\u51fa\u4e1c\u897f\u6765\u4e86\u3002\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u4e2a\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4ece\u4ea4\u6362\u94fe\u56fe\u50cf\u4e2d\u8bbe\u7f6e\u5b9e\u9645\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u51c6\u5907\u7ed8\u5236\u547d\u4ee4\u3002 Vulkan \u547d\u4ee4\u7f13\u51b2\u533a Vulkan \u547d\u4ee4\u7f13\u51b2\u533a \uff0c\u8bf8\u5982\u7ed8\u5236\u548c\u5185\u5b58\u64cd\u4f5c\u76f8\u5173\u547d\u4ee4\uff0c\u5728 Vulkan \u4e2d\u4e0d\u662f\u901a\u8fc7\u51fd\u6570\u76f4\u63a5\u8c03\u7528\u7684\u3002\u6211\u4eec\u9700\u8981\u5728\u547d\u4ee4\u7f13\u51b2\u533a\u5bf9\u8c61\u4e2d\u8bb0\u5f55\u6211\u4eec\u671f\u671b\u7684\u4efb\u4f55\u64cd\u4f5c\u3002\u8fd9\u6837\u505a\u7684\u4f18\u70b9\u662f\u53ef\u4ee5\u63d0\u524d\u5728\u591a\u7ebf\u7a0b\u4e2d\u5b8c\u6210\u6240\u6709\u7ed8\u5236\u547d\u4ee4\u76f8\u5173\u7684\u88c5\u914d\u5de5\u4f5c\uff0c\u5e76\u5728\u4e3b\u7ebf\u7a0b\u5faa\u73af\u7ed3\u6784\u4e2d\u901a\u77e5 Vulkan \u6267\u884c\u5177\u4f53\u7684\u547d\u4ee4\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u547d\u4ee4\u6c60 2 \u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a 3 \u542f\u52a8\u547d\u4ee4\u7f13\u51b2\u8bb0\u5f55 4 \u542f\u52a8\u6e32\u67d3\u901a\u9053 5 \u57fa\u672c\u7ed8\u56fe\u547d\u4ee4 6 \u7ed3\u675f\u6e32\u67d3 \u547d\u4ee4\u6c60 \u6211\u4eec\u5728\u4f7f\u7528\u4efb\u4f55 command buffers \u4e4b\u524d\u9700\u8981\u521b\u5efa\u547d\u4ee4\u5bf9\u8c61\u6c60 command pool \u3002 Command pools \u7ba1\u7406\u7528\u4e8e\u5b58\u50a8\u7f13\u51b2\u533a\u7684\u5185\u5b58\uff0c\u5e76\u4ece\u4e2d\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u6dfb\u52a0\u65b0\u7684\u7c7b\u6210\u5458\u4fdd\u5b58 VkCommandPool : VkCommandPool commandPool; \u521b\u5efa\u65b0\u7684\u51fd\u6570 createCommandPool \u5e76\u5728 initVulkan \u51fd\u6570\u521b\u5efa\u5b8c framebuffers \u540e\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); } ... void createCommandPool() { } \u547d\u4ee4\u5bf9\u8c61\u6c60\u521b\u5efa\u4ec5\u4ec5\u9700\u8981\u4e24\u4e2a\u53c2\u6570: QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice); VkCommandPoolCreateInfo poolInfo = {}; poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily; poolInfo.flags = 0; // Optional \u547d\u4ee4\u7f13\u51b2\u533a\u901a\u8fc7\u5c06\u5176\u63d0\u4ea4\u5230\u5176\u4e2d\u4e00\u4e2a\u8bbe\u5907\u961f\u5217\u4e0a\u6765\u6267\u884c\uff0c\u5982\u6211\u4eec\u68c0\u7d22\u7684 graphics \u548c presentation \u961f\u5217\u3002\u6bcf\u4e2a\u547d\u4ee4\u5bf9\u8c61\u6c60\u53ea\u80fd\u5206\u914d\u5728\u5355\u4e00\u7c7b\u578b\u7684\u961f\u5217\u4e0a\u63d0\u4ea4\u7684\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u6362\u53e5\u8bdd\u8bf4\u8981\u5206\u914d\u7684\u547d\u4ee4\u9700\u8981\u4e0e\u961f\u5217\u7c7b\u578b\u4e00\u81f4\u3002\u6211\u4eec\u8981\u8bb0\u5f55\u7ed8\u5236\u7684\u547d\u4ee4\uff0c\u8fd9\u5c31\u8bf4\u660e\u4e3a\u4ec0\u4e48\u8981\u9009\u62e9\u56fe\u5f62\u961f\u5217\u7c07\u7684\u539f\u56e0\u3002 \u6709\u4e24\u4e2a\u6807\u5fd7\u4f4d\u7528\u4e8e command pools : VK_COMMAND_POOL_CREATE_TRANSIENT_BIT : \u63d0\u793a\u547d\u4ee4\u7f13\u51b2\u533a\u975e\u5e38\u9891\u7e41\u7684\u91cd\u65b0\u8bb0\u5f55\u65b0\u547d\u4ee4(\u53ef\u80fd\u4f1a\u6539\u53d8\u5185\u5b58\u5206\u914d\u884c\u4e3a) VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT : \u5141\u8bb8\u547d\u4ee4\u7f13\u51b2\u533a\u5355\u72ec\u91cd\u65b0\u8bb0\u5f55\uff0c\u6ca1\u6709\u8fd9\u4e2a\u6807\u5fd7\uff0c\u6240\u6709\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u90fd\u5fc5\u987b\u4e00\u8d77\u91cd\u7f6e \u6211\u4eec\u4ec5\u4ec5\u5728\u7a0b\u5e8f\u5f00\u59cb\u7684\u65f6\u5019\u8bb0\u5f55\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u5e76\u5728\u4e3b\u5faa\u73af\u4f53 main loop \u4e2d\u591a\u6b21\u6267\u884c\uff0c\u56e0\u6b64\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u8fd9\u4e9b\u6807\u5fd7\u3002 if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) { throw std::runtime_error(\"failed to create command pool!\"); } \u901a\u8fc7 vkCreateCommandPool \u51fd\u6570\u5b8c\u6210 command pool \u521b\u5efa\u5de5\u4f5c\u3002\u5b83\u4e0d\u9700\u8981\u4efb\u4f55\u7279\u6b8a\u7684\u53c2\u6570\u8bbe\u7f6e\u3002\u547d\u4ee4\u5c06\u88ab\u6574\u4e2a\u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\u4f7f\u7528\u4ee5\u5b8c\u6210\u5c4f\u5e55\u7684\u7ed8\u5236\u5de5\u4f5c\uff0c\u6240\u4ee5\u5bf9\u8c61\u6c60\u5e94\u8be5\u88ab\u5728\u6700\u540e\u9500\u6bc1: void cleanup() { vkDestroyCommandPool(device, commandPool, nullptr); ... } \u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a \u73b0\u5728\u6211\u4eec\u5f00\u59cb\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a\u5e76\u901a\u8fc7\u5b83\u4eec\u8bb0\u5f55\u7ed8\u5236\u6307\u4ee4\u3002\u56e0\u4e3a\u5176\u4e2d\u4e00\u4e2a\u7ed8\u56fe\u547d\u4ee4\u9700\u8981\u6b63\u786e\u7ed1\u5b9a VkFrameBuffer \uff0c\u6211\u4eec\u5b9e\u9645\u4e0a\u9700\u8981\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u8bb0\u5f55\u4e00\u4e2a\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u6700\u540e\u521b\u5efa\u4e00\u4e2a VkCommandBuffer \u5bf9\u8c61\u5217\u8868\u4f5c\u4e3a\u6210\u5458\u53d8\u91cf\u3002\u547d\u4ee4\u7f13\u51b2\u533a\u4f1a\u5728 common pool \u9500\u6bc1\u7684\u65f6\u5019\u81ea\u52a8\u91ca\u653e\u7cfb\u7edf\u8d44\u6e90\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u660e\u786e\u7f16\u5199 cleanup \u903b\u8f91\u3002 std::vector<VkCommandBuffer> commandBuffers; \u73b0\u5728\u5f00\u59cb\u4f7f\u7528\u4e00\u4e2a createCommandBuffers \u51fd\u6570\u6765\u5206\u914d\u548c\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u56fe\u50cf\u5c06\u8981\u5e94\u7528\u7684\u547d\u4ee4\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); } ... void createCommandBuffers() { commandBuffers.resize(swapChainFramebuffers.size()); } \u547d\u4ee4\u7f13\u51b2\u533a\u901a\u8fc7 vkAllocateCommandBuffers \u51fd\u6570\u5206\u914d\uff0c\u5b83\u9700\u8981 VkCommandBufferAllocateInfo \u7ed3\u6784\u4f53\u4f5c\u4e3a\u53c2\u6570\uff0c\u7528\u4ee5\u6307\u5b9a command pool \u548c\u7f13\u51b2\u533a\u5c06\u4f1a\u5206\u914d\u7684\u5927\u5c0f: VkCommandBufferAllocateInfo allocInfo = {}; allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; allocInfo.commandPool = commandPool; allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; allocInfo.commandBufferCount = (uint32_t) commandBuffers.size(); if (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.data()) != VK_SUCCESS) { throw std::runtime_error(\"failed to allocate command buffers!\"); } level \u53c2\u6570\u6307\u5b9a\u5206\u914d\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u4e3b\u4ece\u5173\u7cfb\u3002 VK_COMMAND_BUFFER_LEVEL_PRIMARY : \u53ef\u4ee5\u63d0\u4ea4\u5230\u961f\u5217\u6267\u884c\uff0c\u4f46\u4e0d\u80fd\u4ece\u5176\u4ed6\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u8c03\u7528\u3002 VK_COMMAND_BUFFER_LEVEL_SECONDARY : \u65e0\u6cd5\u76f4\u63a5\u63d0\u4ea4\uff0c\u4f46\u662f\u53ef\u4ee5\u4ece\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u8c03\u7528\u3002 \u6211\u4eec\u4e0d\u4f1a\u5728\u8fd9\u91cc\u4f7f\u7528\u8f85\u52a9\u7f13\u51b2\u533a\u529f\u80fd\uff0c\u4f46\u662f\u53ef\u4ee5\u60f3\u50cf\uff0c\u5bf9\u4e8e\u590d\u7528\u4e3b\u7f13\u51b2\u533a\u7684\u5e38\u7528\u64cd\u4f5c\u5f88\u6709\u5e2e\u52a9\u3002 \u542f\u52a8\u547d\u4ee4\u7f13\u51b2\u8bb0\u5f55 \u901a\u8fc7 vkBeginCommandBuffer \u6765\u5f00\u542f\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u8bb0\u5f55\u529f\u80fd\uff0c\u8be5\u51fd\u6570\u9700\u8981\u4f20\u9012 VkCommandBufferBeginInfo \u7ed3\u6784\u4f53\u4f5c\u4e3a\u53c2\u6570\uff0c\u7528\u4ee5\u6307\u5b9a\u547d\u4ee4\u7f13\u51b2\u533a\u5728\u4f7f\u7528\u8fc7\u7a0b\u4e2d\u7684\u4e00\u4e9b\u5177\u4f53\u4fe1\u606f\u3002 for (size_t i = 0; i < commandBuffers.size(); i++) { VkCommandBufferBeginInfo beginInfo = {}; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT; beginInfo.pInheritanceInfo = nullptr; // Optional vkBeginCommandBuffer(commandBuffers[i], &beginInfo); } flags \u6807\u5fd7\u4f4d\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u5982\u4f55\u4f7f\u7528\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u53ef\u9009\u7684\u53c2\u6570\u7c7b\u578b\u5982\u4e0b: VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT : \u547d\u4ee4\u7f13\u51b2\u533a\u5c06\u5728\u6267\u884c\u4e00\u6b21\u540e\u7acb\u5373\u91cd\u65b0\u8bb0\u5f55\u3002 VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT : \u8fd9\u662f\u4e00\u4e2a\u8f85\u52a9\u7f13\u51b2\u533a\uff0c\u5b83\u9650\u5236\u5728\u5728\u4e00\u4e2a\u6e32\u67d3\u901a\u9053\u4e2d\u3002 VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT : \u547d\u4ee4\u7f13\u51b2\u533a\u4e5f\u53ef\u4ee5\u91cd\u65b0\u63d0\u4ea4\uff0c\u540c\u65f6\u5b83\u4e5f\u5728\u7b49\u5f85\u6267\u884c\u3002 \u6211\u4eec\u4f7f\u7528\u4e86\u6700\u540e\u4e00\u4e2a\u6807\u5fd7\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u80fd\u5df2\u7ecf\u5728\u4e0b\u4e00\u5e27\u7684\u65f6\u5019\u5b89\u6392\u4e86\u7ed8\u5236\u547d\u4ee4\uff0c\u800c\u6700\u540e\u4e00\u5e27\u5c1a\u672a\u5b8c\u6210\u3002 pInheritanceInfo \u53c2\u6570\u4e0e\u8f85\u52a9\u7f13\u51b2\u533a\u76f8\u5173\u3002\u5b83\u6307\u5b9a\u4ece\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u7ee7\u627f\u7684\u72b6\u6001\u3002 \u5982\u679c\u547d\u4ee4\u7f13\u51b2\u533a\u5df2\u7ecf\u88ab\u8bb0\u5f55\u4e00\u6b21\uff0c\u90a3\u4e48\u8c03\u7528 vkBeginCommandBuffer \u4f1a\u9690\u5f0f\u5730\u91cd\u7f6e\u5b83\u3002\u5426\u5219\u5c06\u547d\u4ee4\u9644\u52a0\u5230\u7f13\u51b2\u533a\u662f\u4e0d\u53ef\u80fd\u7684\u3002 \u542f\u52a8\u6e32\u67d3\u901a\u9053 \u7ed8\u5236\u5f00\u59cb\u4e8e\u8c03\u7528 vkCmdBeginRenderPass \u5f00\u542f\u6e32\u67d3\u901a\u9053\u3002render pass\u4f7f\u7528 VkRenderPassBeginInfo \u7ed3\u6784\u4f53\u586b\u5145\u914d\u7f6e\u4fe1\u606f\u4f5c\u4e3a\u8c03\u7528\u65f6\u4f7f\u7528\u7684\u53c2\u6570\u3002 VkRenderPassBeginInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; renderPassInfo.renderPass = renderPass; renderPassInfo.framebuffer = swapChainFramebuffers[i]; \u7ed3\u6784\u4f53\u7b2c\u4e00\u4e2a\u53c2\u6570\u4f20\u9012\u4e3a\u7ed1\u5b9a\u5230\u5bf9\u5e94\u9644\u4ef6\u7684\u6e32\u67d3\u901a\u9053\u672c\u8eab\u3002\u6211\u4eec\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u521b\u5efa\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u6307\u5b9a\u4e3a\u989c\u8272\u9644\u4ef6\u3002 renderPassInfo.renderArea.offset = {0, 0}; renderPassInfo.renderArea.extent = swapChainExtent; \u540e\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u4e86\u6e32\u67d3\u533a\u57df\u7684\u5927\u5c0f\u3002\u6e32\u67d3\u533a\u57df\u5b9a\u4e49\u7740\u8272\u5668\u52a0\u8f7d\u548c\u5b58\u50a8\u5c06\u8981\u53d1\u751f\u7684\u4f4d\u7f6e\u3002\u533a\u57df\u5916\u7684\u50cf\u7d20\u5c06\u5177\u6709\u672a\u5b9a\u7684\u503c\u3002\u4e3a\u4e86\u6700\u4f73\u7684\u6027\u80fd\u5b83\u7684\u5c3a\u5bf8\u5e94\u8be5\u4e0e\u9644\u4ef6\u5339\u914d\u3002 VkClearValue clearColor = {0.0f, 0.0f, 0.0f, 1.0f}; renderPassInfo.clearValueCount = 1; renderPassInfo.pClearValues = &clearColor; \u6700\u540e\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u4e86\u7528\u4e8e VK_ATTACHMENT_LOAD_OP_CLEAR \u7684\u6e05\u9664\u503c\uff0c\u6211\u4eec\u5c06\u5176\u7528\u4f5c\u989c\u8272\u9644\u4ef6\u7684\u52a0\u8f7d\u64cd\u4f5c\u3002\u4e3a\u4e86\u7b80\u5316\u64cd\u4f5c\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86 clear color \u4e3a100%\u9ed1\u8272\u3002 vkCmdBeginRenderPass(commandBuffers[i], &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE); \u6e32\u67d3\u901a\u9053\u73b0\u5728\u53ef\u4ee5\u542f\u7528\u3002\u6240\u6709\u53ef\u4ee5\u88ab\u8bb0\u5f55\u7684\u547d\u4ee4\uff0c\u88ab\u8bc6\u522b\u7684\u524d\u63d0\u662f\u4f7f\u7528 vkCmd \u524d\u7f00\u3002\u5b83\u4eec\u5168\u90e8\u8fd4\u56de void \uff0c\u6240\u4ee5\u5728\u7ed3\u675f\u8bb0\u5f55\u4e4b\u524d\u4e0d\u4f1a\u6709\u4efb\u4f55\u9519\u8bef\u5904\u7406\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u547d\u4ee4\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u603b\u662f\u8bb0\u5f55\u8be5\u547d\u4ee4\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u7b2c\u4e8c\u4e2a\u53c2\u6570\u6307\u5b9a\u6211\u4eec\u4f20\u9012\u7684\u6e32\u67d3\u901a\u9053\u7684\u5177\u4f53\u4fe1\u606f\u3002\u6700\u540e\u7684\u53c2\u6570\u63a7\u5236\u5982\u4f55\u63d0\u4f9b render pass \u5c06\u8981\u5e94\u7528\u7684\u7ed8\u5236\u547d\u4ee4\u3002\u5b83\u4f7f\u7528\u4ee5\u4e0b\u6570\u503c\u4efb\u610f\u4e00\u4e2a: VK_SUBPASS_CONTENTS_INLINE : \u6e32\u67d3\u8fc7\u7a0b\u547d\u4ee4\u88ab\u5d4c\u5165\u5728\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u4e2d\uff0c\u6ca1\u6709\u8f85\u52a9\u7f13\u51b2\u533a\u6267\u884c\u3002 VK_SUBPASS_CONTENTS_SECONDARY_COOMAND_BUFFERS : \u6e32\u67d3\u901a\u9053\u547d\u4ee4\u5c06\u4f1a\u4ece\u8f85\u52a9\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u3002 \u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u8f85\u52a9\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u7b2c\u4e00\u4e2a\u3002 \u57fa\u672c\u7ed8\u56fe\u547d\u4ee4 \u73b0\u5728\u6211\u4eec\u7ed1\u5b9a\u56fe\u5f62\u7ba1\u7ebf: vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline); \u7b2c\u4e8c\u4e2a\u53c2\u6570\u6307\u5b9a\u5177\u4f53\u7ba1\u7ebf\u7c7b\u578b\uff0c graphics or compute pipeline \u3002\u6211\u4eec\u544a\u8bc9Vulkan\u5728\u56fe\u5f62\u7ba1\u7ebf\u4e2d\u6bcf\u4e00\u4e2a\u64cd\u4f5c\u5982\u4f55\u6267\u884c\u53ca\u54ea\u4e2a\u9644\u4ef6\u5c06\u4f1a\u5728\u7247\u6bb5\u7740\u8272\u5668\u4e2d\u4f7f\u7528\uff0c\u6240\u4ee5\u5269\u4e0b\u7684\u5c31\u662f\u544a\u8bc9\u5b83\u7ed8\u5236\u4e09\u89d2\u5f62\u3002 vkCmdDraw(commandBuffers[i], 3, 1, 0, 0); C++ \u5b9e\u9645\u7684 vkCmdDraw \u51fd\u6570\u6709\u70b9\u4e0e\u5b57\u9762\u610f\u601d\u4e0d\u4e00\u81f4\uff0c\u5b83\u662f\u5982\u6b64\u7b80\u5355\uff0c\u4ec5\u56e0\u4e3a\u6211\u4eec\u63d0\u524d\u6307\u5b9a\u6240\u6709\u6e32\u67d3\u76f8\u5173\u7684\u4fe1\u606f\u3002\u5b83\u6709\u5982\u4e0b\u7684\u53c2\u6570\u9700\u8981\u6307\u5b9a\uff0c\u9664\u4e86\u547d\u4ee4\u7f13\u51b2\u533a: vertexCount : \u5373\u4f7f\u6211\u4eec\u6ca1\u6709\u9876\u70b9\u7f13\u51b2\u533a\uff0c\u4f46\u662f\u6211\u4eec\u4ecd\u7136\u67093\u4e2a\u5b9a\u70b9\u9700\u8981\u7ed8\u5236\u3002 instanceCount : \u7528\u4e8einstanced \u6e32\u67d3\uff0c\u5982\u679c\u6ca1\u6709\u4f7f\u7528\u8bf7\u586b1\u3002 firstVertex : \u4f5c\u4e3a\u9876\u70b9\u7f13\u51b2\u533a\u7684\u504f\u79fb\u91cf\uff0c\u5b9a\u4e49gl_VertexIndex\u7684\u6700\u5c0f\u503c\u3002 firstInstance : \u4f5c\u4e3ainstanced \u6e32\u67d3\u7684\u504f\u79fb\u91cf\uff0c\u5b9a\u4e49\u4e86gl_InstanceIndex\u7684\u6700\u5c0f\u503c\u3002 \u7ed3\u675f\u6e32\u67d3 render pass \u6267\u884c\u5b8c\u7ed8\u5236\uff0c\u53ef\u4ee5\u7ed3\u675f\u6e32\u67d3\u4f5c\u4e1a: vkCmdEndRenderPass(commandBuffers[i]); C++ \u5e76\u505c\u6b62\u8bb0\u5f55\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u5de5\u4f5c: if (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to record command buffer!\"); } C++ \u5728\u4e0b\u4e00\u7ae0\u8282\u6211\u4eec\u4f1a\u5c1d\u8bd5\u5728 main loop \u4e2d\u7f16\u5199\u4ee3\u7801\uff0c\u7528\u4e8e\u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u56fe\u50cf\uff0c\u6267\u884c\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u547d\u4ee4\uff0c\u518d\u5c06\u6e32\u67d3\u540e\u7684\u56fe\u50cf\u8fd4\u8fd8\u7ed9\u4ea4\u6362\u94fe\u3002 Vulkan \u6e32\u67d3\u548c\u663e\u793a Vulkan \u6e32\u67d3\u548c\u663e\u793a \uff0c\u8fd9\u4e00\u7ae0\u8282\u4f1a\u628a\u4e4b\u524d\u7684\u6240\u6709\u5185\u5bb9\u8fdb\u884c\u6574\u5408\uff0c\u6211\u4eec\u5c06\u4f1a\u7f16\u5199 drawFrame \u51fd\u6570\uff0c\u901a\u8fc7\u4e3b\u5faa\u73af main loop \u5c06\u4e09\u89d2\u5f62\u7ed8\u5236\u5230\u5c4f\u5e55\u3002 drawFrame \u51fd\u6570\u5c06\u4f1a\u6267\u884c\u5982\u4e0b\u64cd\u4f5c: \u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u4e00\u4e2a\u56fe\u50cf \u5728\u5e27\u7f13\u51b2\u533a\u4e2d\uff0c\u4f7f\u7528\u4f5c\u4e3a\u9644\u4ef6\u7684\u56fe\u50cf\u6765\u6267\u884c\u547d\u4ee4\u7f13\u51b2\u533a\u4e2d\u7684\u547d\u4ee4 \u4e3a\u4e86\u6700\u7ec8\u5448\u73b0\uff0c\u5c06\u56fe\u50cf\u8fd4\u8fd8\u5230\u4ea4\u6362\u94fe \u6bcf\u4e2a\u4e8b\u4ef6\u6d3e\u53d1\u90fd\u6709\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u6765\u5bf9\u5e94\uff0c\u4f46\u5b83\u4eec\u7684\u6267\u884c\u662f\u5f02\u6b65\u7684\u3002\u51fd\u6570\u8c03\u7528\u5c06\u5728\u64cd\u4f5c\u5b9e\u9645\u5b8c\u6210\u4e4b\u524d\u8fd4\u56de\uff0c\u5e76\u4e14\u6267\u884c\u987a\u5e8f\u4e5f\u662f\u672a\u5b9a\u4e49\u7684\u3002\u8fd9\u662f\u4e0d\u7406\u60f3\u7684\uff0c\u56e0\u4e3a\u6bcf\u4e00\u4e2a\u64cd\u4f5c\u90fd\u53d6\u51b3\u4e8e\u524d\u4e00\u4e2a\u64cd\u4f5c\u3002 \u5728 mainLoop \u51fd\u6570\u8c03\u7528: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); drawFrame(); } } ... void drawFrame() { } C++ \u540c\u6b65\u4ea4\u6362\u94fe\u4e8b\u4ef6\u6709\u4e24\u79cd\u65b9\u6cd5:\u6805\u680f\u548c\u4fe1\u53f7\u91cf\u3002\u5b83\u4eec\u90fd\u662f\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u4e00\u4e2a\u64cd\u4f5c\u4fe1\u53f7\uff0c\u8d1f\u8d23\u534f\u8c03\u64cd\u4f5c\u7684\u5bf9\u8c61\u3002\u53e6\u4e00\u4e2a\u64cd\u4f5c\u7b49\u5f85\u6805\u680f\u6216\u8005\u4fe1\u53f7\u91cf\u4ece\u65e0\u4fe1\u53f7\u72b6\u6001\u8f6c\u53d8\u5230\u6709\u4fe1\u53f7\u72b6\u6001\u3002 \u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u53ef\u4ee5\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u8c03\u7528 vkWaitForFence \u8fdb\u5165\u6805\u680f\u72b6\u6001\uff0c\u800c\u4fe1\u53f7\u91cf\u4e0d\u53ef\u4ee5\u3002\u6805\u680f\u4e3b\u8981\u7528\u4e8e\u5e94\u7528\u7a0b\u5e8f\u81ea\u8eab\u4e0e\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u540c\u6b65\uff0c\u800c\u4fe1\u53f7\u91cf\u7528\u4e8e\u5728\u547d\u4ee4\u961f\u5217\u5185\u6216\u8005\u8de8\u547d\u4ee4\u961f\u5217\u540c\u6b65\u64cd\u4f5c\u3002\u6211\u4eec\u671f\u671b\u540c\u6b65\u7ed8\u5236\u4e0e\u5448\u73b0\u7684\u961f\u5217\u64cd\u4f5c\uff0c\u6240\u4ee5\u4f7f\u7528\u4fe1\u53f7\u91cf\u6700\u5408\u9002\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u4fe1\u53f7\u91cf 2 \u4ece\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf 3 \u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a 4 Subpass \u4f9d\u8d56\u6027 5 \u5448\u73b0 6 \u5185\u5b58\u6cc4\u6f0f 7 \u7ed3\u8bba \u4fe1\u53f7\u91cf \u5728\u83b7\u5f97\u4e00\u4e2a\u56fe\u50cf\u65f6\uff0c\u6211\u4eec\u9700\u8981\u53d1\u51fa\u4e00\u4e2a\u4fe1\u53f7\u91cf\u51c6\u5907\u8fdb\u884c\u6e32\u67d3\uff0c\u53e6\u4e00\u4e2a\u4fe1\u53f7\u91cf\u7684\u53d1\u51fa\u7528\u4e8e\u6e32\u67d3\u7ed3\u675f\uff0c\u51c6\u5907\u8fdb\u884c\u5448\u73b0presentation\u3002\u521b\u5efa\u4e24\u4e2a\u6210\u5458\u53d8\u91cf\u5b58\u50a8\u4fe1\u53f7\u91cf\u5bf9\u8c61: VkSemaphore imageAvailableSemaphore; VkSemaphore renderFinishedSemaphore; C++ \u4e3a\u4e86\u521b\u5efa\u4fe1\u53f7\u91cfsemaphores\uff0c\u6211\u4eec\u5c06\u8981\u65b0\u589e\u672c\u7cfb\u5217\u6559\u7a0b\u6700\u540e\u4e00\u4e2a\u51fd\u6570: createSemaphores : void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); createSemaphores(); } ... void createSemaphores() { } C++ \u521b\u5efa\u4fe1\u53f7\u91cf\u5bf9\u8c61\u9700\u8981\u586b\u5145 VkSemaphoreCreateInfo \u7ed3\u6784\u4f53\uff0c\u4f46\u662f\u5728\u5f53\u524d\u7248\u672c\u7684 API \u4e2d\uff0c\u5b9e\u9645\u4e0a\u4e0d\u9700\u8981\u586b\u5145\u4efb\u4f55\u5b57\u6bb5\uff0c\u9664 sType : void createSemaphores() { VkSemaphoreCreateInfo semaphoreInfo = {}; semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; } C++ Vulkan API\u672a\u6765\u7248\u672c\u6216\u8005\u6269\u5c55\u4e2d\u6216\u8bb8\u4f1a\u4e3a flags \u548c pNext \u53c2\u6570\u589e\u52a0\u529f\u80fd\u9009\u9879\u3002\u521b\u5efa\u4fe1\u53f7\u91cf\u5bf9\u8c61\u7684\u8fc7\u7a0b\u5f88\u719f\u6089\u4e86\uff0c\u5728\u8fd9\u91cc\u4f7f\u7528 vkCreateSemaphore : if (vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphore) != VK_SUCCESS || vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphore) != VK_SUCCESS) { throw std::runtime_error(\"failed to create semaphores!\"); } C++ \u5728\u7a0b\u5e8f\u7ed3\u675f\u65f6\uff0c\u5f53\u6240\u6709\u547d\u4ee4\u5b8c\u6210\u5e76\u4e0d\u9700\u8981\u540c\u6b65\u65f6\uff0c\u5e94\u8be5\u6e05\u9664\u4fe1\u53f7\u91cf: void cleanup() { vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); C++ \u4ece\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf \u5c31\u50cf\u4e4b\u524d\u8bf4\u5230\u7684\uff0c drawFrame \u51fd\u6570\u9700\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u56fe\u50cf\u3002\u56de\u60f3\u4e00\u4e0b\u4ea4\u6362\u94fe\u662f\u4e00\u4e2a\u6269\u5c55\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u4f7f\u7528\u5177\u6709vk*KHR\u547d\u540d\u7ea6\u5b9a\u7684\u51fd\u6570: void drawFrame() { uint32_t imageIndex; vkAcquireNextImageKHR(device, swapChain, std::numeric_limits<uint64_t>::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex); } C++ vkAcquireNextImageKHR \u51fd\u6570\u524d\u4e24\u4e2a\u53c2\u6570\u662f\u6211\u4eec\u5e0c\u671b\u83b7\u53d6\u5230\u56fe\u50cf\u7684\u903b\u8f91\u8bbe\u5907\u548c\u4ea4\u6362\u94fe\u3002\u7b2c\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u83b7\u53d6\u6709\u6548\u56fe\u50cf\u7684\u64cd\u4f5ctimeout\uff0c\u5355\u4f4d\u7eb3\u79d2\u3002\u6211\u4eec\u4f7f\u752864\u4f4d\u65e0\u7b26\u53f7\u6700\u5927\u503c\u7981\u6b62 timeout \u3002 \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u4f7f\u7528\u7684\u540c\u6b65\u5bf9\u8c61\uff0c\u5f53 presentation \u5f15\u64ce\u5b8c\u6210\u4e86\u56fe\u50cf\u7684\u5448\u73b0\u540e\u4f1a\u4f7f\u7528\u8be5\u5bf9\u8c61\u53d1\u8d77\u4fe1\u53f7\u3002\u8fd9\u5c31\u662f\u5f00\u59cb\u7ed8\u5236\u7684\u65f6\u95f4\u70b9\u3002\u5b83\u53ef\u4ee5\u6307\u5b9a\u4e00\u4e2a\u4fe1\u53f7\u91cf semaphore \u6216\u8005\u6805\u680f\u6216\u8005\u4e24\u8005\u3002\u51fa\u4e8e\u76ee\u7684\u6027\uff0c\u6211\u4eec\u4f1a\u4f7f\u7528 imageAvailableSemaphore \u3002 \u6700\u540e\u7684\u53c2\u6570\u6307\u5b9a\u4ea4\u6362\u94fe\u4e2d\u6210\u4e3a available \u72b6\u6001\u7684\u56fe\u50cf\u5bf9\u5e94\u7684\u7d22\u5f15\u3002\u5176\u4e2d\u7d22\u5f15\u4f1a\u5f15\u7528\u4ea4\u6362\u94fe\u56fe\u50cf\u6570\u7ec4 swapChainImages \u7684\u56fe\u50cf VkImage \u3002\u6211\u4eec\u4f7f\u7528\u8fd9\u4e2a\u7d22\u5f15\u9009\u62e9\u6b63\u786e\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002 \u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a \u961f\u5217\u63d0\u4ea4\u548c\u540c\u6b65\u901a\u8fc7 VkSubmitInfo \u7ed3\u6784\u4f53\u8fdb\u884c\u53c2\u6570\u914d\u7f6e\u3002 VkSubmitInfo submitInfo = {}; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; VkSemaphore waitSemaphores[] = {imageAvailableSemaphore}; VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT}; submitInfo.waitSemaphoreCount = 1; submitInfo.pWaitSemaphores = waitSemaphores; submitInfo.pWaitDstStageMask = waitStages; C++ \u524d\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u5728\u6267\u884c\u5f00\u59cb\u4e4b\u524d\u8981\u7b49\u5f85\u7684\u54ea\u4e2a\u4fe1\u53f7\u91cf\u53ca\u8981\u7b49\u5f85\u7684\u901a\u9053\u7684\u54ea\u4e2a\u9636\u6bb5\u3002\u4e3a\u4e86\u5411\u56fe\u50cf\u5199\u5165\u989c\u8272\uff0c\u6211\u4eec\u4f1a\u7b49\u5f85\u56fe\u50cf\u72b6\u6001\u53d8\u4e3a available \uff0c\u6240\u6211\u4eec\u6307\u5b9a\u5199\u5165\u989c\u8272\u9644\u4ef6\u7684\u56fe\u5f62\u7ba1\u7ebf\u9636\u6bb5\u3002\u7406\u8bba\u4e0a\u8fd9\u610f\u5473\u7740\uff0c\u5177\u4f53\u7684\u9876\u70b9\u7740\u8272\u5668\u5f00\u59cb\u6267\u884c\uff0c\u800c\u56fe\u50cf\u4e0d\u53ef\u7528\u3002 waitStages \u6570\u7ec4\u5bf9\u5e94 pWaitSemaphores \u4e2d\u5177\u6709\u76f8\u540c\u7d22\u5f15\u7684\u4fe1\u53f7\u91cf\u3002 submitInfo.commandBufferCount = 1; submitInfo.pCommandBuffers = &commandBuffers[imageIndex]; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u54ea\u4e2a\u547d\u4ee4\u7f13\u51b2\u533a\u88ab\u5b9e\u9645\u63d0\u4ea4\u6267\u884c\u3002\u5982\u521d\u671f\u63d0\u5230\u7684\uff0c\u6211\u4eec\u5e94\u8be5\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u5b83\u5c06\u6211\u4eec\u521a\u83b7\u53d6\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u505a\u4e3a\u989c\u8272\u9644\u4ef6\u8fdb\u884c\u7ed1\u5b9a\u3002 VkSemaphore signalSemaphores[] = {renderFinishedSemaphore}; submitInfo.signalSemaphoreCount = 1; submitInfo.pSignalSemaphores = signalSemaphores; C++ signalSemaphoreCount \u548c pSignalSemaphores \u53c2\u6570\u6307\u5b9a\u4e86\u5f53\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u7ed3\u675f\u5411\u54ea\u4e9b\u4fe1\u53f7\u91cf\u53d1\u51fa\u4fe1\u53f7\u3002\u6839\u636e\u6211\u4eec\u7684\u9700\u8981\u4f7f\u7528 renderFinishedSemaphore \u3002 if (vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE) != VK_SUCCESS) { throw std::runtime_error(\"failed to submit draw command buffer!\"); } C++ \u4f7f\u7528 vkQueueSubmit \u51fd\u6570\u5411\u56fe\u50cf\u961f\u5217\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u5f53\u5f00\u9500\u8d1f\u8f7d\u6bd4\u8f83\u5927\u7684\u65f6\u5019\uff0c\u5904\u4e8e\u6548\u7387\u8003\u8651\uff0c\u51fd\u6570\u53ef\u4ee5\u6301\u6709 VkSubmitInfo \u7ed3\u6784\u4f53\u6570\u7ec4\u3002\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u5f15\u7528\u4e86\u4e00\u4e2a\u53ef\u9009\u7684\u6805\u680f\uff0c\u5f53\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u5b8c\u6bd5\u65f6\u5019\u5b83\u4f1a\u88ab\u53d1\u9001\u4fe1\u53f7\u3002\u6211\u4eec\u4f7f\u7528\u4fe1\u53f7\u91cf\u8fdb\u884c\u540c\u6b65\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4f20\u9012 VK_NULL_HANDLE \u3002 Subpass \u4f9d\u8d56\u6027 \u8bf7\u8bb0\u4f4f\uff0c\u6e32\u67d3\u901a\u9053\u4e2d\u7684\u5b50\u901a\u9053\u4f1a\u81ea\u52a8\u5904\u7406\u5e03\u5c40\u7684\u53d8\u6362\u3002\u8fd9\u4e9b\u53d8\u6362\u901a\u8fc7\u5b50\u901a\u9053\u7684\u4f9d\u8d56\u5173\u7cfb\u8fdb\u884c\u63a7\u5236\uff0c\u5b83\u4eec\u6307\u5b9a\u4e86\u5f7c\u6b64\u4e4b\u95f4\u5185\u5b58\u548c\u6267\u884c\u7684\u4f9d\u8d56\u5173\u7cfb\u3002\u73b0\u5728\u53ea\u6709\u4e00\u4e2a\u5b50\u901a\u9053\uff0c\u4f46\u662f\u5728\u6b64\u5b50\u901a\u9053\u4e4b\u524d\u548c\u4e4b\u540e\u7684\u64cd\u4f5c\u4e5f\u88ab\u89c6\u4e3a\u9690\u5f0f\u201c\u5b50\u901a\u9053\u201d\u3002 \u6709\u4e24\u4e2a\u5185\u7f6e\u7684\u4f9d\u8d56\u5173\u7cfb\u5728\u6e32\u67d3\u901a\u9053\u5f00\u59cb\u548c\u6e32\u67d3\u901a\u9053\u7ed3\u675f\u5904\u7406\u8f6c\u6362\uff0c\u4f46\u662f\u524d\u8005\u4e0d\u4f1a\u5728\u5f53\u4e0b\u53d1\u751f\u3002\u5047\u8bbe\u8f6c\u6362\u53d1\u751f\u5728\u7ba1\u7ebf\u7684\u8d77\u59cb\u9636\u6bb5\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u83b7\u53d6\u56fe\u50cf\uff01\u6709\u4e24\u4e2a\u65b9\u6cd5\u5904\u7406\u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u5c06 imageAvailableSemaphore \u7684 waitStages \u66f4\u6539\u4e3a VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT \uff0c\u786e\u4fdd\u56fe\u50cf\u6709\u6548\u4e4b\u524d\u6e32\u67d3\u901a\u9053\u4e0d\u4f1a\u5f00\u59cb\uff0c\u6216\u8005\u6211\u4eec\u8ba9\u6e32\u67d3\u901a\u9053\u7b49\u5f85 VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT \u9636\u6bb5\u3002\u6211\u89c9\u5f97\u4f7f\u7528\u7b2c\u4e8c\u4e2a\u9009\u9879\uff0c\u56e0\u4e3a\u53ef\u4ee5\u6bd4\u8f83\u5168\u9762\u7684\u4e86\u89e3 subpass \u4f9d\u8d56\u5173\u7cfb\u53ca\u5176\u5de5\u4f5c\u65b9\u5f0f\u3002 \u5b50\u901a\u9053\u4f9d\u8d56\u5173\u7cfb\u53ef\u4ee5\u901a\u8fc7 VkSubpassDependency \u7ed3\u6784\u4f53\u6307\u5b9a\uff0c\u5728 createRenderPass \u51fd\u6570\u4e2d\u6dfb\u52a0: VkSubpassDependency dependency = {}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; C++ \u524d\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u4f9d\u8d56\u7684\u5173\u7cfb\u548c\u4ece\u5c5e\u5b50\u901a\u9053\u7684\u7d22\u5f15\u3002\u7279\u6b8a\u503c VK_SUBPASS_EXTERNAL \u662f\u6307\u5728\u6e32\u67d3\u901a\u9053\u4e4b\u524d\u6216\u8005\u4e4b\u540e\u7684\u9690\u5f0f\u5b50\u901a\u9053\uff0c\u53d6\u51b3\u4e8e\u5b83\u662f\u5426\u5728 srcSubpass \u6216\u8005 dstSubPass \u4e2d\u6307\u5b9a\u3002\u7d22\u5f150\u6307\u5b9a\u6211\u4eec\u7684\u5b50\u901a\u9053\uff0c\u8fd9\u662f\u7b2c\u4e00\u4e2a\u4e5f\u662f\u552f\u4e00\u7684\u3002 dstSubpass \u5fc5\u987b\u59cb\u7ec8\u9ad8\u4e8e srcSubPass \u4ee5\u9632\u6b62\u4f9d\u8d56\u5173\u7cfb\u51fa\u73b0\u5faa\u73af\u3002 dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u5b57\u6bb5\u6307\u5b9a\u8981\u7b49\u5f85\u7684\u64cd\u4f5c\u548c\u8fd9\u4e9b\u64cd\u4f5c\u53d1\u751f\u7684\u9636\u6bb5\u3002\u5728\u6211\u4eec\u53ef\u4ee5\u8bbf\u95ee\u5bf9\u8c61\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u7b49\u5f85\u4ea4\u6362\u94fe\u5b8c\u6210\u5bf9\u5e94\u56fe\u50cf\u7684\u8bfb\u53d6\u64cd\u4f5c\u3002\u8fd9\u53ef\u4ee5\u901a\u8fc7\u7b49\u5f85\u989c\u8272\u9644\u4ef6\u8f93\u51fa\u7684\u9636\u6bb5\u6765\u5b9e\u73b0\u3002 dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; C++ \u5728\u989c\u8272\u9644\u4ef6\u9636\u6bb5\u7684\u64cd\u4f5c\u53ca\u6d89\u53ca\u989c\u8272\u9644\u4ef6\u7684\u8bfb\u53d6\u548c\u5199\u5165\u7684\u64cd\u4f5c\u5e94\u8be5\u7b49\u5f85\u3002\u8fd9\u4e9b\u8bbe\u7f6e\u5c06\u963b\u6b62\u8f6c\u6362\u53d1\u751f\uff0c\u76f4\u5230\u5b9e\u9645\u9700\u8981(\u5e76\u5141\u8bb8):\u5f53\u6211\u4eec\u9700\u8981\u5199\u5165\u989c\u8272\u65f6\u5019\u3002 renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; C++ VkRenderPassCreateInfo \u7ed3\u6784\u4f53\u6709\u4e24\u4e2a\u5b57\u6bb5\u6307\u5b9a\u4f9d\u8d56\u7684\u6570\u7ec4\u3002 \u5448\u73b0 \u7ed8\u5236\u5e27\u6700\u540e\u4e00\u4e2a\u6b65\u9aa4\u662f\u5c06\u7ed3\u679c\u63d0\u4ea4\u5230\u4ea4\u6362\u94fe\uff0c\u4f7f\u5176\u6700\u7ec8\u663e\u793a\u5728\u5c4f\u5e55\u4e0a\u3002 Presentation \u901a\u8fc7 VkPresentInfoKHR \u7ed3\u6784\u4f53\u914d\u7f6e\uff0c\u5177\u4f53\u4f4d\u7f6e\u5728 drawFrame \u51fd\u6570\u6700\u540e\u3002 VkPresentInfoKHR presentInfo = {}; presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR; presentInfo.waitSemaphoreCount = 1; presentInfo.pWaitSemaphores = signalSemaphores; C++ \u524d\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u5728\u8fdb\u884cpresentation\u4e4b\u524d\u8981\u7b49\u5f85\u7684\u4fe1\u53f7\u91cf\uff0c\u5c31\u50cf VkSubmitInfo \u4e00\u6837\u3002 VkSwapchainKHR swapChains[] = {swapChain}; presentInfo.swapchainCount = 1; presentInfo.pSwapchains = swapChains; presentInfo.pImageIndices = &imageIndex; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u7528\u4e8e\u63d0\u4ea4\u56fe\u50cf\u7684\u4ea4\u6362\u94fe\u548c\u6bcf\u4e2a\u4ea4\u6362\u94fe\u56fe\u50cf\u7d22\u5f15\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4ec5\u4e00\u4e2a\u3002 presentInfo.pResults = nullptr; // Optional C++ \u6700\u540e\u4e00\u4e2a\u53ef\u9009\u53c2\u6570 pResults \uff0c\u5b83\u5141\u8bb8\u6307\u5b9a\u4e00\u7ec4 VkResult \u503c\uff0c\u4ee5\u4fbf\u5728 presentation \u6210\u529f\u65f6\u68c0\u67e5\u6bcf\u4e2a\u72ec\u7acb\u7684\u4ea4\u6362\u94fe\u3002\u5982\u679c\u53ea\u4f7f\u7528\u5355\u4e2a\u4ea4\u6362\u94fe\uff0c\u5219\u4e0d\u9700\u8981\uff0c\u56e0\u4e3a\u53ef\u4ee5\u7b80\u5355\u7684\u4f7f\u7528\u5f53\u524d\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002 vkQueuePresentKHR(presentQueue, &presentInfo); C++ vkQueuePresentKHR \u51fd\u6570\u63d0\u4ea4\u8bf7\u6c42\u5448\u73b0\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u3002\u6211\u4eec\u5728\u4e0b\u4e00\u4e2a\u7ae0\u8282\u4e3a vkAcquireNextImageKHR \u548c vkQueuePresentKHR \u53ef\u4ee5\u6dfb\u52a0\u9519\u8bef\u5904\u7406\u3002\u56e0\u4e3a\u5b83\u4eec\u5931\u8d25\u5e76\u4e0d\u4e00\u5b9a\u610f\u5473\u7740\u7a0b\u5e8f\u5e94\u8be5\u7ec8\u6b62\uff0c\u4e0e\u6211\u4eec\u8fc4\u4eca\u4e3a\u6b62\u770b\u5230\u7684\u529f\u80fd\u4e0d\u540c\u3002 \u5982\u679c\u4e00\u5207\u987a\u5229\uff0c\u5f53\u518d\u6b21\u8fd0\u884c\u7a0b\u5e8f\u65f6\u5019\uff0c\u5e94\u8be5\u53ef\u4ee5\u770b\u5230\u4e00\u4e0b\u5185\u5bb9: \u9057\u61be\u7684\u662f\uff0c\u53ea\u8981\u7a0b\u5e8f\u5173\u95ed\uff0c\u7531\u4e8e\u5f00\u542f\u4e86validation layers\u4f60\u5c06\u4f1a\u770b\u5230\u7a0b\u5e8f\u5d29\u6e83\u7684\u4fe1\u606f\u3002\u4ece\u7ec8\u7aef\u63a7\u5236\u53f0\u6253\u5370\u7684\u4fe1\u606f\u6765\u6e90 debugCallback \uff0c\u544a\u8bc9\u4e86\u6211\u4eec\u5177\u4f53\u7684\u539f\u56e0: \u9700\u8981\u4e86\u89e3\u7684\u662f drawFrame \u51fd\u6570\u4e2d\u6240\u6709\u7684\u64cd\u4f5c\u90fd\u662f\u5f02\u6b65\u7684\u3002\u610f\u5473\u7740\u5f53\u7a0b\u5e8f\u9000\u51fa mainLoop \uff0c\u7ed8\u5236\u548c\u5448\u73b0\u64cd\u4f5c\u53ef\u80fd\u4ecd\u7136\u5728\u6267\u884c\u3002\u6240\u4ee5\u6e05\u7406\u8be5\u90e8\u5206\u7684\u8d44\u6e90\u662f\u4e0d\u53cb\u597d\u7684\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u5e94\u8be5\u5728\u9000\u51fa mainLoop \u9500\u6bc1\u7a97\u4f53\u524d\u7b49\u5f85\u903b\u8f91\u8bbe\u5907\u7684\u64cd\u4f5c\u5b8c\u6210: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); drawFrame(); } vkDeviceWaitIdle(device); } C++ \u4e5f\u53ef\u4ee5\u4f7f\u7528 vkQueueWaitIdle \u7b49\u5f85\u7279\u5b9a\u547d\u4ee4\u961f\u5217\u4e2d\u7684\u64cd\u4f5c\u5b8c\u6210\u3002\u8fd9\u4e9b\u529f\u80fd\u53ef\u4ee5\u4f5c\u4e3a\u4e00\u4e2a\u975e\u5e38\u57fa\u672c\u7684\u65b9\u5f0f\u6765\u6267\u884c\u540c\u6b65\u3002\u8fd9\u4e2a\u65f6\u5019\u7a97\u4f53\u5173\u95ed\u540e\u8be5\u95ee\u9898\u4e0d\u4f1a\u51fa\u73b0\u3002 \u5185\u5b58\u6cc4\u6f0f \u5982\u679c\u8fd0\u884c\u65f6\u542f\u7528\u4e86 validation layers \u5e76\u76d1\u89c6\u5e94\u7528\u7a0b\u5e8f\u7684\u5185\u5b58\u4f7f\u7528\u60c5\u51b5\uff0c\u4f60\u4f1a\u53d1\u73b0\u5b83\u5728\u6162\u6162\u589e\u52a0\u3002\u539f\u56e0\u662f validation layers \u7684\u5b9e\u73b0\u671f\u671b\u4e0e GPU \u540c\u6b65\u3002\u867d\u7136\u5728\u6280\u672f\u4e0a\u662f\u4e0d\u9700\u8981\u7684\uff0c\u4f46\u662f\u4e00\u65e6\u8fd9\u6837\u505a\uff0c\u6bcf\u4e00\u9488\u5e27\u4e0d\u4f1a\u51fa\u73b0\u660e\u663e\u7684\u6027\u80fd\u5f71\u54cd\u3002 \u6211\u4eec\u53ef\u4ee5\u5728\u5f00\u59cb\u7ed8\u5236\u4e0b\u4e00\u5e27\u4e4b\u524d\u660e\u786e\u7684\u7b49\u5f85 presentation \u5b8c\u6210: void drawFrame() { ... vkQueuePresentKHR(presentQueue, &presentInfo); vkQueueWaitIdle(presentQueue); } C++ \u5728\u5f88\u591a\u5e94\u7528\u7a0b\u5e8f\u7684\u7684\u72b6\u6001\u4e5f\u4f1a\u5728\u6bcf\u4e00\u5e27\u66f4\u65b0\u3002\u4e3a\u6b64\u66f4\u9ad8\u6548\u7684\u7ed8\u5236\u4e00\u9635\u7684\u65b9\u5f0f\u5982\u4e0b\uff1a void drawFrame() { updateAppState(); vkQueueWaitIdle(presentQueue); vkAcquireNextImageKHR(...) submitDrawCommands(); vkQueuePresentKHR(presentQueue, &presentInfo); } C++ \u8be5\u65b9\u6cd5\u5141\u8bb8\u6211\u4eec\u66f4\u65b0\u5e94\u7528\u7a0b\u5e8f\u7684\u72b6\u6001\uff0c\u6bd4\u5982\u8fd0\u884c\u6e38\u620f\u7684AI\u534f\u540c\u7a0b\u5e8f\uff0c\u800c\u524d\u4e00\u5e27\u88ab\u6e32\u67d3\u3002\u8fd9\u6837\uff0c\u59cb\u7ec8\u4fdd\u6301 CPU \u548c GPU \u5904\u4e8e\u5de5\u4f5c\u72b6\u6001\u3002 \u7ed3\u8bba \u5927\u7ea6800\u884c\u4ee3\u7801\u4e4b\u540e\uff0c\u6211\u4eec\u7ec8\u4e8e\u770b\u5230\u4e86\u4e09\u89d2\u5f62\u7ed8\u5236\u5728\u5c4f\u5e55\u4e0a\uff01 Vulkan \u5f15\u5bfc\u7a0b\u5e8f\u9700\u8981\u5f88\u591a\u7684\u5de5\u4f5c\u8981\u53bb\u505a\uff0c\u4f46\u597d\u5904\u662f Vulkan \u901a\u8fc7\u8981\u6c42\u6bcf\u4e00\u4e2a\u660e\u786e\u7684\u5b9e\u73b0\uff0c\u5e26\u6765\u4e86\u4e86\u5de8\u5927\u7684\u63a7\u5236\u6743\u3002\u5efa\u8bae\u82b1\u8d39\u4e00\u4e9b\u65f6\u95f4\u91cd\u65b0\u8bfb\u4ee3\u7801\uff0c\u5e76\u5efa\u7acb\u4e00\u4e2a\u601d\u7ef4\u5bfc\u56fe\u6a21\u578b\uff0c\u76ee\u7684\u5728\u4e8e\u4e86\u89e3 Vulkan \u4e2d\u6bcf\u4e00\u4e2a\u5bf9\u8c61\uff0c\u4ee5\u53ca\u5b83\u4eec\u7684\u4e92\u76f8\u7684\u5173\u7cfb\u3002\u4e4b\u540e\u6211\u4eec\u5c06\u4f1a\u57fa\u4e8e\u8fd9\u4e2a\u57fa\u7840\u6784\u5efa\u6269\u5c55\u7a0b\u5e8f\u529f\u80fd\u3002 \u5728\u4e0b\u4e00\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u7ec6\u5316 Vulkan \u7a0b\u5e8f\u4e2d\u7684\u4e00\u4e9b\u7ec6\u8282\uff0c\u4f7f\u5176\u8868\u73b0\u66f4\u7a33\u5b9a\u3002 Vulkan \u91cd\u6784\u4ea4\u6362\u94fe Vulkan \u91cd\u6784\u4ea4\u6362\u94fe \uff0c\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6210\u529f\u7684\u5728\u5c4f\u5e55\u4e0a\u7ed8\u5236\u51fa\u4e09\u89d2\u5f62\uff0c\u4f46\u662f\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5b83\u4f1a\u51fa\u73b0\u5f02\u5e38\u60c5\u51b5\u3002\u7a97\u4f53 surface \u4f1a\u53d1\u751f\u6539\u53d8\uff0c\u4f7f\u5f97\u4ea4\u6362\u94fe\u4e0d\u5728\u4e0e\u5176\u517c\u5bb9\u3002\u53ef\u80fd\u5bfc\u81f4\u8fd9\u79cd\u60c5\u51b5\u53d1\u751f\u7684\u539f\u56e0\u4e4b\u4e00\u662f\u7a97\u4f53\u7684\u5927\u5c0f\u53d8\u5316\u3002\u6211\u4eec\u5fc5\u987b\u5728\u8fd9\u4e2a\u65f6\u673a\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe 2 \u7a97\u53e3\u5927\u5c0f\u8c03\u6574 3 \u6b21\u4f18\u6216\u8fc7\u671f\u7684\u4ea4\u6362\u94fe \u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe \u6dfb\u52a0\u65b0\u7684\u51fd\u6570 recreateSwapChain \u5e76\u8c03\u7528 createSwapChain \u53ca\u4f9d\u8d56\u4e8e\u4ea4\u6362\u94fe\u6216\u8005\u7a97\u4f53\u5927\u5c0f\u7684\u5bf9\u8c61\u76f8\u5173\u7684\u6240\u6709\u521b\u5efa\u51fd\u6570\u3002 void recreateSwapChain() { vkDeviceWaitIdle(device); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers(); } \u6211\u4eec\u9996\u5148\u8c03\u7528 vkDeviceIdle ,\u5c31\u50cf\u524d\u4e00\u4e2a\u7ae0\u8282\u63d0\u5230\u7684\uff0c\u6211\u4eec\u4e0d\u80fd\u89e6\u78b0\u6b63\u5728\u4f7f\u7528\u4e2d\u7684\u8d44\u6e90\u3002\u5f88\u660e\u663e\uff0c\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u672c\u8eab\u3002\u56fe\u50cf\u89c6\u56fe\u4e5f\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4eec\u76f4\u63a5\u5efa\u7acb\u5728\u4ea4\u6362\u94fe\u56fe\u50cf\u57fa\u7840\u4e0a\u3002\u6e32\u67d3\u901a\u9053\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4f9d\u8d56\u4ea4\u6362\u94fe\u56fe\u50cf\u7684\u683c\u5f0f\u3002\u5728\u7a97\u4f53\u8c03\u6574\u5927\u5c0f\u7684\u64cd\u4f5c\u671f\u95f4\uff0c\u4ea4\u6362\u94fe\u56fe\u50cf\u683c\u5f0f\u5f88\u5c11\u53d1\u751f\u53d8\u5316\uff0c\u4f46\u4ecd\u5e94\u8be5\u88ab\u5904\u7406\u3002\u5728\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u671f\u95f4\u6307\u5b9a Viewport \u548c scissor \u77e9\u5f62\u5927\u5c0f\uff0c\u6240\u4ee5\u7ba1\u7ebf\u9700\u8981\u91cd\u65b0\u6784\u5efa\u3002\u53ef\u4ee5\u4f7f\u7528\u52a8\u6001\u72b6\u6001\u6539\u53d8 viewports \u548c scissor rectangles \uff0c\u907f\u514d\u91cd\u65b0\u521b\u5efa\u3002\u6700\u540e\u5e27\u7f13\u51b2\u533a\u548c\u547d\u4ee4\u7f13\u51b2\u533a\u4e5f\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4eec\u4e5f\u4f9d\u8d56\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u3002 \u4e3a\u4e86\u786e\u4fdd\u91cd\u65b0\u521b\u5efa\u76f8\u5173\u7684\u5bf9\u8c61\u4e4b\u524d\uff0c\u8001\u7248\u672c\u7684\u5bf9\u8c61\u88ab\u7cfb\u7edf\u6b63\u786e\u56de\u6536\u6e05\u7406\uff0c\u6211\u4eec\u9700\u8981\u79fb\u52a8\u4e00\u4e9bcleanup\u4ee3\u7801\u5230\u4e0d\u540c\u7684\u51fd\u6570\u4e2d\uff0c\u8fd9\u6837\u53ef\u4ee5\u5728 recreateSwapChain \u51fd\u6570\u8c03\u7528\u3002\u8be5\u51fd\u6570\u5b9a\u4e49\u4e3a cleanupSwapChain : void cleanupSwapChain() { } void recreateSwapChain() { vkDeviceWaitIdle(device); cleanupSwapChain() createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers(); } \u6211\u4eec\u4ece cleanup \u4e2d\u5c06\u9700\u8981\u88ab\u91cd\u65b0\u521b\u5efa\u7684\u5bf9\u8c61\u6240\u5bf9\u5e94\u7684\u6e05\u7406\u4ee3\u7801\u79fb\u52a8\u5230 cleanupSwapChain \u4e2d: void cleanupSwapChain() { for (size_t i = 0; i < swapChainFramebuffers.size(); i++) { vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); } vkFreeCommandBuffers(device, commandPool, static_cast<uint32_t>(commandBuffers.size()), commandBuffers.data()); vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); for (size_t i = 0; i < swapChainImageViews.size(); i++) { vkDestroyImageView(device, swapChainImageViews[i], nullptr); } vkDestroySwapchainKHR(device, swapChain, nullptr); } void cleanup() { cleanupSwapChain(); vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); vkDestroyCommandPool(device, commandPool, nullptr); vkDestroyDevice(device, nullptr); DestroyDebugReportCallbackEXT(instance, callback, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate(); } \u6211\u4eec\u91cd\u5934\u521b\u5efa\u547d\u4ee4\u5bf9\u8c61\u6c60 command pool \uff0c\u4f46\u662f\u6bd4\u8f83\u6d6a\u8d39\u770b\u8d77\u6765\u3002\u76f8\u53cd\u7684\uff0c\u6211\u4eec\u9009\u62e9\u501f\u52a9 vkFreeCommandBuffers \u51fd\u6570\u6e05\u7406\u5df2\u7ecf\u5b58\u5728\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u8fd9\u79cd\u65b9\u5f0f\u53ef\u4ee5\u91cd\u7528\u5bf9\u8c61\u6c60\u4e2d\u5df2\u7ecf\u5206\u914d\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002 \u4ee5\u4e0a\u90e8\u5206\u5c31\u662f\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u7684\u5de5\u4f5c\uff01\u7136\u800c\u8fd9\u6837\u505a\u7684\u7f3a\u70b9\u5c31\u662f\u5728\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u5b8c\u6bd5\u4e4b\u524d\uff0c\u4f1a\u9020\u6210\u6e32\u67d3\u505c\u6b62\u3002\u521b\u5efa\u65b0\u4ea4\u6362\u94fe\u7684\u540c\u65f6\u5141\u8bb8\u5728\u65e7\u7684\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u4e0a\u7ee7\u7eed\u7ed8\u5236\u547d\u4ee4\u3002\u9700\u8981\u5c06\u4e4b\u524d\u7684\u4ea4\u6362\u94fe\u4f20\u9012\u5230 VkSwapchainCreateInfoKHR \u7ed3\u6784\u4f53\u4e2d\u7684 oldSwapChain \u5b57\u6bb5\uff0c\u5e76\u5728\u4f7f\u7528\u4e4b\u540e\u7acb\u5373\u9500\u6bc1\u3002 \u7a97\u53e3\u5927\u5c0f\u8c03\u6574 \u73b0\u5728\u6211\u4eec\u9700\u8981\u641e\u6e05\u695a\u54ea\u4e9b\u60c5\u51b5\u4e0b\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u662f\u5fc5\u8981\u7684\uff0c\u5e76\u8c03\u7528 recreateSwapChain \u51fd\u6570\u3002\u4e00\u4e2a\u901a\u5e38\u7684\u6761\u4ef6\u662f\u7a97\u4f53\u7684\u5927\u5c0f\u53d8\u5316\u3002\u8ba9\u6211\u4eec\u8c03\u6574\u7a97\u4f53\u7684\u5927\u5c0f\uff0c\u5e76\u89c2\u5bdf\u6355\u6349\u5230\u7684\u4e8b\u4ef6\u3002\u4fee\u6539 initWindow \u51fd\u6570\u4e0d\u518d\u5305\u542b GLFW_RESIZABLE \u884c\uff0c\u6216\u8005\u5c06\u5176\u53c2\u6570\u4ece GLFW_FALSE \u4fee\u6539\u4e3a GLFW_TRUE \u3002 void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); glfwSetWindowUserPointer(window, this); glfwSetWindowSizeCallback(window, HelloTriangleApplication::onWindowResized); } ... static void onWindowResized(GLFWwindow* window, int width, int height) { if (width == 0 || height == 0) return; HelloTriangleApplication* app = reinterpret_cast<HelloTriangleApplication*>(glfwGetWindowUserPointer(window)); app->recreateSwapChain(); } C++ glfwSetWindowSizeCallback \u51fd\u6570\u4f1a\u5728\u7a97\u4f53\u53d1\u751f\u5927\u5c0f\u53d8\u5316\u7684\u65f6\u5019\u88ab\u4e8b\u4ef6\u56de\u8c03\u3002\u9057\u61be\u7684\u662f\uff0c\u5b83\u53ea\u80fd\u63a5\u53d7\u4e00\u4e2a\u6307\u9488\u4f5c\u4e3a\u53c2\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u76f4\u63a5\u4f7f\u7528\u6210\u5458\u51fd\u6570\u3002\u4f46\u5e78\u8fd0\u7684\u662f\uff0cGLFW\u5141\u8bb8\u6211\u4eec\u4f7f\u7528 glfwSetWindowUserPointer \u5c06\u4efb\u610f\u6307\u9488\u5b58\u50a8\u5728\u7a97\u4f53\u5bf9\u8c61\u4e2d\uff0c\u56e0\u6b64\u53ef\u4ee5\u6307\u5b9a\u9759\u6001\u7c7b\u6210\u5458\u8c03\u7528 glfwGetWindowUserPointer \u8fd4\u56de\u539f\u59cb\u7684\u5b9e\u4f8b\u5bf9\u8c61\u3002\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528 recreateSwapChain \uff0c\u8fd9\u79cd\u60c5\u51b5\u901a\u5e38\u53d1\u751f\u5728\uff0c\u7a97\u4f53\u6700\u5c0f\u5316\u5e76\u4e14\u5bfc\u81f4\u4ea4\u6362\u94fe\u521b\u5efa\u5931\u8d25\u65f6. chooseSwapExtent \u51fd\u6570\u5e94\u8be5\u589e\u52a0\u66f4\u65b0\u903b\u8f91\uff0c\u4f7f\u7528\u7a97\u4f53\u6700\u65b0\u7684 width \u548c height \u4ee3\u66ff\u6700\u521d\u7684 WIDTH \u548c HEIGHT : int width, height; glfwGetWindowSize(window, &width, &height); VkExtent2D actualExtent = {width, height}; C++ \u6b21\u4f18\u6216\u8fc7\u671f\u7684\u4ea4\u6362\u94fe \u6709\u4e9b\u65f6\u5019 Vulkan \u53ef\u80fd\u544a\u8bc9\u6211\u4eec\u5f53\u524d\u7684\u4ea4\u6362\u94fe\u5728 presentation \u65f6\u4e0d\u518d\u517c\u5bb9\u3002 vkAcquireNextImageKHR \u548c vkQueuePresentKHR \u51fd\u6570\u53ef\u4ee5\u8fd4\u56de\u5177\u4f53\u7684\u503c\u660e\u786e\u3002 VK_ERROR_OUT_DATE_KHR : \u4ea4\u6362\u94fe\u4e0esurface\u4e0d\u518d\u517c\u5bb9\uff0c\u4e0d\u53ef\u8fdb\u884c\u6e32\u67d3 VK_SUBOPTIMAL_KHR : \u4ea4\u6362\u94fe\u4ecd\u7136\u53ef\u4ee5\u5411surface\u63d0\u4ea4\u56fe\u50cf\uff0c\u4f46\u662fsurface\u7684\u5c5e\u6027\u4e0d\u518d\u5339\u914d\u51c6\u786e\u3002\u6bd4\u5982\u5e73\u53f0\u53ef\u80fd\u91cd\u65b0\u8c03\u6574\u56fe\u50cf\u7684\u5c3a\u5bf8\u9002\u5e94\u7a97\u4f53\u5927\u5c0f\u3002 VkResult result = vkAcquireNextImageKHR(device, swapChain, std::numeric_limits<uint64_t>::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex); if (result == VK_ERROR_OUT_OF_DATE_KHR) { recreateSwapChain(); return; } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) { throw std::runtime_error(\"failed to acquire swap chain image!\"); } C++ \u5982\u679c\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf timeout \uff0c\u8868\u660e\u4e0d\u518d\u53ef\u7528\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u7acb\u5373\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\uff0c\u5e76\u5728\u4e0b\u4e00\u6b21 drawFrame \u8c03\u7528\u4e2d\u5c1d\u8bd5\u83b7\u53d6\u3002 \u4f60\u4e5f\u53ef\u4ee5\u9009\u62e9\u5728\u4ea4\u6362\u94fe\u4e0d\u662f\u6700\u4f73\u72b6\u6001\u7684\u65f6\u5019\uff0c\u9009\u62e9\u91cd\u65b0\u521b\u5efa\uff0c\u6bd4\u5982\u521a\u624d\u8bf4\u7684\u5927\u5c0f\u4e0d\u5339\u914d\u95ee\u9898\u3002\u5728\u8fd9\u91cc\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u83b7\u5f97\u4e86\u4e00\u4e2a\u56fe\u50cf\uff0c\u6240\u4ee5\u7ee7\u7eed\u8fdb\u884c\u3002 VK_SUCCESS \u548c VK_SUBOPTIMAL_KHR \u90fd\u88ab\u8ba4\u4e3a\u662f\u201c\u6210\u529f\u201d\u8fd4\u56de\u7801\u3002 result = vkQueuePresentKHR(presentQueue, &presentInfo); if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) { recreateSwapChain(); } else if (result != VK_SUCCESS) { throw std::runtime_error(\"failed to present swap chain image!\"); } vkQueueWaitIdle(presentQueue); vkQueuePresentKHR \u51fd\u6570\u8fd4\u56de\u540c\u6837\u7684\u503c\u3002\u5728\u6211\u4eec\u7684\u6848\u4f8b\u4e2d\u6211\u4eec\uff0c\u5982\u679c\u662f\u975e\u6700\u4f73\u72b6\u6001\uff0c\u4e5f\u9009\u62e9\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u3002\u56e0\u4e3a\u6211\u4eec\u9700\u8981\u6700\u597d\u7684\u6548\u679c\u3002\u5c1d\u8bd5\u8c03\u6574\u7a97\u4f53\u7684\u5927\u5c0f\uff0c\u5e27\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u53d8\u5316\u4e0e\u7a97\u4f53\u5339\u914d\u3002 Congratulations \uff0c\u6211\u4eec\u5b8c\u7ed3\u4e86\u7b2c\u4e00\u4e2a\u8fd0\u884c\u6bd4\u8f83\u5b8c\u6574\u7684 Vulkan \u7a0b\u5e8f\uff0c\u5728\u4e0b\u9762\u7684\u7ae0\u8282\u4e2d\u6211\u4eec\u5c1d\u8bd5\u6446\u8131\u4e4b\u524d\u7684\u786c\u7f16\u7801\uff0c\u4f7f\u7528\u9876\u70b9\u7f13\u51b2\u533a\u4ee3\u66ff vertex shader \u4e2d\u5199\u6b7b\u9876\u70b9\u6570\u636e\u3002 \u7b2c\u4e8c\u7ae0 Vulkan \u9876\u70b9\u8f93\u5165 Vulkan \u521b\u5efa\u9876\u70b9\u7f13\u51b2\u533a Vulkan \u4e34\u65f6\u7f13\u51b2\u533a Vulkan \u7d22\u5f15\u7f13\u51b2\u533a Vulkan \u63cf\u8ff0\u7b26\u5e03\u5c40\u548c\u7f13\u51b2\u533a Vulkan \u63cf\u8ff0\u7b26\u6c60\u548c\u96c6\u5408 Vulkan \u56fe\u50cf(Images) Vulkan \u56fe\u50cf\u89c6\u56fe\u548c\u91c7\u6837\u5668 Vulkan \u7ec4\u5408\u56fe\u50cf\u53d6\u6837\u5668 Vulkan \u6df1\u5ea6\u7f13\u51b2\u533a Vulkan \u52a0\u8f7d\u6a21\u578b Vulkan \u751f\u6210\u8d34\u56fe(mipmap)","title":"Vulkan\u6559\u7a0b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_1","text":"","title":"\u7b2c\u4e00\u7ae0"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan-vulkan","text":"\u521b\u5efaVulkan\u5b9e\u4f8b \uff0c\u4e0e Vulkan \u6253\u4ea4\u9053\uff0c\u901a\u5e38\u7684\u6b65\u9aa4\u662f\u521b\u5efa\u4e00\u4e2a intance \u53bb\u521d\u59cb\u5316 Vulkan library \u3002\u8fd9\u4e2a instance \u662f\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u4e0e Vulkan \u5e93\u4e4b\u95f4\u7684\u8fde\u63a5\u6865\u6881,\u901a\u5e38\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u9700\u8981\u5411\u9a71\u52a8\u7a0b\u5e8f\u63d0\u4f9b\u4e00\u4e9b\u5e94\u7528\u5c42\u7684\u4fe1\u606f\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b 2 \u68c0\u67e5\u53ef\u9009\u529f\u80fd 3 \u9000\u51fa 4 \u6e90\u4ee3\u7801","title":"Vulkan \u521b\u5efaVulkan\u5b9e\u4f8b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_2","text":"Vulkan API \u4f7f\u7528 vkInstance \u5bf9\u8c61\u6765\u5b58\u50a8\u6240\u6709\u6bcf\u4e2a\u5e94\u7528\u7684\u72b6\u6001\u3002\u5e94\u7528\u7a0b\u5e8f\u5fc5\u987b\u5728\u6267\u884c\u4efb\u4f55\u5176\u4ed6 Vulkan \u64cd\u4f5c\u4e4b\u524d\u521b\u5efa\u4e00\u4e2a Vulkan \u5b9e\u4f8b\uff0c\u57fa\u672c\u7684 Vulkan \u67b6\u6784\u770b\u8d77\u6765\u662f\u8fd9\u6837\u7684\uff1a \u8bf7\u6ce8\u610f\uff0c\u56fe\u4e2d\u6709\u4e00\u4e9b\u5c42\uff08 Layer )\uff0c\u8fd9\u4e9b\u5c42\u4e5f\u88ab\u52a0\u8f7d\u5668\u52a0\u8f7d\u3002\u5c42\u901a\u5e38\u7528\u4e8e\u9a8c\u8bc1\uff0c\u901a\u5e38\u662f\u7531\u9a71\u52a8\u6267\u884c\u7684\u9519\u8bef\u68c0\u67e5\u3002\u5728 Vulkan \u4e2d\uff0c\u9a71\u52a8\u7a0b\u5e8f\u6bd4 OpenGL \u7b49\u5176\u4ed6 API \u8981\u8f7b\u91cf\u5f97\u591a\uff0c\u90e8\u5206\u539f\u56e0\u662f\u5b83\u5c06\u529f\u80fd\u9a8c\u8bc1\u59d4\u6258\u7ed9\u9a8c\u8bc1\u5c42\u3002\u5c42\u662f\u53ef\u9009\u7684\uff0c\u6bcf\u6b21\u5e94\u7528\u7a0b\u5e8f\u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u65f6\u90fd\u53ef\u4ee5\u9009\u62e9\u6027\u5730\u88c5\u8f7d\u3002 Vulkan Layer \u8d85\u51fa\u4e86\u672c\u7ae0\u7684\u8303\u56f4\uff0c\u4e0b\u9762\u5f00\u59cb\u521b\u5efavulkan\u5b9e\u4f8b\uff0c\u9996\u5148\u6dfb\u52a0\u4e00\u4e2a createInstance \u51fd\u6570\uff0c\u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\u3002 void initVulkan() { createInstance(); } C++ \u53e6\u5916\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u6765\u4fdd\u5b58 instance \u53e5\u67c4: private: VkInstance instance; C++ \u73b0\u5728\u6211\u4eec\u521b\u5efa\u4e00\u4e2a instance \uff0c\u5e76\u4e14\u4e3a\u8be5\u6570\u636e\u7ed3\u6784\u8d4b\u4e88\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u4fe1\u606f\u3002\u8fd9\u4e9b\u6570\u636e\u4ece\u6280\u672f\u89d2\u5ea6\u662f\u53ef\u9009\u62e9\u7684\uff0c\u4f46\u662f\u5b83\u53ef\u4ee5\u4e3a\u9a71\u52a8\u7a0b\u5e8f\u63d0\u4f9b\u4e00\u4e9b\u6709\u7528\u7684\u4fe1\u606f\u6765\u4f18\u5316\u7a0b\u5e8f\u7279\u6b8a\u7684\u4f7f\u7528\u60c5\u666f\uff0c\u6bd4\u5982\u9a71\u52a8\u7a0b\u5e8f\u4f7f\u7528\u4e00\u4e9b\u56fe\u5f62\u5f15\u64ce\u7684\u7279\u6b8a\u884c\u4e3a\u3002\u8fd9\u4e2a\u6570\u636e\u7ed3\u6784\u79f0\u4e3a VkApplicationInfo : VkApplicationInfo appInfo = {}; appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;appInfo.pNext = nullptr; appInfo.pApplicationName = \"Hello Triangle\"; appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.pEngineName = \"No Engine\"; appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.apiVersion = VK_API_VERSION_1_0; C++ \u5982\u524d\u6240\u8ff0\uff0c Vulkan \u4e2d\u7684\u8bb8\u591a\u6570\u636e\u7ed3\u6784\u8981\u6c42\u5728 sType \u6210\u5458\u4e2d\u660e\u786e\u7684\u6307\u5b9a\u7c7b\u578b\u3002 pNext \u6210\u5458\u53ef\u7528\u4e8e\u6307\u5411\u7279\u5b9a\u7684\u6269\u5c55\u7ed3\u6784\u3002\u6211\u4eec\u5728\u8fd9\u91cc\u4f7f\u7528\u9ed8\u8ba4\u521d\u59cb\u5316\uff0c\u5c06\u5176\u8bbe\u7f6e\u4e3a nullptr \u3002 Vulkan \u4e2d\u7684\u5927\u91cf\u4fe1\u606f\u901a\u8fc7\u7ed3\u6784\u4f53\u800c\u4e0d\u662f\u51fd\u6570\u53c2\u6570\u4f20\u9012\uff0c\u6211\u4eec\u5c06\u586b\u5145\u4e00\u4e2a\u7ed3\u6784\u4f53\u4ee5\u63d0\u4f9b\u8db3\u591f\u7684\u4fe1\u606f\u521b\u5efa instance \u3002\u4e0b\u4e00\u4e2a\u7ed3\u6784\u4f53\u4e0d\u662f\u53ef\u9009\u7684\uff0c\u5b83\u9700\u8981\u544a\u77e5 Vulkan \u9a71\u52a8\u7a0b\u5e8f\u6211\u4eec\u9700\u8981\u4f7f\u7528\u54ea\u4e9b\u5168\u5c40\u7684 extensions \u548c validation layers \u3002\u8fd9\u91cc\u7684\u5168\u5c40\u610f\u5473\u7740\u5b83\u9002\u7528\u4e8e\u6574\u4e2a\u7a0b\u5e8f\uff0c\u800c\u4e0d\u662f\u7279\u5b9a\u7684\u8bbe\u5907\uff0c\u8fd9\u4e9b\u5185\u5bb9\u5c06\u5728\u63a5\u4e0b\u6765\u7684\u5c0f\u8282\u4e2d\u8bf4\u660e\u3002 VkInstanceCreateInfo \u7ed3\u6784\u4f53\u4fe1\u606f\u5982\u4e0b\uff1a VkInstanceCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pApplicationInfo = &appInfo; C++ \u524d\u51e0\u4e2a\u53c2\u6570\u6bd4\u8f83\u7b80\u5355\u3002\u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u6307\u5b9a\u9700\u8981\u7684\u5168\u5c40\u6269\u5c55\uff0c Vulakn \u5bf9\u4e8e\u5e73\u53f0\u7279\u6027\u662f\u96f6 API \u652f\u6301\u7684(\u81f3\u5c11\u6682\u65f6\u8fd9\u6837)\uff0c\u8fd9\u610f\u5473\u7740\u9700\u8981\u4e00\u4e2a\u6269\u5c55\u624d\u80fd\u4e0e\u4e0d\u540c\u5e73\u53f0\u7684\u7a97\u4f53\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002 GLFW \u6709\u4e00\u4e2a\u65b9\u4fbf\u7684\u5185\u7f6e\u51fd\u6570\uff0c\u8fd4\u56de\u5b83\u6709\u5173\u7684\u6269\u5c55\u4fe1\u606f\uff0c\u6211\u4eec\u53ef\u4ee5\u4f20\u9012\u7ed9 struct : unsigned int glfwExtensionCount = 0; const char** glfwExtensions; glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount); createInfo.enabledExtensionCount = glfwExtensionCount; createInfo.ppEnabledExtensionNames = glfwExtensions; C++ \u7ed3\u6784\u4f53\u7684\u6700\u540e\u4e24\u4e2a\u6210\u5458\u786e\u5b9a\u9700\u8981\u5f00\u542f\u7684\u5168\u5c40\u7684 validation layers \u3002\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u4e00\u8282\u4e2d\u6df1\u5165\u63a2\u8ba8\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u5728\u8fd9\u4e00\u8282\u8bbe\u7f6e\u4e3a\u7a7a\u3002 createInfo.enabledLayerCount = 0; C++ \u6211\u4eec\u73b0\u5728\u5df2\u7ecf\u6307\u5b9a\u4e86 Vulkan \u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u9700\u8981\u7684\u4e00\u5207\u4fe1\u606f\uff0c\u8c03\u7528 vkCreateInstance \u521b\u5efa\u5c5e\u4e8e\u6211\u4eec\u7684\u7b2c\u4e00\u4e2a instance : VkResult result = vkCreateInstance(&createInfo, nullptr, &instance); C++ \u5982\u4f60\u6240\u89c1\uff0c Vulkan \u4e2d\u521b\u5efa\u3001\u5b9e\u4f8b\u5316\u76f8\u5173\u7684\u51fd\u6570\u53c2\u6570\u4e00\u822c\u9075\u5faa\u5982\u4e0b\u539f\u5219\u5b9a\u4e49: \u4f7f\u7528\u6709\u5173creation info \u7684\u7ed3\u6784\u4f53\u6307\u9488 \u4f7f\u7528\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u56de\u8c03\u7684\u6307\u9488 \u4f7f\u7528\u4fdd\u5b58\u65b0\u5bf9\u8c61\u53e5\u67c4\u7684\u6307\u9488 \u5982\u679c\u4e00\u5207\u987a\u5229\uff0c\u6b64\u523binstance\u7684\u53e5\u67c4\u5e94\u8be5\u5b58\u50a8\u5728 VkInstance \u7c7b\u6210\u5458\u4e2d\u4e86\u3002\u51e0\u4e4e\u6240\u6709\u7684Vulkan\u51fd\u6570\u90fd\u8fd4\u56de\u4e00\u4e2a\u503c\u4e3a VK_SUCCESS \u6216\u9519\u8bef\u4ee3\u7801\u7684 VkResult \u7c7b\u578b\u7684\u503c\u3002\u8981\u68c0\u67e5 instance \u662f\u5426\u5df2\u7ecf\u6210\u529f\u521b\u5efa\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u4fdd\u5b58\u7ed3\u679c\uff0c\u4ec5\u4ec5\u4f7f\u7528 VK_SUCCESS \u503c\u6765\u68c0\u6d4b\u5373\u53ef\uff1a if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) { throw std::runtime_error(\"failed to create instance!\"); } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\uff0c\u786e\u8ba4\u6211\u4eec\u7684 instance \u521b\u5efa\u6210\u529f\u3002","title":"\u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_3","text":"\u5982\u679c\u4f60\u67e5\u770b vkCreateInstance \u7684\u6587\u6863\uff0c\u4f60\u4f1a\u770b\u5230\u4e00\u4e2a\u53ef\u80fd\u51fa\u73b0\u7684\u9519\u8bef\u4ee3\u7801\u662f VK_ERROR_EXTENSION_NOT_PRESENT \u3002\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u5730\u6307\u5b9a\u6211\u4eec\u9700\u8981\u7684\u6269\u5c55\uff0c\u5982\u679c\u8be5\u9519\u8bef\u4ee3\u7801\u8fd4\u56de\uff0c\u5219\u7ec8\u6b62\u5b83\u4eec\u3002\u8fd9\u5bf9\u4e8e\u7a97\u4f53\u7cfb\u7edf\u6216\u8005\u8bf8\u5982\u6b64\u7c7b\u7684\u6269\u5c55\u662f\u6709\u610f\u4e49\u7684\uff0c\u90a3\u4e48\u5982\u4f55\u68c0\u67e5\u53ef\u9009\u529f\u80fd\u5462\uff1f \u5728\u521b\u5efa instance \u4e4b\u524d\u68c0\u7d22\u652f\u6301\u7684\u6269\u5c55\u5217\u8868\uff0c\u901a\u8fc7 vkEnumerateInstanceExtensionProperties \u51fd\u6570\u3002\u5b83\u6307\u5411\u4e00\u4e2a\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u5b58\u50a8\u6269\u5c55\u6570\u91cf\u548c\u4e00\u4e2a VkExtensionProperties \u6570\u7ec4\u6765\u5b58\u50a8\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f\u3002\u5b83\u4e5f\u63a5\u53d7\u4e00\u4e2a\u53ef\u9009\u62e9\u7684\u53c2\u6570\uff0c\u5141\u8bb8\u6211\u4eec\u901a\u8fc7\u7279\u5b9a\u7684 validation layers \u8fc7\u6ee4\u6269\u5c55\uff0c\u73b0\u5728\u6211\u4eec\u6682\u65f6\u5ffd\u7565\u8fd9\u4e9b\u3002 \u8981\u5206\u914d\u4e00\u4e2a\u6570\u7ec4\u6765\u4fdd\u5b58\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u77e5\u9053\u6709\u591a\u5c11\u4e2a\u6269\u5c55\u5b58\u5728\u3002\u53ef\u4ee5\u901a\u8fc7\u5c06\u540e\u4e00\u4e2a\u53c2\u6570\u7f6e\u7a7a\u6765\u83b7\u53d6\u6269\u5c55\u6570\u91cf: uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr); C++ \u73b0\u5728\u6211\u4eec\u5206\u914d\u4e00\u4e2a\u96c6\u5408\u53bb\u6301\u6709\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f( include ) std::vector<VkExtensionProperties> extensions(extensionCount); C++ \u6700\u540e\u6211\u4eec\u53ef\u4ee5\u904d\u5386\u6269\u5c55\u7684\u8be6\u7ec6\u4fe1\u606f: vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data()); C++ \u6bcf\u4e2a VkExtensionProperties \u7ed3\u6784\u4f53\u5305\u542b\u6269\u5c55\u7684\u540d\u79f0\u548c\u7248\u672c\u3002\u6211\u4eec\u53ef\u4ee5\u7528\u7b80\u5355\u7684for\u5faa\u73af\u6253\u5370\u4ed6\u4eec(\\t\u662f\u7f29\u8fdb) std::cout << \"available extensions:\" << std::endl; for (const auto& extension : extensions) { std::cout << \"\\t\" << extension.extensionName << std::endl; } C++ \u5982\u679c\u9700\u8981\u83b7\u53d6\u6709\u5173 Vulkan \u652f\u6301\u7684\u4e00\u4e9b\u8be6\u7ec6\u4fe1\u606f\uff0c\u53ef\u4ee5\u5c06\u6b64\u4ee3\u7801\u6dfb\u52a0\u5230 createInstance \u51fd\u6570\u3002\u4f5c\u4e3a\u4e00\u4e2a\u5c1d\u8bd5\uff0c\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\uff0c\u68c0\u67e5 glfwGetRequiredInstanceExtensions \u8fd4\u56de\u7684\u6240\u6709\u6269\u5c55\u662f\u5426\u90fd\u5305\u542b\u5728\u53d7\u652f\u6301\u7684\u6269\u5c55\u5217\u8868\u4e2d\u3002","title":"\u68c0\u67e5\u53ef\u9009\u529f\u80fd"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_4","text":"\u5728\u7a0b\u5e8f\u9000\u51fa\u524d\uff0c\u8bf7\u6b63\u786e\u9500\u6bc1 VkInstance \u3002\u8fd9\u90e8\u5206\u53ef\u4ee5\u5b9a\u4e49\u5728cleanup\u51fd\u6570\u4e2d\uff0c\u8c03\u7528 vkDestroyInstance \u51fd\u6570\u5b8c\u6210\u3002 void cleanup() { vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate(); } C++ vkDestroyInstance \u51fd\u6570\u7684\u53c2\u6570\u5f88\u7b80\u5355\u3002\u50cf\u4e4b\u524d\u5c0f\u8282\u63d0\u5230\u7684\uff0cVulkan\u4e2d\u7684\u5206\u914d\u548c\u91ca\u653e\u529f\u80fd\u6709\u4e00\u4e2a\u53ef\u9009\u7684\u5206\u914d\u5668\u56de\u8c03\uff0c\u6211\u4eec\u901a\u8fc7\u5c06 nullptr \u8bbe\u7f6e\u5ffd\u7565\u3002\u540e\u7eed\u5c0f\u8282\u4e2d\u521b\u5efa\u7684\u6240\u6709Vulkan\u76f8\u5173\u8d44\u6e90\uff0c\u96c6\u4e2d\u5728cleanup\u51fd\u6570\u4e2d\u8fdb\u884c\u6e05\u7406\uff0c\u4e14\u786e\u4fdd\u5728\u9500\u6bc1 instance \u4e4b\u524d\u9500\u6bc1\u3002 \u5728\u8fdb\u884c\u66f4\u590d\u6742\u7684\u5185\u5bb9\u4e4b\u524d\uff0c\u662f\u65f6\u5019\u4e86\u89e3 validation layers \u4e86\u3002","title":"\u9000\u51fa"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan","text":"Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217 \uff0c\u901a\u8fc7 VkInstance \u521d\u59cb\u5316 Vulkan \u540e\uff0c\u6211\u4eec\u9700\u8981\u5728\u7cfb\u7edf\u4e2d\u67e5\u627e\u5e76\u9009\u62e9\u4e00\u4e2a\u652f\u6301\u6211\u4eec\u6240\u9700\u529f\u80fd\u7684\u663e\u5361\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u6570\u91cf\u7684\u663e\u5361\u5e76\u540c\u65f6\u4f7f\u7528\u4ed6\u4eec\uff0c\u4f46\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u5355\u7684\u8bbe\u5b9a\u9009\u62e9\u89c4\u5219\uff0c\u5373\u5c06\u67e5\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u56fe\u5f62\u5361\u4f5c\u4e3a\u6211\u4eec\u9002\u5408\u7684\u7269\u7406\u8bbe\u5907\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9009\u62e9\u7269\u7406\u8bbe\u5907 2 \u8bbe\u5907\u9700\u6c42\u68c0\u6d4b 3 \u961f\u5217\u65cf 4 \u6e90\u4ee3\u7801","title":"Vulkan \u7269\u7406\u8bbe\u5907\u4e0e\u961f\u5217\u7c07"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_5","text":"\u901a\u8fc7 VkInstance \u521d\u59cb\u5316Vulkan\u540e\uff0c\u6211\u4eec\u9700\u8981\u5728\u7cfb\u7edf\u4e2d\u67e5\u627e\u5e76\u9009\u62e9\u4e00\u4e2a\u652f\u6301\u6211\u4eec\u6240\u9700\u529f\u80fd\u7684\u663e\u5361\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u6570\u91cf\u7684\u663e\u5361\u5e76\u540c\u65f6\u4f7f\u7528\u4ed6\u4eec\uff0c\u4f46\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u5355\u7684\u8bbe\u5b9a\u9009\u62e9\u89c4\u5219\uff0c\u5373\u5c06\u67e5\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u56fe\u5f62\u5361\u4f5c\u4e3a\u6211\u4eec\u9002\u5408\u7684\u7269\u7406\u8bbe\u5907\u3002 \u6211\u4eec\u6dfb\u52a0\u51fd\u6570 pickPhysicalDevice \u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); pickPhysicalDevice(); } void pickPhysicalDevice() { } C++ \u6700\u7ec8\u6211\u4eec\u9009\u62e9\u7684\u56fe\u5f62\u663e\u5361\u5b58\u50a8\u5728\u7c7b\u6210\u5458 VkPhysicalDevice \u53e5\u67c4\u4e2d\u3002\u5f53 VkInstance \u9500\u6bc1\u65f6\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u5c06\u4f1a\u88ab\u9690\u5f0f\u9500\u6bc1\uff0c\u6240\u4ee5\u6211\u4eec\u5e76\u4e0d\u9700\u8981\u5728 cleanup \u51fd\u6570\u4e2d\u505a\u4efb\u4f55\u64cd\u4f5c\u3002 VkPhysicalDevice physicalDevice = VK_NULL_HANDLE; C++ \u5173\u4e8e\u83b7\u53d6\u56fe\u5f62\u5361\u5217\u8868\u7684\u65b9\u5f0f\u4e0e\u83b7\u5f97\u6269\u5c55\u5217\u8868\u7684\u65b9\u5f0f\u7c7b\u4f3c\u3002 uint32_t deviceCount = 0; vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr); C++ \u5982\u679c Vulkan \u652f\u6301\u7684\u8bbe\u5907\u6570\u4e3a0\uff0c\u90a3\u4e48\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u8fdb\u884c\u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u9009\u62e9\u629b\u51fa\u5f02\u5e38\u3002 if (deviceCount == 0) { throw std::runtime_error(\"failed to find GPUs with Vulkan support!\"); } C++ \u5426\u5219\u6211\u4eec\u5206\u914d\u6570\u7ec4\u5b58\u50a8\u6240\u6709 VkPhysicalDevice \u7684\u53e5\u67c4\u3002 std::vector<VkPhysicalDevice> devices(deviceCount); vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()); C++ \u73b0\u5728\u6211\u4eec\u9700\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u8bc4\u4f30\uff0c\u68c0\u67e5\u5b83\u4eec\u662f\u5426\u9002\u5408\u6211\u4eec\u8981\u6267\u884c\u7684\u64cd\u4f5c\uff0c\u56e0\u4e3a\u5e76\u4e0d\u662f\u6240\u6709\u7684\u663e\u5361\u529f\u80fd\u4e00\u81f4\u3002\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u51fd\u6570: bool isDeviceSuitable(VkPhysicalDevice device) { return true; } C++ \u6211\u4eec\u5c06\u68c0\u67e5\u662f\u5426\u6709\u4efb\u4f55\u7269\u7406\u8bbe\u5907\u7b26\u5408\u6211\u4eec\u7684\u529f\u80fd\u9700\u6c42\u3002 for (const auto& device : devices) { if (isDeviceSuitable(device)) { physicalDevice = device; break; } } if (physicalDevice == VK_NULL_HANDLE) { throw std::runtime_error(\"failed to find a suitable GPU!\"); } C++ \u4e0b\u4e00\u8282\u6211\u4eec\u4ecb\u7ecd isDeviceSuitable \u51fd\u6570\uff0c\u5e76\u68c0\u67e5\u7b2c\u4e00\u4e2a\u9700\u8981\u6ee1\u8db3\u7684\u529f\u80fd\u3002\u5728\u540e\u7eed\u7684\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u5f00\u59cb\u4f7f\u7528\u66f4\u591a\u7684 Vulkan \u529f\u80fd\uff0c\u6211\u4eec\u4f1a\u6269\u5c55\u6b64\u529f\u80fd\u51fd\u6570\u4ee5\u6ee1\u8db3\u66f4\u591a\u7684\u68c0\u67e5\u6761\u4ef6\u3002","title":"\u9009\u62e9\u7269\u7406\u8bbe\u5907"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_6","text":"\u8bc4\u4f30\u5408\u9002\u7684\u8bbe\u5907\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u904d\u5386\u4e00\u4e9b\u7ec6\u8282\u6765\u5b8c\u6210\u3002\u57fa\u672c\u7684\u8bbe\u5907\u5c5e\u6027\u50cfname, type\u4ee5\u53ca Vulkan \u7248\u672c\u90fd\u53ef\u4ee5\u901a\u8fc7 vkGetPhysicalDeviceProperties \u6765\u904d\u5386\u5f97\u5230\u3002 VkPhysicalDeviceProperties deviceProperties; vkGetPhysicalDeviceProperties(device, &deviceProperties); C++ \u53ef\u4ee5\u4f7f\u7528 vkGetPhysicalDeviceFeatures \u67e5\u8be2\u5bf9\u7eb9\u7406\u538b\u7f29\uff0c64\u4f4d\u6d6e\u70b9\u6570\u548c\u591a\u89c6\u56fe\u6e32\u67d3(VR\u975e\u5e38\u6709\u7528)\u7b49\u53ef\u9009\u529f\u80fd\u7684\u652f\u6301: VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceFeatures(device, &deviceFeatures); C++ \u66f4\u591a\u904d\u5386\u7269\u7406\u8bbe\u5907\u7ec6\u8282\u7684\u4fe1\u606f\uff0c\u8bf8\u5982\u8bbe\u5907\u5185\u5b58\u3001\u961f\u5217\u7c07\u6211\u4eec\u5c06\u4f1a\u5728\u540e\u7eed\u5c0f\u8282\u8ba8\u8bba\u3002 \u4f8b\u5982\uff0c\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u4ec5\u9002\u7528\u4e8e\u652f\u6301 geometry shaders \u7684\u4e13\u7528\u663e\u5361\u3002\u90a3\u4e48 isDeviceSuitable \u51fd\u6570\u5c06\u5982\u4e0b\u6240\u793a: bool isDeviceSuitable(VkPhysicalDevice device) { VkPhysicalDeviceProperties deviceProperties; VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceProperties(device, &deviceProperties); vkGetPhysicalDeviceFeatures(device, &deviceFeatures); return deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU && deviceFeatures.geometryShader; } C++ \u4e3a\u4e86\u907f\u514d\u7eaf\u7cb9\u7684\u5355\u4e00\u7684\u5224\u65ad\u4e00\u4e2a\u8bbe\u5907\u662f\u5426\u5408\u9002\uff0c\u5c24\u5176\u662f\u5f53\u4f60\u53d1\u73b0\u591a\u4e2a\u8bbe\u5907\u90fd\u5408\u9002\u7684\u6761\u4ef6\u4e0b\uff0c\u4f60\u4e5f\u53ef\u4ee5\u7ed9\u6bcf\u4e00\u4e2a\u8bbe\u5907\u505a\u6743\u503c\uff0c\u9009\u62e9\u6700\u9ad8\u7684\u4e00\u4e2a\u3002\u8fd9\u6837\uff0c\u53ef\u4ee5\u901a\u8fc7\u7ed9\u4e88\u66f4\u9ad8\u6743\u503c\u83b7\u53d6\u5b9a\u5236\u5316\u7684\u56fe\u5f62\u8bbe\u5907\uff0c\u4f46\u5982\u679c\u6ca1\u6709\u4e00\u4e2a\u53ef\u7528\u7684\u8bbe\u5907\uff0c\u53ef\u4ee5\u56de\u6eda\u5230\u96c6\u6210\u56fe\u5f62\u8bbe\u5907\u3002\u4f60\u53ef\u4ee5\u6309\u7167\u5982\u4e0b\u65b9\u5f0f\u5b9e\u73b0: #include <map> ... void pickPhysicalDevice() { ... // Use an ordered map to automatically sort candidates by increasing score std::multimap<int, VkPhysicalDevice> candidates; for (const auto& device : devices) { int score = rateDeviceSuitability(device); candidates.insert(std::make_pair(score, device)); } // Check if the best candidate is suitable at all if (candidates.rbegin()->first > 0) { physicalDevice = candidates.rbegin()->second; } else { throw std::runtime_error(\"failed to find a suitable GPU!\"); } } int rateDeviceSuitability(VkPhysicalDevice device) { ... int score = 0; // Discrete GPUs have a significant performance advantage if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) { score += 1000; } // Maximum possible size of textures affects graphics quality score += deviceProperties.limits.maxImageDimension2D; // Application can't function without geometry shaders if (!deviceFeatures.geometryShader) { return 0; } return score; } C++ \u6211\u4eec\u4e0d\u9700\u8981\u5728\u5c0f\u8282\u5185\u5b9e\u73b0\u6240\u6709\u5185\u5bb9\uff0c\u4f46\u6211\u4eec\u53ef\u4ee5\u4e86\u89e3\u5982\u4f55\u9009\u62e9\u56fe\u5f62\u8bbe\u5907\u7684\u8fc7\u7a0b\u3002\u5f53\u7136\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u793a\u56fe\u5f62\u8bbe\u5907\u7684\u540d\u79f0\u5217\u8868\uff0c\u8ba9\u7528\u6237\u9009\u62e9\u3002 \u56e0\u4e3a\u6211\u4eec\u521a\u521a\u5f00\u59cb\uff0c Vulkan \u7684\u652f\u6301\u662f\u6211\u4eec\u552f\u4e00\u9700\u8981\u7684\uff0c\u5728\u8fd9\u91cc\u5047\u8bbe\u4efb\u4f55GPU\u90fd\u53ef\u4ee5: bool isDeviceSuitable(VkPhysicalDevice device) { return true; } C++ \u5728\u4e0b\u4e00\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u8ba8\u8bba\u7b2c\u4e00\u4e2a\u771f\u6b63\u9700\u8981\u68c0\u67e5\u7684\u8bbe\u5907\u529f\u80fd\u3002","title":"\u8bbe\u5907\u9700\u6c42\u68c0\u6d4b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_7","text":"\u4e4b\u524d\u5df2\u7ecf\u7b80\u8981\u7684\u4ecb\u7ecd\u8fc7\uff0c\u51e0\u4e4e\u6240\u6709\u7684 Vulkan \u64cd\u4f5c\uff0c\u4ece\u7ed8\u56fe\u5230\u4e0a\u4f20\u7eb9\u7406\uff0c\u90fd\u9700\u8981\u5c06\u547d\u4ee4\u63d0\u4ea4\u5230\u961f\u5217\u4e2d\u3002\u6709\u4e0d\u540c\u7c7b\u578b\u7684\u961f\u5217\u6765\u6e90\u4e8e\u4e0d\u540c\u7684\u961f\u5217\u7c07\uff0c\u6bcf\u4e2a\u961f\u5217\u7c07\u53ea\u5141\u8bb8\u90e8\u5206 commands \u3002\u4f8b\u5982\uff0c\u53ef\u4ee5\u6709\u4e00\u4e2a\u961f\u5217\u7c07\uff0c\u53ea\u5141\u8bb8\u5904\u7406\u8ba1\u7b97 commands \u6216\u8005\u53ea\u5141\u8bb8\u5185\u5b58\u4f20\u8f93 commands : \u6211\u4eec\u9700\u8981\u68c0\u6d4b\u8bbe\u5907\u4e2d\u652f\u6301\u7684\u961f\u5217\u7c07\uff0c\u5176\u4e2d\u54ea\u4e00\u4e2a\u961f\u5217\u7c07\u652f\u6301\u6211\u4eec\u60f3\u8981\u7684 commands \u3002\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u51fd\u6570 findQueueFamilies \u6765\u67e5\u627e\u6211\u4eec\u9700\u8981\u7684\u961f\u5217\u7c07\u3002\u73b0\u5728\u6211\u4eec\u53ea\u4f1a\u5bfb\u627e\u4e00\u4e2a\u652f\u6301\u56fe\u5f62 commands \u961f\u5217\u7c07\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u5728\u7a0d\u540e\u7684\u5c0f\u8282\u4e2d\u6269\u5c55\u66f4\u591a\u7684\u5185\u5bb9\u3002 \u6b64\u51fd\u6570\u8fd4\u56de\u6ee1\u8db3\u67d0\u4e2a\u5c5e\u6027\u7684\u961f\u5217\u7c07\u7d22\u5f15\u3002\u5b9a\u4e49\u7ed3\u6784\u4f53\uff0c\u5176\u4e2d\u7d22\u5f15 -1 \u8868\u793a\u201d\u672a\u627e\u5230\u201d: struct QueueFamilyIndices { int graphicsFamily = -1; bool isComplete() { return graphicsFamily >= 0; } }; C++ \u73b0\u5728\u6211\u4eec\u5b9e\u73b0 findQueueFamilies \u51fd\u6570: QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) { QueueFamilyIndices indices; ... return indices; } C++ \u83b7\u53d6\u961f\u5217\u7c07\u7684\u5217\u8868\u51fd\u6570\u4e3a vkGetPhysicalDeviceQueueFamilyProperties : uint32_t queueFamilyCount = 0; vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr); std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount); vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data()); C++ \u6709\u5173\u961f\u5217\u7c07\uff0c\u7ed3\u6784\u4f53 VkQueueFamilyProperties \u5305\u542b\u4e86\u5177\u4f53\u4fe1\u606f\uff0c\u5305\u62ec\u652f\u6301\u7684\u64cd\u4f5c\u7c7b\u578b\u548c\u57fa\u4e8e\u5f53\u524d\u961f\u5217\u7c07\u53ef\u4ee5\u521b\u5efa\u7684\u6709\u6548\u961f\u5217\u6570\u3002\u6211\u4eec\u81f3\u5c11\u9700\u8981\u627e\u5230\u4e00\u4e2a\u652f\u6301 VK_QUEUE_GRAPHICS_BIT \u7684\u961f\u5217\u7c07\u3002 int i = 0; for (const auto& queueFamily : queueFamilies) { if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) { indices.graphicsFamily = i; } if (indices.isComplete()) { break; } i++; } C++ \u73b0\u5728\u6211\u4eec\u6709\u4e86\u6bd4\u8f83\u7406\u60f3\u7684\u961f\u5217\u7c07\u67e5\u8be2\u529f\u80fd\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 isDeviceSuitable \u51fd\u6570\u4e2d\u4f7f\u7528\uff0c\u786e\u4fdd\u7269\u7406\u8bbe\u5907\u53ef\u4ee5\u5904\u7406\u6211\u4eec\u9700\u8981\u7684\u547d\u4ee4: bool isDeviceSuitable(VkPhysicalDevice device) { QueueFamilyIndices indices = findQueueFamilies(device); return indices.isComplete(); } C++ \u5f88\u597d\uff0c\u6211\u4eec\u5df2\u7ecf\u627e\u5230\u4e86\u6211\u4eec\u9700\u8981\u7684\u7269\u7406\u8bbe\u5907\uff0c\u5728 \u4e0b\u4e00\u4e2a\u5c0f\u8282 \u6211\u4eec\u4f1a\u8ba8\u8bba\u903b\u8f91\u8bbe\u5907\u3002","title":"\u961f\u5217\u65cf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_1","text":"Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b \uff0c \u4e0a\u4e00\u8282 \u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6b63\u786e\u914d\u7f6e\u3001\u53ef\u8fd0\u884c\u7684\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u4f7f\u7528\u6d4b\u8bd5\u4ee3\u7801\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u672c\u8282\u4e2d\u6211\u4eec\u4ece\u5934\u5f00\u59cb\uff0c\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u6784\u5efa\u4e00\u4e2a\u57fa\u4e8e GLFW \u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\u539f\u578b\u6846\u67b6\u7684\u96cf\u5f62\u3002 \u64cd\u4f5c\u7cfb\u7edf: Windows8.1 \u663e\u5361:Nivida GTX965M \u5f00\u53d1\u5de5\u5177\uff1aVisual Studio 2017 \u6587\u7ae0\u76ee\u5f55 1 \u603b\u4f53\u7ed3\u6784 2 \u8d44\u6e90\u7ba1\u7406 3 \u6574\u5408GLFW","title":"Vulkan \u5e94\u7528\u7a0b\u5e8f\u6846\u67b6\u539f\u578b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_8","text":"\u5728\u4e0a\u4e00\u8282\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6b63\u786e\u914d\u7f6e\u3001\u53ef\u8fd0\u884c\u7684\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u4f7f\u7528\u6d4b\u8bd5\u4ee3\u7801\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u672c\u8282\u4e2d\u6211\u4eec\u4ece\u5934\u5f00\u59cb\uff0c\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u6784\u5efa\u4e00\u4e2a\u57fa\u4e8eGLFW\u7684 Vulkan \u5e94\u7528\u7a0b\u5e8f\u539f\u578b\u6846\u67b6\u7684\u96cf\u5f62\u3002 #include <vulkan/vulkan.h> #include <iostream> #include <stdexcept> #include <functional> class HelloTriangleApplication { public: void run() { initVulkan(); mainLoop(); cleanup(); } private: void initVulkan() { } void mainLoop() { } void cleanup() { } }; int main() { HelloTriangleApplication app; try { app.run(); } catch (const std::runtime_error& e) { std::cerr << e.what() << std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; } C++ \u9996\u5148\u4ece LunarG SDK \u4e2d\u6dfb\u52a0 Vulkan \u5934\u6587\u4ef6\uff0c\u5b83\u63d0\u4f9b\u4e86\u8d2d\u673a\u7231\u4f60 Vulkan \u5e94\u7528\u7a0b\u5e8f\u9700\u8981\u7684\u51fd\u6570\u3001\u7ed3\u6784\u4f53\u3001\u548c\u679a\u4e3e\u3002\u6211\u4eec\u5305\u542b stdexcept \u548c iostream \u5934\u6587\u4ef6\u7528\u4e8e\u629b\u51fa\u5f02\u5e38\u4fe1\u606f\uff0c\u800c functional \u5934\u6587\u4ef6\u7528\u4e8e\u8d44\u6e90\u7ba1\u7406\u90e8\u5206\u652f\u6301 lambda \u8868\u8fbe\u5f0f\u3002 \u7a0b\u5e8f\u88ab\u5c01\u88c5\u5230\u4e00\u4e2a\u7c7b\u4e2d\uff0c\u8be5\u7c7b\u7ed3\u6784\u5c06\u4f1a\u5b58\u50a8Vulkan\u79c1\u6709\u6210\u5458\u5bf9\u8c61\uff0c\u5e76\u6dfb\u52a0\u57fa\u672c\u7684\u51fd\u6570\u6765\u521d\u59cb\u5316\u4ed6\u4eec\u3002\u9996\u5148\u4f1a\u4ece initVulkan \u51fd\u6570\u5f00\u59cb\u8c03\u7528\u3002\u5f53\u4e00\u5207\u51c6\u5907\u597d\uff0c\u6211\u4eec\u8fdb\u5165\u4e3b\u5faa\u73af\u5f00\u59cb\u6e32\u67d3\u5e27\u3002\u6211\u4eec\u5c06\u4f1a\u52a0\u5165 mainLoop \u51fd\u6570\u5305\u542bloop\u5faa\u73af\u8c03\u7528\uff0c\u8be5\u5faa\u73af\u8c03\u7528\u76f4\u5230GLFW\u7a97\u4f53\u7ba1\u7406\u624d\u4f1a\u505c\u6b62\u3002\u5f53\u7a97\u4f53\u5173\u95ed\u5e76\u4e14 mainLoop \u8fd4\u56de\u65f6\uff0c\u6211\u4eec\u9700\u8981\u91ca\u653e\u6211\u4eec\u5df2\u7ecf\u7533\u8bf7\u8fc7\u7684\u4efb\u4f55\u8d44\u6e90\uff0c\u8be5\u6e05\u7406\u903b\u8f91\u5728 cleanup \u51fd\u6570\u4e2d\u53bb\u5b9a\u4e49\u3002 \u7a0b\u5e8f\u8fd0\u884c\u671f\u95f4\uff0c\u5982\u679c\u53d1\u751f\u4e86\u4efb\u4f55\u4e25\u91cd\u7684\u9519\u8bef\u5f02\u5e38\uff0c\u6211\u4eec\u4f1a\u629b\u51fa std::runtime_error \u5e76\u6ce8\u660e\u5f02\u5e38\u63cf\u8ff0\u4fe1\u606f,\u8fd9\u4e2a\u5f02\u5e38\u4fe1\u606f\u4f1a\u88ab main \u51fd\u6570\u6355\u83b7\u53ca\u6253\u5370\u63d0\u793a\u3002\u5f88\u5feb\u4f60\u5c06\u4f1a\u9047\u5230\u4e00\u4e2a\u629b\u51faerror\u7684\u4f8b\u5b50\uff0c\u662f\u5173\u4e8e Vulkan \u5e94\u7528\u7a0b\u5e8f\u4e0d\u652f\u6301\u67d0\u4e2a\u5fc5\u8981\u7684\u6269\u5c55\u529f\u80fd\u3002 \u57fa\u672c\u4e0a\u5728\u4e4b\u540e\u7684\u6bcf\u4e00\u4e2a\u5c0f\u8282\u4e2d\u90fd\u4f1a\u4ece initVulkan \u51fd\u6570\u4e2d\u589e\u52a0\u4e00\u4e2a\u65b0\u7684 Vulkan \u51fd\u6570\u8c03\u7528,\u589e\u52a0\u7684\u51fd\u6570\u4f1a\u4ea7\u751f Vulkan objects \u5e76\u4fdd\u5b58\u4e3a\u7c7b\u7684\u79c1\u6709\u6210\u5458\uff0c\u8bf7\u8bb0\u5f97\u5728 cleanup \u4e2d\u8fdb\u884c\u8d44\u6e90\u7684\u6e05\u7406\u548c\u91ca\u653e\u3002","title":"\u603b\u4f53\u7ed3\u6784"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_9","text":"\u6211\u4eec\u77e5\u9053\u901a\u8fc7 malloc \u5206\u914d\u7684\u6bcf\u4e00\u4e2a\u5185\u5b58\u5feb\u5728\u4f7f\u7528\u5b8c\u4e4b\u540e\u90fd\u9700\u8981 free \u5185\u5b58\u8d44\u6e90\uff0c\u6bcf\u4e00\u4e2a\u6211\u4eec\u521b\u5efa\u7684 Vulkan object \u4e0d\u5728\u4f7f\u7528\u65f6\u90fd\u9700\u8981\u660e\u786e\u7684\u9500\u6bc1\u3002\u5728 C++ \u4e2d\u53ef\u4ee5\u5229\u7528 \u5b8c\u6210auto\u8d44\u6e90\u7ba1\u7406\uff0c\u4f46\u662f\u5728\u672c\u8282\u4e2d\uff0c\u9009\u62e9\u660e\u786e\u7f16\u5199\u6240\u6709\u7684\u5185\u5b58\u7684\u5206\u914d\u548c\u91ca\u653e\u64cd\u4f5c\uff0c\u5176\u4e3b\u8981\u539f\u56e0\u662f`\u7684\u8bbe\u8ba1\u7406\u5ff5\u5c31\u662f\u660e\u786e\u6bcf\u4e00\u6b65\u64cd\u4f5c\uff0c\u6e05\u695a\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f\uff0c\u907f\u514d\u53ef\u80fd\u5b58\u5728\u7684\u672a\u77e5\u4ee3\u7801\u9020\u6210\u7684\u5f02\u5e38\u3002 \u5f53\u7136\u5728\u672c\u8282\u4e4b\u540e,\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u91cd\u8f7d std::shared_ptr \u6765\u5b9e\u73b0auto \u8d44\u6e90\u7ba1\u7406\u3002\u5bf9\u4e8e\u66f4\u5927\u4f53\u91cf\u7684Vulkan\u7a0b\u5e8f,\u5efa\u8bae\u9075\u5faa RAII \u7684\u539f\u5219\u7ef4\u62a4\u8d44\u6e90\u7684\u7ba1\u7406\u3002 Vulkan \u5bf9\u8c61\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 vkCreateXXX \u7cfb\u51fd\u6570\u521b\u5efa\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u5177\u6709 vkAllocateXXX \u7b49\u529f\u80fd\u7684\u4e00\u4e2a\u5bf9\u8c61\u8fdb\u884c\u5206\u914d\u3002\u786e\u4fdd\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u5728\u4e0d\u4f7f\u7528\u7684\u65f6\u5019\u8c03\u7528 vkDestroyXXX \u548c vkFreeXXX \u9500\u6bc1\u3001\u91ca\u653e\u5bf9\u5e94\u7684\u8d44\u6e90\u3002\u8fd9\u4e9b\u51fd\u6570\u7684\u53c2\u6570\u901a\u5e38\u56e0\u4e0d\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u800c\u4e0d\u540c\uff0c\u4f46\u662f\u4ed6\u4eec\u5171\u4eab\u4e00\u4e2a\u53c2\u6570:pAllocator\u3002\u8fd9\u662f\u4e00\u4e2a\u53ef\u9009\u7684\u53c2\u6570\uff0c Vulkan \u5141\u8bb8\u6211\u4eec\u81ea\u5b9a\u4e49\u5185\u5b58\u5206\u914d\u5668\u3002\u6211\u4eec\u5c06\u5728\u672c\u6559\u7a0b\u5ffd\u7565\u6b64\u53c2\u6570\uff0c\u59cb\u7ec8\u4ee5 nullptr \u4f5c\u4e3a\u53c2\u6570\u3002","title":"\u8d44\u6e90\u7ba1\u7406"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#glfw","text":"\u5982\u679c\u6211\u4eec\u5f00\u53d1\u4e00\u4e9b\u4e0d\u9700\u8981\u57fa\u4e8e\u5c4f\u5e55\u663e\u793a\u7684\u7a0b\u5e8f\uff0c\u90a3\u4e48\u7eaf\u7cb9\u7684 Vulkan \u672c\u8eab\u53ef\u4ee5\u5b8c\u7f8e\u7684\u652f\u6301\u5f00\u53d1\u3002\u4f46\u662f\u5982\u679c\u521b\u5efa\u4e00\u4e9b\u8ba9\u4eba\u5174\u594b\u7684\u53ef\u89c6\u5316\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u5c31\u9700\u8981\u5f15\u5165\u7a97\u4f53\u7cfb\u7edf GLFW \uff0c\u5e76\u5c06 #include \u8fdb\u884c\u76f8\u5e94\u7684\u66ff\u6362\u3002 #define GLFW_INCLUDE_VULKAN #include <GLFW/glfw3.h> C++ \u5728\u65b0\u7248\u672c\u7684 GLFW \u4e2d\u5df2\u7ecf\u63d0\u4f9b\u4e86 Vulkan \u76f8\u5173\u7684\u652f\u6301\uff0c\u8be6\u7ec6\u7684\u4f7f\u7528\u5efa\u8bae\u53c2\u9605\u5b98\u65b9\u8d44\u6599\u3002 \u901a\u8fc7\u66ff\u6362\uff0c\u5c06\u4f1a\u4f7f\u7528 GLFW \u5bf9 Vulkan \u7684\u652f\u6301\uff0c\u5e76\u81ea\u52a8\u52a0\u8f7d Vulkan \u7684\u5934\u6587\u4ef6\u3002\u5728 run \u51fd\u6570\u4e2d\u6dfb\u52a0\u4e00\u4e2a initWindow \u51fd\u6570\u8c03\u7528\uff0c\u5e76\u786e\u4fdd\u5728\u5176\u4ed6\u51fd\u6570\u8c03\u7528\u524d\u4f18\u5148\u8c03\u7528\u3002\u6211\u4eec\u5c06\u4f1a\u901a\u8fc7\u8be5\u51fd\u6570\u5b8c\u6210 GLFW \u7684\u7a97\u4f53\u521d\u59cb\u5316\u5de5\u4f5c\u3002 void run() { initWindow(); initVulkan(); mainLoop(); cleanup(); } private: void initWindow() { } C++ initWindow \u4e2d\u7684\u7b2c\u4e00\u4e2a\u8c03\u7528\u662f glfwInit() ,\u5b83\u4f1a\u521d\u59cb\u5316 GLFW \u5e93\u3002\u56e0\u4e3a\u6700\u521d GLFW \u662f\u4e3a OpenGL \u521b\u5efa\u4e0a\u4e0b\u6587\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u4eec\u9700\u8981\u544a\u8bc9\u5b83\u4e0d\u8981\u8c03\u7528 OpenGL \u76f8\u5173\u7684\u521d\u59cb\u5316\u64cd\u4f5c\u3002 glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); C++ \u7279\u522b\u6ce8\u610f\u7a97\u53e3\u5927\u5c0f\u7684\u8bbe\u7f6e\uff0c\u7a0d\u540e\u6211\u4eec\u4f1a\u8c03\u7528\uff0c\u73b0\u5728\u4f7f\u7528\u53e6\u4e00\u4e2a\u7a97\u53e3\u63d0\u793a\u6765\u4ec5\u7528\u5b83\u3002 glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); C++ \u73b0\u5728\u5269\u4e0b\u7684\u5c31\u662f\u521b\u5efa\u5b9e\u9645\u7684\u7a97\u4f53\u3002\u6dfb\u52a0\u4e00\u4e2a GLFWwindow* \u7a97\u4f53\uff0c\u79c1\u6709\u7c7b\u6210\u5458\u5b58\u50a8\u5176\u5f15\u7528\u5e76\u521d\u59cb\u5316\u7a97\u4f53: window = glfwCreateWindow(800, 600, \"Vulkan\", nullptr, nullptr); C++ \u524d\u4e09\u4e2a\u53c2\u6570\u5b9a\u4e49\u7a97\u4f53\u7684\u5bbd\u5ea6\u3001\u9ad8\u5ea6\u548c Title \u3002\u7b2c\u56db\u4e2a\u53c2\u6570\u5141\u8bb8\u5236\u5b9a\u4e00\u4e2a\u76d1\u542c\u5668\u6765\u6253\u5f00\u7a97\u4f53\uff0c\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u4e0e OpenGL \u6709\u5173\uff0c\u6211\u4eec\u9009\u62e9 nullptr \u3002 \u4f7f\u7528\u5e38\u91cf\u4ee3\u66ff\u786c\u7f16\u7801\u5bbd\u5ea6\u548c\u9ad8\u5ea6\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u540e\u7eed\u7684\u5185\u5bb9\u4e2d\u4f1a\u5f15\u7528\u8be5\u6570\u503c\u591a\u6b21\u3002\u5728 HelloTriangleApplication \u7c7b\u5b9a\u4e49\u4e4b\u4e0a\u6dfb\u52a0\u4ee5\u4e0b\u51e0\u884c: const int WIDTH = 800; const int HEIGHT = 600; C++ \u5e76\u66ff\u6362\u7a97\u4f53\u521b\u5efa\u7684\u4ee3\u7801\u8bed\u53e5\u4e3a: window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); C++ \u4f60\u73b0\u5728\u5e94\u8be5\u6709\u4e00\u4e2a\u5982\u4e0b\u6240\u793a\u7684initWindow\u51fd\u6570: void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); } C++ \u4fdd\u6301\u7a0b\u5e8f\u8fd0\u884c\uff0c\u76f4\u5230\u53d1\u751f\u9519\u8bef\u6216\u8005\u7a97\u4f53\u5173\u95ed\uff0c\u6211\u4eec\u9700\u8981\u5411 mainLoop \u51fd\u6570\u6dfb\u52a0\u4e8b\u4ef6\u5faa\u73af\uff0c\u5982\u4e0b\u6240\u793a: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); } } C++ \u8fd9\u6bb5\u4ee3\u7801\u5e94\u8be5\u5f88\u5bb9\u6613\u770b\u61c2\u3002\u5b83\u5faa\u73af\u5e76\u68c0\u67e5 GLFW \u4e8b\u4ef6\uff0c\u76f4\u5230\u6309\u4e0b X \u6309\u94ae\uff0c\u6216\u8005\u5173\u95ed\u7a97\u4f53\u3002\u8be5\u5faa\u73af\u7ed3\u6784\u7a0d\u540e\u4f1a\u8c03\u7528\u6e32\u67d3\u51fd\u6570\u3002 \u4e00\u65e6\u7a97\u4f53\u5173\u95ed\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7 cleanup \u51fd\u6570\u6e05\u7406\u8d44\u6e90\u3001\u7ed3\u675f GLFW \u672c\u8eab\u3002 void cleanup() { glfwDestroyWindow(window); glfwTerminate(); } C++ \u8fd0\u884c\u7a0b\u5e8f\uff0c\u6211\u4eec\u5e94\u8be5\u4f1a\u770b\u5230\u4e00\u4e2a\u540d\u4e3a Vulkan \u7684\u767d\u8272\u7a97\u4f53\uff0c\u76f4\u5230\u5173\u95ed\u7a97\u4f53\u7ec8\u6b62\u5e94\u7528\u7a0b\u5e8f\u3002 ok\uff0c\u5230\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86\u4e00\u4e2a Vulkan \u7a0b\u5e8f\u7684\u9aa8\u67b6\u539f\u578b\uff0c\u5728 \u4e0b\u4e00\u8282 \u6211\u4eec\u4f1a\u521b\u5efa\u7b2c\u4e00\u4e2a Vulkan Object !","title":"\u6574\u5408GLFW"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_2","text":"PASS","title":"[Vulkan \u9a8c\u8bc1\u5c42]"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_3","text":"Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217 \uff0c\u5728\u9009\u62e9\u8981\u4f7f\u7528\u7684\u7269\u7406\u8bbe\u5907\u4e4b\u540e\uff0c\u6211\u4eec\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u903b\u8f91\u8bbe\u5907\u7528\u4e8e\u4ea4\u4e92\u3002\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u8fc7\u7a0b\u4e0einstance\u521b\u5efa\u8fc7\u7a0b\u7c7b\u4f3c\uff0c\u4e5f\u9700\u8981\u63cf\u8ff0\u6211\u4eec\u9700\u8981\u4f7f\u7528\u7684\u529f\u80fd\u3002\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u67e5\u8be2\u8fc7\u54ea\u4e9b\u961f\u5217\u7c07\u53ef\u7528\uff0c\u5728\u8fd9\u91cc\u9700\u8981\u8fdb\u4e00\u6b65\u4e3a\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u5177\u4f53\u7c7b\u578b\u7684\u547d\u4ee4\u961f\u5217\u3002\u5982\u679c\u6709\u4e0d\u540c\u7684\u9700\u6c42\uff0c\u4e5f\u53ef\u4ee5\u57fa\u4e8e\u540c\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u521b\u5efa\u591a\u4e2a\u903b\u8f91\u8bbe\u5907\u3002 \u9996\u5148\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u7c7b\u6210\u5458\u6765\u5b58\u50a8\u903b\u8f91\u8bbe\u5907\u53e5\u67c4\u3002 VkDevice device; C++ \u63a5\u4e0b\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u51fd\u6570 createLogicalDevice \uff0c\u5e76\u5728 initVulkan \u51fd\u6570\u4e2d\u8c03\u7528\uff0c\u4ee5\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u3002 void initVulkan() { createInstance(); setupDebugCallback(); pickPhysicalDevice(); createLogicalDevice(); } void createLogicalDevice() { } C++ https://geek-docs.com/vulkan/vulkan-tutorial/vulkan-logical-devices-and-queues.html#i-5)","title":"Vulkan \u903b\u8f91\u8bbe\u5907\u4e0e\u961f\u5217"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_10","text":"\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u9700\u8981\u5728\u7ed3\u6784\u4f53\u4e2d\u660e\u786e\u5177\u4f53\u7684\u4fe1\u606f\uff0c\u9996\u5148\u7b2c\u4e00\u4e2a\u7ed3\u6784\u4f53 VkDeviceQueueCreateInfo \u3002\u8fd9\u4e2a\u7ed3\u6784\u4f53\u63cf\u8ff0\u961f\u5217\u7c07\u4e2d\u9884\u8981\u7533\u8bf7\u4f7f\u7528\u7684\u961f\u5217\u6570\u91cf\u3002\u73b0\u5728\u6211\u4eec\u4ec5\u5173\u5fc3\u5177\u5907\u56fe\u5f62\u80fd\u529b\u7684\u961f\u5217\u3002 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); VkDeviceQueueCreateInfo queueCreateInfo = {}; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = indices.graphicsFamily; queueCreateInfo.queueCount = 1; C++ \u5f53\u524d\u53ef\u7528\u7684\u9a71\u52a8\u7a0b\u5e8f\u6240\u63d0\u4f9b\u7684\u961f\u5217\u7c07\u53ea\u5141\u8bb8\u521b\u5efa\u5c11\u91cf\u7684\u961f\u5217\uff0c\u5e76\u4e14\u5f88\u591a\u65f6\u5019\u6ca1\u6709\u5fc5\u8981\u521b\u5efa\u591a\u4e2a\u961f\u5217\u3002\u8fd9\u662f\u56e0\u4e3a\u53ef\u4ee5\u5728\u591a\u4e2a\u7ebf\u7a0b\u4e0a\u521b\u5efa\u6240\u6709\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u7136\u540e\u5728\u4e3b\u7ebf\u7a0b\u4e00\u6b21\u6027\u7684\u4ee5\u8f83\u4f4e\u5f00\u9500\u7684\u8c03\u7528\u63d0\u4ea4\u961f\u5217\u3002 Vulkan \u5141\u8bb8\u4f7f\u75280.0\u52301.0\u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u5206\u914d\u961f\u5217\u4f18\u5148\u7ea7\u6765\u5f71\u54cd\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u7684\u8c03\u7528\u3002\u5373\u4f7f\u53ea\u6709\u4e00\u4e2a\u961f\u5217\u4e5f\u662f\u5fc5\u987b\u7684: float queuePriority = 1.0f; queueCreateInfo.pQueuePriorities = &queuePriority; C++","title":"\u6307\u5b9a\u521b\u5efa\u7684\u961f\u5217"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_11","text":"\u4e0b\u4e00\u4e2a\u8981\u660e\u786e\u7684\u4fe1\u606f\u6709\u5173\u8bbe\u5907\u8981\u4f7f\u7528\u7684\u529f\u80fd\u7279\u6027\u3002\u8fd9\u4e9b\u662f\u6211\u4eec\u5728\u4e0a\u4e00\u8282\u4e2d\u7528 vkGetPhysicalDeviceFeatures \u67e5\u8be2\u652f\u6301\u7684\u529f\u80fd\uff0c\u6bd4\u5982geometry shaders\u3002\u73b0\u5728\u6211\u4eec\u4e0d\u9700\u8981\u4efb\u4f55\u7279\u6b8a\u7684\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7684\u5b9a\u4e49\u5b83\u5e76\u5c06\u6240\u6709\u5185\u5bb9\u4fdd\u7559\u5230 VK_FALSE \u3002\u4e00\u65e6\u6211\u4eec\u8981\u5f00\u59cb\u7528Vulkan\u505a\u66f4\u591a\u7684\u4e8b\u60c5\uff0c\u6211\u4eec\u4f1a\u56de\u5230\u8fd9\u4e2a\u7ed3\u6784\u4f53\uff0c\u8fdb\u4e00\u6b65\u8bbe\u7f6e\u3002 VkPhysicalDeviceFeatures deviceFeatures = {}; C++","title":"\u6307\u5b9a\u4f7f\u7528\u7684\u8bbe\u5907\u7279\u6027"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_12","text":"\u4f7f\u7528\u524d\u9762\u7684\u4e24\u4e2a\u7ed3\u6784\u4f53\uff0c\u6211\u4eec\u53ef\u4ee5\u586b\u5145 VkDeviceCreateInfo \u7ed3\u6784\u3002 VkDeviceCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; C++ \u9996\u5148\u6dfb\u52a0\u6307\u5411\u961f\u5217\u521b\u5efa\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\u548c\u8bbe\u5907\u529f\u80fd\u7ed3\u6784\u4f53: createInfo.pQueueCreateInfos = &queueCreateInfo; createInfo.queueCreateInfoCount = 1; createInfo.pEnabledFeatures = &deviceFeatures; C++ \u7ed3\u6784\u4f53\u5176\u4f59\u7684\u90e8\u5206\u4e0e VkInstanceCreateInfo \u76f8\u4f3c\uff0c\u9700\u8981\u6307\u5b9a\u6269\u5c55\u548c validation layers \uff0c\u603b\u800c\u8a00\u4e4b\u8fd9\u6b21\u4e0d\u540c\u4e4b\u5904\u662f\u4e3a\u5177\u4f53\u7684\u8bbe\u5907\u8bbe\u7f6e\u4fe1\u606f\u3002 \u8bbe\u7f6e\u5177\u4f53\u6269\u5c55\u7684\u4e00\u4e2a\u6848\u4f8b\u662f VK_KHR_swapchain \uff0c\u5b83\u5141\u8bb8\u5c06\u6765\u81ea\u8bbe\u5907\u7684\u6e32\u67d3\u56fe\u5f62\u5448\u73b0\u5230 Windows \u3002\u7cfb\u7edf\u4e2d\u7684 Vulkan \u8bbe\u5907\u53ef\u80fd\u7f3a\u5c11\u8be5\u529f\u80fd\uff0c\u4f8b\u5982\u4ec5\u4ec5\u652f\u6301\u8ba1\u7b97\u64cd\u4f5c\u3002\u6211\u4eec\u5c06\u5728\u4ea4\u6362\u94fe\u7ae0\u8282\u4e2d\u5c55\u5f00\u8fd9\u4e2a\u6269\u5c55\u3002 \u5c31\u50cf\u4e4b\u524d validation layers \u5c0f\u8282\u4e2d\u63d0\u5230\u7684\uff0c\u5141\u8bb8\u4e3a instance \u5f00\u542f validation layers \uff0c\u73b0\u5728\u6211\u4eec\u5c06\u4e3a\u8bbe\u5907\u5f00\u542f validation layers \uff0c\u800c\u4e0d\u9700\u8981\u4e3a\u8bbe\u5907\u6307\u5b9a\u4efb\u4f55\u6269\u5c55\u3002 createInfo.enabledExtensionCount = 0; if (enableValidationLayers) { createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size()); createInfo.ppEnabledLayerNames = validationLayers.data(); } else { createInfo.enabledLayerCount = 0; } C++ \u5c31\u8fd9\u6837\uff0c\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 vkCreateDevice \u51fd\u6570\u6765\u521b\u5efa\u5b9e\u4f8b\u5316\u903b\u8f91\u8bbe\u5907\u3002 if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) { throw std::runtime_error(\"failed to create logical device!\"); } C++ \u8fd9\u4e9b\u53c2\u6570\u5206\u522b\u662f\u5305\u542b\u5177\u4f53\u961f\u5217\u4f7f\u7528\u4fe1\u606f\u7684\u7269\u7406\u8bbe\u5907\uff0c\u53ef\u9009\u7684\u5206\u914d\u5668\u56de\u8c03\u6307\u9488\u4ee5\u53ca\u7528\u4e8e\u5b58\u50a8\u903b\u8f91\u8bbe\u5907\u7684\u53e5\u67c4\u3002\u4e0e instance \u521b\u5efa\u7c7b\u4f3c\uff0c\u6b64\u8c03\u7528\u53ef\u80fd\u7531\u4e8e\u542f\u7528\u4e0d\u5b58\u5728\u7684\u6269\u5c55\u6216\u8005\u6307\u5b9a\u4e0d\u652f\u6301\u7684\u529f\u80fd\uff0c\u5bfc\u81f4\u8fd4\u56de\u9519\u8bef\u3002 \u5728 cleanup \u51fd\u6570\u4e2d\u903b\u8f91\u8bbe\u5907\u9700\u8981\u8c03\u7528 vkDestroyDevice \u9500\u6bc1: void cleanup() { vkDestroyDevice(device, nullptr); ... } C++ \u903b\u8f91\u8bbe\u5907\u4e0d\u4e0e instance \u4ea4\u4e92\uff0c\u6240\u4ee5\u53c2\u6570\u4e2d\u4e0d\u5305\u542b instance \u3002","title":"\u521b\u5efa\u903b\u8f91\u8bbe\u5907"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_13","text":"\u8fd9\u4e9b\u961f\u5217\u4e0e\u903b\u8f91\u8bbe\u5907\u81ea\u52a8\u7684\u4e00\u540c\u521b\u5efa\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u4e00\u4e2a\u4e0e\u5b83\u4eec\u8fdb\u884c\u4ea4\u4e92\u7684\u53e5\u67c4\u3002\u5728\u8fd9\u91cc\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u7c7b\u6210\u5458\u6765\u5b58\u50a8\u56fe\u5f62\u961f\u5217\u53e5\u67c4: VkQueue graphicsQueue; C++ \u8bbe\u5907\u961f\u5217\u5728\u8bbe\u5907\u88ab\u9500\u6bc1\u7684\u65f6\u5019\u9690\u5f0f\u6e05\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u5728 cleanup \u51fd\u6570\u4e2d\u505a\u4efb\u4f55\u64cd\u4f5c\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 vkGetDeviceQueue \u51fd\u6570\u6765\u68c0\u6d4b\u6bcf\u4e2a\u961f\u5217\u7c07\u4e2d\u961f\u5217\u7684\u53e5\u67c4\u3002\u53c2\u6570\u662f\u903b\u8f91\u8bbe\u5907\uff0c\u961f\u5217\u7c07\uff0c\u961f\u5217\u7d22\u5f15\u548c\u5b58\u50a8\u83b7\u53d6\u961f\u5217\u53d8\u91cf\u53e5\u67c4\u7684\u6307\u9488\u3002\u56e0\u4e3a\u6211\u4eec\u53ea\u662f\u4ece\u8fd9\u4e2a\u961f\u5217\u7c07\u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u6240\u4ee5\u9700\u8981\u4f7f\u7528\u7d22\u5f15 0 \u3002 vkGetDeviceQueue(device, indices.graphicsFamily, 0, &graphicsQueue); C++ \u5728\u6210\u529f\u83b7\u53d6\u903b\u8f91\u8bbe\u5907\u548c\u961f\u5217\u53e5\u67c4\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u663e\u5361\u505a\u4e00\u4e9b\u5b9e\u9645\u7684\u4e8b\u60c5\u4e86\uff0c\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u4f1a\u8bbe\u7f6e\u8d44\u6e90\u5e76\u5c06\u76f8\u5e94\u7684\u7ed3\u679c\u63d0\u4ea4\u5230\u7a97\u4f53\u7cfb\u7edf\u3002","title":"\u68c0\u7d22\u961f\u5217\u5904\u7406"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_4","text":"Vulkan \u4ea4\u6362\u94fe \uff0c\u5728\u8fd9\u4e00\u7ae0\u8282\uff0c\u6211\u4eec\u4e86\u89e3\u4e00\u4e0b\u5c06\u6e32\u67d3\u56fe\u50cf\u63d0\u4ea4\u5230\u5c4f\u5e55\u7684\u57fa\u672c\u673a\u5236\u3002\u8fd9\u79cd\u673a\u5236\u79f0\u4e3a\u4ea4\u6362\u94fe\uff0c\u5e76\u4e14\u9700\u8981\u5728 Vulkan \u4e0a\u4e0b\u6587\u4e2d\u88ab\u660e\u786e\u521b\u5efa\u3002\u4ece\u5c4f\u5e55\u7684\u89d2\u5ea6\u89c2\u5bdf\uff0c\u4ea4\u6362\u94fe\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u56fe\u50cf\u961f\u5217\u3002\u5e94\u7528\u7a0b\u5e8f\u4f5c\u4e3a\u751f\u4ea7\u8005\u4f1a\u83b7\u53d6\u56fe\u50cf\u8fdb\u884c\u7ed8\u5236\uff0c\u7136\u540e\u5c06\u5176\u8fd4\u8fd8\u7ed9\u4ea4\u6362\u94fe\u56fe\u50cf\u961f\u5217\uff0c\u7b49\u5f85\u5c4f\u5e55\u6d88\u8d39\u3002\u4ea4\u6362\u94fe\u7684\u5177\u4f53\u914d\u7f6e\u4fe1\u606f\u51b3\u5b9a\u4e86\u5e94\u7528\u7a0b\u5e8f\u63d0\u4ea4\u7ed8\u5236\u56fe\u50cf\u5230\u961f\u5217\u7684\u6761\u4ef6\u4ee5\u53ca\u56fe\u50cf\u961f\u5217\u8868\u73b0\u7684\u6548\u679c\uff0c\u4f46\u4ea4\u6362\u94fe\u7684\u901a\u5e38\u4f7f\u7528\u76ee\u7684\u662f\u4f7f\u7ed8\u5236\u56fe\u50cf\u7684\u6700\u7ec8\u5448\u73b0\u4e0e\u5c4f\u5e55\u7684\u5237\u65b0\u9891\u7387\u540c\u6b65\u3002\u53ef\u4ee5\u7b80\u5355\u5c06\u4ea4\u6362\u94fe\u7406\u89e3\u4e3a\u4e00\u4e2a\u961f\u5217\uff0c\u540c\u6b65\u4ece\u751f\u4ea7\u8005\uff0c\u5373\u5e94\u7528\u7a0b\u5e8f\u7ed8\u5236\u56fe\u50cf\uff0c\u5230\u6d88\u8d39\u8005\uff0c\u5c4f\u5e55\u5237\u65b0\u7684 Produce-Consume \u5173\u7cfb\u3002\u5728\u6df1\u5165\u5185\u5bb9\u524d\u770b\u4e00\u4e0b\u5b98\u65b9\u7ed9\u51fa\u7684\u6574\u4f53\u4ea4\u6362\u94fe\u793a\u4f8b\u56fe\u3002 \u5f53\u7136\u56fe\u793a\u4e0a\u6709\u4e00\u4e9b\u964c\u751f\u7684\u5173\u952e\u5b57\u4f1a\u5728\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\u4e2d\u9010\u4e00\u4ecb\u7ecd\uff0c\u5728\u6b64\u6709\u4e00\u4e2a\u6574\u4f53\u6982\u5ff5\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u68c0\u67e5\u4ea4\u6362\u94fe\u652f\u6301 2 \u67e5\u8be2\u4ea4\u6362\u94fe\u652f\u6301\u7684\u8be6\u60c5 3 \u4e3a\u4ea4\u6362\u94fe\u9009\u62e9\u6b63\u786e\u7684\u8bbe\u7f6e 4 Surface \u683c\u5f0f 5 \u6f14\u793a\u6a21\u5f0f 6 \u4ea4\u6362\u8303\u56f4 7 \u521b\u5efa\u4ea4\u6362\u94fe 8 \u83b7\u53d6\u4ea4\u6362\u94fe\u56fe\u50cf","title":"Vulkan \u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_14","text":"\u5e76\u4e0d\u662f\u6240\u6709\u7684\u56fe\u5f62\u5361\u5177\u5907\u80fd\u529b\u5c06\u7ed8\u5236\u7684\u56fe\u50cf\u76f4\u63a5\u663e\u793a\u5230\u5c4f\u5e55\u4e0a\u3002\u6bd4\u5982\u4e00\u4e2aGPU\u5361\u662f\u4e3a\u670d\u52a1\u5668\u8bbe\u8ba1\u7684\uff0c\u90a3\u5c31\u4e0d\u4f1a\u5177\u5907\u4efb\u4f55\u6709\u5173\u663e\u793a\u7684\u8f93\u51fa\u3002\u5176\u6b21\uff0c\u56fe\u50cf\u5448\u73b0\u662f\u4e0e surface \u6253\u4ea4\u9053\uff0c\u800c surface \u53c8\u4e0e\u5177\u4f53\u7684\u7a97\u4f53\u7cfb\u7edf\u5f3a\u5173\u8054\uff0c\u4ece\u8fd9\u4e2a\u89d2\u5ea6\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u5b83\u4e0d\u662f Vulkan \u6838\u5fc3\u7684\u90e8\u5206\u3002\u5728\u67e5\u8be2\u56fe\u5f62\u5361\u662f\u5426\u652f\u6301\u540e\uff0c\u9700\u8981\u542f\u7528 VK_KHR_swapchain \u8bbe\u5907\u7ea7\u522b\u7684\u6269\u5c55\u3002 \u6240\u4ee5\u5462\uff0c\u6211\u4eec\u9996\u5148\u6269\u5c55\u4e4b\u524d\u7684 isDeviceSuitable \u51fd\u6570\uff0c\u786e\u8ba4\u8bbe\u5907\u662f\u5426\u652f\u6301\u3002\u4e4b\u524d\u6211\u4eec\u5df2\u7ecf\u4e86\u89e3\u5982\u4f55\u5217\u51fa VkPhysicalDevice \u652f\u6301\u7684\u6269\u5c55\u5217\u8868\uff0c\u5728\u6b64\u5c31\u4e0d\u5c55\u5f00\u5177\u4f53\u7ec6\u8282\u4e86\u3002\u8bf7\u6ce8\u610f\u7684\u662f\uff0cVulkan\u5934\u6587\u4ef6\u63d0\u4f9b\u7ed9\u4e86\u4e00\u4e2a\u65b9\u4fbf\u7684\u5b8f VK_KHR_SWAPCHAIN_EXTENSION_NAME \uff0c\u8be5\u5b8f\u5b9a\u4e49\u4e3a VK_KHR_swapchain \u3002\u4f7f\u7528\u5b8f\u7684\u4f18\u70b9\u5c31\u662f\u907f\u514d\u62fc\u5199\u9519\u8bef\u3002 \u9996\u5148\u58f0\u660e\u9700\u8981\u7684\u8bbe\u5907\u6269\u5c55\u6e05\u5355\uff0c\u4e0e\u4e4b\u524d\u5f00\u542f validation layers \u7684\u5217\u8868\u662f\u76f8\u4f3c\u7684\u3002 const std::vector<const char*> deviceExtensions = { VK_KHR_SWAPCHAIN_EXTENSION_NAME }; C++ \u63a5\u4e0b\u6765\uff0c\u521b\u5efa\u4e00\u4e2a\u4ece isDeviceSuitable \u8c03\u7528\u7684\u65b0\u51fd\u6570 checkDeviceExtensionSupport \u4f5c\u4e3a\u989d\u5916\u7684\u68c0\u67e5\u903b\u8f91: bool isDeviceSuitable(VkPhysicalDevice device) { QueueFamilyIndices indices = findQueueFamilies(device); bool extensionsSupported = checkDeviceExtensionSupport(device); return indices.isComplete() && extensionsSupported; } bool checkDeviceExtensionSupport(VkPhysicalDevice device) { return true; } C++ \u4fee\u6539\u51fd\u6570\u4f53\u4ee5\u4fbf\u4e8e\u679a\u4e3e\u8bbe\u5907\u6240\u6709\u96c6\u5408\uff0c\u5e76\u68c0\u6d4b\u662f\u5426\u6240\u6709\u9700\u8981\u7684\u6269\u5c55\u5728\u5176\u4e2d\u3002 bool checkDeviceExtensionSupport(VkPhysicalDevice device) { uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr); std::vector<VkExtensionProperties> availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availableExtensions.data()); std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end()); for (const auto& extension : availableExtensions) { requiredExtensions.erase(extension.extensionName); } return requiredExtensions.empty(); } C++ \u9009\u62e9\u4e00\u7ec4\u5b57\u7b26\u4e32\u6765\u8868\u793a\u672a\u7ecf\u786e\u8ba4\u8fc7\u7684\u6269\u5c55\u540d\u3002\u8fd9\u6837\u505a\u53ef\u4ee5\u6bd4\u8f83\u5bb9\u6613\u7684\u8fdb\u884c\u589e\u5220\u53ca\u904d\u5386\u7684\u6b21\u5e8f\u3002\u5f53\u7136\u4e5f\u53ef\u4ee5\u50cf CheckValidationLayerSupport \u51fd\u6570\u90a3\u6837\u505a\u5d4c\u5957\u7684\u5faa\u73af\u3002\u6027\u80fd\u7684\u5dee\u5f02\u5728\u8fd9\u91cc\u662f\u4e0d\u5173\u7d27\u8981\u7684\u3002\u73b0\u5728\u8fd0\u884c\u4ee3\u7801\u9a8c\u8bc1\u56fe\u5f62\u5361\u662f\u5426\u80fd\u591f\u987a\u5229\u521b\u5efa\u4e00\u4e2a\u4ea4\u6362\u94fe\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u524d\u4e00\u4e2a\u7ae0\u8282\u4e2d\u9a8c\u8bc1\u8fc7\u7684 presentation \u961f\u5217\u6709\u6548\u6027\uff0c\u5e76\u6ca1\u6709\u660e\u786e\u6307\u51fa\u4ea4\u6362\u94fe\u6269\u5c55\u4e5f\u5fc5\u987b\u6709\u6548\u652f\u6301\u3002\u597d\u5728\u6269\u5c55\u5fc5\u987b\u660e\u786e\u7684\u5f00\u542f\u3002 \u542f\u7528\u6269\u5c55\u9700\u8981\u5bf9\u903b\u8f91\u8bbe\u5907\u7684\u521b\u5efa\u7ed3\u6784\u4f53\u505a\u4e00\u4e9b\u5c0f\u7684\u6539\u52a8: createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size()); createInfo.ppEnabledExtensionNames = deviceExtensions.data(); C++","title":"\u68c0\u67e5\u4ea4\u6362\u94fe\u652f\u6301"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_15","text":"\u5982\u679c\u4ec5\u4ec5\u662f\u4e3a\u4e86\u6d4b\u8bd5\u4ea4\u6362\u94fe\u7684\u6709\u6548\u6027\u662f\u8fdc\u8fdc\u4e0d\u591f\u7684\uff0c\u56e0\u4e3a\u5b83\u8fd8\u4e0d\u80fd\u5f88\u597d\u7684\u4e0e\u7a97\u4f53 surface \u517c\u5bb9\u3002\u521b\u5efa\u4ea4\u6362\u94fe\u540c\u6837\u4e5f\u9700\u8981\u5f88\u591a\u8bbe\u7f6e\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4e86\u89e3\u4e00\u4e9b\u6709\u5173\u8bbe\u7f6e\u7684\u7ec6\u8282\u3002 \u57fa\u672c\u4e0a\u6709\u4e09\u5927\u7c7b\u5c5e\u6027\u9700\u8981\u8bbe\u7f6e: \u57fa\u672c\u7684surface\u529f\u80fd\u5c5e\u6027(min/max number of images in swap chain, min/max width and height of images) Surface\u683c\u5f0f(pixel format, color space) \u6709\u6548\u7684presentation\u6a21\u5f0f \u4e0e findQueueFamilies \u7c7b\u4f3c\uff0c\u6211\u4eec\u4f7f\u7528\u7ed3\u6784\u4f53\u4e00\u6b21\u6027\u7684\u4f20\u9012\u8be6\u7ec6\u7684\u4fe1\u606f\u3002\u4e09\u7c7b\u5c5e\u6027\u5c01\u88c5\u5728\u5982\u4e0b\u7ed3\u6784\u4f53\u4e2d\uff1a struct SwapChainSupportDetails { VkSurfaceCapabilitiesKHR capabilities; std::vector<VkSurfaceFormatKHR> formats; std::vector<VkPresentModeKHR> presentModes; }; C++ \u73b0\u5728\u521b\u5efa\u65b0\u7684\u51fd\u6570 querySwapChainSupport \u586b\u5145\u8be5\u7ed3\u6784\u4f53\u3002 SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) { SwapChainSupportDetails details; return details; } C++ \u672c\u5c0f\u8282\u6d89\u53ca\u5982\u4f55\u67e5\u8be2\u5305\u542b\u6b64\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\uff0c\u8fd9\u4e9b\u7ed3\u6784\u4f53\u7684\u542b\u4e49\u53ca\u5305\u542b\u7684\u6570\u636e\u5c06\u5728\u4e0b\u4e00\u8282\u8ba8\u8bba\u3002 \u6211\u4eec\u73b0\u5728\u5f00\u59cb\u57fa\u672c\u7684 surface \u529f\u80fd\u8bbe\u7f6e\u90e8\u5206\u3002\u8fd9\u4e9b\u5c5e\u6027\u53ef\u4ee5\u901a\u8fc7\u7b80\u5355\u7684\u51fd\u6570\u8c03\u7528\u67e5\u8be2\uff0c\u5e76\u8fd4\u56de\u5230\u5355\u4e2a VkSurfaceCapabilitiesKHR \u7ed3\u6784\u4f53\u4e2d\u3002 vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &details.capabilities); C++ \u8fd9\u4e2a\u51fd\u6570\u9700\u8981 VkPhysicalDevice \u548c VkSurfaceKHR \u7a97\u4f53 surface \u51b3\u5b9a\u652f\u6301\u54ea\u4e9b\u5177\u4f53\u529f\u80fd\u3002\u6240\u6709\u7528\u4e8e\u67e5\u770b\u652f\u6301\u529f\u80fd\u7684\u51fd\u6570\u90fd\u9700\u8981\u8fd9\u4e24\u4e2a\u53c2\u6570\uff0c\u56e0\u4e3a\u5b83\u4eec\u662f\u4ea4\u6362\u94fe\u7684\u6838\u5fc3\u7ec4\u4ef6\u3002 \u4e0b\u4e00\u6b65\u67e5\u8be2\u652f\u6301\u7684 surface \u683c\u5f0f\u3002\u56e0\u4e3a\u83b7\u53d6\u5230\u7684\u662f\u4e00\u4e2a\u7ed3\u6784\u4f53\u5217\u8868\uff0c\u5177\u4f53\u5e94\u7528\u5f62\u5f0f\u5982\u4e0b: uint32_t formatCount; vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, nullptr); if (formatCount != 0) { details.formats.resize(formatCount); vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, details.formats.data()); } C++ \u786e\u4fdd\u96c6\u5408\u5bf9\u4e8e\u6240\u6709\u6709\u6548\u7684\u683c\u5f0f\u53ef\u6269\u5145\u3002\u6700\u540e\u67e5\u8be2\u652f\u6301\u7684 presentation \u6a21\u5f0f\uff0c\u540c\u6837\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528 vkGetPhysicalDeviceSurfacePresentModesKHR : uint32_t presentModeCount; vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, nullptr); if (presentModeCount != 0) { details.presentModes.resize(presentModeCount); vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, details.presentModes.data()); } C++ \u73b0\u5728\u7ed3\u6784\u4f53\u7684\u76f8\u5173\u7ec6\u8282\u4ecb\u7ecd\u5b8c\u6bd5\uff0c\u8ba9\u6211\u4eec\u6269\u5145 isDeviceSuitable \u51fd\u6570\uff0c\u4ece\u800c\u5229\u7528\u8be5\u51fd\u6570\u9a8c\u8bc1\u4ea4\u6362\u94fe\u8db3\u591f\u7684\u652f\u6301\u3002\u5728\u672c\u7ae0\u8282\u4e2d\u4ea4\u6362\u94fe\u7684\u652f\u6301\u662f\u8db3\u591f\u7684\uff0c\u56e0\u4e3a\u5bf9\u4e8e\u7ed9\u5b9a\u7684\u7a97\u4f53 surface \uff0c\u5b83\u81f3\u5c11\u652f\u6301\u4e00\u4e2a\u56fe\u50cf\u683c\u5f0f\uff0c\u4e00\u4e2a presentaion \u6a21\u5f0f\u3002 bool swapChainAdequate = false; if (extensionsSupported) { SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device); swapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty(); } C++ \u6bd4\u8f83\u91cd\u8981\u7684\u662f\u5c1d\u8bd5\u67e5\u8be2\u4ea4\u6362\u94fe\u7684\u652f\u6301\u662f\u5728\u9a8c\u8bc1\u5b8c\u6269\u5c55\u6709\u6548\u6027\u4e4b\u540e\u8fdb\u884c\u3002\u51fd\u6570\u7684\u6700\u540e\u4e00\u884c\u4ee3\u7801\u4fee\u6539\u4e3a: return indices.isComplete() && extensionsSupported && swapChainAdequate; C++","title":"\u67e5\u8be2\u4ea4\u6362\u94fe\u652f\u6301\u7684\u8be6\u60c5"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_16","text":"\u5982\u679c swapChainAdequate \u6761\u4ef6\u8db3\u591f\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u652f\u6301\u7684\u8db3\u591f\u7684\uff0c\u4f46\u662f\u6839\u636e\u4e0d\u540c\u7684\u6a21\u5f0f\u4ecd\u7136\u6709\u4e0d\u540c\u7684\u6700\u4f73\u9009\u62e9\u3002\u6211\u4eec\u7f16\u5199\u4e00\u7ec4\u51fd\u6570\uff0c\u901a\u8fc7\u8fdb\u4e00\u6b65\u7684\u8bbe\u7f6e\u67e5\u627e\u6700\u5339\u914d\u7684\u4ea4\u6362\u94fe\u3002\u8fd9\u91cc\u6709\u4e09\u79cd\u7c7b\u578b\u7684\u8bbe\u7f6e\u53bb\u786e\u5b9a: Surface\u683c\u5f0f (color depth) Presentation mode (conditions for \u201cswapping\u201d image to the screen) Swap extent (resolution of images in swap chain) \u9996\u5148\u5728\u8111\u6d77\u4e2d\u5bf9\u6bcf\u4e00\u4e2a\u8bbe\u7f6e\u90fd\u6709\u4e00\u4e2a\u7406\u60f3\u7684\u6570\u503c\uff0c\u5982\u679c\u8fbe\u6210\u4e00\u81f4\u6211\u4eec\u5c31\u4f7f\u7528\uff0c\u5426\u5219\u6211\u4eec\u4e00\u8d77\u521b\u5efa\u4e00\u4e9b\u903b\u8f91\u53bb\u627e\u5230\u66f4\u597d\u7684\u89c4\u5219\u3001\u6570\u503c\u3002","title":"\u4e3a\u4ea4\u6362\u94fe\u9009\u62e9\u6b63\u786e\u7684\u8bbe\u7f6e"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#surface","text":"\u8fd9\u4e2a\u51fd\u6570\u7528\u6765\u8bbe\u7f6esurface\u683c\u5f0f\u3002\u6211\u4eec\u4f20\u9012 formats \u4f5c\u4e3a\u51fd\u6570\u7684\u53c2\u6570\uff0c\u7c7b\u578b\u4e3a SwapChainSupportDetails \u3002 VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) { } C++ \u6bcf\u4e2a VkSurfaceFormatKHR \u7ed3\u6784\u90fd\u5305\u542b\u4e00\u4e2a format \u548c\u4e00\u4e2a colorSpace \u6210\u5458\u3002 format \u6210\u5458\u53d8\u91cf\u6307\u5b9a\u8272\u5f69\u901a\u9053\u548c\u7c7b\u578b\u3002\u6bd4\u5982\uff0c VK_FORMAT_B8G8R8A8_UNORM \u4ee3\u8868\u4e86\u6211\u4eec\u4f7f\u7528B,G,R\u548calpha\u6b21\u5e8f\u7684\u901a\u9053\uff0c\u4e14\u6bcf\u4e00\u4e2a\u901a\u9053\u4e3a\u65e0\u7b26\u53f78bit\u6574\u6570\uff0c\u6bcf\u4e2a\u50cf\u7d20\u603b\u8ba132bits\u3002 colorSpace \u6210\u5458\u63cf\u8ff0 SRGB \u989c\u8272\u7a7a\u95f4\u662f\u5426\u901a\u8fc7 VK_COLOR_SPACE_SRGB_NONLINEAR_KHR \u6807\u5fd7\u652f\u6301\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u5728\u8f83\u65e9\u7248\u672c\u7684\u89c4\u8303\u4e2d\uff0c\u8fd9\u4e2a\u6807\u5fd7\u540d\u4e3a VK_COLORSPACE_SRGB_NONLINEAR_KHR \u3002 \u5982\u679c\u53ef\u4ee5\u6211\u4eec\u5c3d\u53ef\u80fd\u4f7f\u7528SRGB(\u5f69\u8272\u8bed\u8a00\u534f\u8bae)\uff0c \u56e0\u4e3a\u5b83\u4f1a\u5f97\u5230\u66f4\u5bb9\u6613\u611f\u77e5\u7684\u3001\u7cbe\u786e\u7684\u8272\u5f69 \u3002\u76f4\u63a5\u4e0e SRGB \u989c\u8272\u6253\u4ea4\u9053\u662f\u6bd4\u8f83\u6709\u6311\u6218\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u4f7f\u7528\u6807\u51c6\u7684RGB\u4f5c\u4e3a\u989c\u8272\u683c\u5f0f\uff0c\u8fd9\u4e5f\u662f\u901a\u5e38\u4f7f\u7528\u7684\u4e00\u4e2a\u683c\u5f0f VK_FORMAT_B8G8R8A8_UNORM \u3002 \u6700\u7406\u60f3\u7684\u60c5\u51b5\u662fsurface\u6ca1\u6709\u8bbe\u7f6e\u4efb\u4f55\u504f\u5411\u6027\u7684\u683c\u5f0f\uff0c\u8fd9\u4e2a\u65f6\u5019Vulkan\u4f1a\u901a\u8fc7\u4ec5\u8fd4\u56de\u4e00\u4e2a VkSurfaceFormatKHR \u7ed3\u6784\u8868\u793a\uff0c\u4e14\u8be5\u7ed3\u6784\u7684 format \u6210\u5458\u8bbe\u7f6e\u4e3a VK_FORMAT_UNDEFINED \u3002 if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) { return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; } C++ \u5982\u679c\u4e0d\u80fd\u81ea\u7531\u7684\u8bbe\u7f6e\u683c\u5f0f\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u904d\u5386\u5217\u8868\u8bbe\u7f6e\u5177\u6709\u504f\u5411\u6027\u7684\u7ec4\u5408: for (const auto& availableFormat : availableFormats) { if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { return availableFormat; } } C++ \u5982\u679c\u4ee5\u4e0a\u4e24\u79cd\u65b9\u5f0f\u90fd\u5931\u6548\u4e86\uff0c\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u201c\u4f18\u826f\u201d\u8fdb\u884c\u6253\u5206\u6392\u5e8f\uff0c\u4f46\u662f\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4f1a\u9009\u62e9\u7b2c\u4e00\u4e2a\u683c\u5f0f\u4f5c\u4e3a\u7406\u60f3\u7684\u9009\u62e9\u3002 VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) { if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) { return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; } for (const auto& availableFormat : availableFormats) { if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { return availableFormat; } } return availableFormats[0]; } C++","title":"Surface \u683c\u5f0f"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_17","text":"presentation \u6a21\u5f0f\u5bf9\u4e8e\u4ea4\u6362\u94fe\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u56e0\u4e3a\u5b83\u4ee3\u8868\u4e86\u5728\u5c4f\u5e55\u5448\u73b0\u56fe\u50cf\u7684\u6761\u4ef6\u3002\u5728 Vulkan \u4e2d\u6709\u56db\u4e2a\u6a21\u5f0f\u53ef\u4ee5\u4f7f\u7528: VK_PRESENT_MODE_IMMEDIATE_KHR : \u5e94\u7528\u7a0b\u5e8f\u63d0\u4ea4\u7684\u56fe\u50cf\u88ab\u7acb\u5373\u4f20\u8f93\u5230\u5c4f\u5e55\u5448\u73b0\uff0c\u8fd9\u79cd\u6a21\u5f0f\u53ef\u80fd\u4f1a\u9020\u6210\u6495\u88c2\u6548\u679c\u3002 VK_PRESENT_MODE_FIFO_KHR : \u4ea4\u6362\u94fe\u88ab\u770b\u4f5c\u4e00\u4e2a\u961f\u5217\uff0c\u5f53\u663e\u793a\u5185\u5bb9\u9700\u8981\u5237\u65b0\u7684\u65f6\u5019\uff0c\u663e\u793a\u8bbe\u5907\u4ece\u961f\u5217\u7684\u524d\u9762\u83b7\u53d6\u56fe\u50cf\uff0c\u5e76\u4e14\u7a0b\u5e8f\u5c06\u6e32\u67d3\u5b8c\u6210\u7684\u56fe\u50cf\u63d2\u5165\u961f\u5217\u7684\u540e\u9762\u3002\u5982\u679c\u961f\u5217\u662f\u6ee1\u7684\u7a0b\u5e8f\u4f1a\u7b49\u5f85\u3002\u8fd9\u79cd\u89c4\u6a21\u4e0e\u89c6\u9891\u6e38\u620f\u7684\u5782\u76f4\u540c\u6b65\u5f88\u7c7b\u4f3c\u3002\u663e\u793a\u8bbe\u5907\u7684\u5237\u65b0\u65f6\u523b\u88ab\u6210\u4e3a\u201c\u5782\u76f4\u4e2d\u65ad\u201d\u3002 VK_PRESENT_MODE_FIFO_RELAXED_KHR : \u8be5\u6a21\u5f0f\u4e0e\u4e0a\u4e00\u4e2a\u6a21\u5f0f\u7565\u6709\u4e0d\u540c\u7684\u5730\u65b9\u4e3a\uff0c\u5982\u679c\u5e94\u7528\u7a0b\u5e8f\u5b58\u5728\u5ef6\u8fdf\uff0c\u5373\u63a5\u53d7\u6700\u540e\u4e00\u4e2a\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\u65f6\u961f\u5217\u7a7a\u4e86\uff0c\u5c06\u4e0d\u4f1a\u7b49\u5f85\u4e0b\u4e00\u4e2a\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\uff0c\u800c\u662f\u5c06\u56fe\u50cf\u76f4\u63a5\u4f20\u9001\u3002\u8fd9\u6837\u505a\u53ef\u80fd\u5bfc\u81f4\u53ef\u89c1\u7684\u6495\u88c2\u6548\u679c\u3002 VK_PRESENT_MODE_MAILBOX_KHR : \u8fd9\u662f\u7b2c\u4e8c\u79cd\u6a21\u5f0f\u7684\u53d8\u79cd\u3002\u5f53\u4ea4\u6362\u94fe\u961f\u5217\u6ee1\u7684\u65f6\u5019\uff0c\u9009\u62e9\u65b0\u7684\u66ff\u6362\u65e7\u7684\u56fe\u50cf\uff0c\u4ece\u800c\u66ff\u4ee3\u963b\u585e\u5e94\u7528\u7a0b\u5e8f\u7684\u60c5\u5f62\u3002\u8fd9\u79cd\u6a21\u5f0f\u901a\u5e38\u7528\u6765\u5b9e\u73b0\u4e09\u91cd\u7f13\u51b2\u533a\uff0c\u4e0e\u6807\u51c6\u7684\u5782\u76f4\u540c\u6b65\u53cc\u7f13\u51b2\u76f8\u6bd4\uff0c\u5b83\u53ef\u4ee5\u6709\u6548\u907f\u514d\u5ef6\u8fdf\u5e26\u6765\u7684\u6495\u88c2\u6548\u679c\u3002 \u903b\u8f91\u4e0a\u770b\u4ec5\u4ec5 VR_PRESENT_MODE_FIFO_KHR \u6a21\u5f0f\u4fdd\u8bc1\u53ef\u7528\u6027\uff0c\u6240\u4ee5\u6211\u4eec\u518d\u6b21\u589e\u52a0\u4e00\u4e2a\u51fd\u6570\u67e5\u627e\u6700\u4f73\u7684\u6a21\u5f0f: VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { return VK_PRESENT_MODE_FIFO_KHR; } C++ \u6211\u4e2a\u4eba\u8ba4\u4e3a\u4e09\u7ea7\u7f13\u51b2\u662f\u4e00\u4e2a\u975e\u5e38\u597d\u7684\u7b56\u7565\u3002\u5b83\u5141\u8bb8\u6211\u4eec\u907f\u514d\u6495\u88c2\uff0c\u540c\u65f6\u4ecd\u7136\u4fdd\u6301\u76f8\u5bf9\u4f4e\u7684\u5ef6\u8fdf\uff0c\u901a\u8fc7\u6e32\u67d3\u5c3d\u53ef\u80fd\u65b0\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u63a5\u53d7\u5782\u76f4\u540c\u6b65\u4fe1\u53f7\u3002\u6240\u4ee5\u6211\u4eec\u770b\u4e00\u4e0b\u5217\u8868\uff0c\u5b83\u662f\u5426\u53ef\u7528: VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { for (const auto& availablePresentMode : availablePresentModes) { if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { return availablePresentMode; } } return VK_PRESENT_MODE_FIFO_KHR; } C++ \u9057\u61be\u7684\u662f\uff0c\u4e00\u4e9b\u9a71\u52a8\u7a0b\u5e8f\u76ee\u524d\u5e76\u4e0d\u652f\u6301 VK_PRESENT_MODE_FIFO_KHR ,\u9664\u6b64\u4e4b\u5916\u5982\u679c VK_PRESENT_MODE_MAILBOX_KHR \u4e5f\u4e0d\u53ef\u7528\uff0c\u6211\u4eec\u66f4\u503e\u5411\u4f7f\u7528 VK_PRESENT_MODE_IMMEDIATE_KHR : VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR> availablePresentModes) { VkPresentModeKHR bestMode = VK_PRESENT_MODE_FIFO_KHR; for (const auto& availablePresentMode : availablePresentModes) { if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) { return availablePresentMode; } else if (availablePresentMode == VK_PRESENT_MODE_IMMEDIATE_KHR) { bestMode = availablePresentMode; } } return bestMode; } C++","title":"\u6f14\u793a\u6a21\u5f0f"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_18","text":"\u8fd8\u5269\u4e0b\u4e00\u4e2a\u5c5e\u6027\uff0c\u4e3a\u6b64\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u51fd\u6570: VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) { } C++ \u4ea4\u6362\u8303\u56f4\u662f\u6307\u4ea4\u6362\u94fe\u56fe\u50cf\u7684\u5206\u8fa8\u7387\uff0c\u5b83\u51e0\u4e4e\u603b\u662f\u7b49\u4e8e\u6211\u4eec\u7ed8\u5236\u7a97\u4f53\u7684\u5206\u8fa8\u7387\u3002\u5206\u8fa8\u7387\u7684\u8303\u56f4\u88ab\u5b9a\u4e49\u5728 VkSurfaceCapabilitiesKHR \u7ed3\u6784\u4f53\u4e2d\u3002 Vulkan \u544a\u8bc9\u6211\u4eec\u901a\u8fc7\u8bbe\u7f6e currentExtent \u6210\u5458\u7684 width \u548c height \u6765\u5339\u914d\u7a97\u4f53\u7684\u5206\u8fa8\u7387\u3002\u7136\u800c\uff0c\u4e00\u4e9b\u7a97\u4f53\u7ba1\u7406\u5668\u5141\u8bb8\u4e0d\u540c\u7684\u8bbe\u7f6e\uff0c\u610f\u5473\u7740\u5c06 currentExtent \u7684width\u548cheight\u8bbe\u7f6e\u4e3a\u7279\u6b8a\u7684\u6570\u503c\u8868\u793a: uint32_t \u7684\u6700\u5927\u503c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53c2\u8003\u7a97\u4f53 minImageExtent \u548c maxImageExtent \u9009\u62e9\u6700\u5339\u914d\u7684\u5206\u8fa8\u7387\u3002 VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) { if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) { return capabilities.currentExtent; } else { VkExtent2D actualExtent = {WIDTH, HEIGHT}; actualExtent.width = std::max(capabilities.minImageExtent.width, std::min(capabilities.maxImageExtent.width, actualExtent.width)); actualExtent.height = std::max(capabilities.minImageExtent.height, std::min(capabilities.maxImageExtent.height, actualExtent.height)); return actualExtent; } } C++ max \u548c min \u51fd\u6570\u7528\u4e8e\u5c06 WIDTH \u548c HEIGHT \u6536\u655b\u5728\u5b9e\u9645\u652f\u6301\u7684 minimum \u548c maximum \u8303\u56f4\u4e2d\u3002\u5728\u8fd9\u91cc\u786e\u8ba4\u5305\u542b <algorithm> \u5934\u6587\u4ef6\u3002","title":"\u4ea4\u6362\u8303\u56f4"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_19","text":"\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6709\u4e86\u8fd9\u4e9b\u8f85\u52a9\u51fd\u6570\uff0c\u7528\u4ee5\u5728\u8fd0\u884c\u65f6\u5e2e\u52a9\u6211\u4eec\u505a\u51fa\u660e\u667a\u7684\u9009\u62e9\uff0c\u6700\u7ec8\u83b7\u5f97\u6709\u4e86\u521b\u5efa\u4ea4\u6362\u94fe\u6240\u9700\u8981\u7684\u6240\u6709\u4fe1\u606f\u3002 \u521b\u5efa\u4e00\u4e2a\u51fd\u6570 createSwapChain \uff0c\u5728 initVulkan \u51fd\u6570\u4e2d\uff0c\u8be5\u51fd\u6570\u4f1a\u5728\u521b\u5efa\u903b\u8f91\u8bbe\u5907\u4e4b\u540e\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); } void createSwapChain() { SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice); VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats); VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes); VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities); } C++ \u5b9e\u9645\u4e0a\u8fd8\u6709\u4e00\u4e9b\u5c0f\u4e8b\u60c5\u9700\u8981\u786e\u5b9a\uff0c\u4f46\u662f\u6bd4\u8f83\u7b80\u5355\uff0c\u6240\u4ee5\u6ca1\u6709\u5355\u72ec\u521b\u5efa\u51fd\u6570\u3002\u7b2c\u4e00\u4e2a\u662f\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u53ef\u4ee5\u7406\u89e3\u4e3a\u961f\u5217\u7684\u957f\u5ea6\u3002\u5b83\u6307\u5b9a\u8fd0\u884c\u65f6\u56fe\u50cf\u7684\u6700\u5c0f\u6570\u91cf\uff0c\u6211\u4eec\u5c06\u5c1d\u8bd5\u5927\u4e8e1\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u4ee5\u5b9e\u73b0\u4e09\u91cd\u7f13\u51b2\u3002 uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1; if (swapChainSupport.capabilities.maxImageCount > 0 && imageCount > swapChainSupport.capabilities.maxImageCount) { imageCount = swapChainSupport.capabilities.maxImageCount; } C++ \u5bf9\u4e8e maxImageCount \u6570\u503c\u4e3a 0 \u4ee3\u8868\u9664\u4e86\u5185\u5b58\u4e4b\u5916\u6ca1\u6709\u9650\u5236\uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u9700\u8981\u68c0\u67e5\u3002 \u4e0eVulkan\u5176\u4ed6\u5bf9\u8c61\u7684\u521b\u5efa\u8fc7\u7a0b\u4e00\u6837\uff0c\u521b\u5efa\u4ea4\u6362\u94fe\u4e5f\u9700\u8981\u586b\u5145\u5927\u91cf\u7684\u7ed3\u6784\u4f53: VkSwapchainCreateInfoKHR createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; createInfo.surface = surface; C++ \u5728\u6307\u5b9a\u4ea4\u6362\u94fe\u7ed1\u5b9a\u5230\u5177\u4f53\u7684 surface \u4e4b\u540e\uff0c\u9700\u8981\u6307\u5b9a\u4ea4\u6362\u94fe\u56fe\u50cf\u6709\u5173\u7684\u8be6\u7ec6\u4fe1\u606f: createInfo.minImageCount = imageCount; createInfo.imageFormat = surfaceFormat.format; createInfo.imageColorSpace = surfaceFormat.colorSpace; createInfo.imageExtent = extent; createInfo.imageArrayLayers = 1; createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; C++ imageArrayLayers \u6307\u5b9a\u6bcf\u4e2a\u56fe\u50cf\u7ec4\u6210\u7684\u5c42\u6570\u3002\u9664\u975e\u6211\u4eec\u5f00\u53d13D\u5e94\u7528\u7a0b\u5e8f\uff0c\u5426\u5219\u59cb\u7ec8\u4e3a1\u3002 imageUsage \u4f4d\u5b57\u6bb5\u6307\u5b9a\u5728\u4ea4\u6362\u94fe\u4e2d\u5bf9\u56fe\u50cf\u8fdb\u884c\u7684\u5177\u4f53\u64cd\u4f5c\u3002\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u76f4\u63a5\u5bf9\u5b83\u4eec\u8fdb\u884c\u6e32\u67d3\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u4eec\u4f5c\u4e3a\u989c\u8272\u9644\u4ef6\u3002\u4e5f\u53ef\u4ee5\u9996\u5148\u5c06\u56fe\u50cf\u6e32\u67d3\u4e3a\u5355\u72ec\u7684\u56fe\u50cf\uff0c\u8fdb\u884c\u540e\u5904\u7406\u64cd\u4f5c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u53ef\u4ee5\u4f7f\u7528\u50cf VK_IMAGE_USAGE_TRANSFER_DST_BIT \u8fd9\u6837\u7684\u503c\uff0c\u5e76\u4f7f\u7528\u5185\u5b58\u64cd\u4f5c\u5c06\u6e32\u67d3\u7684\u56fe\u50cf\u4f20\u8f93\u5230\u4ea4\u6362\u94fe\u56fe\u50cf\u961f\u5217\u3002 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); uint32_t queueFamilyIndices[] = {(uint32_t) indices.graphicsFamily, (uint32_t) indices.presentFamily}; if (indices.graphicsFamily != indices.presentFamily) { createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT; createInfo.queueFamilyIndexCount = 2; createInfo.pQueueFamilyIndices = queueFamilyIndices; } else { createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; createInfo.queueFamilyIndexCount = 0; // Optional createInfo.pQueueFamilyIndices = nullptr; // Optional } C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u6307\u5b9a\u5982\u4f55\u5904\u7406\u8de8\u591a\u4e2a\u961f\u5217\u7c07\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u3002\u5982\u679cgraphics\u961f\u5217\u7c07\u4e0epresentation\u961f\u5217\u7c07\u4e0d\u540c\uff0c\u4f1a\u51fa\u73b0\u5982\u4e0b\u60c5\u5f62\u3002\u6211\u4eec\u5c06\u4ecegraphics\u961f\u5217\u4e2d\u7ed8\u5236\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\uff0c\u7136\u540e\u5728\u53e6\u4e00\u4e2apresentation\u961f\u5217\u4e2d\u63d0\u4ea4\u4ed6\u4eec\u3002\u591a\u961f\u5217\u5904\u7406\u56fe\u50cf\u6709\u4e24\u79cd\u65b9\u6cd5: VK_SHARING_MODE_EXCLUSIVE : \u540c\u4e00\u65f6\u95f4\u56fe\u50cf\u53ea\u80fd\u88ab\u4e00\u4e2a\u961f\u5217\u7c07\u5360\u7528\uff0c\u5982\u679c\u5176\u4ed6\u961f\u5217\u7c07\u9700\u8981\u5176\u6240\u6709\u6743\u9700\u8981\u660e\u786e\u6307\u5b9a\u3002\u8fd9\u79cd\u65b9\u5f0f\u63d0\u4f9b\u4e86\u6700\u597d\u7684\u6027\u80fd\u3002 VK_SHARING_MODE_CONCURRENT : \u56fe\u50cf\u53ef\u4ee5\u88ab\u591a\u4e2a\u961f\u5217\u7c07\u8bbf\u95ee\uff0c\u4e0d\u9700\u8981\u660e\u786e\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\u3002 \u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u5982\u679c\u961f\u5217\u7c07\u4e0d\u540c\uff0c\u5c06\u4f1a\u4f7f\u7528 concurrent \u6a21\u5f0f\uff0c\u907f\u514d\u5904\u7406\u56fe\u50cf\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\u7684\u5185\u5bb9\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u4f1a\u6d89\u53ca\u4e0d\u5c11\u6982\u5ff5\uff0c\u5efa\u8bae\u540e\u7eed\u7684\u7ae0\u8282\u8ba8\u8bba\u3002 Concurrent \u6a21\u5f0f\u9700\u8981\u9884\u5148\u6307\u5b9a\u961f\u5217\u7c07\u6240\u6709\u6743\u4ece\u5c5e\u5173\u7cfb\uff0c\u901a\u8fc7 queueFamilyIndexCount \u548c pQueueFamilyIndices \u53c2\u6570\u8fdb\u884c\u5171\u4eab\u3002\u5982\u679c graphics \u961f\u5217\u7c07\u548cpresentation\u961f\u5217\u7c07\u76f8\u540c\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 exclusive \u6a21\u5f0f\uff0c\u56e0\u4e3a concurrent \u6a21\u5f0f\u9700\u8981\u81f3\u5c11\u4e24\u4e2a\u4e0d\u540c\u7684\u961f\u5217\u7c07\u3002 createInfo.preTransform = swapChainSupport.capabilities.currentTransform; C++ \u5982\u679c\u4ea4\u6362\u94fe\u652f\u6301( supportedTransforms in capabilities ),\u6211\u4eec\u53ef\u4ee5\u4e3a\u4ea4\u6362\u94fe\u56fe\u50cf\u6307\u5b9a\u67d0\u4e9b\u8f6c\u6362\u903b\u8f91\uff0c\u6bd4\u598290\u5ea6\u987a\u65f6\u9488\u65cb\u8f6c\u6216\u8005\u6c34\u5e73\u53cd\u8f6c\u3002\u5982\u679c\u4e0d\u9700\u8981\u4efb\u4f55 transoform \u64cd\u4f5c\uff0c\u53ef\u4ee5\u7b80\u5355\u7684\u8bbe\u7f6e\u4e3a currentTransoform \u3002 createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR; C++ \u6df7\u5408Alpha\u5b57\u6bb5\u6307\u5b9aalpha\u901a\u9053\u662f\u5426\u5e94\u7528\u4e0e\u4e0e\u5176\u4ed6\u7684\u7a97\u4f53\u7cfb\u7edf\u8fdb\u884c\u6df7\u5408\u64cd\u4f5c\u3002\u5982\u679c\u5ffd\u7565\u8be5\u529f\u80fd\uff0c\u7b80\u5355\u7684\u586b VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR \u3002 createInfo.presentMode = presentMode; createInfo.clipped = VK_TRUE; C++ presentMode \u6307\u5411\u81ea\u5df1\u3002\u5982\u679c clipped \u6210\u5458\u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u610f\u5473\u7740\u6211\u4eec\u4e0d\u5173\u5fc3\u88ab\u906e\u853d\u7684\u50cf\u7d20\u6570\u636e\uff0c\u6bd4\u5982\u7531\u4e8e\u5176\u4ed6\u7684\u7a97\u4f53\u7f6e\u4e8e\u524d\u65b9\u65f6\u6216\u8005\u6e32\u67d3\u7684\u90e8\u5206\u5185\u5bb9\u5b58\u5728\u4e8e\u53ef\u662f\u533a\u57df\u4e4b\u5916\uff0c\u9664\u975e\u771f\u7684\u9700\u8981\u8bfb\u53d6\u8fd9\u4e9b\u50cf\u7d20\u83b7\u6570\u636e\u8fdb\u884c\u5904\u7406\uff0c\u5426\u5219\u53ef\u4ee5\u5f00\u542f\u88c1\u526a\u83b7\u5f97\u6700\u4f73\u6027\u80fd\u3002 createInfo.oldSwapchain = VK_NULL_HANDLE; C++ \u6700\u540e\u4e00\u4e2a\u5b57\u6bb5 oldSwapChain \u3002Vulkan\u8fd0\u884c\u65f6\uff0c\u4ea4\u6362\u94fe\u53ef\u80fd\u5728\u67d0\u4e9b\u6761\u4ef6\u4e0b\u88ab\u66ff\u6362\uff0c\u6bd4\u5982\u7a97\u53e3\u8c03\u6574\u5927\u5c0f\u6216\u8005\u4ea4\u6362\u94fe\u9700\u8981\u91cd\u65b0\u5206\u914d\u66f4\u5927\u7684\u56fe\u50cf\u961f\u5217\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4ea4\u6362\u94fe\u5b9e\u9645\u4e0a\u9700\u8981\u91cd\u65b0\u5206\u914d\u521b\u5efa\uff0c\u5e76\u4e14\u5fc5\u987b\u5728\u6b64\u5b57\u6bb5\u4e2d\u6307\u5b9a\u5bf9\u65e7\u7684\u5f15\u7528\uff0c\u7528\u4ee5\u56de\u6536\u8d44\u6e90\u3002\u8fd9\u662f\u4e00\u4e2a\u6bd4\u8f83\u590d\u6742\u7684\u8bdd\u9898\uff0c\u6211\u4eec\u4f1a\u5728\u540e\u9762\u7684\u7ae0\u8282\u4e2d\u8be6\u7ec6\u4ecb\u7ecd\u3002\u73b0\u5728\u5047\u8bbe\u6211\u4eec\u53ea\u4f1a\u521b\u5efa\u4e00\u4e2a\u4ea4\u6362\u94fe\u3002 \u73b0\u5728\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u53d8\u91cf\u5b58\u50a8 VkSwapchainKHR \u5bf9\u8c61: VkSwapchainKHR swapChain; C++ \u521b\u5efa\u4ea4\u6362\u94fe\u53ea\u9700\u8981\u7b80\u5355\u7684\u8c03\u7528\u51fd\u6570: vkCreateSwapchainKHR : if (vkCreateSwapchainKHR(device, &createInfo, nullptr, &swapChain) != VK_SUCCESS) { throw std::runtime_error(\"failed to create swap chain!\"); } C++ \u53c2\u6570\u662f\u903b\u8f91\u8bbe\u5907\uff0c\u4ea4\u6362\u94fe\u521b\u5efa\u7684\u4fe1\u606f\uff0c\u53ef\u9009\u62e9\u7684\u5206\u914d\u5668\u548c\u4e00\u4e2a\u5b58\u50a8\u4ea4\u6362\u540e\u7684\u53e5\u67c4\u6307\u9488\u3002\u5b83\u4e5f\u9700\u8981\u5728\u8bbe\u5907\u88ab\u6e05\u7406\u524d\uff0c\u8fdb\u884c\u9500\u6bc1\u64cd\u4f5c\uff0c\u901a\u8fc7\u8c03\u7528 vkDestroySwapchainKHR \u3002 void cleanup() { vkDestroySwapchainKHR(device, swapChain, nullptr); ... } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\u786e\u4fdd\u4ea4\u6362\u94fe\u521b\u5efa\u6210\u529f\uff01 \u5c1d\u8bd5\u79fb\u9664 createInfo.imageExtent = extent; \u5e76\u5728validation layers\u5f00\u542f\u7684\u6761\u4ef6\u4e0b\uff0cvalidation layers\u4f1a\u7acb\u523b\u6355\u83b7\u5230\u6709\u5e2e\u52a9\u7684\u5f02\u5e38\u4fe1\u606f:","title":"\u521b\u5efa\u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_20","text":"\u4ea4\u6362\u94fe\u521b\u5efa\u540e\uff0c\u9700\u8981\u83b7\u53d6 VkImage \u76f8\u5173\u7684\u53e5\u67c4\u3002\u5b83\u4f1a\u5728\u540e\u7eed\u6e32\u67d3\u7684\u7ae0\u8282\u4e2d\u5f15\u7528\u3002\u6dfb\u52a0\u7c7b\u6210\u5458\u53d8\u91cf\u5b58\u50a8\u8be5\u53e5\u67c4: std::vector<VkImage> swapChainImages; C++ \u56fe\u50cf\u88ab\u4ea4\u6362\u94fe\u521b\u5efa\uff0c\u4e5f\u4f1a\u5728\u4ea4\u6362\u94fe\u9500\u6bc1\u7684\u540c\u65f6\u81ea\u52a8\u6e05\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u6dfb\u52a0\u4efb\u4f55\u6e05\u7406\u4ee3\u7801\u3002 \u6211\u4eec\u5728 createSwapChain \u51fd\u6570\u4e0b\u9762\u6dfb\u52a0\u4ee3\u7801\u83b7\u53d6\u53e5\u67c4\uff0c\u5728 vkCreateSwapchainKHR \u540e\u8c03\u7528\u3002\u83b7\u53d6\u53e5\u67c4\u7684\u64cd\u4f5c\u540c\u4e4b\u524d\u83b7\u53d6\u6570\u7ec4\u96c6\u5408\u7684\u64cd\u4f5c\u975e\u5e38\u7c7b\u4f3c\u3002\u9996\u5148\u901a\u8fc7\u8c03\u7528 vkGetSwapchainImagesKHR \u83b7\u53d6\u4ea4\u6362\u94fe\u4e2d\u56fe\u50cf\u7684\u6570\u91cf\uff0c\u5e76\u6839\u636e\u6570\u91cf\u8bbe\u7f6e\u5408\u9002\u7684\u5bb9\u5668\u5927\u5c0f\u4fdd\u5b58\u83b7\u53d6\u5230\u7684\u53e5\u67c4\u96c6\u5408\u3002 vkGetSwapchainImagesKHR(device, swapChain, &imageCount, nullptr); swapChainImages.resize(imageCount); vkGetSwapchainImagesKHR(device, swapChain, &imageCount, swapChainImages.data()); C++ \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e4b\u524d\u521b\u5efa\u4ea4\u6362\u94fe\u6b65\u9aa4\u4e2d\u6211\u4eec\u4f20\u9012\u4e86\u671f\u671b\u7684\u56fe\u50cf\u5927\u5c0f\u5230\u5b57\u6bb5 minImageCount \u3002\u800c\u5b9e\u9645\u7684\u8fd0\u884c\uff0c\u5141\u8bb8\u6211\u4eec\u521b\u5efa\u66f4\u591a\u7684\u56fe\u50cf\u6570\u91cf\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u9700\u8981\u518d\u4e00\u6b21\u83b7\u53d6\u6570\u91cf\u3002 \u6700\u540e\uff0c\u5b58\u50a8\u4ea4\u6362\u94fe\u683c\u5f0f\u548c\u8303\u56f4\u5230\u6210\u5458\u53d8\u91cf\u4e2d\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7ae0\u8282\u4f7f\u7528\u3002 VkSwapchainKHR swapChain; std::vector<VkImage> swapChainImages; VkFormat swapChainImageFormat; VkExtent2D swapChainExtent; ... swapChainImageFormat = surfaceFormat.format; swapChainExtent = extent; C++ \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u56fe\u50cf\uff0c\u8fd9\u4e9b\u56fe\u50cf\u53ef\u4ee5\u88ab\u7ed8\u5236\uff0c\u5e76\u5448\u73b0\u5230\u7a97\u4f53\u3002 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u5f00\u59cb\u8ba8\u8bba\u5982\u4f55\u4e3a\u56fe\u50cf\u8bbe\u7f6e\u6e32\u67d3\u76ee\u6807\uff0c\u5e76\u4e86\u89e3\u5b9e\u9645\u7684\u56fe\u50cf\u7ba1\u7ebf\u548c\u7ed8\u5236\u547d\u4ee4\u3002","title":"\u83b7\u53d6\u4ea4\u6362\u94fe\u56fe\u50cf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan-window-surface","text":"Vulkan Window Surface \uff0c\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u4e86\u89e3\u5230 Vulkan \u662f\u4e00\u4e2a\u4e0e\u5e73\u53f0\u7279\u6027\u65e0\u5173\u8054\u7684 API \u96c6\u5408\u3002\u5b83\u4e0d\u80fd\u76f4\u63a5\u4e0e\u7a97\u53e3\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002\u4e3a\u4e86\u5c06\u6e32\u67d3\u7ed3\u679c\u5448\u73b0\u5230\u5c4f\u5e55\uff0c\u9700\u8981\u5efa\u7acb Vulkan \u4e0e\u7a97\u4f53\u7cfb\u7edf\u4e4b\u95f4\u7684\u8fde\u63a5\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 WSI (\u7a97\u4f53\u7cfb\u7edf\u96c6\u6210)\u6269\u5c55\u3002\u5728\u672c\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u8ba8\u8bba\u7b2c\u4e00\u4e2a\uff0c\u5373 VK_KHR_surface \u3002\u5b83\u66b4\u9732\u4e86 VkSurfaceKHR \uff0c\u5b83\u4ee3\u8868 surface \u7684\u4e00\u4e2a\u62bd\u8c61\u7c7b\u578b\uff0c\u7528\u4ee5\u5448\u73b0\u6e32\u67d3\u56fe\u50cf\u4f7f\u7528\u3002\u6211\u4eec\u7a0b\u5e8f\u4e2d\u5c06\u8981\u4f7f\u7528\u5230\u7684 surface \u662f\u7531\u6211\u4eec\u5df2\u7ecf\u5f15\u5165\u7684 GLFW \u6269\u5c55\u53ca\u5176\u6253\u5f00\u7684\u76f8\u5173\u7a97\u4f53\u652f\u6301\u7684\u3002\u7b80\u5355\u6765\u8bf4surface\u5c31\u662fVulkan\u4e0e\u7a97\u4f53\u7cfb\u7edf\u7684\u8fde\u63a5\u6865\u6881\u3002 VK_KHR_surface \u6269\u5c55\u662f\u4e00\u4e2ainstance\u7ea7\u6269\u5c55\uff0c\u6211\u4eec\u76ee\u524d\u4e3a\u6b62\u5df2\u7ecf\u542f\u7528\u8fc7\u5b83\uff0c\u5b83\u5305\u542b\u5728 glfwGetRequiredInstanceExtensions \u8fd4\u56de\u7684\u5217\u8868\u4e2d\u3002\u8be5\u5217\u8868\u8fd8\u5305\u62ec\u5c06\u5728\u63a5\u4e0b\u6765\u51e0\u5c0f\u8282\u4e2d\u4f7f\u7528\u7684\u4e00\u4e9b\u5176\u4ed6WSI\u6269\u5c55\u3002 \u9700\u8981\u5728 instance \u521b\u5efa\u4e4b\u540e\u7acb\u5373\u521b\u5efa\u7a97\u4f53 surface \uff0c\u56e0\u4e3a\u5b83\u4f1a\u5f71\u54cd\u7269\u7406\u8bbe\u5907\u7684\u9009\u62e9\u3002\u4e4b\u6240\u4ee5\u5728\u672c\u5c0f\u8282\u5c06 surface \u521b\u5efa\u903b\u8f91\u7eb3\u5165\u8ba8\u8bba\u8303\u56f4\uff0c\u662f\u56e0\u4e3a\u7a97\u4f53 surface \u5bf9\u4e8e\u6e32\u67d3\u3001\u5448\u73b0\u65b9\u5f0f\u662f\u4e00\u4e2a\u6bd4\u8f83\u5927\u7684\u8bfe\u9898\uff0c\u5982\u679c\u8fc7\u65e9\u7684\u5728\u521b\u5efa\u7269\u7406\u8bbe\u5907\u52a0\u5165\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u4f1a\u6df7\u6dc6\u57fa\u672c\u7684\u7269\u7406\u8bbe\u5907\u8bbe\u7f6e\u5de5\u4f5c\u3002\u53e6\u5916\u7a97\u4f53 surface \u672c\u8eab\u5bf9\u4e8e Vulkan \u4e5f\u662f\u975e\u5f3a\u5236\u7684\u3002 Vulkan \u5141\u8bb8\u8fd9\u6837\u505a\uff0c\u4e0d\u9700\u8981\u540c OpenGL \u4e00\u6837\u5fc5\u987b\u8981\u521b\u5efa\u7a97\u4f53 surface \u3002 \u6587\u7ae0\u76ee\u5f55 1 \u521b\u5efa Window Surface 2 \u67e5\u8be2\u6f14\u793a\u652f\u6301 3 \u521b\u5efa\u6f14\u793a\u961f\u5217","title":"Vulkan Window Surface"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#window-surface","text":"\u73b0\u5728\u5f00\u59cb\u7740\u624b\u521b\u5efa\u7a97\u4f53 surface \uff0c\u5728\u7c7b\u6210\u5458 debugCallback \u4e0b\u52a0\u5165\u6210\u5458\u53d8\u91cf surface \u3002 VkSurfaceKHR surface; C++ \u867d\u7136 VkSurfaceKHR \u5bf9\u8c61\u53ca\u5176\u7528\u6cd5\u4e0e\u5e73\u53f0\u65e0\u5173\u8054\uff0c\u4f46\u521b\u5efa\u8fc7\u7a0b\u9700\u8981\u4f9d\u8d56\u5177\u4f53\u7684\u7a97\u4f53\u7cfb\u7edf\u7684\u7ec6\u8282\u3002\u6bd4\u5982\uff0c\u5728 Windows \u5e73\u53f0\u4e2d\uff0c\u5b83\u9700\u8981 WIndows \u4e0a\u7684 HWND \u548c HMODULE \u53e5\u67c4\u3002\u56e0\u6b64\u9488\u5bf9\u7279\u5b9a\u5e73\u53f0\u63d0\u4f9b\u76f8\u5e94\u7684\u6269\u5c55\uff0c\u5728 Windows \u4e0a\u4e3a VK_KHR_win32_surface \uff0c\u5b83\u81ea\u52a8\u5305\u542b\u5728 glfwGetRequiredInstanceExtensions \u5217\u8868\u4e2d\u3002 \u6211\u4eec\u5c06\u4f1a\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u7279\u5b9a\u5e73\u53f0\u7684\u6269\u5c55\u6765\u521b\u5efa Windows \u4e0a\u7684 surface \u6865\uff0c\u4f46\u662f\u4e0d\u4f1a\u5728\u6559\u7a0b\u4e2d\u5b9e\u9645\u4f7f\u7528\u5b83\u3002\u4f7f\u7528GLFW\u8fd9\u6837\u7684\u5e93\u907f\u514d\u4e86\u7f16\u5199\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u7684\u8de8\u5e73\u53f0\u76f8\u5173\u4ee3\u7801\u3002 GLFW \u5b9e\u9645\u4e0a\u901a\u8fc7 glfwCreateWindowSurface \u5f88\u597d\u7684\u5904\u7406\u4e86\u5e73\u53f0\u5dee\u5f02\u6027\u3002\u5f53\u7136\u4e86\uff0c\u6bd4\u8f83\u7406\u60f3\u662f\u5728\u4f9d\u8d56\u5b83\u4eec\u5e2e\u52a9\u6211\u4eec\u5b8c\u6210\u5177\u4f53\u5de5\u4f5c\u4e4b\u524d\uff0c\u4e86\u89e3\u4e00\u4e0b\u80cc\u540e\u7684\u5b9e\u73b0\u662f\u6709\u5e2e\u52a9\u7684\u3002 \u56e0\u4e3a\u4e00\u4e2a\u7a97\u4f53 surface \u662f\u4e00\u4e2a Vulkan \u5bf9\u8c61\uff0c\u5b83\u9700\u8981\u586b\u5145 VkWin32SurfaceCreateInfoKHR \u7ed3\u6784\u4f53\uff0c\u8fd9\u91cc\u6709\u4e24\u4e2a\u6bd4\u8f83\u91cd\u8981\u7684\u53c2\u6570: hwnd \u548c hinstance \u3002\u5982\u679c\u719f\u6089 windows \u4e0b\u5f00\u53d1\u5e94\u8be5\u77e5\u9053\uff0c\u8fd9\u4e9b\u662f\u7a97\u53e3\u548c\u8fdb\u7a0b\u7684\u53e5\u67c4\u3002 VkWin32SurfaceCreateInfoKHR createInfo; createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR; createInfo.hwnd = glfwGetWin32Window(window); createInfo.hinstance = GetModuleHandle(nullptr); C++ glfwGetWin32Window \u51fd\u6570\u7528\u4e8e\u4eceGLFW\u7a97\u4f53\u5bf9\u8c61\u83b7\u53d6\u539f\u59cb\u7684 HWND \u3002 GetModuleHandle \u51fd\u6570\u8fd4\u56de\u5f53\u524d\u8fdb\u7a0b\u7684 HINSTANCE \u53e5\u67c4\u3002 \u586b\u5145\u5b8c\u7ed3\u6784\u4f53\u4e4b\u540e\uff0c\u53ef\u4ee5\u5229\u7528 vkCreateWin32SurfaceKHR \u521b\u5efasurface\u6865\uff0c\u548c\u4e4b\u524d\u83b7\u53d6\u521b\u5efa\u3001\u9500\u6bc1 DebugReportCallEXT \u4e00\u6837\uff0c\u8fd9\u91cc\u540c\u6837\u9700\u8981\u901a\u8fc7 instance \u83b7\u53d6\u521b\u5efa surface \u7528\u5230\u7684\u51fd\u6570\u3002\u8fd9\u91cc\u6d89\u53ca\u5230\u7684\u53c2\u6570\u5206\u522b\u4e3a instance , surface \u521b\u5efa\u7684\u4fe1\u606f\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u6700\u7ec8\u4fdd\u5b58 surface \u7684\u53e5\u67c4\u53d8\u91cf\u3002 auto CreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) vkGetInstanceProcAddr(instance, \"vkCreateWin32SurfaceKHR\"); if (!CreateWin32SurfaceKHR || CreateWin32SurfaceKHR(instance, &createInfo, nullptr, &surface) != VK_SUCCESS) { throw std::runtime_error(\"failed to create window surface!\"); } C++ \u8be5\u8fc7\u7a0b\u4e0e\u5176\u4ed6\u5e73\u53f0\u7c7b\u4f3c\uff0c\u6bd4\u5982 Linux \uff0c\u4f7f\u7528X11\u754c\u9762\u7a97\u4f53\u7cfb\u7edf\uff0c\u53ef\u4ee5\u901a\u8fc7 vkCreateXcbSurfaceKHR \u51fd\u6570\u5efa\u7acb\u8fde\u63a5\u3002 glfwCreateWindowSurface \u51fd\u6570\u6839\u636e\u4e0d\u540c\u5e73\u53f0\u7684\u5dee\u5f02\u6027\uff0c\u5728\u5b9e\u73b0\u7ec6\u8282\u4e0a\u4f1a\u6709\u6240\u4e0d\u540c\u3002\u6211\u4eec\u73b0\u5728\u5c06\u5176\u6574\u5408\u5230\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\u3002\u4ece initVulkan \u4e2d\u6dfb\u52a0\u4e00\u4e2a\u51fd\u6570 createSurface ,\u5b89\u6392\u5728 createInstnace \u548c setupDebugCallback \u51fd\u6570\u4e4b\u540e\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); } void createSurface() { } C++ GLFW \u6ca1\u6709\u4f7f\u7528\u7ed3\u6784\u4f53\uff0c\u800c\u662f\u9009\u62e9\u975e\u5e38\u76f4\u63a5\u7684\u53c2\u6570\u4f20\u9012\u6765\u8c03\u7528\u51fd\u6570\u3002 void createSurface() { if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) { throw std::runtime_error(\"failed to create window surface!\"); } } C++ \u53c2\u6570\u662f VkInstance , GLFW \u7a97\u4f53\u7684\u6307\u9488\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u7528\u4e8e\u5b58\u50a8 VkSurfaceKHR \u53d8\u91cf\u7684\u6307\u9488\u3002\u5bf9\u4e8e\u4e0d\u540c\u5e73\u53f0\u7edf\u4e00\u8fd4\u56de VkResult \u3002 GLFW \u6ca1\u6709\u63d0\u4f9b\u4e13\u7528\u7684\u51fd\u6570\u9500\u6bc1 surface ,\u4f46\u662f\u53ef\u4ee5\u7b80\u5355\u7684\u901a\u8fc7 Vulkan \u539f\u59cb\u7684 API \u5b8c\u6210: void cleanup() { ... vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); ... } C++ \u6700\u540e\u8bf7\u786e\u4fddsurface\u7684\u6e05\u7406\u662f\u5728instance\u9500\u6bc1\u4e4b\u524d\u5b8c\u6210\u3002","title":"\u521b\u5efa Window Surface"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_21","text":"\u867d\u7136 Vulkan \u7684\u5b9e\u73b0\u652f\u6301\u7a97\u4f53\u96c6\u6210\u529f\u80fd\uff0c\u4f46\u662f\u5e76\u4e0d\u610f\u5473\u7740\u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e00\u4e2a\u7269\u7406\u8bbe\u5907\u90fd\u652f\u6301\u5b83\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u6269\u5c55 isDeviceSuitable \u51fd\u6570\uff0c\u786e\u4fdd\u8bbe\u5907\u53ef\u4ee5\u5c06\u56fe\u50cf\u5448\u73b0\u5230\u6211\u4eec\u521b\u5efa\u7684 surface \u3002\u7531\u4e8e presentation \u662f\u4e00\u4e2a\u961f\u5217\u7684\u7279\u6027\u529f\u80fd\uff0c\u56e0\u6b64\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6cd5\u5c31\u662f\u627e\u5230\u652f\u6301 presentation \u7684\u961f\u5217\u7c07\uff0c\u6700\u7ec8\u83b7\u53d6\u961f\u5217\u6ee1\u8db3 surface \u521b\u5efa\u7684\u9700\u8981\u3002 \u5b9e\u9645\u60c5\u51b5\u662f\uff0c\u652f\u6301 graphics \u547d\u4ee4\u7684\u7684\u961f\u5217\u7c07\u548c\u652f\u6301 presentation \u547d\u4ee4\u7684\u961f\u5217\u7c07\u53ef\u80fd\u4e0d\u662f\u540c\u4e00\u4e2a\u7c07\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u4fee\u6539 QueueFamilyIndices \u7ed3\u6784\u4f53\uff0c\u4ee5\u652f\u6301\u5dee\u5f02\u5316\u7684\u5b58\u50a8\u3002 struct QueueFamilyIndices { int graphicsFamily = -1; int presentFamily = -1; bool isComplete() { return graphicsFamily >= 0 && presentFamily >= 0; } }; C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4fee\u6539 findQueueFamilies \u51fd\u6570\u6765\u67e5\u627e\u5177\u5907 presentation \u529f\u80fd\u7684\u961f\u5217\u7c07\u3002\u51fd\u6570\u4e2d\u7528\u4e8e\u68c0\u67e5\u7684\u6838\u5fc3\u4ee3\u7801\u662f vkGetPhysicalDeviceSurfaceSupportKHR ,\u5b83\u5c06\u7269\u7406\u8bbe\u5907\u3001\u961f\u5217\u7c07\u7d22\u5f15\u548c surface \u4f5c\u4e3a\u53c2\u6570\u3002\u5728 VK_QUEUE_GRAPHICS_BIT \u76f8\u540c\u7684\u5faa\u73af\u4f53\u4e2d\u6dfb\u52a0\u51fd\u6570\u7684\u8c03\u7528: VkBool32 presentSupport = false; vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport); C++ \u7136\u540e\u4e4b\u9700\u8981\u68c0\u67e5\u5e03\u5c14\u503c\u5e76\u5b58\u50a8 presentation \u961f\u5217\u7c07\u7684\u7d22\u5f15: if (queueFamily.queueCount > 0 && presentSupport) { indices.presentFamily = i; } C++ \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e3a\u4e86\u652f\u6301 graphics \u548c presentation \u529f\u80fd\uff0c\u6211\u4eec\u5b9e\u9645\u73af\u5883\u4e2d\u5f97\u5230\u7684\u53ef\u80fd\u662f\u540c\u4e00\u4e2a\u961f\u5217\u7c07\uff0c\u4e5f\u53ef\u80fd\u4e0d\u540c\uff0c\u4e3a\u6b64\u5728\u6211\u4eec\u7684\u7a0b\u5e8f\u6570\u636e\u7ed3\u6784\u53ca\u9009\u62e9\u903b\u8f91\u4e2d\uff0c\u5c06\u6309\u7167\u5747\u6765\u81ea\u4e0d\u540c\u7684\u961f\u5217\u7c07\u5206\u522b\u5904\u7406\uff0c\u8fd9\u6837\u4fbf\u53ef\u4ee5\u7edf\u4e00\u5904\u7406\u4ee5\u4e0a\u4e24\u79cd\u60c5\u51b5\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u51fa\u4e8e\u6027\u80fd\u7684\u8003\u8651\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u903b\u8f91\u660e\u786e\u7684\u6307\u5b9a\u7269\u7406\u8bbe\u5907\u6240\u4f7f\u7528\u7684 graphics \u548c presentation \u529f\u80fd\u6765\u81ea\u540c\u4e00\u4e2a\u961f\u5217\u7c07\u3002","title":"\u67e5\u8be2\u6f14\u793a\u652f\u6301"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_22","text":"\u5269\u4e0b\u7684\u4e8b\u60c5\u662f\u4fee\u6539\u903b\u8f91\u8bbe\u5907\u521b\u5efa\u8fc7\u7a0b\uff0c\u5728\u4e8e\u521b\u5efa presentation \u961f\u5217\u5e76\u83b7\u53d6 VkQueue \u7684\u53e5\u67c4\u3002\u6dfb\u52a0\u4fdd\u5b58\u961f\u5217\u53e5\u67c4\u7684\u6210\u5458\u53d8\u91cf: VkQueue presentQueue; C++ \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9700\u8981\u591a\u4e2a VkDeviceQueueCreateInfo \u7ed3\u6784\u6765\u521b\u5efa\u4e0d\u540c\u529f\u80fd\u7684\u961f\u5217\u3002\u4e00\u4e2a\u4f18\u96c5\u7684\u65b9\u5f0f\u662f\u9488\u5bf9\u4e0d\u540c\u529f\u80fd\u7684\u961f\u5217\u7c07\u521b\u5efa\u4e00\u4e2aset\u96c6\u5408\u786e\u4fdd\u961f\u5217\u7c07\u7684\u552f\u4e00\u6027: #include <set> ... QueueFamilyIndices indices = findQueueFamilies(physicalDevice); std::vector<VkDeviceQueueCreateInfo> queueCreateInfos; std::set<int> uniqueQueueFamilies = {indices.graphicsFamily, indices.presentFamily}; float queuePriority = 1.0f; for (int queueFamily : uniqueQueueFamilies) { VkDeviceQueueCreateInfo queueCreateInfo = {}; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = queueFamily; queueCreateInfo.queueCount = 1; queueCreateInfo.pQueuePriorities = &queuePriority; queueCreateInfos.push_back(queueCreateInfo); } C++ \u540c\u65f6\u8fd8\u8981\u4fee\u6539 VkDeviceCreateInfo \u6307\u5411\u961f\u5217\u96c6\u5408: createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size()); createInfo.pQueueCreateInfos = queueCreateInfos.data(); C++ \u5982\u679c\u961f\u5217\u7c07\u76f8\u540c\uff0c\u90a3\u4e48\u6211\u4eec\u4e4b\u9700\u8981\u4f20\u9012\u4e00\u6b21\u7d22\u5f15\u3002\u6700\u540e\uff0c\u6dfb\u52a0\u4e00\u4e2a\u8c03\u7528\u68c0\u7d22\u961f\u5217\u53e5\u67c4: vkGetDeviceQueue(device, indices.presentFamily, 0, &presentQueue); C++ \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u961f\u5217\u7c07\u662f\u76f8\u540c\u7684\uff0c\u4e24\u4e2a\u53e5\u67c4\u53ef\u80fd\u4f1a\u6709\u76f8\u540c\u7684\u503c\u3002\u5728 \u4e0b\u4e00\u4e2a\u7ae0\u8282 \u4e2d\u6211\u4eec\u4f1a\u770b\u770b\u4ea4\u6362\u94fe\uff0c\u4ee5\u53ca\u5b83\u4eec\u5982\u4f55\u4f7f\u6211\u4eec\u80fd\u591f\u5c06\u56fe\u50cf\u5448\u73b0\u7ed9 surface \u3002","title":"\u521b\u5efa\u6f14\u793a\u961f\u5217"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_5","text":"Vulkan \u56fe\u5f62\u7ba1\u7ebf \uff0c\u901a\u8fc7\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\uff0c\u6211\u4eec\u5c06\u4f1a\u5f00\u542f\u6709\u5173\u56fe\u5f62\u7ba1\u7ebf\u7684\u8bdd\u9898\uff0c\u901a\u8fc7\u5bf9\u56fe\u5f62\u6e32\u67d3\u7ba1\u7ebf\u7684\u914d\u7f6e\u5b8c\u6210\u6700\u540e\u7684\u4e09\u89d2\u5f62\u7ed8\u753b\u3002\u6240\u8c13\u56fe\u5f62\u7ba1\u7ebf\u5c31\u662f\u5c06 mesh \u4f7f\u7528\u5230\u7684 vertices \u5b9a\u70b9\u6570\u636e\u548c\u8d34\u56fe\u6570\u636e\uff0c\u8f6c\u5316\u4e3a\u6e32\u67d3 targets \u50cf\u7d20\u7684\u64cd\u4f5c\u5e8f\u5217\u3002\u7b80\u8981\u7684\u6982\u8ff0\u5982\u4e0b\u56fe\u6240\u793a: Input assembler \u6536\u96c6\u6700\u539f\u59cb\u7684\u9876\u70b9\u6570\u636e\uff0c\u5e76\u4e14\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7d22\u5f15\u7f13\u51b2\u533a\u590d\u7528\u8fd9\u4e9b\u6570\u636e\u5143\u7d20\uff0c\u800c\u4e0d\u5fc5\u590d\u5236\u5197\u4f59\u7684\u9876\u70b9\u6570\u636e\u526f\u672c\u3002 vertex shader \u4f1a\u5e94\u7528\u5728\u6bcf\u4e00\u4e2a\u9876\u70b9\u6570\u636e\uff0c\u901a\u5e38\u5e94\u7528\u53d8\u6362\u64cd\u4f5c\uff0c\u4ece\u800c\u5c06\u9876\u70b9\u7684\u4f4d\u7f6e\u5750\u6807\u6570\u636e\u4ece\u6a21\u578b\u7a7a\u95f4\u8f6c\u6362\u4e3a\u5c4f\u5e55\u7a7a\u95f4\u3002\u5728\u5904\u7406\u5b8c\u6bd5\u4e4b\u540e\u4f1a\u5c06\u6570\u636e\u7ee7\u7eed\u5728\u7ba1\u7ebf\u4f20\u9012\u4e0b\u53bb\u3002 tessellation shader \u66f2\u9762\u7740\u8272\u5668\u5141\u8bb8\u57fa\u4e8e\u67d0\u4e9b\u89c4\u5219\u8fdb\u4e00\u6b65\u7ec6\u5206\u51e0\u4f55\u6570\u636e\u589e\u52a0\u7f51\u683c\u7684\u8d28\u91cf\u3002\u7ecf\u5e38\u5e94\u7528\u4e0e\u5899\u9762\u548c\u697c\u68af\u8868\u9762\uff0c\u4f7f\u9644\u8fd1\u770b\u8d77\u6765\u4e0d\u662f\u90a3\u4e48\u5e73\u5766\u3002 geometry shader \u96c6\u5408\u7740\u8272\u5668\u5e94\u7528\u5728\u6bcf\u4e00\u4e2a\u56fe\u5143\u4e0a\uff0c\u53ef\u7528\u4e8e\u589e\u51cf\u56fe\u5143\uff0c\u5b83\u4e0e\u66f2\u9762\u7740\u8272\u5668\u7c7b\u4f3c\uff0c\u4f46\u66f4\u52a0\u7075\u6d3b\u3002\u7136\u800c\uff0c\u5b83\u5728\u4eca\u5929\u7684\u5e94\u7528\u4e2d\u5e76\u6ca1\u6709\u592a\u591a\u7684\u5e94\u7528\u60c5\u666f\uff0c\u56e0\u4e3a\u9664\u4e86 Intel \u7684\u96c6\u6210\u663e\u5361\u5916\uff0c\u5927\u591a\u6570\u663e\u5361\u6027\u80fd\u652f\u6301\u90fd\u4e0d\u7406\u60f3\u3002 \u5149\u6805\u5316\u9636\u6bb5\u5c06\u56fe\u5143\u5206\u89e3\u4e3a\u7247\u5143\u3002\u8fd9\u4e9b\u662f\u586b\u5145\u5728\u5e27\u7f13\u51b2\u533a\u4e0a\u7684\u50cf\u7d20\u5143\u7d20\u3002\u5c4f\u5e55\u5916\u533a\u57df\u7684\u7247\u5143\u4f1a\u88ab\u4e22\u5f03\uff0c\u9876\u70b9\u7740\u8272\u5668\u8f93\u51fa\u7684\u6570\u636e\u5728\u4f20\u9012\u5230\u7247\u5143\u7740\u8272\u5668\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u5982\u56fe\u6240\u793a\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u6839\u636e\u6df1\u5ea6\u6d4b\u8bd5\u7684\u7ed3\u679c\u4e5f\u4f1a\u5bf9\u7247\u5143\u8fdb\u884c\u4e22\u5f03\u3002 fragment shader \u5e94\u7528\u4e8e\u6bcf\u4e2a\u7247\u5143\uff0c\u786e\u5b9a\u6bcf\u4e2a\u5e27\u7f13\u51b2\u533a\u4e2d\u5199\u5165\u7684\u7247\u5143\u6570\u636e\u7684\u989c\u8272\u548c\u6df1\u5ea6\u503c\u3002\u7247\u5143\u7740\u8272\u5668\u53ef\u4ee5\u4f7f\u7528\u9876\u70b9\u7740\u8272\u5668\u7684\u63d2\u503c\u6570\u636e\uff0c\u8d34\u56fe\u7684UV\u5750\u6807\u548c\u5149\u6e90\u6cd5\u7ebf\u6570\u636e\u3002 \u6df7\u8272\u64cd\u4f5c\u9636\u6bb5\u4f1a\u5bf9\u4e0d\u540c\u7247\u5143\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\uff0c\u6700\u7ec8\u6620\u5c04\u5230\u5e27\u7f13\u51b2\u533a\u7684\u540c\u4e00\u4e2a\u50cf\u7d20\u4e0a\u3002\u7247\u5143\u4e5f\u53ef\u4ee5\u7b80\u5355\u7684\u4e92\u76f8\u91cd\u5199\uff0c\u53e0\u52a0\u6216\u8005\u6839\u636e\u900f\u660e\u5ea6\u6df7\u5408\u3002 \u7eff\u8272\u7684\u9636\u6bb5\u88ab\u79f0\u4e3a\u56fa\u5b9a\u6d41\u6c34\u7ebf\u3002\u8fd9\u4e2a\u9636\u6bb5\u5141\u8bb8\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684\u53c2\u6570\u6570\u503c\uff0c\u4f46\u662f\u5b83\u5185\u90e8\u7684\u5de5\u4f5c\u903b\u8f91\u662f\u9884\u5236\u597d\u7684\u3002 \u6a59\u8272\u7684\u9636\u6bb5\u88ab\u79f0\u4e3a\u53ef\u7f16\u7a0b\u9636\u6bb5 programmable \uff0c\u6211\u4eec\u53ef\u4ee5\u5411GPU\u63d0\u4ea4\u81ea\u5df1\u7f16\u5199\u7684\u4ee3\u7801\u6267\u884c\u5177\u4f53\u7684\u903b\u8f91\u3002\u6bd4\u5982\u5728\u4f7f\u7528 fragment shader \u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u5b9e\u73b0\u4efb\u4f55\u4ece\u8d34\u56fe\u5230\u706f\u5149\u7684\u5149\u7ebf\u8ffd\u8e2a\u3002\u8fd9\u4e9b\u7a0b\u5e8f\u540c\u65f6\u8fd0\u884c\u5728\u591a\u6838GPU\u4e0a\u5904\u7406\u8bb8\u591a\u5bf9\u8c61\uff0c\u6bd4\u5982\u5e76\u884c\u7684\u9876\u70b9\u548c\u7247\u6bb5\u7a0b\u5e8f\u3002 \u5982\u679c\u4e4b\u524d\u4f7f\u7528\u8fc7\u65e7\u7684API( OpenGL \u548c Direct3D ),\u90a3\u4e48\u5c06\u53ef\u4ee5\u968f\u610f\u901a\u8fc7 glBlendFunc \u548c OMSetBlendState \u8c03\u7528\u66f4\u6539\u7ba1\u7ebf\u8bbe\u7f6e\u3002 Vulkan\u4e2d \u7684\u56fe\u5f62\u7ba1\u7ebf\u51e0\u4e4e\u4e0d\u53ef\u6539\u53d8\uff0c\u56e0\u6b64\u5982\u679c\u9700\u8981\u66f4\u6539\u7740\u8272\u5668\uff0c\u7ed1\u5b9a\u5230\u4e0d\u540c\u7684\u5e27\u7f13\u51b2\u533a\u6216\u8005\u66f4\u6539\u6df7\u5408\u51fd\u6570\uff0c\u5219\u5fc5\u987b\u4ece\u5934\u521b\u5efa\u7ba1\u7ebf\u3002\u7f3a\u70b9\u662f\u5fc5\u987b\u521b\u5efa\u4e00\u4e9b\u7ba1\u7ebf\uff0c\u8fd9\u4e9b\u7ba1\u7ebf\u4ee3\u8868\u5728\u6e32\u67d3\u64cd\u4f5c\u4e2d\u4f7f\u7528\u7684\u4e0d\u540c\u7684\u7ec4\u5408\u72b6\u6001\u3002\u4f46\u662f\u7531\u4e8e\u6240\u6709\u7ba1\u7ebf\u7684\u64cd\u4f5c\u90fd\u662f\u63d0\u524d\u77e5\u9053\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7\u9a71\u52a8\u7a0b\u5e8f\u66f4\u597d\u7684\u4f18\u5316\u5b83\u3002 \u4e00\u4e9b\u53ef\u7f16\u7a0b\u9636\u6bb5\u662f\u57fa\u4e8e\u6253\u7b97\u505a\u4ec0\u4e48\u800c\u51b3\u5b9a\u7684\u3002\u6bd4\u5982\uff0c\u5982\u679c\u53ea\u662f\u7b80\u5355\u7684\u7ed8\u5236\u51e0\u4f55\u56fe\u5f62\uff0c\u5219\u53ef\u4ee5\u7981\u7528 tessellation \u548c geometry \u7740\u8272\u5668\u3002\u5982\u679c\u53ea\u5bf9\u6df1\u5ea6\u503c\u611f\u5174\u8da3\uff0c\u5219\u53ef\u4ee5\u7981\u7528 fragment \u7740\u8272\u5668\uff0c\u8fd9\u5bf9\u4e8e\u751f\u6210 shadow map \u751f\u6210\u5f88\u6709\u7528\u3002 \u5728\u4e0b\u4e00\u4e2a\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u9996\u5148\u521b\u5efa\u5c06\u4e09\u89d2\u5f62\u653e\u5728\u5c4f\u5e55\u4e0a\u6240\u9700\u8981\u7684\u4e24\u4e2a\u53ef\u7f16\u7a0b\u9636\u6bb5: vertice shader \u548c fragment shader \u3002\u56fa\u5b9a\u529f\u80fd\u7684\u8bbe\u7f6e\u5305\u62ec blending mode , viewport , rasterization \u5c06\u5728\u4e4b\u540e\u7684\u7ae0\u8282\u4e2d\u8bbe\u7f6e\u3002\u5728 Vulkan \u4e2d\u8bbe\u7f6e\u56fe\u5f62\u6d41\u6c34\u7ebf\u7684\u6700\u540e\u4e00\u90e8\u5206\u5185\u5bb9\u6d89\u53ca\u8f93\u5165\u548c\u8f93\u51fa\u5e27\u7f13\u51b2\u533a\u3002 \u5728 initVulkan \u4e2d\u521b\u5efa\u51fd\u6570 createGraphicsPipeline \u5e76\u5728 createImageViews \u540e\u7acb\u5373\u8c03\u7528\u3002\u6211\u4eec\u5728\u4e0b\u4e00\u7ae0\u8282\u4ecb\u7ecd\u51fd\u6570\u529f\u80fd\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createGraphicsPipeline(); } ... void createGraphicsPipeline() { } C++ \u5728\u7ed3\u5c3e\u5904\u5206\u4eab\u4e00\u4e0b Vulkan \u5b98\u65b9\u7684\u56fe\u5f62\u7ba1\u7ebf\u7ed3\u6784\u56fe\uff0c\u5982\u4e0b:","title":"Vulkan \u56fe\u5f62\u7ba1\u7ebf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_6","text":"Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe \uff0c\u4f7f\u7528\u4efb\u4f55\u7684 VkImage \uff0c\u5305\u62ec\u5728\u4ea4\u6362\u94fe\u6216\u8005\u6e32\u67d3\u7ba1\u7ebf\u4e2d\u7684\uff0c\u6211\u4eec\u90fd\u9700\u8981\u521b\u5efa VkImageView \u5bf9\u8c61\u3002\u4ece\u5b57\u9762\u4e0a\u7406\u89e3\u5b83\u5c31\u662f\u4e00\u4e2a\u9488\u5bf9\u56fe\u50cf\u7684\u89c6\u56fe\u6216\u5bb9\u5668\uff0c\u901a\u8fc7\u5b83\u5177\u4f53\u7684\u6e32\u67d3\u7ba1\u7ebf\u624d\u80fd\u591f\u8bfb\u5199\u6e32\u67d3\u6570\u636e\uff0c\u6362\u53e5\u8bdd\u8bf4 VkImage \u4e0d\u80fd\u4e0e\u6e32\u67d3\u7ba1\u7ebf\u8fdb\u884c\u4ea4\u4e92\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u56fe\u50cf\u89c6\u56fe\u53ef\u4ee5\u8fdb\u4e00\u6b65\u5b9a\u4e49\u5177\u4f53 Image \u7684\u683c\u5f0f\uff0c\u6bd4\u5982\u5b9a\u4e49\u4e3a2D\u8d34\u56fe\uff0c\u90a3\u4e48\u672c\u8d28\u4e0a\u5c31\u4e0d\u9700\u8981\u4efb\u4f55\u7ea7\u522b\u7684 mipmapping \u3002 \u5728\u672c\u7ae0\u8282\u6211\u4eec\u4f1a\u65b0\u589e\u4e00\u4e2a createImageViews \u51fd\u6570\uff0c\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u521b\u5efa\u57fa\u672c\u7684\u89c6\u56fe\uff0c\u8fd9\u4e9b\u89c6\u56fe\u5728\u540e\u9762\u7684\u5185\u5bb9\u4e2d\u4f1a\u88ab\u4f5c\u4e3a\u989c\u8272\u76ee\u6807\u4e0e\u6e32\u67d3\u7ba1\u7ebf\u914d\u5408\u4f7f\u7528\u3002 \u9996\u5148\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u6210\u5458\u7528\u4e8e\u4fdd\u5b58\u56fe\u50cf\u89c6\u56fe\u7684\u53e5\u67c4\u96c6: std::vector<VkImageView> swapChainImageViews; C++ \u521b\u5efa createImagesViews \u51fd\u6570\uff0c\u5e76\u5728\u521b\u5efa\u4ea4\u6362\u94fe\u5b8c\u6210\u4e4b\u540e\u8c03\u7528: void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); } void createImageViews() { } C++ \u6211\u4eec\u9700\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u9700\u8981\u5b9a\u4e49\u4fdd\u5b58\u56fe\u50cf\u89c6\u56fe\u96c6\u5408\u7684\u5927\u5c0f: void createImageViews() { swapChainImageViews.resize(swapChainImages.size()); } C++ \u4e0b\u4e00\u6b65\uff0c\u5faa\u73af\u8fed\u4ee3\u6240\u6709\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u3002 for (size_t i = 0; i < swapChainImages.size(); i++) { } C++ \u521b\u5efa\u56fe\u50cf\u89c6\u56fe\u7684\u53c2\u6570\u88ab\u5b9a\u4e49\u5728 VkImageViewCreateInfo \u7ed3\u6784\u4f53\u4e2d\u3002\u524d\u51e0\u4e2a\u53c2\u6570\u7684\u586b\u5145\u975e\u5e38\u7b80\u5355\u3001\u76f4\u63a5\u3002 VkImageViewCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; createInfo.image = swapChainImages[i]; C++ \u5176\u4e2d viewType \u548c format \u5b57\u6bb5\u7528\u4e8e\u63cf\u8ff0\u56fe\u50cf\u6570\u636e\u8be5\u88ab\u5982\u4f55\u89e3\u91ca\u3002 viewType \u53c2\u6570\u5141\u8bb8\u5c06\u56fe\u50cf\u5b9a\u4e49\u4e3a 1D textures , 2D textures , 3D textures \u548c cube maps \u3002 createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; createInfo.format = swapChainImageFormat; C++ components \u5b57\u6bb5\u5141\u8bb8\u8c03\u6574\u989c\u8272\u901a\u9053\u7684\u6700\u7ec8\u7684\u6620\u5c04\u903b\u8f91\u3002\u6bd4\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6240\u6709\u989c\u8272\u901a\u9053\u6620\u5c04\u4e3a\u7ea2\u8272\u901a\u9053\uff0c\u4ee5\u5b9e\u73b0\u5355\u8272\u7eb9\u7406\u3002\u6211\u4eec\u4e5f\u53ef\u4ee5\u5c06\u901a\u9053\u6620\u5c04\u5177\u4f53\u7684\u5e38\u91cf\u6570\u503c 0 \u548c 1 \u3002\u5728\u7ae0\u8282\u4e2d\u6211\u4eec\u4f7f\u7528\u9ed8\u8ba4\u7684\u6620\u5c04\u7b56\u7565\u3002 createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY; C++ subresourceRangle \u5b57\u6bb5\u7528\u4e8e\u63cf\u8ff0\u56fe\u50cf\u7684\u4f7f\u7528\u76ee\u6807\u662f\u4ec0\u4e48\uff0c\u4ee5\u53ca\u53ef\u4ee5\u88ab\u8bbf\u95ee\u7684\u6709\u6548\u533a\u57df\u3002\u6211\u4eec\u7684\u56fe\u50cf\u5c06\u4f1a\u4f5c\u4e3a color targets \uff0c\u6ca1\u6709\u4efb\u4f55 mipmapping levels \u6216\u662f\u591a\u5c42 multiple layers \u3002 createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; createInfo.subresourceRange.baseMipLevel = 0; createInfo.subresourceRange.levelCount = 1; createInfo.subresourceRange.baseArrayLayer = 0; createInfo.subresourceRange.layerCount = 1; C++ \u5982\u679c\u5728\u7f16\u5199\u6c89\u6d78\u5f0f\u7684 3D \u5e94\u7528\u7a0b\u5e8f\uff0c\u6bd4\u5982 VR \uff0c\u5c31\u9700\u8981\u521b\u5efa\u652f\u6301\u591a\u5c42\u7684\u4ea4\u6362\u94fe\u3002\u5e76\u4e14\u901a\u8fc7\u4e0d\u540c\u7684\u5c42\u4e3a\u6bcf\u4e00\u4e2a\u56fe\u50cf\u521b\u5efa\u591a\u4e2a\u89c6\u56fe\uff0c\u4ee5\u6ee1\u8db3\u4e0d\u540c\u5c42\u7684\u56fe\u50cf\u5728\u5de6\u53f3\u773c\u6e32\u67d3\u65f6\u5bf9\u89c6\u56fe\u7684\u9700\u8981\u3002 \u521b\u5efa\u56fe\u50cf\u89c6\u56fe\u8c03\u7528 vkCreateImageView \u51fd\u6570: if (vkCreateImageView(device, &createInfo, nullptr, &swapChainImageViews[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to create image views!\"); } C++ \u4e0e\u56fe\u50cf\u4e0d\u540c\u7684\u662f\uff0c\u56fe\u50cf\u89c6\u56fe\u9700\u8981\u660e\u786e\u7684\u521b\u5efa\u8fc7\u7a0b\uff0c\u6240\u4ee5\u5728\u7a0b\u5e8f\u9000\u51fa\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a\u5faa\u73af\u53bb\u9500\u6bc1\u4ed6\u4eec\u3002 void cleanup() { for (size_t i = 0; i < swapChainImageViews.size(); i++) { vkDestroyImageView(device, swapChainImageViews[i], nullptr); } ... } C++ \u62e5\u6709\u4e86\u56fe\u50cf\u89c6\u56fe\u540e\uff0c\u4f7f\u7528\u56fe\u50cf\u4f5c\u4e3a\u8d34\u56fe\u5df2\u7ecf\u8db3\u591f\u4e86\uff0c\u4f46\u662f\u5b83\u8fd8\u6ca1\u6709\u51c6\u5907\u597d\u4f5c\u4e3a\u6e32\u67d3\u7684 target \u3002\u5b83\u9700\u8981\u66f4\u591a\u7684\u95f4\u63a5\u6b65\u9aa4\u53bb\u51c6\u5907\uff0c\u5176\u4e2d\u4e00\u4e2a\u5c31\u662f framebuffer \uff0c\u88ab\u79f0\u4f5c\u5e27\u7f13\u51b2\u533a\u3002\u4f46\u9996\u5148\u6211\u4eec\u8981\u8bbe\u7f6e\u56fe\u5f62\u7ba1\u7ebf\u3002","title":"Vulkan \u56fe\u50cf\u4e0e\u89c6\u56fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_7","text":"Vulkan \u7740\u8272\u5668\u6a21\u5757 \uff0c\u4e0e\u4e4b\u524d\u7684\u56fe\u50cf API \u4e0d\u540c\uff0c Vulkan \u4e2d\u7684\u7740\u8272\u5668\u4ee3\u7801\u5fc5\u987b\u4ee5\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u7684\u683c\u5f0f\u4f7f\u7528\uff0c\u800c\u4e0d\u662f\u50cf GLSL \u548c HLSL \u8fd9\u6837\u5177\u6709\u6bd4\u8f83\u597d\u7684\u53ef\u8bfb\u6027\u7684\u8bed\u6cd5\u3002\u6b64\u5b57\u8282\u683c\u5f0f\u6210\u4e3a SPIR-V \uff0c\u5b83\u53ef\u4ee5\u4e0e Vulkan \u548c OpenCL \u4e00\u540c\u4f7f\u7528\u3002\u8fd9\u662f\u4e00\u79cd\u53ef\u4ee5\u7f16\u5199\u56fe\u5f62\u548c\u8ba1\u7b97\u7740\u8272\u5668\u7684\u683c\u5f0f\uff0c\u4f46\u6211\u4eec\u91cd\u70b9\u4ecb\u7ecd\u672c\u6559\u7a0b\u4e2d Vulkan \u56fe\u5f62\u6d41\u6c34\u7ebf\u4f7f\u7528\u7684\u7740\u8272\u5668\u3002 \u4f7f\u7528\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u683c\u5f0f\u7684\u4f18\u70b9\u4e4b\u4e00\u662f \u4f7f\u5f97 GPU \u5382\u5546\u7f16\u5199\u5c06\u7740\u8272\u5668\u4ee3\u7801\u8f6c\u6362\u4e3a\u672c\u5730\u4ee3\u7801\u7684\u7f16\u8bd1\u5668\u590d\u6742\u5ea6\u51cf\u5c11\u4e86\u5f88\u591a\u3002\u7ecf\u9a8c\u8868\u660e\u4f7f\u7528\u53ef\u8bfb\u6027\u6bd4\u8f83\u5f3a\u7684\u8bed\u6cd5\uff0c\u6bd4\u5982 GLSL \u4e00\u4e9b GPU \u5382\u5546\u76f8\u5f53\u7075\u6d3b\u5730\u7406\u89e3\u8fd9\u4e2a\u6807\u51c6\u3002\u8fd9\u5bfc\u81f4\u4e00\u79cd\u60c5\u51b5\u4f1a\u53d1\u751f\uff0c\u6bd4\u5982\u7f16\u5199\u597d\uff0c\u5e76\u5728\u4e00\u4e2a\u5382\u5546\u7684 GPU \u8fd0\u884c\u7684\u4e0d\u9519\u7684\u7740\u8272\u5668\u7a0b\u5e8f\uff0c\u53ef\u80fd\u5728\u5176\u4ed6\u7684 GPU \u5382\u5546\u7684 GPU \u9a71\u52a8\u7a0b\u5e8f\u8fd0\u884c\u5f02\u5e38\uff0c\u53ef\u80fd\u662f\u8bed\u6cd5\u7684\u95ee\u9898\uff0c\u6216\u8005\u66f4\u7cdf\u7684\u662f\u4e0d\u540c GPU \u5382\u5546\u7f16\u5199\u7684\u7f16\u8bd1\u5668\u5dee\u5f02\uff0c\u5bfc\u81f4\u7740\u8272\u5668\u8fd0\u884c\u9519\u8bef\u3002\u5982\u679c\u76f4\u63a5\u4f7f\u7528\u7f16\u8bd1\u597d\u7684\u4e8c\u8fdb\u5236\u5b57\u8282\u7801\u683c\u5f0f\uff0c\u53ef\u4ee5\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\u3002 \u4f46\u662f\uff0c\u5e76\u4e0d\u610f\u5473\u7740\u6211\u4eec\u8981\u624b\u5199\u5b57\u8282\u7801\u3002 Khronos \u53d1\u5e03\u4e86\u4e0e\u5382\u5546\u65e0\u5173\u7684\u7f16\u8bd1\u5668\uff0c\u5b83\u5c06 GLSL \u7f16\u8bd1\u6210 SPIR-V \u3002\u8be5\u7f16\u8bd1\u5668\u7528\u4e8e\u9a8c\u8bc1\u7740\u8272\u5668\u4ee3\u7801\u662f\u5426\u7b26\u5408\u6807\u51c6\uff0c\u5e76\u751f\u6210\u4e0e Vulkan \u529f\u80fd\u8fd0\u884c\u7684 SPRIR-V \u4e8c\u8fdb\u5236\u6587\u4ef6\u3002\u9664\u6b64\u4e4b\u5916\u8fd8\u53ef\u4ee5\u5c06\u6b64\u7f16\u8bd1\u5668\u4f5c\u4e3a\u5e93\u5728\u8fd0\u884c\u65f6\u7f16\u8bd1\u751f\u6210 SPRI-V \uff0c\u4f46\u5728\u672c\u6559\u7a0b\u4e2d\u4e0d\u4f1a\u8fd9\u6837\u64cd\u4f5c\u3002\u7f16\u8bd1\u5668 glslangValidator.exe \u5305\u542b\u5728 LunarG SDK \u4e2d\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u4e0b\u8f7d\u4efb\u4f55\u989d\u5916\u7684\u5185\u5bb9\u3002 GLSL \u662f\u5177\u6709C\u98ce\u683c\u8bed\u6cd5\u7684\u7740\u8272\u8bed\u8a00\u3002\u5728\u7a0b\u5e8f\u4e2d\u9700\u8981\u5b9a\u4e49\u7f16\u5199 main \u51fd\u6570\u4f5c\u4e3a\u5165\u53e3\u3002 GLSL \u4e0d\u4f1a\u4f7f\u7528\u8f93\u5165\u53c2\u6570\u548c\u8fd4\u56de\u503c\u4f5c\u4e3a\u8f93\u51fa\uff0c\u800c\u662f\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\u6765\u5904\u7406\u8f93\u5165\u548c\u8f93\u51fa\u3002\u8be5\u8bed\u8a00\u5305\u62ec\u5f88\u591a\u529f\u80fd\u7b80\u5316\u56fe\u5f62\u7f16\u7a0b\uff0c\u6bd4\u5982\u5185\u7f6e\u7684\u57fa\u4e8e\u5411\u91cf\u548c\u77e9\u9635\u7684\u53c9\u79ef\u64cd\u4f5c\u51fd\u6570\uff0c\u77e9\u9635\u548c\u77e2\u91cf\u4e58\u6cd5\u64cd\u4f5c\u51fd\u6570\u3002\u77e2\u91cf\u7c7b\u578b\u4e3a vec \uff0c\u6570\u5b57\u8868\u793a\u5206\u91cf\u7684\u6570\u91cf\u3002\u4f8b\u59823D\u4f4d\u7f6e\u5b58\u50a8\u5728 vec3 \u4e2d\u3002\u53ef\u4ee5\u901a\u8fc7\u8bf8\u5982 .x \u4e4b\u7c7b\u7684\u6210\u5458\u8bbf\u95ee\u5355\u4e2a\u5206\u91cf\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u591a\u4e2a\u5206\u91cf\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5411\u91cf\u3002\u6bd4\u5982\uff0c\u8868\u8fbe\u5f0f vec3(1.0, 2.0, 3.0).xy \u622a\u53d6\u524d\u4e24\u4e2a\u5206\u91cf\uff0c\u5e76\u8d4b\u4e88\u65b0\u7684 vec2 \u4e2d\u3002\u5411\u91cf\u7684\u6784\u9020\u51fd\u6570\u4e5f\u53ef\u4ee5\u91c7\u7528\u77e2\u91cf\u5bf9\u8c61\u548c\u6807\u91cf\u503c\u7684\u7ec4\u5408\u3002\u6bd4\u5982 vec3 \u53ef\u4ee5\u7528 vec3(vec2(1.0, 2.0), 3.0) \u6784\u9020\u3002 \u5982\u524d\u9762\u63d0\u5230\u7684\u4e00\u6837\uff0c\u6211\u4eec\u9700\u8981\u7f16\u5199\u4e00\u4e2a vertex shader \u548c\u4e00\u4e2a fragment shader \u7ed8\u5236\u4e09\u89d2\u5f62\u5728\u5c4f\u5e55\u3002\u4e0b\u9762\u4e24\u4e2a\u5c0f\u8282\u4f1a\u63a2\u8ba8\u4e0e\u4e4b\u76f8\u5173\u7684 GLSL \u4ee3\u7801\uff0c\u5e76\u5c55\u793a\u5982\u4f55\u751f\u6210\u4e24\u4e2a SPIR-V \u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u6700\u540e\u52a0\u8f7d\u5230\u7a0b\u5e8f\u4e2d\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9876\u70b9\u7740\u8272\u5668 2 \u7247\u5143\u7740\u8272\u5668 3 \u9876\u70b9\u989c\u8272\u7ec4 4 \u7f16\u8bd1\u7740\u8272\u5668 5 \u52a0\u8f7d\u7740\u8272\u5668 6 \u521b\u5efa\u7740\u8272\u5668\u6a21\u578b 7 \u7740\u8272\u5668\u9636\u6bb5\u521b\u5efa","title":"Vulkan \u7740\u8272\u5668\u6a21\u5757"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_23","text":"\u9876\u70b9\u7740\u8272\u5668\u5904\u7406\u6bcf\u4e00\u4e2a\u9876\u70b9\u6570\u636e\u3002\u5b83\u7684\u5c5e\u6027\uff0c\u5982\u4e16\u754c\u5750\u6807\uff0c\u989c\u8272\uff0c\u6cd5\u7ebf\u548c\u7eb9\u7406UV\u5750\u6807\u4f5c\u4e3a\u8f93\u5165\u3002\u8f93\u51fa\u7684\u662f\u6700\u7ec8\u7684clip coordinates \u88c1\u526a\u5750\u6807\u548c\u9700\u8981\u4f20\u9012\u5230\u7247\u5143\u7740\u8272\u5668\u7684\u5c5e\u6027\uff0c\u5305\u62ec\u989c\u8272\u548c\u7eb9\u7406UV\u5750\u6807\u3002\u8fd9\u4e9b\u503c\u4f1a\u5728\u5149\u6805\u5316\u9636\u6bb5\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u4ee5\u4ea7\u751f\u5e73\u6ed1\u7684\u8fc7\u5ea6\u3002 \u88c1\u526a\u5750\u6807 clip coordinate \u662f\u4e00\u4e2a\u6765\u6b64\u9876\u70b9\u7740\u8272\u5668\u7684\u601d\u7ef4\u5411\u91cf\uff0c\u968f\u540e\u901a\u8fc7\u77e2\u91cf\u6700\u540e\u4e00\u4e2a\u5206\u91cf\u8fdb\u884c\u6574\u4f53\u5f52\u4e00\u5316\u64cd\u4f5c\u3002\u8fd9\u4e9b\u5f52\u4e00\u5316\u540e\u7684\u8bbe\u5907\u5750\u6807\u662f homogeneous coordinates ****\u6700\u7ec8\u6620\u5c04\u5230\u7f13\u51b2\u533a\u8303\u56f4\u4e3a [-1, 1] \u7684 [-1, 1] \u5750\u6807\u7cfb\u7edf\uff0c\u5982\u4e0b\u6240\u793a: \u5982\u679c\u4e4b\u524d\u7684\u8ba1\u7b97\u673a\u56fe\u5f62\u6bd4\u8f83\u719f\u6089\u7684\u8bdd\uff0c\u5bf9\u8fd9\u90e8\u5206\u4f1a\u6bd4\u8f83\u719f\u6089\u3002\u5982\u679c\u4f60\u4e4b\u524d\u4f7f\u7528\u8fc7 OpenGL \uff0c\u4f60\u4f1a\u6ce8\u610f\u5230Y\u5750\u6807\u8f74\u662f\u53cd\u8f6c\u7684\uff0cZ\u5750\u6807\u8f74\u7684\u8303\u56f4\u4e0e Direct3D \u662f\u4e00\u81f4\u7684\u8303\u56f4\uff0c\u4ece0\u52301. \u5bf9\u4e8e\u7b2c\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u6211\u4eec\u4e0d\u4f1a\u505a\u4efb\u4f55\u8f6c\u6362\u64cd\u4f5c\uff0c\u6211\u4eec\u5c06\u4e09\u4e2a\u9876\u70b9\u7684\u4f4d\u7f6e\u6307\u5b9a\u4e3a\u5f52\u4e00\u5316\u8bbe\u5907\u5750\u6807\uff0c\u521b\u5efa\u5982\u4e0b\u56fe\u5f62: \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5c06\u5176\u8f93\u51fa\u4e3a\u88c1\u526a\u5750\u6807\u76f4\u63a5\u8f93\u51fa\u5f52\u4e00\u5316\u7684\u8bbe\u5907\u5750\u6807\uff0c\u9876\u70b9\u7740\u8272\u5668\u7684\u5750\u6807\u4e0e\u6700\u540e\u4e00\u4e2a\u5206\u91cf\u8bbe\u7f6e\u4e3a 1 \u3002\u5c06\u88c1\u526a\u5750\u6807\u8f6c\u6362\u4e3a\u5f52\u4e00\u5316\u7684\u8bbe\u5907\u5750\u6807\u6ca1\u6709\u6539\u53d8\u4efb\u4f55\u4e1c\u897f\u3002 \u901a\u5e38\u60c5\u51b5\u4e0b\u9876\u70b9\u5750\u6807\u6570\u636e\u662f\u5b58\u50a8\u5728\u4e00\u4e2a\u9876\u70b9\u7f13\u51b2\u533a\u4e2d\uff0c\u4f46\u662f\u5728 Vulkan \u4e2d\u521b\u5efa\u4e00\u4e2a\u9876\u70b9\u7f13\u51b2\u533a\u5e76\u586b\u5145\u6570\u636e\u7684\u8fc7\u7a0b\u5e76\u4e0d\u662f\u76f4\u63a5\u7684\u3002\u6240\u4ee5\u6211\u4eec\u540e\u7f6e\u8fd9\u4e9b\u6b65\u9aa4\uff0c\u76f4\u5230\u6211\u4eec\u6ee1\u610f\u7684\u770b\u5230\u4e00\u4e2a\u4e09\u89d2\u5f62\u51fa\u73b0\u5728\u5c4f\u5e55\u4e0a\u3002\u540c\u65f6\u6211\u4eec\u9700\u8981\u505a\u4e00\u4e9b\u975e\u6b63\u7edf\u7684\u4e8b\u60c5:\u5c06\u5750\u6807\u76f4\u63a5\u5305\u542b\u5728\u9876\u70b9\u7740\u8272\u5668\u7684\u5185\u90e8\u3002\u4ee3\u7801\u5982\u4e0b\u6240\u793a: #version 450 #extension GL_ARB_separate_shader_objects : enable out gl_PerVertex { vec4 gl_Position; }; vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); } C++ main \u51fd\u6570\u7684\u6267\u884c\u5e94\u7528\u4e8e\u6bcf\u4e2a\u9876\u70b9\uff0c\u5185\u7f6e\u7684 gl_VertexIndex \u53d8\u91cf\u5305\u542b\u4e86\u5f53\u524d\u9876\u70b9\u7684\u7d22\u5f15\u4fe1\u606f\u3002\u901a\u5e38\u662f\u9876\u70b9\u7f13\u51b2\u533a\u7684\u7d22\u5f15\uff0c\u4f46\u662f\u5728\u8fd9\u91cc\u6211\u4eec\u786c\u7f16\u7801\u5230\u9876\u70b9\u6570\u636e\u7684\u96c6\u5408\u4e2d\u3002\u6bcf\u4e2a\u9876\u70b9\u7684\u4f4d\u7f6e\u4ece\u5e38\u91cf\u6570\u7ec4\u4e2d\u8bbf\u95ee\uff0c\u5e76\u4e0e z \u548c w \u5206\u91cf\u7ec4\u5408\u4f7f\u7528\uff0c\u4ee5\u4ea7\u751f\u88c1\u526a\u5750\u6807\u4e2d\u7684\u6709\u6548\u4f4d\u7f6e\u4fe1\u606f\u3002\u5185\u7f6e\u7684 gl_Position \u53d8\u91cf\u4f5c\u4e3a\u8f93\u51fa\u3002\u6700\u540eVulkan\u4e2d\u4f7f\u7528shader\uff0c\u9700\u8981\u786e\u4fdd GL_ARG_separate_shader_objects \u6269\u5c55\u5f00\u542f\u3002","title":"\u9876\u70b9\u7740\u8272\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_24","text":"\u7531\u9876\u70b9\u7740\u8272\u5668\u7684\u4f4d\u7f6e\u6570\u636e\u5f62\u6210\u7684\u4e09\u89d2\u5f62\u7528\u7247\u6bb5\u7740\u8272\u5668\u586b\u5145\u5c4f\u5e55\u4e0a\u7684\u533a\u57df\u4e2d\u3002\u7247\u6bb5\u7740\u8272\u5668\u9488\u5bf9\u4e00\u4e2a\u6216\u8005\u591a\u4e2aframebuffer\u5e27\u7f13\u51b2\u533a\u7684\u6bcf\u4e2a\u7247\u5143\u4ea7\u751f\u5177\u4f53\u7684\u989c\u8272\u548c\u6df1\u5ea6\u4fe1\u606f\u3002\u4e00\u4e2a\u7b80\u5355\u7684\u7247\u6bb5\u7740\u8272\u5668\u4e3a\u5b8c\u6210\u7684\u4e09\u89d2\u5f62\u8f93\u51fa\u7ea2\u8272\u4fe1\u606f\u7684\u4ee3\u7801\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable layout(location = 0) out vec4 outColor; void main() { outColor = vec4(1.0, 0.0, 0.0, 1.0); } C++ fragment sahder\u4e2d\u7684 main \u51fd\u6570\u4e0e vertex shader \u4e2d\u7684 main \u51fd\u6570\u7c7b\u4f3c\uff0c\u4f1a\u4e3a\u6bcf\u4e00\u4e2a\u7247\u5143\u8c03\u7528\u5904\u7406\u3002\u989c\u8272\u7684\u4fe1\u606f\u5728GLSL\u4e2d\u662f4\u4e2a\u5206\u91cf\u7ec4\u6210\u7684\u77e2\u91cf\uff0c\u5305\u62ecR,G,B\u548cAlpha\u901a\u9053\uff0c\u503c\u57df\u6536\u655b\u5728[0, 1]\u8303\u56f4\u5185\u3002\u4e0d\u50cf\u9876\u70b9\u7740\u8272\u5668\u7684 gl_Position \uff0c\u5b83\u6ca1\u6709\u5185\u7f6e\u7684\u53d8\u91cf\u4e3a\u5f53\u524d\u7247\u5143\u8f93\u51fa\u989c\u8272\u4fe1\u606f\u3002\u5728\u8fd9\u91cc\u5fc5\u987b\u4e3aframebuffer\u5b9a\u4e49\u8f93\u51fa\u53d8\u91cf\uff0c layout(location = 0) \u4fee\u9970\u7b26\u660e\u786eframebuffer\u7684\u7d22\u5f15\u3002\u7ea2\u8272\u4fe1\u606f\u5199\u8fdb outColor \u53d8\u91cf\u4e2d\uff0c\u8be5\u53d8\u91cf\u94fe\u63a5\u7b2c\u4e00\u4e2aframebuffer\u4e2d\uff0c\u7d22\u5f15\u4e3a 0 \u3002","title":"\u7247\u5143\u7740\u8272\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_25","text":"\u4e00\u4e2a\u7eaf\u7ea2\u8272\u7684\u4e09\u89d2\u5f62\u770b\u8d77\u6765\u5e76\u4e0d\u662f\u5f88\u9177\u70ab\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u8bd5\u7740\u9177\u70ab\u4e00\u4e9b\u5462? \u6211\u4eec\u9488\u5bf9\u4e24\u4e2a\u7c7b\u578b\u7684\u7740\u8272\u5668\u5c1d\u8bd5\u505a\u4e00\u4e9b\u6539\u53d8\uff0c\u5b8c\u6210\u4e0a\u56fe\u7684\u6548\u679c\u3002\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u6bcf\u4e2a\u9876\u70b9\u8bbe\u7f6e\u5dee\u5f02\u5316\u7684\u989c\u8272\u3002\u9876\u70b9\u7740\u8272\u5668\u5e94\u8be5\u5305\u542b\u4e00\u4e2a\u989c\u8272\u6570\u7ec4\uff0c\u5c31\u50cf\u4f4d\u7f6e\u4fe1\u606f\u7684\u6570\u7ec4\u4e00\u6837: vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) ); C++ \u73b0\u5728\u6211\u4eec\u9700\u8981\u628a\u6bcf\u4e2a\u9876\u70b9\u7684\u989c\u8272\u4f20\u9012\u5230\u7247\u6bb5\u7740\u8272\u5668\u4e2d\uff0c\u4ece\u800c\u8f93\u51fa\u7ecf\u8fc7\u63d2\u503c\u540e\u7684\u989c\u8272\u4fe1\u606f\u5230 framebuffer \u4e2d\u3002\u4e3a\u9876\u70b9\u7740\u8272\u5668\u6dfb\u589e\u52a0\u8f93\u51fa\u989c\u8272\u652f\u6301\uff0c\u5728 main \u51fd\u6570\u4e2d\u5b9a\u4e49\u5982\u4e0b: layout(location = 0) out vec3 fragColor; void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex]; } C++ \u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u9700\u8981\u5c06\u7247\u6bb5\u7740\u8272\u5668\u7684\u8f93\u5165\u5339\u914d\u9876\u70b9\u7740\u8272\u5668\u7684\u8f93\u51fa: layout(location = 0) in vec3 fragColor; void main() { outColor = vec4(fragColor, 1.0); } C++ \u8f93\u5165\u7684\u53d8\u91cf\u4e0d\u4e00\u5b9a\u8981\u540c\u540d\uff0c\u5b83\u4eec\u5c06\u901a\u8fc7 location \u7d22\u5f15\u6307\u4ee4\u94fe\u63a5\u5728\u4e00\u8d77\u3002 main \u51fd\u6570\u4e2d\u4fee\u6539\u5c06\u8981\u8f93\u51fa\u7684\u989c\u8272alpha\u503c\u3002\u5c31\u50cf\u4e4b\u524d\u8ba8\u8bba\u7684\u4e00\u6837\uff0c fragColor \u5c06\u4f1a\u4e3a\u4e09\u4e2a\u9876\u70b9\u6240\u5c5e\u7684\u7247\u5143\u81ea\u52a8\u8fdb\u884c\u5185\u63d2\u503c\uff0c\u5f62\u6210\u5e73\u6ed1\u7684\u989c\u8272\u8fc7\u5ea6\u3002","title":"\u9876\u70b9\u989c\u8272\u7ec4"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_26","text":"\u5728\u9879\u76ee\u6839\u76ee\u5f55\u4e0b\u521b\u5efa\u4e00\u4e2a\u5b50\u76ee\u5f55\uff0c\u540d shaders \u7528\u4e8e\u5b58\u50a8\u9876\u70b9\u7740\u8272\u5668\u6587\u4ef6 shader.vert \u548c\u7247\u6bb5\u7740\u8272\u5668\u6587\u4ef6 shader.frag \u3002GLSL\u7740\u8272\u5668\u5b98\u65b9\u6ca1\u6709\u7ea6\u5b9a\u7684\u6269\u5c55\u540d\uff0c\u4f46\u662f\u8fd9\u4e24\u4e2a\u6269\u5c55\u540d\u662f\u6bd4\u8f83\u666e\u904d\u901a\u7528\u7684\u3002 shader.vert \u5185\u5bb9\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable out gl_PerVertex { vec4 gl_Position; }; layout(location = 0) out vec3 fragColor; vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex]; } C++ shader.frag \u6587\u4ef6\u5185\u5bb9\u5982\u4e0b: #version 450 #extension GL_ARB_separate_shader_objects : enable layout(location = 0) in vec3 fragColor; layout(location = 0) out vec4 outColor; void main() { outColor = vec4(fragColor, 1.0); } C++ \u73b0\u5728\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 glslangValidator \u7a0b\u5e8f\u7f16\u8bd1SPIR-V\u4e8c\u8fdb\u5236\u7801\u3002 \u521b\u5efa\u4e00\u4e2acompile.bat\u6279\u5904\u7406\u6587\u4ef6\uff0c\u5185\u5bb9\u5982\u4e0b: C:/VulkanSDK/1.0.17.0/Bin32/glslangValidator.exe -V shader.vert C:/VulkanSDK/1.0.17.0/Bin32/glslangValidator.exe -V shader.frag pause C++ \u5c06 glslangValidator.exe \u7684path\u8def\u5f84\u66ff\u6362\u4e3a\u4f60\u7684VulkanSDK\u5b89\u88c5\u8def\u5f84\uff0c\u7136\u540e\u53cc\u51fb\u8be5\u6587\u4ef6\u8fd0\u884c\u3002 \u8fd9\u4e24\u4e2a\u547d\u4ee4\u4f7f\u7528 -V \u6807\u5fd7\u8c03\u7528\u7f16\u8bd1\u5668\uff0c\u8be5\u6807\u5fd7\u544a\u8bc9\u5b83\u5c06GLSL\u6e90\u6587\u4ef6\u7f16\u8bd1\u4e3aSPIR-V\u5b57\u8282\u7801\u3002\u8fd0\u884c\u7f16\u8bd1\u811a\u672c\u65f6\uff0c\u4f1a\u770b\u5230\u521b\u5efa\u4e86\u4e24\u4e2aSPIR-V\u4e8c\u8fdb\u5236\u6587\u4ef6: vert.spv \u548c frag.spv \u3002\u8fd9\u4e9b\u540d\u79f0\u4ece\u7740\u8272\u5668\u4e2d\u6d3e\u751f\u800c\u6765\uff0c\u4f46\u662f\u53ef\u4ee5\u91cd\u547d\u540d\u4e3a\u4efb\u4f55\u540d\u5b57\u3002\u5728\u7f16\u8bd1\u7740\u8272\u5668\u65f6\uff0c\u53ef\u80fd\u6536\u5230\u5173\u4e8e\u67d0\u4e9b\u529f\u80fd\u7f3a\u5931\u7684\u8b66\u544a\u4fe1\u606f\uff0c\u5728\u8fd9\u91cc\u653e\u5fc3\u7684\u5ffd\u7565\u5b83\u4eec\u3002 \u5982\u679c\u7740\u8272\u5668\u5305\u542b\u8bed\u6cd5\u9519\u8bef\uff0c\u90a3\u4e48\u7f16\u8bd1\u5668\u4f1a\u6309\u7167\u60a8\u7684\u9884\u671f\u544a\u8bc9\u5177\u4f53\u7684\u884c\u53f7\u548c\u95ee\u9898\u3002\u5c1d\u8bd5\u7701\u7565\u4e00\u4e2a\u5206\u53f7\uff0c\u7136\u540e\u91cd\u65b0\u8fd0\u884c\u7f16\u8bd1\u811a\u672c\u3002\u8fd8\u53ef\u4ee5\u5c1d\u8bd5\u8fd0\u884c\u7f16\u8bd1\u5668\uff0c\u800c\u65e0\u9700\u4efb\u4f55\u53c2\u6570\u6765\u67e5\u770b\u5b83\u652f\u6301\u54ea\u4e9b\u7c7b\u578b\u7684\u6807\u5fd7\u3002\u4f8b\u5982\uff0c\u5b83\u53ef\u4ee5\u5c06\u5b57\u8282\u7801\u8f93\u51fa\u4e3a\u53ef\u8bfb\u7684\u683c\u5f0f\uff0c\u4ee5\u4fbf\u51c6\u786e\u4e86\u89e3\u7740\u8272\u5668\u6b63\u5728\u6267\u884c\u7684\u64cd\u4f5c\u4ee5\u53ca\u5728\u6b64\u9636\u6bb5\u5e94\u7528\u7684\u4efb\u4f55\u4f18\u5316\u3002","title":"\u7f16\u8bd1\u7740\u8272\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_27","text":"\u73b0\u5728\u6211\u4eec\u6709\u4e00\u79cd\u4ea7\u751fSPIR-V\u7740\u8272\u5668\u7684\u65b9\u6cd5\uff0c\u662f\u65f6\u5019\u52a0\u8f7d\u5b83\u4eec\u5230\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\uff0c\u4ee5\u4fbf\u5728\u9002\u5f53\u7684\u65f6\u5019\u63d2\u5165\u5230\u56fe\u5f62\u7ba1\u7ebf\u4e2d\u3002\u9996\u5148\u6211\u4eec\u7f16\u5199\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\u7528\u4ee5\u52a0\u8f7d\u4e8c\u8fdb\u5236\u6570\u636e\u6587\u4ef6\u3002 #include <fstream> ... static std::vector<char> readFile(const std::string& filename) { std::ifstream file(filename, std::ios::ate | std::ios::binary); if (!file.is_open()) { throw std::runtime_error(\"failed to open file!\"); } } C++ readFile \u51fd\u6570\u5c06\u4f1a\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6240\u6709\u7684\u4e8c\u8fdb\u5236\u6570\u636e\uff0c\u5e76\u7528 std::vector \u5b57\u8282\u96c6\u5408\u7ba1\u7406\u3002\u6211\u4eec\u4f7f\u7528\u4e24\u4e2a\u6807\u5fd7\u7528\u4ee5\u6253\u5f00\u6587\u4ef6: ate :\u5728\u6587\u4ef6\u672b\u5c3e\u5f00\u59cb\u8bfb\u53d6 binary :\u4ee5\u4e8c\u8fdb\u5236\u683c\u5f0f\u53bb\u8bfb\u6587\u4ef6(\u907f\u514d\u5b57\u7b26\u683c\u5f0f\u7684\u8f6c\u4e49) \u4ece\u6587\u4ef6\u672b\u5c3e\u5f00\u59cb\u8bfb\u53d6\u7684\u4f18\u70b9\u662f\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u8bfb\u53d6\u4f4d\u7f6e\u6765\u786e\u5b9a\u6587\u4ef6\u7684\u5927\u5c0f\u5e76\u5206\u914d\u7f13\u51b2\u533a: size_t fileSize = (size_t) file.tellg(); std::vector<char> buffer(fileSize); C++ \u4e4b\u540e\u6211\u4eec\u53ef\u4ee5\u8ffd\u6eaf\u5230\u6587\u4ef6\u7684\u5f00\u5934\uff0c\u540c\u65f6\u8bfb\u53d6\u6240\u6709\u7684\u5b57\u8282: file.seekg(0); file.read(buffer.data(), fileSize); C++ \u6700\u540e\u5173\u95ed\u6587\u4ef6\uff0c\u8fd4\u56de\u5b57\u8282\u6570\u636e: file.close(); return buffer; C++ \u6211\u4eec\u8c03\u7528\u51fd\u6570createGraphicsPipeline\u52a0\u8f7d\u4e24\u4e2a\u7740\u8272\u5668\u7684\u4e8c\u8fdb\u5236\u7801: void createGraphicsPipeline() { auto vertShaderCode = readFile(\"shaders/vert.spv\"); auto fragShaderCode = readFile(\"shaders/frag.spv\"); } C++ \u786e\u4fdd\u7740\u8272\u5668\u6b63\u786e\u52a0\u8f7d\uff0c\u5e76\u6253\u5370\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u662f\u5426\u4e0e\u6587\u4ef6\u5b9e\u9645\u5927\u5c0f\u4e00\u81f4\u3002","title":"\u52a0\u8f7d\u7740\u8272\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_28","text":"\u5728\u5c06\u4ee3\u7801\u4f20\u9012\u7ed9\u6e32\u67d3\u7ba1\u7ebf\u4e4b\u524d\uff0c\u6211\u4eec\u5fc5\u987b\u5c06\u5176\u5c01\u88c5\u5230 VkShaderModule \u5bf9\u8c61\u4e2d\u3002\u8ba9\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570 createShaderModule \u5b9e\u73b0\u8be5\u903b\u8f91\u3002 VkShaderModule createShaderModule(const std::vector<char>& code) { } C++ \u8be5\u51fd\u6570\u9700\u8981\u5b57\u8282\u7801\u7684\u7f13\u51b2\u533a\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u901a\u8fc7\u7f13\u51b2\u533a\u521b\u5efa VkShaderModule \u3002 \u521b\u5efashader module\u662f\u6bd4\u8f83\u7b80\u5355\u7684\uff0c\u6211\u4eec\u4ec5\u4ec5\u9700\u8981\u6307\u5b9a\u4e8c\u8fdb\u5236\u7801\u7f13\u51b2\u533a\u7684\u6307\u9488\u548c\u5b83\u7684\u5177\u4f53\u957f\u5ea6\u3002\u8fd9\u4e9b\u4fe1\u606f\u88ab\u586b\u5145\u5728 VkShaderModuleCreateInfo \u7ed3\u6784\u4f53\u4e2d\u3002\u9700\u8981\u7559\u610f\u7684\u662f\u5b57\u8282\u7801\u7684\u5927\u5c0f\u662f\u4ee5\u5b57\u8282\u6307\u5b9a\u7684\uff0c\u4f46\u662f\u5b57\u8282\u7801\u6307\u9488\u662f\u4e00\u4e2a uint32_t \u7c7b\u578b\u7684\u6307\u9488\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a char \u6307\u9488\u3002\u6240\u4ee5\u6211\u4eec\u4f7f\u7528 reinterpret_cast \u8fdb\u884c\u8f6c\u6362\u6307\u9488\u3002\u5982\u4e0b\u6240\u793a\uff0c\u5f53\u9700\u8981\u8f6c\u6362\u65f6\uff0c\u8fd8\u9700\u8981\u786e\u4fdd\u6570\u636e\u6ee1\u8db3 uint32_t \u7684\u5bf9\u9f50\u8981\u6c42\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u6570\u636e\u5b58\u50a8\u5728 std::vector \u4e2d\uff0c\u9ed8\u8ba4\u5206\u914d\u5668\u5df2\u7ecf\u786e\u4fdd\u6570\u636e\u6ee1\u8db3\u6700\u5dee\u60c5\u51b5\u4e0b\u7684\u5bf9\u9f50\u8981\u6c42\u3002 VkShaderModuleCreateInfo createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; createInfo.codeSize = code.size(); createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data()); C++ \u8c03\u7528 vkCreateShaderMoudle \u521b\u5efa VkShaderModule : VkShaderModule shaderModule; if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) { throw std::runtime_error(\"failed to create shader module!\"); } C++ \u53c2\u6570\u4e0e\u4e4b\u524d\u521b\u5efa\u5bf9\u8c61\u529f\u80fd\u7c7b\u4f3c:\u903b\u8f91\u8bbe\u5907\uff0c\u521b\u5efa\u5bf9\u8c61\u4fe1\u606f\u7ed3\u6784\u4f53\u7684\u6307\u9488\uff0c\u81ea\u5b9a\u4e49\u5206\u914d\u5668\u548c\u4fdd\u5b58\u7ed3\u679c\u7684\u53e5\u67c4\u53d8\u91cf\u3002\u5728shader module\u521b\u5efa\u5b8c\u6bd5\u540e\uff0c\u53ef\u4ee5\u5bf9\u4e8c\u8fdb\u5236\u7801\u7684\u7f13\u51b2\u533a\u8fdb\u884c\u7acb\u5373\u7684\u91ca\u653e\u3002\u6700\u540e\u4e0d\u8981\u5fd8\u8bb0\u8fd4\u56de\u521b\u5efa\u597d\u7684shader module\u3002 return shaderModule; C++ shader module\u5bf9\u8c61\u4ec5\u4ec5\u5728\u6e32\u67d3\u7ba1\u7ebf\u5904\u7406\u8fc7\u7a0b\u4e2d\u9700\u8981\uff0c\u6240\u4ee5\u6211\u4eec\u4f1a\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u5b9a\u4e49\u672c\u5730\u53d8\u91cf\u4fdd\u5b58\u5b83\u4eec\uff0c\u800c\u4e0d\u662f\u5b9a\u4e49\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709\u5b83\u4eec\u7684\u53e5\u67c4: VkShaderModule vertShaderModule; VkShaderModule fragShaderModule; C++ \u8c03\u7528\u52a0\u8f7dshader module\u7684\u8f85\u52a9\u51fd\u6570: vertShaderModule = createShaderModule(vertShaderCode); fragShaderModule = createShaderModule(fragShaderCode); C++ \u5728\u56fe\u5f62\u7ba1\u7ebf\u521b\u5efa\u5b8c\u6210\u4e14 createGraphicsPipeline \u51fd\u6570\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u5b83\u4eec\u5e94\u8be5\u88ab\u6e05\u7406\u6389\uff0c\u6240\u4ee5\u5728\u8be5\u51fd\u6570\u540e\u5220\u9664\u5b83\u4eec: ... vkDestroyShaderModule(device, fragShaderModule, nullptr); vkDestroyShaderModule(device, vertShaderModule, nullptr); } C++","title":"\u521b\u5efa\u7740\u8272\u5668\u6a21\u578b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_29","text":"VkShaderModule \u5bf9\u8c61\u53ea\u662f\u5b57\u8282\u7801\u7f13\u51b2\u533a\u7684\u4e00\u4e2a\u5305\u88c5\u5bb9\u5668\u3002\u7740\u8272\u5668\u5e76\u6ca1\u6709\u5f7c\u6b64\u94fe\u63a5\uff0c\u751a\u81f3\u6ca1\u6709\u7ed9\u51fa\u76ee\u7684\u3002\u901a\u8fc7 VkPipelineShaderStageCreateInfo \u7ed3\u6784\u5c06\u7740\u8272\u5668\u6a21\u5757\u5206\u914d\u5230\u7ba1\u7ebf\u4e2d\u7684\u9876\u70b9\u6216\u8005\u7247\u6bb5\u7740\u8272\u5668\u9636\u6bb5\u3002VkPipelineShaderStageCreateInfo\u7ed3\u6784\u4f53\u662f\u5b9e\u9645\u7ba1\u7ebf\u521b\u5efa\u8fc7\u7a0b\u7684\u4e00\u90e8\u5206\u3002 \u6211\u4eec\u9996\u5148\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u586b\u5199\u9876\u70b9\u7740\u8272\u5668\u7ed3\u6784\u4f53\u3002 VkPipelineShaderStageCreateInfo vertShaderStageInfo = {}; vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; C++ \u9664\u4e86\u5f3a\u5236\u7684 sType \u6210\u5458\u5916\uff0c\u7b2c\u4e00\u4e2a\u9700\u8981\u544a\u77e5Vulkan\u5c06\u5728\u54ea\u4e2a\u6d41\u6c34\u7ebf\u9636\u6bb5\u4f7f\u7528\u7740\u8272\u5668\u3002\u5728\u4e0a\u4e00\u4e2a\u7ae0\u8282\u7684\u6bcf\u4e2a\u53ef\u7f16\u7a0b\u9636\u6bb5\u90fd\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u679a\u4e3e\u503c\u3002 vertShaderStageInfo.module = vertShaderModule; vertShaderStageInfo.pName = \"main\"; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u6210\u5458\u6307\u5b9a\u5305\u542b\u4ee3\u7801\u7684\u7740\u8272\u5668\u6a21\u5757\u548c\u8c03\u7528\u7684\u4e3b\u51fd\u6570\u3002\u8fd9\u610f\u5473\u7740\u53ef\u4ee5\u5c06\u591a\u4e2a\u7247\u6bb5\u7740\u8272\u5668\u7ec4\u5408\u5230\u5355\u4e2a\u7740\u8272\u5668\u6a21\u5757\u4e2d\uff0c\u5e76\u4f7f\u7528\u4e0d\u540c\u7684\u5165\u53e3\u70b9\u6765\u533a\u5206\u5b83\u4eec\u7684\u884c\u4e3a\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u575a\u6301\u4f7f\u7528\u6807\u51c6 main \u51fd\u6570\u4f5c\u4e3a\u5165\u53e3\u3002 \u8fd8\u6709\u4e00\u4e2a\u53ef\u9009\u6210\u5458\uff0c pSpecializationInfo ,\u5728\u8fd9\u91cc\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u5b83\uff0c\u4f46\u662f\u503c\u5f97\u8ba8\u8bba\u4e00\u4e0b\u3002\u5b83\u5141\u8bb8\u4e3a\u7740\u8272\u5668\u6307\u5b9a\u5e38\u91cf\u503c\u3002\u4f7f\u7528\u5355\u4e2a\u7740\u8272\u5668\u6a21\u5757\uff0c\u901a\u8fc7\u4e3a\u5176\u4e2d\u4f7f\u7528\u4e0d\u540c\u7684\u5e38\u91cf\u503c\uff0c\u53ef\u4ee5\u5728\u6d41\u6c34\u7ebf\u521b\u5efa\u65f6\u5bf9\u884c\u4e3a\u8fdb\u884c\u914d\u7f6e\u3002\u8fd9\u6bd4\u5728\u6e32\u67d3\u65f6\u4f7f\u7528\u53d8\u91cf\u914d\u7f6e\u7740\u8272\u5668\u66f4\u6709\u6548\u7387\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u53ef\u4ee5\u8fdb\u884c\u4f18\u5316\uff0c\u4f8b\u5982\u6d88\u9664 if \u503c\u5224\u65ad\u7684\u8bed\u53e5\u3002\u5982\u679c\u6ca1\u6709\u8fd9\u6837\u7684\u5e38\u91cf\uff0c\u53ef\u4ee5\u5c06\u6210\u5458\u8bbe\u7f6e\u4e3a nullptr \uff0c\u6211\u4eec\u7684struct\u7ed3\u6784\u4f53\u521d\u59cb\u5316\u81ea\u52a8\u8fdb\u884c\u3002 \u4fee\u6539\u7ed3\u6784\u4f53\u6ee1\u8db3\u7247\u6bb5\u7740\u8272\u5668\u7684\u9700\u8981: VkPipelineShaderStageCreateInfo fragShaderStageInfo = {}; fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; fragShaderStageInfo.module = fragShaderModule; fragShaderStageInfo.pName = \"main\"; C++ \u5b8c\u6210\u4e24\u4e2a\u7ed3\u6784\u4f53\u7684\u521b\u5efa\uff0c\u5e76\u901a\u8fc7\u6570\u7ec4\u4fdd\u5b58\uff0c\u8fd9\u90e8\u5206\u5f15\u7528\u5c06\u4f1a\u5728\u5b9e\u9645\u7684\u7ba1\u7ebf\u521b\u5efa\u5f00\u59cb\u3002 VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo}; C++ \u5230\u6b64\u4e3a\u6b62\uff0c\u5c31\u662f\u6240\u6709\u5173\u4e8e\u53ef\u7f16\u7a0b\u7ba1\u7ebf\u9636\u6bb5\u7684\u903b\u8f91\u3002\u5728 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u4f1a\u770b\u4e00\u4e0b\u56fa\u5b9a\u7ba1\u7ebf\u5404\u4e2a\u9636\u6bb5\u3002","title":"\u7740\u8272\u5668\u9636\u6bb5\u521b\u5efa"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_8","text":"Vulkan \u56fa\u6709\u529f\u80fd \uff0c\u65e9\u8d77\u7684\u56fe\u5f62API\u5728\u56fe\u5f62\u6e32\u67d3\u7ba1\u7ebf\u7684\u8bb8\u591a\u9636\u6bb5\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u7684\u72b6\u6001\u3002\u5728 Vulkan \u4e2d\uff0c\u4ece viewport \u7684\u5927\u5c0f\u5230\u6df7\u8272\u51fd\u6570\uff0c\u9700\u8981\u51e1\u4e8b\u505a\u5230\u4eb2\u5386\u4eb2\u4e3a\u3002\u5728\u672c\u7ae0\u8282\u4e2d\u6211\u4eec\u4f1a\u586b\u5145\u6709\u5173\u56fa\u6709\u529f\u80fd\u64cd\u4f5c\u7684\u6240\u6709\u7ed3\u6784\u4f53\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u9876\u70b9\u8f93\u5165 2 \u8f93\u5165\u7ec4\u4ef6 3 \u89c6\u7a97\u548c\u88c1\u526a 4 \u5149\u6805\u5316 5 \u91cd\u91c7\u6837 6 \u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5 7 \u989c\u8272\u6df7\u5408 8 \u52a8\u6001\u4fee\u6539 9 \u7ba1\u9053\u5e03\u5c40 10 \u7ed3\u8bba","title":"Vulkan \u56fa\u6709\u529f\u80fd"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_30","text":"VkPipelineVertexInputStateCreateInfo \u7ed3\u6784\u4f53\u63cf\u8ff0\u4e86\u9876\u70b9\u6570\u636e\u7684\u683c\u5f0f\uff0c\u8be5\u7ed3\u6784\u4f53\u6570\u636e\u4f20\u9012\u5230 vertex shader \u4e2d\u3002\u5b83\u4ee5\u4e24\u79cd\u65b9\u5f0f\u8fdb\u884c\u63cf\u8ff0: Bindings :\u6839\u636e\u6570\u636e\u7684\u95f4\u9699\uff0c\u786e\u5b9a\u6570\u636e\u662f\u6bcf\u4e2a\u9876\u70b9\u6216\u8005\u662f\u6bcf\u4e2ainstance( instancing ) Attribute \u63cf\u8ff0:\u63cf\u8ff0\u5c06\u8981\u8fdb\u884c\u7ed1\u5b9a\u53ca\u52a0\u8f7d\u5c5e\u6027\u7684\u9876\u70b9\u7740\u8272\u5668\u4e2d\u7684\u76f8\u5173\u5c5e\u6027\u7c7b\u578b\u3002 \u56e0\u4e3a\u6211\u4eec\u5c06\u9876\u70b9\u6570\u636e\u786c\u7f16\u7801\u5230 vertex shader \u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u5c06\u8981\u586b\u5145\u7684\u7ed3\u6784\u4f53\u6ca1\u6709\u9876\u70b9\u6570\u636e\u53bb\u52a0\u8f7d\u3002\u6211\u4eec\u5c06\u4f1a\u5728 vertex buffer \u7ae0\u8282\u4e2d\u56de\u6765\u64cd\u4f5c\u3002 VkPipelineVertexInputStateCreateInfo vertexInputInfo = {}; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.pVertexBindingDescriptions = nullptr; // Optional vertexInputInfo.vertexAttributeDescriptionCount = 0; vertexInputInfo.pVertexAttributeDescriptions = nullptr; // Optional C++ pVertexBindingDescriptions \u548c pVertexAttributeDescriptions \u6210\u5458\u6307\u5411\u7ed3\u6784\u4f53\u6570\u7ec4\uff0c\u7528\u4e8e\u8fdb\u4e00\u6b65\u63cf\u8ff0\u52a0\u8f7d\u7684\u9876\u70b9\u6570\u636e\u4fe1\u606f\u3002\u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u7684 shaderStages \u6570\u7ec4\u540e\u6dfb\u52a0\u8be5\u7ed3\u6784\u4f53\u3002","title":"\u9876\u70b9\u8f93\u5165"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_31","text":"VkPipelineInputAssemblyStateCreateInfo \u7ed3\u6784\u4f53\u63cf\u8ff0\u4e24\u4ef6\u4e8b\u60c5:\u9876\u70b9\u6570\u636e\u4ee5\u4ec0\u4e48\u7c7b\u578b\u7684\u51e0\u4f55\u56fe\u5143\u62d3\u6251\u8fdb\u884c\u7ed8\u5236\u53ca\u662f\u5426\u542f\u7528\u9876\u70b9\u7d22\u91cd\u65b0\u5f00\u59cb\u56fe\u5143\u3002\u56fe\u5143\u7684\u62d3\u6251\u7ed3\u6784\u7c7b\u578b topology \u679a\u4e3e\u503c\u5982\u4e0b: VK_PRIMITIVE_TOPOLOGY_POINT_LIST : \u9876\u70b9\u5230\u70b9 VK_PRIMITIVE_TOPOLOGY_LINE_LIST : \u4e24\u70b9\u6210\u7ebf\uff0c\u9876\u70b9\u4e0d\u5171\u7528 VK_PRIMITIVE_TOPOLOGY_LINE_STRIP : \u4e24\u70b9\u6210\u7ebf\uff0c\u6bcf\u4e2a\u7ebf\u6bb5\u7684\u7ed3\u675f\u9876\u70b9\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u7ebf\u6bb5\u7684\u5f00\u59cb\u9876\u70b9 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST : \u4e09\u70b9\u6210\u9762\uff0c\u9876\u70b9\u4e0d\u5171\u7528 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP : \u6bcf\u4e2a\u4f46\u6559\u8bad\u7684\u7b2c\u4e8c\u4e2a\u3001\u7b2c\u4e09\u4e2a\u9876\u70b9\u90fd\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u4e09\u89d2\u5f62\u7684\u524d\u4e24\u4e2a\u9876\u70b9 \u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u9876\u70b9\u6570\u636e\u6309\u7167\u7f13\u51b2\u533a\u4e2d\u7684\u5e8f\u5217\u4f5c\u4e3a\u7d22\u5f15\uff0c\u4f46\u662f\u4e5f\u53ef\u4ee5\u901a\u8fc7element buffer\u7f13\u51b2\u533a\u81ea\u884c\u6307\u5b9a\u9876\u70b9\u6570\u636e\u7684\u7d22\u5f15\u3002\u901a\u8fc7\u590d\u7528\u9876\u70b9\u6570\u636e\u63d0\u5347\u6027\u80fd\u3002\u5982\u679c\u8bbe\u7f6e primitiveRestartEnable \u6210\u5458\u4e3a VK_TRUE \uff0c\u53ef\u4ee5\u901a\u8fc7 0xFFFF \u6216\u8005 0xFFFFFFFF \u4f5c\u4e3a\u7279\u6b8a\u7d22\u5f15\u6765\u5206\u89e3\u7ebf\u548c\u4e09\u89d2\u5f62\u5728 _STRIP \u6a21\u5f0f\u4e0b\u7684\u56fe\u5143\u62d3\u6251\u7ed3\u6784\u3002 \u901a\u8fc7\u672c\u6559\u7a0b\u7ed8\u5236\u4e09\u89d2\u5f62\uff0c\u6240\u4ee5\u6211\u4eec\u575a\u6301\u6309\u7167\u5982\u4e0b\u683c\u5f0f\u586b\u5145\u6570\u636e\u7ed3\u6784: VkPipelineInputAssemblyStateCreateInfo inputAssembly = {}; inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; inputAssembly.primitiveRestartEnable = VK_FALSE; C++","title":"\u8f93\u5165\u7ec4\u4ef6"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_32","text":"Viewport\u7528\u4e8e\u63cf\u8ff0framebuffer\u4f5c\u4e3a\u6e32\u67d3\u8f93\u51fa\u7ed3\u679c\u76ee\u6807\u533a\u57df\u3002\u5b83\u7684\u6570\u503c\u5728\u672c\u6559\u7a0b\u4e2d\u603b\u662f\u8bbe\u7f6e\u5728 (0, 0) \u548c (width, height) \u3002 VkViewport viewport = {}; viewport.x = 0.0f; viewport.y = 0.0f; viewport.width = (float) swapChainExtent.width; viewport.height = (float) swapChainExtent.height; viewport.minDepth = 0.0f; viewport.maxDepth = 1.0f; C++ \u8bb0\u5f97\u4ea4\u6362\u94fe\u548c\u5b83\u7684images\u56fe\u50cf\u5927\u5c0f WIDTH \u548c HEIGHT \u4f1a\u6839\u636e\u4e0d\u540c\u7684\u7a97\u4f53\u800c\u4e0d\u540c\u3002\u4ea4\u6362\u94fe\u56fe\u50cf\u5c06\u4f1a\u5728\u5e27\u7f13\u51b2\u533aframebuffers\u4f7f\u7528\uff0c\u6240\u4ee5\u6211\u4eec\u5e94\u8be5\u575a\u6301\u5b83\u4eec\u7684\u5927\u5c0f\u3002 minDepth \u548c maxDepth \u6570\u503c\u6307\u5b9aframebuffer\u4e2d\u6df1\u5ea6\u7684\u8303\u56f4\u3002\u8fd9\u4e9b\u6570\u503c\u5fc5\u987b\u6536\u655b\u5728 [0.0f, 1.0f] \u533a\u95f4\u51b2\uff0c\u4f46\u662f minDepth \u53ef\u80fd\u4f1a\u5927\u4e8e maxDepth \u3002\u5982\u679c\u4f60\u4e0d\u505a\u4efb\u4f55\u6307\u5b9a\uff0c\u5efa\u8bae\u4f7f\u7528\u6807\u51c6\u7684\u6570\u503c 0.0 f\u548c 1.0f \u3002 viewports \u5b9a\u4e49\u4e86image\u56fe\u50cf\u5230framebuffer\u5e27\u7f13\u51b2\u533a\u7684\u8f6c\u6362\u5173\u7cfb\uff0c\u88c1\u526a\u77e9\u5f62\u5b9a\u4e49\u4e86\u54ea\u4e9b\u533a\u57df\u7684\u50cf\u7d20\u88ab\u5b58\u50a8\u3002\u4efb\u4f55\u5728\u88c1\u526a\u5de8\u578b\u5916\u7684\u50cf\u7d20\u90fd\u4f1a\u5728\u5149\u6805\u5316\u9636\u6bb5\u4e22\u5f03\u3002\u5b83\u4eec\u7684\u529f\u80fd\u66f4\u50cf\u8fc7\u6ee4\u5668\u800c\u4e0d\u662f\u5b9a\u4e49\u8f6c\u6362\u5173\u7cfb\u3002\u8fd9\u4e2a\u533a\u522b\u5982\u4e0b\u56fe\u6240\u793a\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5bf9\u4e8e\u56fe\u50cf\u6bd4 viewport \u5c3a\u5bf8\u5927\u7684\u60c5\u5f62\uff0c\u5de6\u4fa7\u7684\u88c1\u526a\u77e9\u5f62\u53ea\u662f\u4f17\u591a\u53ef\u80fd\u7684\u4e00\u4e2a\u8868\u73b0\u3002 \u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u9700\u8981\u5c06\u56fe\u50cf\u7ed8\u5236\u5230\u5b8c\u6574\u7684\u5e27\u7f13\u51b2\u533a framebuffer \u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u5b9a\u4e49\u88c1\u526a\u77e9\u5f62\u8986\u76d6\u5230\u6574\u4f53\u56fe\u50cf: VkRect2D scissor = {}; scissor.offset = {0, 0}; scissor.extent = swapChainExtent; C++ viewport\u548c\u88c1\u526a\u77e9\u5f62\u9700\u8981\u501f\u52a9 VkPipelineViewportStateCreateInfo \u7ed3\u6784\u4f53\u8054\u5408\u4f7f\u7528\u3002\u53ef\u4ee5\u4f7f\u7528\u591a viewports \u548c\u88c1\u526a\u77e9\u5f62\u5728\u4e00\u4e9b\u56fe\u5f62\u5361\uff0c\u901a\u8fc7\u6570\u7ec4\u5f15\u7528\u3002\u4f7f\u7528\u8be5\u7279\u6027\u9700\u8981GPU\u652f\u6301\u8be5\u529f\u80fd\uff0c\u5177\u4f53\u770b\u903b\u8f91\u8bbe\u5907\u7684\u521b\u5efa\u3002 VkPipelineViewportStateCreateInfo viewportState = {}; viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; viewportState.viewportCount = 1; viewportState.pViewports = &viewport; viewportState.scissorCount = 1; viewportState.pScissors = &scissor; C++","title":"\u89c6\u7a97\u548c\u88c1\u526a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_33","text":"\u5149\u6805\u5316\u901a\u8fc7\u9876\u70b9\u7740\u8272\u5668\u53ca\u5177\u4f53\u7684\u51e0\u4f55\u7b97\u6cd5\u5c06\u9876\u70b9\u8fdb\u884c\u5851\u5f62\uff0c\u5e76\u5c06\u56fe\u5f62\u4f20\u9012\u5230\u7247\u6bb5\u7740\u8272\u5668\u8fdb\u884c\u7740\u8272\u5de5\u4f5c\u3002\u5b83\u4e5f\u4f1a\u6267\u884c\u6df1\u5ea6\u6d4b\u8bd5 depth testing \u3001\u9762\u88c1\u5207 face culling \u548c\u88c1\u526a\u6d4b\u8bd5\uff0c\u5b83\u53ef\u4ee5\u5bf9\u8f93\u51fa\u7684\u7247\u5143\u8fdb\u884c\u914d\u7f6e\uff0c\u51b3\u5b9a\u662f\u5426\u8f93\u51fa\u6574\u4e2a\u56fe\u5143\u62d3\u6251\u6216\u8005\u662f\u8fb9\u6846(\u7ebf\u6846\u6e32\u67d3)\u3002\u6240\u6709\u7684\u914d\u7f6e\u901a\u8fc7 VkPipelineRasterizationStateCreateInfo \u7ed3\u6784\u4f53\u5b9a\u4e49\u3002 VkPipelineRasterizationStateCreateInfo rasterizer = {}; rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; rasterizer.depthClampEnable = VK_FALSE; C++ \u5b83\u7684 depthClampEnable \u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u8d85\u8fc7\u8fdc\u8fd1\u88c1\u526a\u9762\u7684\u7247\u5143\u4f1a\u8fdb\u884c\u6536\u655b\uff0c\u800c\u4e0d\u662f\u4e22\u5f03\u5b83\u4eec\u3002\u5b83\u5728\u7279\u6b8a\u7684\u60c5\u51b5\u4e0b\u6bd4\u8f83\u6709\u7528\uff0c\u50cf\u9634\u5f71\u8d34\u56fe\u3002\u4f7f\u7528\u8be5\u529f\u80fd\u9700\u8981\u5f97\u5230 GPU \u7684\u652f\u6301\u3002 rasterizer.rasterizerDiscardEnable = VK_FALSE; C++ \u5982\u679c rasterizerDiscardEnable \u8bbe\u7f6e\u4e3a VK_TRUE \uff0c\u90a3\u4e48\u51e0\u4f55\u56fe\u5143\u6c38\u8fdc\u4e0d\u4f1a\u4f20\u9012\u5230\u5149\u6805\u5316\u9636\u6bb5\u3002\u8fd9\u662f\u57fa\u672c\u7684\u7981\u6b62\u4efb\u4f55\u8f93\u51fa\u5230framebuffer\u5e27\u7f13\u51b2\u533a\u7684\u65b9\u6cd5\u3002 rasterizer.polygonMode = VK_POLYGON_MODE_FILL; C++ polygonMode \u51b3\u5b9a\u51e0\u4f55\u4ea7\u751f\u56fe\u7247\u7684\u5185\u5bb9\u3002\u4e0b\u5217\u6709\u6548\u6a21\u5f0f: VK_POLYGON_MODE_FILL : \u591a\u8fb9\u5f62\u533a\u57df\u586b\u5145 VK_POLYGON_MODE_LINE : \u591a\u8fb9\u5f62\u8fb9\u7f18\u7ebf\u6846\u7ed8\u5236 VK_POLYGON_MODE_POINT : \u591a\u8fb9\u5f62\u9876\u70b9\u4f5c\u4e3a\u63cf\u70b9\u7ed8\u5236 \u4f7f\u7528\u4efb\u4f55\u6a21\u5f0f\u586b\u5145\u9700\u8981\u5f00\u542fGPU\u529f\u80fd\u3002 rasterizer.lineWidth = 1.0f; C++ lineWidth \u6210\u5458\u662f\u76f4\u63a5\u586b\u5145\u7684\uff0c\u6839\u636e\u7247\u5143\u7684\u6570\u91cf\u63cf\u8ff0\u7ebf\u7684\u5bbd\u5ea6\u3002\u6700\u5927\u7684\u7ebf\u5bbd\u652f\u6301\u53d6\u51b3\u4e8e\u786c\u4ef6\uff0c\u4efb\u4f55\u5927\u4e8e 1.0 \u7684\u7ebf\u5bbd\u9700\u8981\u5f00\u542fGPU\u7684 wideLines \u7279\u6027\u652f\u6301\u3002 rasterizer.cullMode = VK_CULL_MODE_BACK_BIT; rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; C++ cullMode \u53d8\u91cf\u7528\u4e8e\u51b3\u5b9a\u9762\u88c1\u526a\u7684\u7c7b\u578b\u65b9\u5f0f\u3002\u53ef\u4ee5\u7981\u6b62 culling \uff0c\u88c1\u526a front faces \uff0c cull back faces \u6216\u8005\u5168\u90e8\u3002 frontFace \u7528\u4e8e\u63cf\u8ff0\u4f5c\u4e3a front-facing \u9762\u7684\u9876\u70b9\u7684\u987a\u5e8f\uff0c\u53ef\u4ee5\u662f\u987a\u65f6\u9488\u4e5f\u53ef\u4ee5\u662f\u9006\u65f6\u9488\u3002 rasterizer.depthBiasEnable = VK_FALSE; rasterizer.depthBiasConstantFactor = 0.0f; // Optional rasterizer.depthBiasClamp = 0.0f; // Optional rasterizer.depthBiasSlopeFactor = 0.0f; // Optional C++ \u5149\u6805\u5316\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u5e38\u91cf\u6216\u8005\u57fa\u4e8e\u7247\u5143\u7684\u659c\u7387\u6765\u66f4\u6539\u6df1\u5ea6\u503c\u3002\u4e00\u4e9b\u65f6\u5019\u5bf9\u4e8e\u9634\u5f71\u8d34\u56fe\u662f\u6709\u7528\u7684\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u4f1a\u5728\u7ae0\u8282\u4e2d\u4f7f\u7528\uff0c\u8bbe\u7f6e depthBiasEnable \u4e3a VK_FALSE \u3002","title":"\u5149\u6805\u5316"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_34","text":"VkPipelineMultisampleStateCreateInfo \u7ed3\u6784\u4f53\u7528\u4e8e\u914d\u7f6e\u591a\u91cd\u91c7\u6837\u3002\u6240\u8c13\u591a\u91cd\u91c7\u6837\u662f\u6297\u952f\u9f7f anti-aliasing \u7684\u4e00\u79cd\u5b9e\u73b0\u3002\u5b83\u901a\u8fc7\u7ec4\u5408\u591a\u4e2a\u591a\u8fb9\u5f62\u7684\u7247\u6bb5\u7740\u8272\u5668\u7ed3\u679c\uff0c\u5149\u6805\u5316\u5230\u540c\u4e00\u4e2a\u50cf\u7d20\u3002\u8fd9\u4e3b\u8981\u53d1\u751f\u5728\u8fb9\u7f18\uff0c\u8fd9\u4e5f\u662f\u6700\u5f15\u4eba\u6ce8\u76ee\u7684\u952f\u9f7f\u51fa\u73b0\u7684\u5730\u65b9\u3002\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u591a\u8fb9\u5f62\u6620\u5c04\u5230\u50cf\u7d20\u662f\u4e0d\u9700\u8981\u591a\u6b21\u8fd0\u884c\u7247\u6bb5\u7740\u8272\u5668\u8fdb\u884c\u91c7\u6837\u7684\uff0c\u76f8\u6bd4\u9ad8\u5206\u8fa8\u7387\u6765\u8bf4\uff0c\u5b83\u4f1a\u82b1\u8d39\u8f83\u4f4e\u7684\u5f00\u9500\u3002\u5f00\u542f\u8be5\u529f\u80fd\u9700\u8981GPU\u652f\u6301\u3002 VkPipelineMultisampleStateCreateInfo multisampling = {}; multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; multisampling.sampleShadingEnable = VK_FALSE; multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT; multisampling.minSampleShading = 1.0f; // Optional multisampling.pSampleMask = nullptr; // Optional multisampling.alphaToCoverageEnable = VK_FALSE; // Optional multisampling.alphaToOneEnable = VK_FALSE; // Optional C++ \u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u591a\u91cd\u91c7\u6837\uff0c\u4f46\u662f\u53ef\u4ee5\u968f\u610f\u7684\u5c1d\u8bd5\uff0c\u5177\u4f53\u7684\u53c2\u6570\u8bf7\u53c2\u9605\u89c4\u8303\u3002","title":"\u91cd\u91c7\u6837"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_35","text":"\u5982\u679c\u4f7f\u7528depth \u6216\u8005 stencil\u7f13\u51b2\u533a\uff0c\u9700\u8981\u4f7f\u7528 VkPipelineDepthStencilStateCreateInfo \u914d\u7f6e\u3002\u6211\u4eec\u73b0\u5728\u4e0d\u9700\u8981\u4f7f\u7528\uff0c\u6240\u4ee5\u7b80\u5355\u7684\u4f20\u9012 nullptr \uff0c\u5173\u4e8e\u8fd9\u90e8\u5206\u4f1a\u4e13\u95e8\u5728\u6df1\u5ea6\u7f13\u51b2\u533a\u7ae0\u8282\u4e2d\u8ba8\u8bba\u3002","title":"\u6df1\u5ea6\u548c\u6a21\u677f\u6d4b\u8bd5"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_36","text":"\u7247\u6bb5\u7740\u8272\u5668\u8f93\u51fa\u5177\u4f53\u7684\u989c\u8272\uff0c\u5b83\u9700\u8981\u4e0e\u5e27\u7f13\u51b2\u533a framebuffer \u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\u3002\u8fd9\u4e2a\u8f6c\u6362\u7684\u8fc7\u7a0b\u6210\u4e3a\u6df7\u8272\uff0c\u5b83\u6709\u4e24\u79cd\u65b9\u5f0f: \u5c06old\u548cnew\u989c\u8272\u8fdb\u884c\u6df7\u5408\u4ea7\u51fa\u4e00\u4e2a\u6700\u7ec8\u7684\u989c\u8272 \u4f7f\u7528\u6309\u4f4d\u64cd\u4f5c\u6df7\u5408old\u548cnew\u989c\u8272\u7684\u503c \u6709\u4e24\u4e2a\u7ed3\u6784\u4f53\u7528\u4e8e\u914d\u7f6e\u989c\u8272\u6df7\u5408\u3002\u7b2c\u4e00\u4e2a\u7ed3\u6784\u4f53 VkPipelineColorBlendAttachmentState \u5305\u62ec\u4e86\u6bcf\u4e2a\u9644\u52a0\u5230\u5e27\u7f13\u51b2\u533a\u7684\u914d\u7f6e\u3002\u7b2c\u4e8c\u4e2a\u7ed3\u6784\u4f53 VkPipelineColorBlendStateCreateInfo \u5305\u542b\u4e86\u5168\u5c40\u6df7\u8272\u7684\u8bbe\u7f6e\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u4ec5\u4f7f\u7528\u7b2c\u4e00\u79cd\u65b9\u5f0f: VkPipelineColorBlendAttachmentState colorBlendAttachment = {}; colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; colorBlendAttachment.blendEnable = VK_FALSE; colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; // Optional colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; // Optional colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; // Optional colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; // Optional C++ \u8fd9\u79cd\u9488\u5bf9\u6bcf\u4e2a\u5e27\u7f13\u51b2\u533a\u914d\u7f6e\u6df7\u8272\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528\u5982\u4e0b\u4f2a\u4ee3\u7801\u8fdb\u884c\u8bf4\u660e: if (blendEnable) { finalColor.rgb = (srcColorBlendFactor * newColor.rgb) <colorBlendOp> (dstColorBlendFactor * oldColor.rgb); finalColor.a = (srcAlphaBlendFactor * newColor.a) <alphaBlendOp> (dstAlphaBlendFactor * oldColor.a); } else { finalColor = newColor; } finalColor = finalColor & colorWriteMask; C++ \u5982\u679c blendEnable \u8bbe\u7f6e\u4e3a VK_FALSE ,\u90a3\u4e48\u4ece\u7247\u6bb5\u7740\u8272\u5668\u8f93\u51fa\u7684\u65b0\u989c\u8272\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u5426\u5219\u4e24\u4e2a\u6df7\u8272\u64cd\u4f5c\u4f1a\u8ba1\u7b97\u65b0\u7684\u989c\u8272\u3002\u6240\u5f97\u5230\u7684\u7ed3\u679c\u4e0e colorWriteMask \u8fdb\u884cAND\u8fd0\u7b97\uff0c\u4ee5\u786e\u5b9a\u5b9e\u9645\u4f20\u9012\u7684\u901a\u9053\u3002 \u5927\u591a\u6570\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u6df7\u8272\u7528\u4e8e\u5b9e\u73b0 alpha blending \uff0c\u65b0\u7684\u989c\u8272\u4e0e\u65e7\u7684\u989c\u8272\u8fdb\u884c\u6df7\u5408\u4f1a\u57fa\u4e8e\u5b83\u4eec\u7684 opacity \u900f\u660e\u901a\u9053\u3002 finalColor \u4f5c\u4e3a\u6700\u7ec8\u7684\u8f93\u51fa: finalColor.rgb = newAlpha * newColor + (1 - newAlpha) * oldColor; finalColor.a = newAlpha.a; C++ \u53ef\u4ee5\u901a\u8fc7\u4e00\u4e0b\u53c2\u6570\u5b8c\u6210: colorBlendAttachment.blendEnable = VK_TRUE; colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA; colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; C++ \u53ef\u4ee5\u5728\u89c4\u8303\u4e2d\u627e\u5230\u6240\u6709\u6709\u5173 VkBlendFactor \u548c VkBlendOp \u7684\u679a\u4e3e\u503c\u3002 \u7b2c\u4e8c\u4e2a\u7ed3\u6784\u4f53\u6301\u6709\u6240\u6709\u5e27\u7f13\u51b2\u533a\u7684\u5f15\u7528\uff0c\u5b83\u5141\u8bb8\u8bbe\u7f6e\u6df7\u5408\u64cd\u4f5c\u7684\u5e38\u91cf\uff0c\u8be5\u5e38\u91cf\u53ef\u4ee5\u4f5c\u4e3a\u540e\u7eed\u8ba1\u7b97\u7684\u6df7\u5408\u56e0\u5b50: VkPipelineColorBlendStateCreateInfo colorBlending = {}; colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; colorBlending.logicOpEnable = VK_FALSE; colorBlending.logicOp = VK_LOGIC_OP_COPY; // Optional colorBlending.attachmentCount = 1; colorBlending.pAttachments = &colorBlendAttachment; colorBlending.blendConstants[0] = 0.0f; // Optional colorBlending.blendConstants[1] = 0.0f; // Optional colorBlending.blendConstants[2] = 0.0f; // Optional colorBlending.blendConstants[3] = 0.0f; // Optional C++ \u5982\u679c\u9700\u8981\u4f7f\u7528\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u8bbe\u7f6e\u6df7\u5408\u64cd\u4f5c( bitwise combination ), \u9700\u8981\u8bbe\u7f6e logicOpEnable \u4e3a VK_TURE \u3002\u4e8c\u8fdb\u5236\u4f4d\u64cd\u4f5c\u5728 logicOp \u5b57\u6bb5\u4e2d\u6307\u5b9a\u3002\u5728\u7b2c\u4e00\u79cd\u65b9\u5f0f\u4e2d\u4f1a\u81ea\u52a8\u7981\u6b62\uff0c\u7b49\u540c\u4e8e\u4e3a\u6bcf\u4e00\u4e2a\u9644\u52a0\u7684\u5e27\u7f13\u51b2\u533aframebuffer\u5173\u95ed\u6df7\u5408\u64cd\u4f5c\uff0c blendEnable \u4e3a VK_FALSE \u3002 colorWriteMask \u63a9\u7801\u4f1a\u7528\u786e\u5b9a\u5e27\u7f13\u51b2\u533a\u4e2d\u5177\u4f53\u54ea\u4e2a\u901a\u9053\u7684\u989c\u8272\u53d7\u5230\u5f71\u54cd\u3002\u5b83\u4e5f\u53ef\u4ee5\u5728\u4e24\u79cd\u65b9\u5f0f\u4e0b\u7981\u6b62\uff0c\u622a\u81f3\u76ee\u524d\uff0c\u7247\u6bb5\u7f13\u51b2\u533a\u5411\u5e27\u7f13\u51b2\u533a\u4e2d\u8f93\u51fa\u7684\u989c\u8272\u4e0d\u4f1a\u8fdb\u884c\u4efb\u4f55\u53d8\u5316\u3002","title":"\u989c\u8272\u6df7\u5408"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_37","text":"\u4e4b\u524d\u521b\u5efa\u7684\u4e00\u4e9b\u7ed3\u6784\u4f53\u7684\u72b6\u6001\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u52a8\u6001\u4fee\u6539\uff0c\u800c\u4e0d\u5fc5\u91cd\u65b0\u521b\u5efa\u3002\u6bd4\u5982 viewport \u7684\u5927\u5c0f, line width \u548c blend constants \u3002\u5982\u679c\u9700\u8981\u8fdb\u884c\u8fd9\u6837\u7684\u64cd\u4f5c\uff0c\u9700\u8981\u586b\u5145 VkPipelineDynamicStateCreateInfo \u7ed3\u6784\u4f53: VkDynamicState dynamicStates[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_LINE_WIDTH }; VkPipelineDynamicStateCreateInfo dynamicState = {}; dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO; dynamicState.dynamicStateCount = 2; dynamicState.pDynamicStates = dynamicStates; C++ \u5728\u7ed8\u5236\u7684\u8fc7\u7a0b\u4e2d\u6307\u5b9a\u8fd9\u4e9b\u6570\u636e\uff0c\u8fd9\u4f1a\u5bfc\u81f4\u5ffd\u7565\u4e4b\u524d\u7684\u76f8\u5173\u6570\u503c\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7684\u7ae0\u8282\u4e2d\u56de\u8fc7\u5934\u6765\u8ba8\u8bba\u3002\u5982\u679c\u6ca1\u6709\u4efb\u4f55\u9700\u8981\u52a8\u6001\u4fee\u6539\u7684\u6570\u503c\u6e05\u8bbe\u7f6e\u4e3a nullptr \u3002","title":"\u52a8\u6001\u4fee\u6539"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_38","text":"\u53ef\u4ee5\u5728\u7740\u8272\u5668\u4e2d\u4f7f\u7528 uniform \uff0c\u5b83\u662f\u7c7b\u4f3c\u4e0e\u52a8\u6001\u72b6\u6001\u53d8\u91cf\u7684\u5168\u5c40\u53d8\u91cf\uff0c\u53ef\u4ee5\u5728\u7ed8\u753b\u65f6\u4fee\u6539\uff0c\u53ef\u4ee5\u66f4\u6539\u7740\u8272\u5668\u7684\u884c\u4e3a\u800c\u65e0\u9700\u91cd\u65b0\u521b\u5efa\u5b83\u4eec\u3002\u5b83\u4eec\u901a\u5e38\u7528\u4e8e\u5c06\u53d8\u6362\u77e9\u9635\u4f20\u9012\u5230\u9876\u70b9\u7740\u8272\u5668\u6216\u8005\u5728\u7247\u6bb5\u7740\u8272\u5668\u51b2\u521b\u5efa\u7eb9\u7406\u91c7\u6837\u5668\u3002 \u8fd9\u4e9b uniform \u6570\u503c\u9700\u8981\u5728\u7ba1\u7ebf\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u901a\u8fc7 VkPipelineLayout \u5bf9\u8c61\u6307\u5b9a\u3002\u5373\u4f7f\u5728\u540e\u7eed\u5185\u5bb9\u4e2d\u7528\u5230\uff0c\u6211\u4eec\u4e5f\u4ecd\u7136\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u7a7a\u7684 pipeline layout \u3002 \u521b\u5efa\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709\u8be5\u5bf9\u8c61\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u540e\u7eed\u7ae0\u8282\u4e2d\u7684\u51fd\u6570\u4e2d\u5f15\u7528\u5b83: VkPipelineLayout pipelineLayout; C++ \u5728 createGraphicsPipeline \u51fd\u6570\u4e2d\u521b\u5efa\u5bf9\u8c61: VkPipelineLayoutCreateInfo pipelineLayoutInfo = {}; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; // Optional pipelineLayoutInfo.pSetLayouts = nullptr; // Optional pipelineLayoutInfo.pushConstantRangeCount = 0; // Optional pipelineLayoutInfo.pPushConstantRanges = 0; // Optional if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) { throw std::runtime_error(\"failed to create pipeline layout!\"); } C++ \u8be5\u7ed3\u6784\u4f53\u8fd8\u6307\u5b9a\u4e86 push \u5e38\u91cf\uff0c\u8fd9\u662f\u5c06\u52a8\u6001\u503c\u4f20\u9012\u7ed9\u7740\u8272\u5668\u7684\u62ce\u4e00\u4e2a\u65b9\u5f0f\u3002 pipeline layout \u53ef\u4ee5\u5728\u6574\u4e2a\u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\u5185\u5f15\u7528\uff0c\u6240\u4ee5\u5b83\u5728\u7a0b\u5e8f\u9000\u51fa\u7684\u65f6\u5019\u8fdb\u884c\u9500\u6bc1\u3002 void cleanup() { vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ... } C++","title":"\u7ba1\u9053\u5e03\u5c40"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_39","text":"\u8fd9\u5c31\u662f\u6240\u6709\u6709\u5173 fixed-function \u7684\u5185\u5bb9\uff0c\u770b\u8d77\u6765\u6709\u5f88\u591a\u7684\u5de5\u4f5c\u53bb\u505a\uff0c\u503c\u5f97\u5e86\u5e78\u7684\u662f\u6211\u4eec\u51e0\u4e4e\u4e86\u89e3\u4e86\u6240\u6709\u6709\u5173\u6e32\u67d3\u7ba1\u7ebf\u7684\u5185\u5bb9\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u51cf\u5c11\u4e86\u56e0\u4e3a\u4e0d\u4e86\u89e3\u67d0\u4e9b\u7ec4\u4ef6\u7684\u9ed8\u8ba4\u72b6\u6001\uff0c\u800c\u9020\u6210\u8fd0\u884c\u65f6\u78b0\u5230\u672a\u77e5\u884c\u4e3a\u7684\u53ef\u80fd\u6027\u3002 \u7136\u800c\uff0c\u5728\u6211\u4eec\u53ef\u4ee5\u6700\u7ec8\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u4e4b\u524d\uff0c\u8fd8\u6709\u4e00\u4e2a\u5bf9\u8c61\u9700\u8981\u521b\u5efa\uff0c\u5b83\u5c31\u662f render pass \u3002","title":"\u7ed3\u8bba"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_9","text":"Vulkan \u5e27\u7f13\u51b2\u533a \uff0c\u6211\u4eec\u5728\u524d\u9762\u7684\u7ae0\u8282\u4e2d\u5df2\u7ecf\u8ba8\u8bba\u4e86\u5f88\u591a\u6b21 framebuffers \u5e27\u7f13\u51b2\u533a\uff0c\u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u914d\u7f6e\u4e86 render pass \u6e32\u67d3\u901a\u9053\u5e76\u5e0c\u671b\u8f93\u51fa\u4e00\u4e2a\u4e0e\u4ea4\u6362\u94fe\u56fe\u50cf\u683c\u5f0f\u4e00\u81f4\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u4f46\u662f\u6211\u4eec\u5b9e\u9645\u4e0a\u8fd8\u6ca1\u6709\u521b\u5efa\u3002 \u5728 render pass \u521b\u5efa\u9636\u6bb5\u6211\u4eec\u6307\u5b9a\u4e86\u5177\u4f53\u7684\u9644\u4ef6\uff0c\u5e76\u901a\u8fc7 VkFramebuffer \u5bf9\u8c61\u5305\u88c5\u7ed1\u5b9a\u3002\u5e27\u7f13\u51b2\u533a\u5bf9\u8c61\u5f15\u7528\u8868\u793a\u4e3a\u9644\u4ef6\u7684\u6240\u6709\u7684 VkImageView \u5bf9\u8c61\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u53ea\u4f1a\u4f7f\u7528\u4e00\u4e2a\u5e27\u7f13\u51b2\u533a: color attachment \u3002\u7136\u800c\u6211\u4eec\u4f5c\u4e3a\u9644\u4ef6\u7684\u56fe\u50cf\u4f9d\u8d56\u4ea4\u6362\u94fe\u7528\u4e8e\u5448\u73b0\u65f6\u8fd4\u56de\u7684\u56fe\u50cf\u3002\u8fd9\u610f\u5473\u7740\u6211\u4eec\u5fc5\u987b\u4e3a\u4ea4\u6362\u94fe\u4e2d\u7684\u6240\u6709\u56fe\u50cf\u521b\u5efa\u4e00\u4e2a\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u5728\u7ed8\u5236\u7684\u65f6\u5019\u4f7f\u7528\u5bf9\u5e94\u7684\u56fe\u50cf\u3002 \u6700\u540e\uff0c\u5728\u7c7b\u6210\u5458\u4e2d\u521b\u5efa\u53e6\u4e00\u4e2a std::vector \u7528\u4e8e\u4fdd\u5b58 framebuffers : std::vector<VkFramebuffer> swapChainFramebuffers; C++ \u6211\u4eec\u5728\u65b0\u7684\u51fd\u6570 createFramebuffers \u4e2d\u4e3a\u6570\u7ec4\u521b\u5efa\u5bf9\u8c61\u96c6\u5408\uff0c\u8fd9\u4e2a\u51fd\u6570\u5728 initVulkan \u521b\u5efa\u5b8c\u7ba1\u7ebf\u540e\u8c03\u7528: void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); } ... void createFramebuffers() { } C++ \u52a8\u6001\u8c03\u6574\u7528\u4e8e\u4fdd\u5b58 framebuffers \u7684\u5bb9\u5668\u5927\u5c0f: void createFramebuffers() { swapChainFramebuffers.resize(swapChainImageViews.size()); } C++ \u6211\u4eec\u63a5\u4e0b\u6765\u8fed\u4ee3\u5de6\u53f3\u7684\u56fe\u50cf\u89c6\u56fe\u5e76\u901a\u8fc7\u5b83\u4eec\u521b\u5efa\u5bf9\u5e94\u7684 framebuffers : for (size_t i = 0; i < swapChainImageViews.size(); i++) { VkImageView attachments[] = { swapChainImageViews[i] }; VkFramebufferCreateInfo framebufferInfo = {}; framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; framebufferInfo.renderPass = renderPass; framebufferInfo.attachmentCount = 1; framebufferInfo.pAttachments = attachments; framebufferInfo.width = swapChainExtent.width; framebufferInfo.height = swapChainExtent.height; framebufferInfo.layers = 1; if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &swapChainFramebuffers[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to create framebuffer!\"); } } C++ \u5982\u4f60\u6240\u89c1\uff0c\u521b\u5efa framebuffers \u662f\u975e\u5e38\u76f4\u63a5\u7684\u3002\u9996\u5148\u9700\u8981\u6307\u5b9a framebuffer \u9700\u8981\u517c\u5bb9\u7684 renderPass \u3002\u6211\u4eec\u53ea\u80fd\u4f7f\u7528\u4e0e\u5176\u517c\u5bb9\u7684\u6e32\u67d3\u901a\u9053\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u8fd9\u5927\u4f53\u4e0a\u610f\u5473\u7740\u5b83\u4eec\u4f7f\u7528\u76f8\u540c\u7684\u9644\u4ef6\u6570\u91cf\u548c\u7c7b\u578b\u3002 attachmentCount \u548c pAttachments \u53c2\u6570\u6307\u5b9a\u5728\u6e32\u67d3\u901a\u9053\u7684 pAttachment \u6570\u7ec4\u4e2d\u7ed1\u5b9a\u5230\u76f8\u5e94\u7684\u9644\u4ef6\u63cf\u8ff0\u7684 VkImageView \u5bf9\u8c61\u3002 width \u548c height \u53c2\u6570\u662f\u5bb9\u6613\u7406\u89e3\u7684\uff0c layer \u662f\u6307\u5b9a\u56fe\u50cf\u6570\u7ec4\u4e2d\u7684\u5c42\u6570\u3002\u6211\u4eec\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u662f\u5355\u4e2a\u56fe\u50cf\uff0c\u56e0\u6b64\u5c42\u6570\u4e3a 1 \u3002 \u6211\u4eec\u5728\u56fe\u50cf\u89c6\u56fe\u548c\u6e32\u67d3\u901a\u9053\u6e32\u67d3\u5b8c\u6bd5\u4e4b\u540e\uff0c\u5220\u9664\u5bf9\u5e94\u7684\u5e27\u7f13\u51b2\u533a: void cleanup() { for (size_t i = 0; i < swapChainFramebuffers.size(); i++) { vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); } ... } C++ \u6211\u4eec\u5df2\u7ecf\u8fbe\u5230\u4e86\u4e00\u4e2a\u91cc\u7a0b\u7891\uff0c\u6211\u4eec\u62e5\u6709\u6e32\u67d3\u9700\u8981\u7684\u6240\u6709\u5bf9\u8c61\u3002\u5728\u4e0b\u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u7f16\u5199\u7b2c\u4e00\u4e2a\u5b9e\u9645\u7ed8\u5236\u7684\u547d\u4ee4\u3002","title":"Vulkan \u5e27\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_10","text":"Vulkan \u6e32\u67d3\u901a\u9053 \uff0c\u5728\u6211\u4eec\u5b8c\u6210\u7ba1\u7ebf\u7684\u521b\u5efa\u5de5\u4f5c\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9 Vulkan \u6e32\u67d3\u65f6\u5019\u4f7f\u7528\u7684 framebuffer \u5e27\u7f13\u51b2\u533a\u9644\u4ef6\u76f8\u5173\u4fe1\u606f\u3002\u6211\u4eec\u9700\u8981\u6307\u5b9a\u591a\u5c11\u4e2a\u989c\u8272\u548c\u6df1\u5ea6\u7f13\u51b2\u533a\u5c06\u4f1a\u88ab\u4f7f\u7528\uff0c\u6307\u5b9a\u591a\u5c11\u4e2a\u91c7\u6837\u5668\u88ab\u7528\u5230\u53ca\u5728\u6574\u4e2a\u6e32\u67d3\u64cd\u4f5c\u4e2d\u76f8\u5173\u7684\u5185\u5bb9\u5982\u4f55\u5904\u7406\u3002\u6240\u6709\u7684\u8fd9\u4e9b\u4fe1\u606f\u90fd\u88ab\u5c01\u88c5\u5728\u4e00\u4e2a\u53eb\u505a render pass \u7684\u5bf9\u8c61\u4e2d\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u8bbe\u7f6e 2 \u9644\u4ef6\u63cf\u8ff0 3 \u5b50\u901a\u9053\u548c\u9644\u4ef6\u5f15\u7528 4 \u6e32\u67d3\u901a\u9053","title":"Vulkan \u6e32\u67d3\u901a\u9053"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_40","text":"\u6211\u4eec\u65b0\u6dfb\u52a0\u4e00\u4e2a createRenderPass \u51fd\u6570\uff0c\u5728 initVulkan \u51fd\u6570\u4e2d\u786e\u4fdd createGraphicsPipeline \u8c03\u7528\u4e4b\u524d\uff0c\u8c03\u7528\u5b83\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); } ... void createRenderPass() { } C++","title":"\u8bbe\u7f6e"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_41","text":"\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u5c06\u53ea\u6709\u4e00\u4e2a\u989c\u8272\u7f13\u51b2\u533a\u9644\u4ef6\uff0c\u5b83\u7531\u4ea4\u6362\u94fe\u4e2d\u7684\u4e00\u4e2a\u56fe\u50cf\u6240\u8868\u793a\u3002 void createRenderPass() { VkAttachmentDescription colorAttachment = {}; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT; } C++ format \u662f\u989c\u8272\u9644\u4ef6\u7684\u683c\u5f0f\uff0c\u5b83\u5e94\u8be5\u4e0e\u4ea4\u6362\u94fe\u4e2d\u56fe\u50cf\u7684\u683c\u5f0f\u76f8\u5339\u914d\uff0c\u540c\u65f6\u6211\u4eec\u4e0d\u4f1a\u505a\u4efb\u4f55\u591a\u91cd\u91c7\u6837\u7684\u5de5\u4f5c\uff0c\u6240\u4ee5\u91c7\u6837\u5668\u8bbe\u7f6e\u4e3a1\u3002 colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR; colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; C++ loadOp \u548c storeOp \u51b3\u5b9a\u4e86\u6e32\u67d3\u524d\u548c\u6e32\u67d3\u540e\u6570\u636e\u5728\u5bf9\u5e94\u9644\u4ef6\u7684\u64cd\u4f5c\u884c\u4e3a\u3002\u5bf9\u4e8e loadOp \u6211\u4eec\u6709\u5982\u4e0b\u9009\u9879\uff1a VK_ATTACHMENT_LOAD_OP_LOAD : \u4fdd\u5b58\u5df2\u7ecf\u5b58\u5728\u4e8e\u5f53\u524d\u9644\u4ef6\u7684\u5185\u5bb9 VK_ATTACHMENT_LOAD_OP_CLEAR : \u8d77\u59cb\u9636\u6bb5\u4ee5\u4e00\u4e2a\u5e38\u91cf\u6e05\u7406\u9644\u4ef6\u5185\u5bb9 VK_ATTACHMENT_LOAD_OP_DONT_CARE : \u5b58\u5728\u7684\u5185\u5bb9\u672a\u5b9a\u4e49\uff0c\u5ffd\u7565\u5b83\u4eec \u5728\u7ed8\u5236\u65b0\u7684\u4e00\u5e27\u5185\u5bb9\u4e4b\u524d\uff0c\u6211\u4eec\u8981\u505a\u7684\u662f\u4f7f\u7528\u6e05\u7406\u64cd\u4f5c\u6765\u6e05\u7406\u5e27\u7f13\u51b2\u533aframebuffer\u4e3a\u9ed1\u8272\u3002\u540c\u65f6\u5bf9\u4e8e storeOp \u4ec5\u6709\u4e24\u4e2a\u9009\u9879\uff1a VK_ATTACHMENT_STORE_OP_STORE : \u6e32\u67d3\u7684\u5185\u5bb9\u4f1a\u5b58\u50a8\u5728\u5185\u5b58\uff0c\u5e76\u5728\u4e4b\u540e\u8fdb\u884c\u8bfb\u53d6\u64cd\u4f5c VK_ATTACHMENT_STORE_OP_DONT_CARE : \u5e27\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u5728\u6e32\u67d3\u64cd\u4f5c\u5b8c\u6bd5\u540e\u8bbe\u7f6e\u4e3aundefined \u6211\u4eec\u8981\u505a\u7684\u662f\u6e32\u67d3\u4e00\u4e2a\u4e09\u89d2\u5f62\u5728\u5c4f\u5e55\u4e0a\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u5b58\u50a8\u64cd\u4f5c\u3002 colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE; colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; C++ loadOp \u548c storeOp \u5e94\u7528\u5728\u989c\u8272\u548c\u6df1\u5ea6\u6570\u636e\uff0c\u540c\u65f6 stencilLoadOp / stencilStoreOp \u5e94\u7528\u5728\u6a21\u7248\u6570\u636e\u3002\u6211\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u4e0d\u4f1a\u505a\u4efb\u4f55\u6a21\u7248\u7f13\u51b2\u533a\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u5b83\u7684loading\u548cstoring\u65e0\u5173\u7d27\u8981\u3002 colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; C++ \u7eb9\u7406\u548c\u5e27\u7f13\u51b2\u533a\u5728Vulkan\u4e2d\u901a\u5e38\u7528 VkImage \u5bf9\u8c61\u914d\u4ee5\u67d0\u79cd\u50cf\u7d20\u683c\u5f0f\u6765\u4ee3\u8868\u3002\u4f46\u662f\u50cf\u7d20\u5728\u5185\u5b58\u4e2d\u7684\u5e03\u5c40\u53ef\u4ee5\u57fa\u4e8e\u9884\u8981\u5bf9image\u56fe\u50cf\u8fdb\u884c\u7684\u64cd\u4f5c\u53d1\u751f\u5185\u5b58\u5e03\u5c40\u7684\u53d8\u5316\u3002 \u4e00\u4e9b\u5e38\u7528\u7684\u5e03\u5c40: VK_IMAGE_LAYOUT_COLOR_ATTACHMET_OPTIMAL : \u56fe\u50cf\u4f5c\u4e3a\u989c\u8272\u9644\u4ef6 VK_IMAGE_LAYOUT_PRESENT_SRC_KHR : \u56fe\u50cf\u5728\u4ea4\u6362\u94fe\u4e2d\u88ab\u5448\u73b0 VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL : \u56fe\u50cf\u4f5c\u4e3a\u76ee\u6807\uff0c\u7528\u4e8e\u5185\u5b58COPY\u64cd\u4f5c \u6211\u4eec\u4f1a\u6df1\u5165\u8ba8\u8bba\u8fd9\u4e9b\u5185\u5bb9\u5728\u7eb9\u7406\u7ae0\u8282\uff0c\u73b0\u5728\u6700\u91cd\u8981\u7684\u662f\u4e3a\u9700\u8981\u8f6c\u53d8\u7684\u56fe\u50cf\u6307\u5b9a\u5408\u9002\u7684layout\u5e03\u5c40\u8fdb\u884c\u64cd\u4f5c\u3002 initialLayout \u6307\u5b9a\u56fe\u50cf\u5728\u5f00\u59cb\u8fdb\u5165\u6e32\u67d3\u901a\u9053render pass\u524d\u5c06\u8981\u4f7f\u7528\u7684\u5e03\u5c40\u7ed3\u6784\u3002 finalLayout \u6307\u5b9a\u5f53\u6e32\u67d3\u901a\u9053\u7ed3\u675f\u81ea\u52a8\u53d8\u6362\u65f6\u4f7f\u7528\u7684\u5e03\u5c40\u3002\u4f7f\u7528 VK_IMAGE_LAYOUT_UNDEFINED \u8bbe\u7f6e initialLayout \uff0c\u610f\u4e3a\u4e0d\u5173\u5fc3\u56fe\u50cf\u4e4b\u524d\u7684\u5e03\u5c40\u3002\u7279\u6b8a\u503c\u8868\u660e\u56fe\u50cf\u7684\u5185\u5bb9\u4e0d\u786e\u5b9a\u4f1a\u88ab\u4fdd\u7559\uff0c\u4f46\u662f\u8fd9\u5e76\u4e0d\u603b\u8981\uff0c\u56e0\u4e3a\u65e0\u8bba\u5982\u4f55\u6211\u4eec\u90fd\u8981\u6e05\u7406\u5b83\u3002\u6211\u4eec\u5e0c\u671b\u56fe\u50cf\u6e32\u67d3\u5b8c\u6bd5\u540e\u4f7f\u7528\u4ea4\u6362\u94fe\u8fdb\u884c\u5448\u73b0\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48 finalLayout \u8981\u8bbe\u7f6e\u4e3a VK_IMAGE_LAYOUT_PRESENT_SRC_KHR \u3002 \u5982\u679c\u6ca1\u6709\u641e\u6e05\u695a\u5e03\u5c40\u5b58\u5728\u7684\u610f\u4e49\uff0c\u8fdb\u4e00\u6b65\u89e3\u91calayout\u8bf7\u770b\u5982\u4e0b\u56fe\u793a: \u4e00\u822c\u610f\u4e49\u4e0a\uff0c\u6211\u4eec\u7406\u89e3 CPU \u8fdb\u884c\u5185\u5b58\u4e2d\u7684\u6570\u636e\u8bfb\u5199\u5f80\u5f80\u90fd\u662f\u7ebf\u6027\u6392\u5e8f\u7684 linear memory layout \uff0c\u53ef\u4ee5\u770b\u5230 AB \u4e0e CD \u4f5c\u4e3a\u6765\u4e2a\u8fde\u7eed\u7684\u884c\u6765\u8fdb\u884c\u8bfb\u53d6\u3002\u4f46\u662f\u5728\u5f88\u591a\u65f6\u5019\u5bf9\u4e8e\u50cf\u7d20\u7eb9\u7406\u6570\u636e\u7684\u64cd\u4f5c\u662f\u975e\u7ebf\u6027\u8fde\u7eed\u7684\uff0c\u8fd9\u79cd\u60c5\u666f\u66f4\u591a\u53d1\u751f\u5728 GPU \u64cd\u4f5c\u4e2d\uff0c\u6240\u4ee5 GPU \u786c\u4ef6\u66f4\u591a\u7684\u652f\u6301\u57fa\u4e8e( Tiled )\u5e73\u94fa\u7684\u6216\u8005\u6210\u4e3a\u6700\u4f73\u7684\u5185\u5b58\u5e03\u5c40\u7ed3\u6784\uff0c\u6765\u63d0\u964d\u4f4e GPU \u5904\u7406\u6570\u636e\u7684\u5f00\u9500\u3002 \u6240\u4ee5\u4ece CPU linear layout \u5185\u5b58\u6570\u636e \u5230 GPU optimal layout \u663e\u5b58\u6570\u636e\u7684\u8bfb\u5199 \u5f80\u8fd4\u4e4b\u95f4\u5b58\u5728\u6570\u636e\u5b58\u50a8\u683c\u5f0f\u7684\u4f18\u5316\u8f6c\u53d8\u6b65\u9aa4\u3002","title":"\u9644\u4ef6\u63cf\u8ff0"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_42","text":"\u4e00\u4e2a\u5355\u72ec\u7684\u6e32\u67d3\u901a\u9053\u53ef\u4ee5\u7531\u591a\u4e2a\u5b50\u901a\u9053\u7ec4\u6210\u3002\u5b50\u901a\u9053\u662f\u6e32\u67d3\u64cd\u4f5c\u7684\u4e00\u4e2a\u5e8f\u5217\u3002\u5b50\u901a\u9053\u4f5c\u7528\u4e0e\u540e\u7eed\u7684\u6e32\u67d3\u64cd\u4f5c\uff0c\u5e76\u4f9d\u8d56\u4e4b\u524d\u6e32\u67d3\u901a\u9053\u8f93\u51fa\u5230\u5e27\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u3002\u6bd4\u5982\u8bf4\u540e\u5904\u7406\u6548\u679c\u7684\u5e8f\u5217\u901a\u5e38\u6bcf\u4e00\u6b65\u90fd\u4f9d\u8d56\u4e4b\u524d\u7684\u64cd\u4f5c\u3002\u5982\u679c\u5c06\u8fd9\u4e9b\u6e32\u67d3\u64cd\u4f5c\u5206\u7ec4\u5230\u4e00\u4e2a\u6e32\u67d3\u901a\u9053\u4e2d\uff0c\u901a\u8fc7 Vulkan \u5c06\u901a\u9053\u4e2d\u7684\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u91cd\u6392\u5e8f\uff0c\u53ef\u4ee5\u8282\u7701\u5185\u5b58\u4ece\u800c\u83b7\u5f97\u66f4\u597d\u7684\u6027\u80fd\u3002\u5bf9\u4e8e\u6211\u4eec\u8981\u7ed8\u5236\u7684\u4e09\u89d2\u5f62\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4e00\u4e2a\u5b50\u901a\u9053\u3002 \u6bcf\u4e2a\u5b50\u901a\u9053\u5f15\u7528\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\u4e4b\u524d\u4f7f\u7528\u7ed3\u6784\u4f53\u63cf\u8ff0\u7684\u9644\u4ef6\u3002\u8fd9\u4e9b\u5f15\u7528\u672c\u8eab\u5c31\u662f VkAttachmentReference \u7ed3\u6784\u4f53: VkAttachmentReference colorAttachmentRef = {}; colorAttachmentRef.attachment = 0; colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; C++ attachment \u9644\u4ef6\u53c2\u6570\u901a\u8fc7\u9644\u4ef6\u63cf\u8ff0\u7b26\u96c6\u5408\u4e2d\u7684\u7d22\u5f15\u6765\u6301\u6709\u3002\u6211\u4eec\u7684\u96c6\u5408\u662f\u7531\u4e00\u4e2a VkAttachmentDesription \u7ec4\u6210\u7684\uff0c\u6240\u4ee5\u5b83\u7684\u7d22\u5f15\u4e3a 0 \u3002 layout \u4e3a\u9644\u4ef6\u6307\u5b9a\u5b50\u901a\u9053\u5728\u6301\u6709\u5f15\u7528\u65f6\u5019\u7684layout\u3002\u5f53\u5b50\u901a\u9053\u5f00\u59cb\u7684\u65f6\u5019Vulkan\u4f1a\u81ea\u52a8\u8f6c\u53d8\u9644\u4ef6\u5230\u8fd9\u4e2alayout\u3002\u56e0\u4e3a\u6211\u4eec\u671f\u671b\u9644\u4ef6\u8d77\u5230\u989c\u8272\u7f13\u51b2\u533a\u7684\u4f5c\u7528\uff0clayout\u8bbe\u7f6e\u4e3a VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL \u4f1a\u7ed9\u6211\u4eec\u6700\u597d\u7684\u6027\u80fd\u3002 \u5b50\u901a\u9053\u4f7f\u7528 VkSubpassDescription \u7ed3\u6784\u4f53\u63cf\u8ff0: VkSubpassDescription subpass = {}; subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; C++ Vulkan\u5728\u672a\u6765\u53ef\u80fd\u4f1a\u652f\u6301\u5173\u4e8e compute subpasses \u7684\u529f\u80fd\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u4eec\u660e\u786e\u6307\u5b9a graphics subpass \u56fe\u5f62\u5b50\u901a\u9053\u3002\u4e0b\u4e00\u6b65\u4e3a\u5b83\u6307\u5b9a\u989c\u8272\u9644\u4ef6\u7684\u5f15\u7528: subpass.colorAttachmentCount = 1; subpass.pColorAttachments = &colorAttachmentRef; C++ \u9644\u4ef6\u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15\u76f4\u63a5\u4ece\u7247\u6bb5\u7740\u8272\u5668\u5f15\u7528\uff0c\u5176 layout(location = 0) out vec4 outColor \u6307\u4ee4! \u53ef\u4ee5\u88ab\u5b50\u901a\u9053\u5f15\u7528\u7684\u9644\u4ef6\u7c7b\u578b\u5982\u4e0b: pInputAttachments : \u9644\u4ef6\u4ece\u7740\u8272\u5668\u4e2d\u8bfb\u53d6 pResolveAttachments : \u9644\u4ef6\u7528\u4e8e\u989c\u8272\u9644\u4ef6\u7684\u591a\u91cd\u91c7\u6837 pDepthStencilAttachment : \u9644\u4ef6\u7528\u4e8e\u6df1\u5ea6\u548c\u6a21\u7248\u6570\u636e pPreserveAttachments : \u9644\u4ef6\u4e0d\u88ab\u5b50\u901a\u9053\u4f7f\u7528\uff0c\u4f46\u662f\u6570\u636e\u88ab\u4fdd\u5b58","title":"\u5b50\u901a\u9053\u548c\u9644\u4ef6\u5f15\u7528"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_43","text":"\u73b0\u5728\u9644\u4ef6\u548c\u57fa\u672c\u7684\u5b50\u901a\u9053\u5df2\u7ecf\u4ecb\u7ecd\u8fc7\u4e86\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u6e32\u67d3\u901a\u9053\u4e86\u3002\u9996\u5148\u65b0\u5efa\u4e00\u4e2a\u7c7b\u6210\u5458\u53d8\u91cf\u6301\u6709 VkRenderPass \u5bf9\u8c61\uff0c\u8be5\u53d8\u91cf\u5728 pipelineLayout \u4e0a\u5b9a\u4e49: VkRenderPass renderPass; VkPipelineLayout pipelineLayout; C++ \u6e32\u67d3\u901a\u9053\u5bf9\u8c61\u521b\u5efa\u901a\u8fc7\u586b\u5145 VkRenderPassCreateInfo \u7ed3\u6784\u4f53\uff0c\u5e76\u914d\u5408\u76f8\u5173\u9644\u4ef6\u548c\u5b50\u901a\u9053\u6765\u5b8c\u6210\u3002 VkAttachmentReference \u5bf9\u8c61\u5f15\u7528\u9644\u4ef6\u6570\u7ec4\u3002 VkRenderPassCreateInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.attachmentCount = 1; renderPassInfo.pAttachments = &colorAttachment; renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = &subpass; if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) { throw std::runtime_error(\"failed to create render pass!\"); } C++ \u5c31\u50cf pipeline layout \u4e00\u6837\uff0c\u6e32\u67d3\u901a\u9053\u5728\u6574\u4e2a\u7a0b\u5e8f\u751f\u547d\u5468\u671f\u5185\u90fd\u88ab\u4f7f\u7528\uff0c\u6240\u4ee5\u9700\u8981\u5728\u9000\u51fa\u9636\u6bb5\u8fdb\u884c\u6e05\u7406\uff1a void cleanup() { vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); ... } C++ \u8fd9\u770b\u8d77\u6765\u5f88\u591a\u5de5\u4f5c\u91cf\uff0c\u4f46\u662f\u5728 \u4e0b\u4e00\u7ae0\u8282 \u6211\u4eec\u4f1a\u628a\u6240\u6709\u7684\u7ec4\u4ef6\u6574\u5408\u8d77\u6765\uff0c\u521b\u5efa\u6700\u7ec8\u7684\u56fe\u5f62\u7ba1\u7ebf\u5bf9\u8c61\u3002","title":"\u6e32\u67d3\u901a\u9053"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_11","text":"ulkan \u96c6\u6210\u7ba1\u7ebf \uff0c\u6211\u4eec\u73b0\u5728\u6574\u5408\u524d\u51e0\u7ae0\u8282\u7684\u7ed3\u6784\u4f53\u548c \u5bf9\u8c61\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf \uff01\u4ee5\u4e0b\u662f\u6211\u4eec\u73b0\u5728\u7528\u5230\u7684\u5bf9\u8c61\u7c7b\u578b\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u5feb\u901f\u56de\u987e: Shader stages : \u7740\u8272\u5668\u6a21\u5757\u5b9a\u4e49\u4e86\u56fe\u5f62\u7ba1\u7ebf\u53ef\u7f16\u7a0b\u9636\u6bb5\u7684\u529f\u80fd Fixed-function state : \u7ed3\u6784\u4f53\u5b9a\u4e49\u56fa\u5b9a\u7ba1\u7ebf\u529f\u80fd\uff0c\u6bd4\u5982\u8f93\u5165\u88c5\u914d\u3001\u5149\u6805\u5316\u3001viewport\u548ccolor blending Pipeline layout : \u7ba1\u7ebf\u5e03\u5c40\u5b9a\u4e49uniform \u548c push values\uff0c\u88ab\u7740\u8272\u5668\u6bcf\u4e00\u6b21\u7ed8\u5236\u7684\u65f6\u5019\u5f15\u7528 Render pass : \u6e32\u67d3\u901a\u9053\u901a\u8fc7\u7ba1\u7ebf\u9636\u6bb5\u5f15\u7528\u9644\u4ef6\uff0c\u5e76\u5b9a\u4e49\u5b83\u7684\u4f7f\u7528\u65b9\u5f0f \u6240\u6709\u8fd9\u4e9b\u51b3\u5b9a\u4e86\u56fe\u5f62\u7ba1\u7ebf\u7684\u6700\u7ec8\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u5728 createGraphicsPipeline \u51fd\u6570\u7684\u6700\u540e\u586b\u5145 VkGraphicsPipelineCreateInfo \u7ed3\u6784\u4f53\u3002 VkGraphicsPipelineCreateInfo pipelineInfo = {}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 2; pipelineInfo.pStages = shaderStages; C++ \u73b0\u5728\u5f00\u59cb\u5f15\u7528\u4e4b\u524d\u7684 VkPipelineShaderStageCreateInfo \u7ed3\u6784\u4f53\u6570\u7ec4\u3002 pipelineInfo.pVertexInputState = &vertexInputInfo; pipelineInfo.pInputAssemblyState = &inputAssembly; pipelineInfo.pViewportState = &viewportState; pipelineInfo.pRasterizationState = &rasterizer; pipelineInfo.pMultisampleState = &multisampling; pipelineInfo.pDepthStencilState = nullptr; // Optional pipelineInfo.pColorBlendState = &colorBlending; pipelineInfo.pDynamicState = nullptr; // Optional C++ \u5e76\u5f15\u7528\u4e4b\u524d\u63cf\u8ff0\u56fa\u5b9a\u7ba1\u7ebf\u529f\u80fd\u7684\u7ed3\u6784\u4f53\u3002 pipelineInfo.layout = pipelineLayout; C++ \u5b8c\u6210\u4e4b\u540e\uff0c pipeline layout \u7ba1\u7ebf\u5e03\u5c40\uff0c\u5b83\u662f\u4e00\u4e2a Vulkan \u53e5\u67c4\u800c\u4e0d\u662f\u7ed3\u6784\u4f53\u6307\u9488\u3002 pipelineInfo.renderPass = renderPass; pipelineInfo.subpass = 0; C++ \u6700\u540e\u6211\u4eec\u9700\u8981\u5f15\u7528 render pass \u548c\u56fe\u5f62\u7ba1\u7ebf\u5c06\u8981\u4f7f\u7528\u7684\u5b50\u901a\u9053 sub pass \u7684\u7d22\u5f15\u3002 pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; // Optional pipelineInfo.basePipelineIndex = -1; // Optional C++ \u5b9e\u9645\u4e0a\u8fd8\u6709\u4e24\u4e2a\u53c2\u6570: basePipelineHandle \u548c basePipelineIndex \u3002Vulkan\u5141\u8bb8\u60a8\u901a\u8fc7\u5df2\u7ecf\u5b58\u5728\u7684\u7ba1\u7ebf\u521b\u5efa\u65b0\u7684\u56fe\u5f62\u7ba1\u7ebf\u3002\u8fd9\u79cd\u884d\u751f\u51fa\u65b0\u7ba1\u7ebf\u7684\u60f3\u6cd5\u5728\u4e8e\uff0c\u5f53\u8981\u521b\u5efa\u7684\u7ba1\u7ebf\u4e0e\u73b0\u6709\u7ba1\u9053\u529f\u80fd\u76f8\u540c\u65f6\uff0c\u83b7\u5f97\u8f83\u4f4e\u7684\u5f00\u9500\uff0c\u540c\u65f6\u4e5f\u53ef\u4ee5\u66f4\u5feb\u7684\u5b8c\u6210\u7ba1\u7ebf\u5207\u6362\uff0c\u5f53\u5b83\u4eec\u6765\u81ea\u540c\u4e00\u4e2a\u7236\u7ba1\u7ebf\u3002\u53ef\u4ee5\u901a\u8fc7 basePipelineHandle \u6307\u5b9a\u73b0\u6709\u7ba1\u7ebf\u7684\u53e5\u67c4\uff0c\u4e5f\u53ef\u4ee5\u5f15\u7528\u7531 basePipelineIndex \u6240\u4ee5\u521b\u5efa\u7684\u53e6\u4e00\u4e2a\u7ba1\u7ebf\u3002\u76ee\u524d\u53ea\u6709\u4e00\u4e2a\u7ba1\u7ebf\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u6307\u5b9a\u4e00\u4e2a\u7a7a\u53e5\u67c4\u548c\u4e00\u4e2a\u65e0\u6548\u7684\u7d22\u5f15\u3002\u53ea\u6709\u5728 VkGraphicsPipelineCreateInfo \u7684 flags \u5b57\u6bb5\u4e2d\u4e5f\u6307\u5b9a\u4e86 VK_PIPELINE_CREATE_DERIVATIVE_BIT \u6807\u5fd7\u65f6\uff0c\u624d\u9700\u8981\u4f7f\u7528\u8fd9\u4e9b\u503c\u3002 \u73b0\u5728\u51c6\u5907\u6700\u540e\u4e00\u6b65\uff0c\u521b\u5efa\u4e00\u4e2a\u7c7b\u6210\u5458\u4fdd\u5b58 VkPipeline \u5bf9\u8c61: VkPipeline graphicsPipeline; C++ \u6700\u540e\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf: if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline) != VK_SUCCESS) { throw std::runtime_error(\"failed to create graphics pipeline!\"); } C++ vkCreateGraphicsPipelines \u51fd\u6570\u5728Vulkan\u4e2d\u6bd4\u8d77\u4e00\u822c\u7684\u521b\u5efa\u5bf9\u8c61\u51fd\u6570\u9700\u8981\u66f4\u591a\u7684\u53c2\u6570\u3002\u5b83\u53ef\u4ee5\u7528\u6765\u4f20\u9012\u591a\u4e2a VkGraphicsPipelineCreateInfo \u5bf9\u8c61\u5e76\u521b\u5efa\u591a\u4e2a VkPipeline \u5bf9\u8c61\u3002 \u6211\u4eec\u4f20\u9012 VK_NULL_HANDLE \u53c2\u6570\u4f5c\u4e3a\u7b2c\u4e8c\u4e2a\u53c2\u6570\uff0c\u4f5c\u4e3a\u53ef\u9009 VkPipelineCache \u5bf9\u8c61\u7684\u5f15\u7528\u3002\u7ba1\u7ebf\u7f13\u5b58\u53ef\u4ee5\u7528\u4e8e\u5b58\u50a8\u548c\u590d\u7528\u4e0e\u901a\u8fc7\u591a\u6b21\u8c03\u7528 vkCreateGraphicsPipelines \u51fd\u6570\u76f8\u5173\u7684\u6570\u636e\uff0c\u751a\u81f3\u5728\u7a0b\u5e8f\u6267\u884c\u7684\u65f6\u5019\u7f13\u5b58\u5230\u4e00\u4e2a\u6587\u4ef6\u4e2d\u3002\u8fd9\u6837\u53ef\u4ee5\u52a0\u901f\u540e\u7eed\u7684\u7ba1\u7ebf\u521b\u5efa\u903b\u8f91\u3002\u5177\u4f53\u7684\u5185\u5bb9\u6211\u4eec\u4f1a\u5728\u7ba1\u7ebf\u7f13\u5b58\u7ae0\u8282\u4ecb\u7ecd\u3002 \u56fe\u5f62\u7ba1\u7ebf\u5bf9\u4e8e\u5e38\u89c1\u7684\u7ed8\u56fe\u64cd\u4f5c\u662f\u5fc5\u987b\u7684\uff0c\u6240\u4ee5\u5b83\u4e5f\u5e94\u8be5\u5728\u7a0b\u5e8f\u7ed3\u675f\u65f6\u9500\u6bc1: void cleanup() { vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ... } C++ \u73b0\u5728\u8fd0\u884c\u7a0b\u5e8f\uff0c\u786e\u8ba4\u6240\u6709\u5de5\u4f5c\u6b63\u5e38\uff0c\u5e76\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u6210\u529f\uff01\u6211\u4eec\u5df2\u7ecf\u65e0\u6bd4\u63a5\u8fd1\u5728\u5c4f\u5e55\u4e0a\u7ed8\u5236\u51fa\u4e1c\u897f\u6765\u4e86\u3002\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u4e2a\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4ece\u4ea4\u6362\u94fe\u56fe\u50cf\u4e2d\u8bbe\u7f6e\u5b9e\u9645\u7684\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u51c6\u5907\u7ed8\u5236\u547d\u4ee4\u3002","title":"Vulkan \u96c6\u6210\u7ba1\u7ebf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_12","text":"Vulkan \u547d\u4ee4\u7f13\u51b2\u533a \uff0c\u8bf8\u5982\u7ed8\u5236\u548c\u5185\u5b58\u64cd\u4f5c\u76f8\u5173\u547d\u4ee4\uff0c\u5728 Vulkan \u4e2d\u4e0d\u662f\u901a\u8fc7\u51fd\u6570\u76f4\u63a5\u8c03\u7528\u7684\u3002\u6211\u4eec\u9700\u8981\u5728\u547d\u4ee4\u7f13\u51b2\u533a\u5bf9\u8c61\u4e2d\u8bb0\u5f55\u6211\u4eec\u671f\u671b\u7684\u4efb\u4f55\u64cd\u4f5c\u3002\u8fd9\u6837\u505a\u7684\u4f18\u70b9\u662f\u53ef\u4ee5\u63d0\u524d\u5728\u591a\u7ebf\u7a0b\u4e2d\u5b8c\u6210\u6240\u6709\u7ed8\u5236\u547d\u4ee4\u76f8\u5173\u7684\u88c5\u914d\u5de5\u4f5c\uff0c\u5e76\u5728\u4e3b\u7ebf\u7a0b\u5faa\u73af\u7ed3\u6784\u4e2d\u901a\u77e5 Vulkan \u6267\u884c\u5177\u4f53\u7684\u547d\u4ee4\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u547d\u4ee4\u6c60 2 \u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a 3 \u542f\u52a8\u547d\u4ee4\u7f13\u51b2\u8bb0\u5f55 4 \u542f\u52a8\u6e32\u67d3\u901a\u9053 5 \u57fa\u672c\u7ed8\u56fe\u547d\u4ee4 6 \u7ed3\u675f\u6e32\u67d3","title":"Vulkan \u547d\u4ee4\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_44","text":"\u6211\u4eec\u5728\u4f7f\u7528\u4efb\u4f55 command buffers \u4e4b\u524d\u9700\u8981\u521b\u5efa\u547d\u4ee4\u5bf9\u8c61\u6c60 command pool \u3002 Command pools \u7ba1\u7406\u7528\u4e8e\u5b58\u50a8\u7f13\u51b2\u533a\u7684\u5185\u5b58\uff0c\u5e76\u4ece\u4e2d\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u6dfb\u52a0\u65b0\u7684\u7c7b\u6210\u5458\u4fdd\u5b58 VkCommandPool : VkCommandPool commandPool; \u521b\u5efa\u65b0\u7684\u51fd\u6570 createCommandPool \u5e76\u5728 initVulkan \u51fd\u6570\u521b\u5efa\u5b8c framebuffers \u540e\u8c03\u7528\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); } ... void createCommandPool() { } \u547d\u4ee4\u5bf9\u8c61\u6c60\u521b\u5efa\u4ec5\u4ec5\u9700\u8981\u4e24\u4e2a\u53c2\u6570: QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice); VkCommandPoolCreateInfo poolInfo = {}; poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily; poolInfo.flags = 0; // Optional \u547d\u4ee4\u7f13\u51b2\u533a\u901a\u8fc7\u5c06\u5176\u63d0\u4ea4\u5230\u5176\u4e2d\u4e00\u4e2a\u8bbe\u5907\u961f\u5217\u4e0a\u6765\u6267\u884c\uff0c\u5982\u6211\u4eec\u68c0\u7d22\u7684 graphics \u548c presentation \u961f\u5217\u3002\u6bcf\u4e2a\u547d\u4ee4\u5bf9\u8c61\u6c60\u53ea\u80fd\u5206\u914d\u5728\u5355\u4e00\u7c7b\u578b\u7684\u961f\u5217\u4e0a\u63d0\u4ea4\u7684\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u6362\u53e5\u8bdd\u8bf4\u8981\u5206\u914d\u7684\u547d\u4ee4\u9700\u8981\u4e0e\u961f\u5217\u7c7b\u578b\u4e00\u81f4\u3002\u6211\u4eec\u8981\u8bb0\u5f55\u7ed8\u5236\u7684\u547d\u4ee4\uff0c\u8fd9\u5c31\u8bf4\u660e\u4e3a\u4ec0\u4e48\u8981\u9009\u62e9\u56fe\u5f62\u961f\u5217\u7c07\u7684\u539f\u56e0\u3002 \u6709\u4e24\u4e2a\u6807\u5fd7\u4f4d\u7528\u4e8e command pools : VK_COMMAND_POOL_CREATE_TRANSIENT_BIT : \u63d0\u793a\u547d\u4ee4\u7f13\u51b2\u533a\u975e\u5e38\u9891\u7e41\u7684\u91cd\u65b0\u8bb0\u5f55\u65b0\u547d\u4ee4(\u53ef\u80fd\u4f1a\u6539\u53d8\u5185\u5b58\u5206\u914d\u884c\u4e3a) VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT : \u5141\u8bb8\u547d\u4ee4\u7f13\u51b2\u533a\u5355\u72ec\u91cd\u65b0\u8bb0\u5f55\uff0c\u6ca1\u6709\u8fd9\u4e2a\u6807\u5fd7\uff0c\u6240\u6709\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u90fd\u5fc5\u987b\u4e00\u8d77\u91cd\u7f6e \u6211\u4eec\u4ec5\u4ec5\u5728\u7a0b\u5e8f\u5f00\u59cb\u7684\u65f6\u5019\u8bb0\u5f55\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u5e76\u5728\u4e3b\u5faa\u73af\u4f53 main loop \u4e2d\u591a\u6b21\u6267\u884c\uff0c\u56e0\u6b64\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u8fd9\u4e9b\u6807\u5fd7\u3002 if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) { throw std::runtime_error(\"failed to create command pool!\"); } \u901a\u8fc7 vkCreateCommandPool \u51fd\u6570\u5b8c\u6210 command pool \u521b\u5efa\u5de5\u4f5c\u3002\u5b83\u4e0d\u9700\u8981\u4efb\u4f55\u7279\u6b8a\u7684\u53c2\u6570\u8bbe\u7f6e\u3002\u547d\u4ee4\u5c06\u88ab\u6574\u4e2a\u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\u4f7f\u7528\u4ee5\u5b8c\u6210\u5c4f\u5e55\u7684\u7ed8\u5236\u5de5\u4f5c\uff0c\u6240\u4ee5\u5bf9\u8c61\u6c60\u5e94\u8be5\u88ab\u5728\u6700\u540e\u9500\u6bc1: void cleanup() { vkDestroyCommandPool(device, commandPool, nullptr); ... }","title":"\u547d\u4ee4\u6c60"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_45","text":"\u73b0\u5728\u6211\u4eec\u5f00\u59cb\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a\u5e76\u901a\u8fc7\u5b83\u4eec\u8bb0\u5f55\u7ed8\u5236\u6307\u4ee4\u3002\u56e0\u4e3a\u5176\u4e2d\u4e00\u4e2a\u7ed8\u56fe\u547d\u4ee4\u9700\u8981\u6b63\u786e\u7ed1\u5b9a VkFrameBuffer \uff0c\u6211\u4eec\u5b9e\u9645\u4e0a\u9700\u8981\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u8bb0\u5f55\u4e00\u4e2a\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u6700\u540e\u521b\u5efa\u4e00\u4e2a VkCommandBuffer \u5bf9\u8c61\u5217\u8868\u4f5c\u4e3a\u6210\u5458\u53d8\u91cf\u3002\u547d\u4ee4\u7f13\u51b2\u533a\u4f1a\u5728 common pool \u9500\u6bc1\u7684\u65f6\u5019\u81ea\u52a8\u91ca\u653e\u7cfb\u7edf\u8d44\u6e90\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u660e\u786e\u7f16\u5199 cleanup \u903b\u8f91\u3002 std::vector<VkCommandBuffer> commandBuffers; \u73b0\u5728\u5f00\u59cb\u4f7f\u7528\u4e00\u4e2a createCommandBuffers \u51fd\u6570\u6765\u5206\u914d\u548c\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u56fe\u50cf\u5c06\u8981\u5e94\u7528\u7684\u547d\u4ee4\u3002 void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); } ... void createCommandBuffers() { commandBuffers.resize(swapChainFramebuffers.size()); } \u547d\u4ee4\u7f13\u51b2\u533a\u901a\u8fc7 vkAllocateCommandBuffers \u51fd\u6570\u5206\u914d\uff0c\u5b83\u9700\u8981 VkCommandBufferAllocateInfo \u7ed3\u6784\u4f53\u4f5c\u4e3a\u53c2\u6570\uff0c\u7528\u4ee5\u6307\u5b9a command pool \u548c\u7f13\u51b2\u533a\u5c06\u4f1a\u5206\u914d\u7684\u5927\u5c0f: VkCommandBufferAllocateInfo allocInfo = {}; allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; allocInfo.commandPool = commandPool; allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; allocInfo.commandBufferCount = (uint32_t) commandBuffers.size(); if (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.data()) != VK_SUCCESS) { throw std::runtime_error(\"failed to allocate command buffers!\"); } level \u53c2\u6570\u6307\u5b9a\u5206\u914d\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u4e3b\u4ece\u5173\u7cfb\u3002 VK_COMMAND_BUFFER_LEVEL_PRIMARY : \u53ef\u4ee5\u63d0\u4ea4\u5230\u961f\u5217\u6267\u884c\uff0c\u4f46\u4e0d\u80fd\u4ece\u5176\u4ed6\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u8c03\u7528\u3002 VK_COMMAND_BUFFER_LEVEL_SECONDARY : \u65e0\u6cd5\u76f4\u63a5\u63d0\u4ea4\uff0c\u4f46\u662f\u53ef\u4ee5\u4ece\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u8c03\u7528\u3002 \u6211\u4eec\u4e0d\u4f1a\u5728\u8fd9\u91cc\u4f7f\u7528\u8f85\u52a9\u7f13\u51b2\u533a\u529f\u80fd\uff0c\u4f46\u662f\u53ef\u4ee5\u60f3\u50cf\uff0c\u5bf9\u4e8e\u590d\u7528\u4e3b\u7f13\u51b2\u533a\u7684\u5e38\u7528\u64cd\u4f5c\u5f88\u6709\u5e2e\u52a9\u3002","title":"\u5206\u914d\u547d\u4ee4\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_46","text":"\u901a\u8fc7 vkBeginCommandBuffer \u6765\u5f00\u542f\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u8bb0\u5f55\u529f\u80fd\uff0c\u8be5\u51fd\u6570\u9700\u8981\u4f20\u9012 VkCommandBufferBeginInfo \u7ed3\u6784\u4f53\u4f5c\u4e3a\u53c2\u6570\uff0c\u7528\u4ee5\u6307\u5b9a\u547d\u4ee4\u7f13\u51b2\u533a\u5728\u4f7f\u7528\u8fc7\u7a0b\u4e2d\u7684\u4e00\u4e9b\u5177\u4f53\u4fe1\u606f\u3002 for (size_t i = 0; i < commandBuffers.size(); i++) { VkCommandBufferBeginInfo beginInfo = {}; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT; beginInfo.pInheritanceInfo = nullptr; // Optional vkBeginCommandBuffer(commandBuffers[i], &beginInfo); } flags \u6807\u5fd7\u4f4d\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u5982\u4f55\u4f7f\u7528\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u53ef\u9009\u7684\u53c2\u6570\u7c7b\u578b\u5982\u4e0b: VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT : \u547d\u4ee4\u7f13\u51b2\u533a\u5c06\u5728\u6267\u884c\u4e00\u6b21\u540e\u7acb\u5373\u91cd\u65b0\u8bb0\u5f55\u3002 VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT : \u8fd9\u662f\u4e00\u4e2a\u8f85\u52a9\u7f13\u51b2\u533a\uff0c\u5b83\u9650\u5236\u5728\u5728\u4e00\u4e2a\u6e32\u67d3\u901a\u9053\u4e2d\u3002 VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT : \u547d\u4ee4\u7f13\u51b2\u533a\u4e5f\u53ef\u4ee5\u91cd\u65b0\u63d0\u4ea4\uff0c\u540c\u65f6\u5b83\u4e5f\u5728\u7b49\u5f85\u6267\u884c\u3002 \u6211\u4eec\u4f7f\u7528\u4e86\u6700\u540e\u4e00\u4e2a\u6807\u5fd7\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u80fd\u5df2\u7ecf\u5728\u4e0b\u4e00\u5e27\u7684\u65f6\u5019\u5b89\u6392\u4e86\u7ed8\u5236\u547d\u4ee4\uff0c\u800c\u6700\u540e\u4e00\u5e27\u5c1a\u672a\u5b8c\u6210\u3002 pInheritanceInfo \u53c2\u6570\u4e0e\u8f85\u52a9\u7f13\u51b2\u533a\u76f8\u5173\u3002\u5b83\u6307\u5b9a\u4ece\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u7ee7\u627f\u7684\u72b6\u6001\u3002 \u5982\u679c\u547d\u4ee4\u7f13\u51b2\u533a\u5df2\u7ecf\u88ab\u8bb0\u5f55\u4e00\u6b21\uff0c\u90a3\u4e48\u8c03\u7528 vkBeginCommandBuffer \u4f1a\u9690\u5f0f\u5730\u91cd\u7f6e\u5b83\u3002\u5426\u5219\u5c06\u547d\u4ee4\u9644\u52a0\u5230\u7f13\u51b2\u533a\u662f\u4e0d\u53ef\u80fd\u7684\u3002","title":"\u542f\u52a8\u547d\u4ee4\u7f13\u51b2\u8bb0\u5f55"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_47","text":"\u7ed8\u5236\u5f00\u59cb\u4e8e\u8c03\u7528 vkCmdBeginRenderPass \u5f00\u542f\u6e32\u67d3\u901a\u9053\u3002render pass\u4f7f\u7528 VkRenderPassBeginInfo \u7ed3\u6784\u4f53\u586b\u5145\u914d\u7f6e\u4fe1\u606f\u4f5c\u4e3a\u8c03\u7528\u65f6\u4f7f\u7528\u7684\u53c2\u6570\u3002 VkRenderPassBeginInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; renderPassInfo.renderPass = renderPass; renderPassInfo.framebuffer = swapChainFramebuffers[i]; \u7ed3\u6784\u4f53\u7b2c\u4e00\u4e2a\u53c2\u6570\u4f20\u9012\u4e3a\u7ed1\u5b9a\u5230\u5bf9\u5e94\u9644\u4ef6\u7684\u6e32\u67d3\u901a\u9053\u672c\u8eab\u3002\u6211\u4eec\u4e3a\u6bcf\u4e00\u4e2a\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u521b\u5efa\u5e27\u7f13\u51b2\u533a\uff0c\u5e76\u6307\u5b9a\u4e3a\u989c\u8272\u9644\u4ef6\u3002 renderPassInfo.renderArea.offset = {0, 0}; renderPassInfo.renderArea.extent = swapChainExtent; \u540e\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u4e86\u6e32\u67d3\u533a\u57df\u7684\u5927\u5c0f\u3002\u6e32\u67d3\u533a\u57df\u5b9a\u4e49\u7740\u8272\u5668\u52a0\u8f7d\u548c\u5b58\u50a8\u5c06\u8981\u53d1\u751f\u7684\u4f4d\u7f6e\u3002\u533a\u57df\u5916\u7684\u50cf\u7d20\u5c06\u5177\u6709\u672a\u5b9a\u7684\u503c\u3002\u4e3a\u4e86\u6700\u4f73\u7684\u6027\u80fd\u5b83\u7684\u5c3a\u5bf8\u5e94\u8be5\u4e0e\u9644\u4ef6\u5339\u914d\u3002 VkClearValue clearColor = {0.0f, 0.0f, 0.0f, 1.0f}; renderPassInfo.clearValueCount = 1; renderPassInfo.pClearValues = &clearColor; \u6700\u540e\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u4e86\u7528\u4e8e VK_ATTACHMENT_LOAD_OP_CLEAR \u7684\u6e05\u9664\u503c\uff0c\u6211\u4eec\u5c06\u5176\u7528\u4f5c\u989c\u8272\u9644\u4ef6\u7684\u52a0\u8f7d\u64cd\u4f5c\u3002\u4e3a\u4e86\u7b80\u5316\u64cd\u4f5c\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86 clear color \u4e3a100%\u9ed1\u8272\u3002 vkCmdBeginRenderPass(commandBuffers[i], &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE); \u6e32\u67d3\u901a\u9053\u73b0\u5728\u53ef\u4ee5\u542f\u7528\u3002\u6240\u6709\u53ef\u4ee5\u88ab\u8bb0\u5f55\u7684\u547d\u4ee4\uff0c\u88ab\u8bc6\u522b\u7684\u524d\u63d0\u662f\u4f7f\u7528 vkCmd \u524d\u7f00\u3002\u5b83\u4eec\u5168\u90e8\u8fd4\u56de void \uff0c\u6240\u4ee5\u5728\u7ed3\u675f\u8bb0\u5f55\u4e4b\u524d\u4e0d\u4f1a\u6709\u4efb\u4f55\u9519\u8bef\u5904\u7406\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u547d\u4ee4\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u603b\u662f\u8bb0\u5f55\u8be5\u547d\u4ee4\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u7b2c\u4e8c\u4e2a\u53c2\u6570\u6307\u5b9a\u6211\u4eec\u4f20\u9012\u7684\u6e32\u67d3\u901a\u9053\u7684\u5177\u4f53\u4fe1\u606f\u3002\u6700\u540e\u7684\u53c2\u6570\u63a7\u5236\u5982\u4f55\u63d0\u4f9b render pass \u5c06\u8981\u5e94\u7528\u7684\u7ed8\u5236\u547d\u4ee4\u3002\u5b83\u4f7f\u7528\u4ee5\u4e0b\u6570\u503c\u4efb\u610f\u4e00\u4e2a: VK_SUBPASS_CONTENTS_INLINE : \u6e32\u67d3\u8fc7\u7a0b\u547d\u4ee4\u88ab\u5d4c\u5165\u5728\u4e3b\u547d\u4ee4\u7f13\u51b2\u533a\u4e2d\uff0c\u6ca1\u6709\u8f85\u52a9\u7f13\u51b2\u533a\u6267\u884c\u3002 VK_SUBPASS_CONTENTS_SECONDARY_COOMAND_BUFFERS : \u6e32\u67d3\u901a\u9053\u547d\u4ee4\u5c06\u4f1a\u4ece\u8f85\u52a9\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u3002 \u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u8f85\u52a9\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u7b2c\u4e00\u4e2a\u3002","title":"\u542f\u52a8\u6e32\u67d3\u901a\u9053"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_48","text":"\u73b0\u5728\u6211\u4eec\u7ed1\u5b9a\u56fe\u5f62\u7ba1\u7ebf: vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline); \u7b2c\u4e8c\u4e2a\u53c2\u6570\u6307\u5b9a\u5177\u4f53\u7ba1\u7ebf\u7c7b\u578b\uff0c graphics or compute pipeline \u3002\u6211\u4eec\u544a\u8bc9Vulkan\u5728\u56fe\u5f62\u7ba1\u7ebf\u4e2d\u6bcf\u4e00\u4e2a\u64cd\u4f5c\u5982\u4f55\u6267\u884c\u53ca\u54ea\u4e2a\u9644\u4ef6\u5c06\u4f1a\u5728\u7247\u6bb5\u7740\u8272\u5668\u4e2d\u4f7f\u7528\uff0c\u6240\u4ee5\u5269\u4e0b\u7684\u5c31\u662f\u544a\u8bc9\u5b83\u7ed8\u5236\u4e09\u89d2\u5f62\u3002 vkCmdDraw(commandBuffers[i], 3, 1, 0, 0); C++ \u5b9e\u9645\u7684 vkCmdDraw \u51fd\u6570\u6709\u70b9\u4e0e\u5b57\u9762\u610f\u601d\u4e0d\u4e00\u81f4\uff0c\u5b83\u662f\u5982\u6b64\u7b80\u5355\uff0c\u4ec5\u56e0\u4e3a\u6211\u4eec\u63d0\u524d\u6307\u5b9a\u6240\u6709\u6e32\u67d3\u76f8\u5173\u7684\u4fe1\u606f\u3002\u5b83\u6709\u5982\u4e0b\u7684\u53c2\u6570\u9700\u8981\u6307\u5b9a\uff0c\u9664\u4e86\u547d\u4ee4\u7f13\u51b2\u533a: vertexCount : \u5373\u4f7f\u6211\u4eec\u6ca1\u6709\u9876\u70b9\u7f13\u51b2\u533a\uff0c\u4f46\u662f\u6211\u4eec\u4ecd\u7136\u67093\u4e2a\u5b9a\u70b9\u9700\u8981\u7ed8\u5236\u3002 instanceCount : \u7528\u4e8einstanced \u6e32\u67d3\uff0c\u5982\u679c\u6ca1\u6709\u4f7f\u7528\u8bf7\u586b1\u3002 firstVertex : \u4f5c\u4e3a\u9876\u70b9\u7f13\u51b2\u533a\u7684\u504f\u79fb\u91cf\uff0c\u5b9a\u4e49gl_VertexIndex\u7684\u6700\u5c0f\u503c\u3002 firstInstance : \u4f5c\u4e3ainstanced \u6e32\u67d3\u7684\u504f\u79fb\u91cf\uff0c\u5b9a\u4e49\u4e86gl_InstanceIndex\u7684\u6700\u5c0f\u503c\u3002","title":"\u57fa\u672c\u7ed8\u56fe\u547d\u4ee4"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_49","text":"render pass \u6267\u884c\u5b8c\u7ed8\u5236\uff0c\u53ef\u4ee5\u7ed3\u675f\u6e32\u67d3\u4f5c\u4e1a: vkCmdEndRenderPass(commandBuffers[i]); C++ \u5e76\u505c\u6b62\u8bb0\u5f55\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u5de5\u4f5c: if (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) { throw std::runtime_error(\"failed to record command buffer!\"); } C++ \u5728\u4e0b\u4e00\u7ae0\u8282\u6211\u4eec\u4f1a\u5c1d\u8bd5\u5728 main loop \u4e2d\u7f16\u5199\u4ee3\u7801\uff0c\u7528\u4e8e\u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u56fe\u50cf\uff0c\u6267\u884c\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u547d\u4ee4\uff0c\u518d\u5c06\u6e32\u67d3\u540e\u7684\u56fe\u50cf\u8fd4\u8fd8\u7ed9\u4ea4\u6362\u94fe\u3002","title":"\u7ed3\u675f\u6e32\u67d3"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_13","text":"Vulkan \u6e32\u67d3\u548c\u663e\u793a \uff0c\u8fd9\u4e00\u7ae0\u8282\u4f1a\u628a\u4e4b\u524d\u7684\u6240\u6709\u5185\u5bb9\u8fdb\u884c\u6574\u5408\uff0c\u6211\u4eec\u5c06\u4f1a\u7f16\u5199 drawFrame \u51fd\u6570\uff0c\u901a\u8fc7\u4e3b\u5faa\u73af main loop \u5c06\u4e09\u89d2\u5f62\u7ed8\u5236\u5230\u5c4f\u5e55\u3002 drawFrame \u51fd\u6570\u5c06\u4f1a\u6267\u884c\u5982\u4e0b\u64cd\u4f5c: \u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u4e00\u4e2a\u56fe\u50cf \u5728\u5e27\u7f13\u51b2\u533a\u4e2d\uff0c\u4f7f\u7528\u4f5c\u4e3a\u9644\u4ef6\u7684\u56fe\u50cf\u6765\u6267\u884c\u547d\u4ee4\u7f13\u51b2\u533a\u4e2d\u7684\u547d\u4ee4 \u4e3a\u4e86\u6700\u7ec8\u5448\u73b0\uff0c\u5c06\u56fe\u50cf\u8fd4\u8fd8\u5230\u4ea4\u6362\u94fe \u6bcf\u4e2a\u4e8b\u4ef6\u6d3e\u53d1\u90fd\u6709\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u6765\u5bf9\u5e94\uff0c\u4f46\u5b83\u4eec\u7684\u6267\u884c\u662f\u5f02\u6b65\u7684\u3002\u51fd\u6570\u8c03\u7528\u5c06\u5728\u64cd\u4f5c\u5b9e\u9645\u5b8c\u6210\u4e4b\u524d\u8fd4\u56de\uff0c\u5e76\u4e14\u6267\u884c\u987a\u5e8f\u4e5f\u662f\u672a\u5b9a\u4e49\u7684\u3002\u8fd9\u662f\u4e0d\u7406\u60f3\u7684\uff0c\u56e0\u4e3a\u6bcf\u4e00\u4e2a\u64cd\u4f5c\u90fd\u53d6\u51b3\u4e8e\u524d\u4e00\u4e2a\u64cd\u4f5c\u3002 \u5728 mainLoop \u51fd\u6570\u8c03\u7528: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); drawFrame(); } } ... void drawFrame() { } C++ \u540c\u6b65\u4ea4\u6362\u94fe\u4e8b\u4ef6\u6709\u4e24\u79cd\u65b9\u6cd5:\u6805\u680f\u548c\u4fe1\u53f7\u91cf\u3002\u5b83\u4eec\u90fd\u662f\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u4e00\u4e2a\u64cd\u4f5c\u4fe1\u53f7\uff0c\u8d1f\u8d23\u534f\u8c03\u64cd\u4f5c\u7684\u5bf9\u8c61\u3002\u53e6\u4e00\u4e2a\u64cd\u4f5c\u7b49\u5f85\u6805\u680f\u6216\u8005\u4fe1\u53f7\u91cf\u4ece\u65e0\u4fe1\u53f7\u72b6\u6001\u8f6c\u53d8\u5230\u6709\u4fe1\u53f7\u72b6\u6001\u3002 \u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u53ef\u4ee5\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u8c03\u7528 vkWaitForFence \u8fdb\u5165\u6805\u680f\u72b6\u6001\uff0c\u800c\u4fe1\u53f7\u91cf\u4e0d\u53ef\u4ee5\u3002\u6805\u680f\u4e3b\u8981\u7528\u4e8e\u5e94\u7528\u7a0b\u5e8f\u81ea\u8eab\u4e0e\u6e32\u67d3\u64cd\u4f5c\u8fdb\u884c\u540c\u6b65\uff0c\u800c\u4fe1\u53f7\u91cf\u7528\u4e8e\u5728\u547d\u4ee4\u961f\u5217\u5185\u6216\u8005\u8de8\u547d\u4ee4\u961f\u5217\u540c\u6b65\u64cd\u4f5c\u3002\u6211\u4eec\u671f\u671b\u540c\u6b65\u7ed8\u5236\u4e0e\u5448\u73b0\u7684\u961f\u5217\u64cd\u4f5c\uff0c\u6240\u4ee5\u4f7f\u7528\u4fe1\u53f7\u91cf\u6700\u5408\u9002\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u4fe1\u53f7\u91cf 2 \u4ece\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf 3 \u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a 4 Subpass \u4f9d\u8d56\u6027 5 \u5448\u73b0 6 \u5185\u5b58\u6cc4\u6f0f 7 \u7ed3\u8bba","title":"Vulkan \u6e32\u67d3\u548c\u663e\u793a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_50","text":"\u5728\u83b7\u5f97\u4e00\u4e2a\u56fe\u50cf\u65f6\uff0c\u6211\u4eec\u9700\u8981\u53d1\u51fa\u4e00\u4e2a\u4fe1\u53f7\u91cf\u51c6\u5907\u8fdb\u884c\u6e32\u67d3\uff0c\u53e6\u4e00\u4e2a\u4fe1\u53f7\u91cf\u7684\u53d1\u51fa\u7528\u4e8e\u6e32\u67d3\u7ed3\u675f\uff0c\u51c6\u5907\u8fdb\u884c\u5448\u73b0presentation\u3002\u521b\u5efa\u4e24\u4e2a\u6210\u5458\u53d8\u91cf\u5b58\u50a8\u4fe1\u53f7\u91cf\u5bf9\u8c61: VkSemaphore imageAvailableSemaphore; VkSemaphore renderFinishedSemaphore; C++ \u4e3a\u4e86\u521b\u5efa\u4fe1\u53f7\u91cfsemaphores\uff0c\u6211\u4eec\u5c06\u8981\u65b0\u589e\u672c\u7cfb\u5217\u6559\u7a0b\u6700\u540e\u4e00\u4e2a\u51fd\u6570: createSemaphores : void initVulkan() { createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); createSemaphores(); } ... void createSemaphores() { } C++ \u521b\u5efa\u4fe1\u53f7\u91cf\u5bf9\u8c61\u9700\u8981\u586b\u5145 VkSemaphoreCreateInfo \u7ed3\u6784\u4f53\uff0c\u4f46\u662f\u5728\u5f53\u524d\u7248\u672c\u7684 API \u4e2d\uff0c\u5b9e\u9645\u4e0a\u4e0d\u9700\u8981\u586b\u5145\u4efb\u4f55\u5b57\u6bb5\uff0c\u9664 sType : void createSemaphores() { VkSemaphoreCreateInfo semaphoreInfo = {}; semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; } C++ Vulkan API\u672a\u6765\u7248\u672c\u6216\u8005\u6269\u5c55\u4e2d\u6216\u8bb8\u4f1a\u4e3a flags \u548c pNext \u53c2\u6570\u589e\u52a0\u529f\u80fd\u9009\u9879\u3002\u521b\u5efa\u4fe1\u53f7\u91cf\u5bf9\u8c61\u7684\u8fc7\u7a0b\u5f88\u719f\u6089\u4e86\uff0c\u5728\u8fd9\u91cc\u4f7f\u7528 vkCreateSemaphore : if (vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphore) != VK_SUCCESS || vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphore) != VK_SUCCESS) { throw std::runtime_error(\"failed to create semaphores!\"); } C++ \u5728\u7a0b\u5e8f\u7ed3\u675f\u65f6\uff0c\u5f53\u6240\u6709\u547d\u4ee4\u5b8c\u6210\u5e76\u4e0d\u9700\u8981\u540c\u6b65\u65f6\uff0c\u5e94\u8be5\u6e05\u9664\u4fe1\u53f7\u91cf: void cleanup() { vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); C++","title":"\u4fe1\u53f7\u91cf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_51","text":"\u5c31\u50cf\u4e4b\u524d\u8bf4\u5230\u7684\uff0c drawFrame \u51fd\u6570\u9700\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\u4ece\u4ea4\u6362\u94fe\u4e2d\u83b7\u53d6\u56fe\u50cf\u3002\u56de\u60f3\u4e00\u4e0b\u4ea4\u6362\u94fe\u662f\u4e00\u4e2a\u6269\u5c55\u529f\u80fd\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u4f7f\u7528\u5177\u6709vk*KHR\u547d\u540d\u7ea6\u5b9a\u7684\u51fd\u6570: void drawFrame() { uint32_t imageIndex; vkAcquireNextImageKHR(device, swapChain, std::numeric_limits<uint64_t>::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex); } C++ vkAcquireNextImageKHR \u51fd\u6570\u524d\u4e24\u4e2a\u53c2\u6570\u662f\u6211\u4eec\u5e0c\u671b\u83b7\u53d6\u5230\u56fe\u50cf\u7684\u903b\u8f91\u8bbe\u5907\u548c\u4ea4\u6362\u94fe\u3002\u7b2c\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u83b7\u53d6\u6709\u6548\u56fe\u50cf\u7684\u64cd\u4f5ctimeout\uff0c\u5355\u4f4d\u7eb3\u79d2\u3002\u6211\u4eec\u4f7f\u752864\u4f4d\u65e0\u7b26\u53f7\u6700\u5927\u503c\u7981\u6b62 timeout \u3002 \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u4f7f\u7528\u7684\u540c\u6b65\u5bf9\u8c61\uff0c\u5f53 presentation \u5f15\u64ce\u5b8c\u6210\u4e86\u56fe\u50cf\u7684\u5448\u73b0\u540e\u4f1a\u4f7f\u7528\u8be5\u5bf9\u8c61\u53d1\u8d77\u4fe1\u53f7\u3002\u8fd9\u5c31\u662f\u5f00\u59cb\u7ed8\u5236\u7684\u65f6\u95f4\u70b9\u3002\u5b83\u53ef\u4ee5\u6307\u5b9a\u4e00\u4e2a\u4fe1\u53f7\u91cf semaphore \u6216\u8005\u6805\u680f\u6216\u8005\u4e24\u8005\u3002\u51fa\u4e8e\u76ee\u7684\u6027\uff0c\u6211\u4eec\u4f1a\u4f7f\u7528 imageAvailableSemaphore \u3002 \u6700\u540e\u7684\u53c2\u6570\u6307\u5b9a\u4ea4\u6362\u94fe\u4e2d\u6210\u4e3a available \u72b6\u6001\u7684\u56fe\u50cf\u5bf9\u5e94\u7684\u7d22\u5f15\u3002\u5176\u4e2d\u7d22\u5f15\u4f1a\u5f15\u7528\u4ea4\u6362\u94fe\u56fe\u50cf\u6570\u7ec4 swapChainImages \u7684\u56fe\u50cf VkImage \u3002\u6211\u4eec\u4f7f\u7528\u8fd9\u4e2a\u7d22\u5f15\u9009\u62e9\u6b63\u786e\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002","title":"\u4ece\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_52","text":"\u961f\u5217\u63d0\u4ea4\u548c\u540c\u6b65\u901a\u8fc7 VkSubmitInfo \u7ed3\u6784\u4f53\u8fdb\u884c\u53c2\u6570\u914d\u7f6e\u3002 VkSubmitInfo submitInfo = {}; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; VkSemaphore waitSemaphores[] = {imageAvailableSemaphore}; VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT}; submitInfo.waitSemaphoreCount = 1; submitInfo.pWaitSemaphores = waitSemaphores; submitInfo.pWaitDstStageMask = waitStages; C++ \u524d\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u5728\u6267\u884c\u5f00\u59cb\u4e4b\u524d\u8981\u7b49\u5f85\u7684\u54ea\u4e2a\u4fe1\u53f7\u91cf\u53ca\u8981\u7b49\u5f85\u7684\u901a\u9053\u7684\u54ea\u4e2a\u9636\u6bb5\u3002\u4e3a\u4e86\u5411\u56fe\u50cf\u5199\u5165\u989c\u8272\uff0c\u6211\u4eec\u4f1a\u7b49\u5f85\u56fe\u50cf\u72b6\u6001\u53d8\u4e3a available \uff0c\u6240\u6211\u4eec\u6307\u5b9a\u5199\u5165\u989c\u8272\u9644\u4ef6\u7684\u56fe\u5f62\u7ba1\u7ebf\u9636\u6bb5\u3002\u7406\u8bba\u4e0a\u8fd9\u610f\u5473\u7740\uff0c\u5177\u4f53\u7684\u9876\u70b9\u7740\u8272\u5668\u5f00\u59cb\u6267\u884c\uff0c\u800c\u56fe\u50cf\u4e0d\u53ef\u7528\u3002 waitStages \u6570\u7ec4\u5bf9\u5e94 pWaitSemaphores \u4e2d\u5177\u6709\u76f8\u540c\u7d22\u5f15\u7684\u4fe1\u53f7\u91cf\u3002 submitInfo.commandBufferCount = 1; submitInfo.pCommandBuffers = &commandBuffers[imageIndex]; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u54ea\u4e2a\u547d\u4ee4\u7f13\u51b2\u533a\u88ab\u5b9e\u9645\u63d0\u4ea4\u6267\u884c\u3002\u5982\u521d\u671f\u63d0\u5230\u7684\uff0c\u6211\u4eec\u5e94\u8be5\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a\uff0c\u5b83\u5c06\u6211\u4eec\u521a\u83b7\u53d6\u7684\u4ea4\u6362\u94fe\u56fe\u50cf\u505a\u4e3a\u989c\u8272\u9644\u4ef6\u8fdb\u884c\u7ed1\u5b9a\u3002 VkSemaphore signalSemaphores[] = {renderFinishedSemaphore}; submitInfo.signalSemaphoreCount = 1; submitInfo.pSignalSemaphores = signalSemaphores; C++ signalSemaphoreCount \u548c pSignalSemaphores \u53c2\u6570\u6307\u5b9a\u4e86\u5f53\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u7ed3\u675f\u5411\u54ea\u4e9b\u4fe1\u53f7\u91cf\u53d1\u51fa\u4fe1\u53f7\u3002\u6839\u636e\u6211\u4eec\u7684\u9700\u8981\u4f7f\u7528 renderFinishedSemaphore \u3002 if (vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE) != VK_SUCCESS) { throw std::runtime_error(\"failed to submit draw command buffer!\"); } C++ \u4f7f\u7528 vkQueueSubmit \u51fd\u6570\u5411\u56fe\u50cf\u961f\u5217\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u5f53\u5f00\u9500\u8d1f\u8f7d\u6bd4\u8f83\u5927\u7684\u65f6\u5019\uff0c\u5904\u4e8e\u6548\u7387\u8003\u8651\uff0c\u51fd\u6570\u53ef\u4ee5\u6301\u6709 VkSubmitInfo \u7ed3\u6784\u4f53\u6570\u7ec4\u3002\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u5f15\u7528\u4e86\u4e00\u4e2a\u53ef\u9009\u7684\u6805\u680f\uff0c\u5f53\u547d\u4ee4\u7f13\u51b2\u533a\u6267\u884c\u5b8c\u6bd5\u65f6\u5019\u5b83\u4f1a\u88ab\u53d1\u9001\u4fe1\u53f7\u3002\u6211\u4eec\u4f7f\u7528\u4fe1\u53f7\u91cf\u8fdb\u884c\u540c\u6b65\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4f20\u9012 VK_NULL_HANDLE \u3002","title":"\u63d0\u4ea4\u547d\u4ee4\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#subpass","text":"\u8bf7\u8bb0\u4f4f\uff0c\u6e32\u67d3\u901a\u9053\u4e2d\u7684\u5b50\u901a\u9053\u4f1a\u81ea\u52a8\u5904\u7406\u5e03\u5c40\u7684\u53d8\u6362\u3002\u8fd9\u4e9b\u53d8\u6362\u901a\u8fc7\u5b50\u901a\u9053\u7684\u4f9d\u8d56\u5173\u7cfb\u8fdb\u884c\u63a7\u5236\uff0c\u5b83\u4eec\u6307\u5b9a\u4e86\u5f7c\u6b64\u4e4b\u95f4\u5185\u5b58\u548c\u6267\u884c\u7684\u4f9d\u8d56\u5173\u7cfb\u3002\u73b0\u5728\u53ea\u6709\u4e00\u4e2a\u5b50\u901a\u9053\uff0c\u4f46\u662f\u5728\u6b64\u5b50\u901a\u9053\u4e4b\u524d\u548c\u4e4b\u540e\u7684\u64cd\u4f5c\u4e5f\u88ab\u89c6\u4e3a\u9690\u5f0f\u201c\u5b50\u901a\u9053\u201d\u3002 \u6709\u4e24\u4e2a\u5185\u7f6e\u7684\u4f9d\u8d56\u5173\u7cfb\u5728\u6e32\u67d3\u901a\u9053\u5f00\u59cb\u548c\u6e32\u67d3\u901a\u9053\u7ed3\u675f\u5904\u7406\u8f6c\u6362\uff0c\u4f46\u662f\u524d\u8005\u4e0d\u4f1a\u5728\u5f53\u4e0b\u53d1\u751f\u3002\u5047\u8bbe\u8f6c\u6362\u53d1\u751f\u5728\u7ba1\u7ebf\u7684\u8d77\u59cb\u9636\u6bb5\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u83b7\u53d6\u56fe\u50cf\uff01\u6709\u4e24\u4e2a\u65b9\u6cd5\u5904\u7406\u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u5c06 imageAvailableSemaphore \u7684 waitStages \u66f4\u6539\u4e3a VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT \uff0c\u786e\u4fdd\u56fe\u50cf\u6709\u6548\u4e4b\u524d\u6e32\u67d3\u901a\u9053\u4e0d\u4f1a\u5f00\u59cb\uff0c\u6216\u8005\u6211\u4eec\u8ba9\u6e32\u67d3\u901a\u9053\u7b49\u5f85 VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT \u9636\u6bb5\u3002\u6211\u89c9\u5f97\u4f7f\u7528\u7b2c\u4e8c\u4e2a\u9009\u9879\uff0c\u56e0\u4e3a\u53ef\u4ee5\u6bd4\u8f83\u5168\u9762\u7684\u4e86\u89e3 subpass \u4f9d\u8d56\u5173\u7cfb\u53ca\u5176\u5de5\u4f5c\u65b9\u5f0f\u3002 \u5b50\u901a\u9053\u4f9d\u8d56\u5173\u7cfb\u53ef\u4ee5\u901a\u8fc7 VkSubpassDependency \u7ed3\u6784\u4f53\u6307\u5b9a\uff0c\u5728 createRenderPass \u51fd\u6570\u4e2d\u6dfb\u52a0: VkSubpassDependency dependency = {}; dependency.srcSubpass = VK_SUBPASS_EXTERNAL; dependency.dstSubpass = 0; C++ \u524d\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u4f9d\u8d56\u7684\u5173\u7cfb\u548c\u4ece\u5c5e\u5b50\u901a\u9053\u7684\u7d22\u5f15\u3002\u7279\u6b8a\u503c VK_SUBPASS_EXTERNAL \u662f\u6307\u5728\u6e32\u67d3\u901a\u9053\u4e4b\u524d\u6216\u8005\u4e4b\u540e\u7684\u9690\u5f0f\u5b50\u901a\u9053\uff0c\u53d6\u51b3\u4e8e\u5b83\u662f\u5426\u5728 srcSubpass \u6216\u8005 dstSubPass \u4e2d\u6307\u5b9a\u3002\u7d22\u5f150\u6307\u5b9a\u6211\u4eec\u7684\u5b50\u901a\u9053\uff0c\u8fd9\u662f\u7b2c\u4e00\u4e2a\u4e5f\u662f\u552f\u4e00\u7684\u3002 dstSubpass \u5fc5\u987b\u59cb\u7ec8\u9ad8\u4e8e srcSubPass \u4ee5\u9632\u6b62\u4f9d\u8d56\u5173\u7cfb\u51fa\u73b0\u5faa\u73af\u3002 dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.srcAccessMask = 0; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u5b57\u6bb5\u6307\u5b9a\u8981\u7b49\u5f85\u7684\u64cd\u4f5c\u548c\u8fd9\u4e9b\u64cd\u4f5c\u53d1\u751f\u7684\u9636\u6bb5\u3002\u5728\u6211\u4eec\u53ef\u4ee5\u8bbf\u95ee\u5bf9\u8c61\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u7b49\u5f85\u4ea4\u6362\u94fe\u5b8c\u6210\u5bf9\u5e94\u56fe\u50cf\u7684\u8bfb\u53d6\u64cd\u4f5c\u3002\u8fd9\u53ef\u4ee5\u901a\u8fc7\u7b49\u5f85\u989c\u8272\u9644\u4ef6\u8f93\u51fa\u7684\u9636\u6bb5\u6765\u5b9e\u73b0\u3002 dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; C++ \u5728\u989c\u8272\u9644\u4ef6\u9636\u6bb5\u7684\u64cd\u4f5c\u53ca\u6d89\u53ca\u989c\u8272\u9644\u4ef6\u7684\u8bfb\u53d6\u548c\u5199\u5165\u7684\u64cd\u4f5c\u5e94\u8be5\u7b49\u5f85\u3002\u8fd9\u4e9b\u8bbe\u7f6e\u5c06\u963b\u6b62\u8f6c\u6362\u53d1\u751f\uff0c\u76f4\u5230\u5b9e\u9645\u9700\u8981(\u5e76\u5141\u8bb8):\u5f53\u6211\u4eec\u9700\u8981\u5199\u5165\u989c\u8272\u65f6\u5019\u3002 renderPassInfo.dependencyCount = 1; renderPassInfo.pDependencies = &dependency; C++ VkRenderPassCreateInfo \u7ed3\u6784\u4f53\u6709\u4e24\u4e2a\u5b57\u6bb5\u6307\u5b9a\u4f9d\u8d56\u7684\u6570\u7ec4\u3002","title":"Subpass \u4f9d\u8d56\u6027"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_53","text":"\u7ed8\u5236\u5e27\u6700\u540e\u4e00\u4e2a\u6b65\u9aa4\u662f\u5c06\u7ed3\u679c\u63d0\u4ea4\u5230\u4ea4\u6362\u94fe\uff0c\u4f7f\u5176\u6700\u7ec8\u663e\u793a\u5728\u5c4f\u5e55\u4e0a\u3002 Presentation \u901a\u8fc7 VkPresentInfoKHR \u7ed3\u6784\u4f53\u914d\u7f6e\uff0c\u5177\u4f53\u4f4d\u7f6e\u5728 drawFrame \u51fd\u6570\u6700\u540e\u3002 VkPresentInfoKHR presentInfo = {}; presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR; presentInfo.waitSemaphoreCount = 1; presentInfo.pWaitSemaphores = signalSemaphores; C++ \u524d\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u5728\u8fdb\u884cpresentation\u4e4b\u524d\u8981\u7b49\u5f85\u7684\u4fe1\u53f7\u91cf\uff0c\u5c31\u50cf VkSubmitInfo \u4e00\u6837\u3002 VkSwapchainKHR swapChains[] = {swapChain}; presentInfo.swapchainCount = 1; presentInfo.pSwapchains = swapChains; presentInfo.pImageIndices = &imageIndex; C++ \u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u6307\u5b9a\u7528\u4e8e\u63d0\u4ea4\u56fe\u50cf\u7684\u4ea4\u6362\u94fe\u548c\u6bcf\u4e2a\u4ea4\u6362\u94fe\u56fe\u50cf\u7d22\u5f15\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4ec5\u4e00\u4e2a\u3002 presentInfo.pResults = nullptr; // Optional C++ \u6700\u540e\u4e00\u4e2a\u53ef\u9009\u53c2\u6570 pResults \uff0c\u5b83\u5141\u8bb8\u6307\u5b9a\u4e00\u7ec4 VkResult \u503c\uff0c\u4ee5\u4fbf\u5728 presentation \u6210\u529f\u65f6\u68c0\u67e5\u6bcf\u4e2a\u72ec\u7acb\u7684\u4ea4\u6362\u94fe\u3002\u5982\u679c\u53ea\u4f7f\u7528\u5355\u4e2a\u4ea4\u6362\u94fe\uff0c\u5219\u4e0d\u9700\u8981\uff0c\u56e0\u4e3a\u53ef\u4ee5\u7b80\u5355\u7684\u4f7f\u7528\u5f53\u524d\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002 vkQueuePresentKHR(presentQueue, &presentInfo); C++ vkQueuePresentKHR \u51fd\u6570\u63d0\u4ea4\u8bf7\u6c42\u5448\u73b0\u4ea4\u6362\u94fe\u4e2d\u7684\u56fe\u50cf\u3002\u6211\u4eec\u5728\u4e0b\u4e00\u4e2a\u7ae0\u8282\u4e3a vkAcquireNextImageKHR \u548c vkQueuePresentKHR \u53ef\u4ee5\u6dfb\u52a0\u9519\u8bef\u5904\u7406\u3002\u56e0\u4e3a\u5b83\u4eec\u5931\u8d25\u5e76\u4e0d\u4e00\u5b9a\u610f\u5473\u7740\u7a0b\u5e8f\u5e94\u8be5\u7ec8\u6b62\uff0c\u4e0e\u6211\u4eec\u8fc4\u4eca\u4e3a\u6b62\u770b\u5230\u7684\u529f\u80fd\u4e0d\u540c\u3002 \u5982\u679c\u4e00\u5207\u987a\u5229\uff0c\u5f53\u518d\u6b21\u8fd0\u884c\u7a0b\u5e8f\u65f6\u5019\uff0c\u5e94\u8be5\u53ef\u4ee5\u770b\u5230\u4e00\u4e0b\u5185\u5bb9: \u9057\u61be\u7684\u662f\uff0c\u53ea\u8981\u7a0b\u5e8f\u5173\u95ed\uff0c\u7531\u4e8e\u5f00\u542f\u4e86validation layers\u4f60\u5c06\u4f1a\u770b\u5230\u7a0b\u5e8f\u5d29\u6e83\u7684\u4fe1\u606f\u3002\u4ece\u7ec8\u7aef\u63a7\u5236\u53f0\u6253\u5370\u7684\u4fe1\u606f\u6765\u6e90 debugCallback \uff0c\u544a\u8bc9\u4e86\u6211\u4eec\u5177\u4f53\u7684\u539f\u56e0: \u9700\u8981\u4e86\u89e3\u7684\u662f drawFrame \u51fd\u6570\u4e2d\u6240\u6709\u7684\u64cd\u4f5c\u90fd\u662f\u5f02\u6b65\u7684\u3002\u610f\u5473\u7740\u5f53\u7a0b\u5e8f\u9000\u51fa mainLoop \uff0c\u7ed8\u5236\u548c\u5448\u73b0\u64cd\u4f5c\u53ef\u80fd\u4ecd\u7136\u5728\u6267\u884c\u3002\u6240\u4ee5\u6e05\u7406\u8be5\u90e8\u5206\u7684\u8d44\u6e90\u662f\u4e0d\u53cb\u597d\u7684\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u5e94\u8be5\u5728\u9000\u51fa mainLoop \u9500\u6bc1\u7a97\u4f53\u524d\u7b49\u5f85\u903b\u8f91\u8bbe\u5907\u7684\u64cd\u4f5c\u5b8c\u6210: void mainLoop() { while (!glfwWindowShouldClose(window)) { glfwPollEvents(); drawFrame(); } vkDeviceWaitIdle(device); } C++ \u4e5f\u53ef\u4ee5\u4f7f\u7528 vkQueueWaitIdle \u7b49\u5f85\u7279\u5b9a\u547d\u4ee4\u961f\u5217\u4e2d\u7684\u64cd\u4f5c\u5b8c\u6210\u3002\u8fd9\u4e9b\u529f\u80fd\u53ef\u4ee5\u4f5c\u4e3a\u4e00\u4e2a\u975e\u5e38\u57fa\u672c\u7684\u65b9\u5f0f\u6765\u6267\u884c\u540c\u6b65\u3002\u8fd9\u4e2a\u65f6\u5019\u7a97\u4f53\u5173\u95ed\u540e\u8be5\u95ee\u9898\u4e0d\u4f1a\u51fa\u73b0\u3002","title":"\u5448\u73b0"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_54","text":"\u5982\u679c\u8fd0\u884c\u65f6\u542f\u7528\u4e86 validation layers \u5e76\u76d1\u89c6\u5e94\u7528\u7a0b\u5e8f\u7684\u5185\u5b58\u4f7f\u7528\u60c5\u51b5\uff0c\u4f60\u4f1a\u53d1\u73b0\u5b83\u5728\u6162\u6162\u589e\u52a0\u3002\u539f\u56e0\u662f validation layers \u7684\u5b9e\u73b0\u671f\u671b\u4e0e GPU \u540c\u6b65\u3002\u867d\u7136\u5728\u6280\u672f\u4e0a\u662f\u4e0d\u9700\u8981\u7684\uff0c\u4f46\u662f\u4e00\u65e6\u8fd9\u6837\u505a\uff0c\u6bcf\u4e00\u9488\u5e27\u4e0d\u4f1a\u51fa\u73b0\u660e\u663e\u7684\u6027\u80fd\u5f71\u54cd\u3002 \u6211\u4eec\u53ef\u4ee5\u5728\u5f00\u59cb\u7ed8\u5236\u4e0b\u4e00\u5e27\u4e4b\u524d\u660e\u786e\u7684\u7b49\u5f85 presentation \u5b8c\u6210: void drawFrame() { ... vkQueuePresentKHR(presentQueue, &presentInfo); vkQueueWaitIdle(presentQueue); } C++ \u5728\u5f88\u591a\u5e94\u7528\u7a0b\u5e8f\u7684\u7684\u72b6\u6001\u4e5f\u4f1a\u5728\u6bcf\u4e00\u5e27\u66f4\u65b0\u3002\u4e3a\u6b64\u66f4\u9ad8\u6548\u7684\u7ed8\u5236\u4e00\u9635\u7684\u65b9\u5f0f\u5982\u4e0b\uff1a void drawFrame() { updateAppState(); vkQueueWaitIdle(presentQueue); vkAcquireNextImageKHR(...) submitDrawCommands(); vkQueuePresentKHR(presentQueue, &presentInfo); } C++ \u8be5\u65b9\u6cd5\u5141\u8bb8\u6211\u4eec\u66f4\u65b0\u5e94\u7528\u7a0b\u5e8f\u7684\u72b6\u6001\uff0c\u6bd4\u5982\u8fd0\u884c\u6e38\u620f\u7684AI\u534f\u540c\u7a0b\u5e8f\uff0c\u800c\u524d\u4e00\u5e27\u88ab\u6e32\u67d3\u3002\u8fd9\u6837\uff0c\u59cb\u7ec8\u4fdd\u6301 CPU \u548c GPU \u5904\u4e8e\u5de5\u4f5c\u72b6\u6001\u3002","title":"\u5185\u5b58\u6cc4\u6f0f"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_55","text":"\u5927\u7ea6800\u884c\u4ee3\u7801\u4e4b\u540e\uff0c\u6211\u4eec\u7ec8\u4e8e\u770b\u5230\u4e86\u4e09\u89d2\u5f62\u7ed8\u5236\u5728\u5c4f\u5e55\u4e0a\uff01 Vulkan \u5f15\u5bfc\u7a0b\u5e8f\u9700\u8981\u5f88\u591a\u7684\u5de5\u4f5c\u8981\u53bb\u505a\uff0c\u4f46\u597d\u5904\u662f Vulkan \u901a\u8fc7\u8981\u6c42\u6bcf\u4e00\u4e2a\u660e\u786e\u7684\u5b9e\u73b0\uff0c\u5e26\u6765\u4e86\u4e86\u5de8\u5927\u7684\u63a7\u5236\u6743\u3002\u5efa\u8bae\u82b1\u8d39\u4e00\u4e9b\u65f6\u95f4\u91cd\u65b0\u8bfb\u4ee3\u7801\uff0c\u5e76\u5efa\u7acb\u4e00\u4e2a\u601d\u7ef4\u5bfc\u56fe\u6a21\u578b\uff0c\u76ee\u7684\u5728\u4e8e\u4e86\u89e3 Vulkan \u4e2d\u6bcf\u4e00\u4e2a\u5bf9\u8c61\uff0c\u4ee5\u53ca\u5b83\u4eec\u7684\u4e92\u76f8\u7684\u5173\u7cfb\u3002\u4e4b\u540e\u6211\u4eec\u5c06\u4f1a\u57fa\u4e8e\u8fd9\u4e2a\u57fa\u7840\u6784\u5efa\u6269\u5c55\u7a0b\u5e8f\u529f\u80fd\u3002 \u5728\u4e0b\u4e00\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u7ec6\u5316 Vulkan \u7a0b\u5e8f\u4e2d\u7684\u4e00\u4e9b\u7ec6\u8282\uff0c\u4f7f\u5176\u8868\u73b0\u66f4\u7a33\u5b9a\u3002","title":"\u7ed3\u8bba"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_14","text":"Vulkan \u91cd\u6784\u4ea4\u6362\u94fe \uff0c\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6210\u529f\u7684\u5728\u5c4f\u5e55\u4e0a\u7ed8\u5236\u51fa\u4e09\u89d2\u5f62\uff0c\u4f46\u662f\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5b83\u4f1a\u51fa\u73b0\u5f02\u5e38\u60c5\u51b5\u3002\u7a97\u4f53 surface \u4f1a\u53d1\u751f\u6539\u53d8\uff0c\u4f7f\u5f97\u4ea4\u6362\u94fe\u4e0d\u5728\u4e0e\u5176\u517c\u5bb9\u3002\u53ef\u80fd\u5bfc\u81f4\u8fd9\u79cd\u60c5\u51b5\u53d1\u751f\u7684\u539f\u56e0\u4e4b\u4e00\u662f\u7a97\u4f53\u7684\u5927\u5c0f\u53d8\u5316\u3002\u6211\u4eec\u5fc5\u987b\u5728\u8fd9\u4e2a\u65f6\u673a\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u3002 \u6587\u7ae0\u76ee\u5f55 1 \u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe 2 \u7a97\u53e3\u5927\u5c0f\u8c03\u6574 3 \u6b21\u4f18\u6216\u8fc7\u671f\u7684\u4ea4\u6362\u94fe","title":"Vulkan \u91cd\u6784\u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_56","text":"\u6dfb\u52a0\u65b0\u7684\u51fd\u6570 recreateSwapChain \u5e76\u8c03\u7528 createSwapChain \u53ca\u4f9d\u8d56\u4e8e\u4ea4\u6362\u94fe\u6216\u8005\u7a97\u4f53\u5927\u5c0f\u7684\u5bf9\u8c61\u76f8\u5173\u7684\u6240\u6709\u521b\u5efa\u51fd\u6570\u3002 void recreateSwapChain() { vkDeviceWaitIdle(device); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers(); } \u6211\u4eec\u9996\u5148\u8c03\u7528 vkDeviceIdle ,\u5c31\u50cf\u524d\u4e00\u4e2a\u7ae0\u8282\u63d0\u5230\u7684\uff0c\u6211\u4eec\u4e0d\u80fd\u89e6\u78b0\u6b63\u5728\u4f7f\u7528\u4e2d\u7684\u8d44\u6e90\u3002\u5f88\u660e\u663e\uff0c\u8981\u505a\u7684\u7b2c\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u672c\u8eab\u3002\u56fe\u50cf\u89c6\u56fe\u4e5f\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4eec\u76f4\u63a5\u5efa\u7acb\u5728\u4ea4\u6362\u94fe\u56fe\u50cf\u57fa\u7840\u4e0a\u3002\u6e32\u67d3\u901a\u9053\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4f9d\u8d56\u4ea4\u6362\u94fe\u56fe\u50cf\u7684\u683c\u5f0f\u3002\u5728\u7a97\u4f53\u8c03\u6574\u5927\u5c0f\u7684\u64cd\u4f5c\u671f\u95f4\uff0c\u4ea4\u6362\u94fe\u56fe\u50cf\u683c\u5f0f\u5f88\u5c11\u53d1\u751f\u53d8\u5316\uff0c\u4f46\u4ecd\u5e94\u8be5\u88ab\u5904\u7406\u3002\u5728\u521b\u5efa\u56fe\u5f62\u7ba1\u7ebf\u671f\u95f4\u6307\u5b9a Viewport \u548c scissor \u77e9\u5f62\u5927\u5c0f\uff0c\u6240\u4ee5\u7ba1\u7ebf\u9700\u8981\u91cd\u65b0\u6784\u5efa\u3002\u53ef\u4ee5\u4f7f\u7528\u52a8\u6001\u72b6\u6001\u6539\u53d8 viewports \u548c scissor rectangles \uff0c\u907f\u514d\u91cd\u65b0\u521b\u5efa\u3002\u6700\u540e\u5e27\u7f13\u51b2\u533a\u548c\u547d\u4ee4\u7f13\u51b2\u533a\u4e5f\u9700\u8981\u91cd\u65b0\u521b\u5efa\uff0c\u56e0\u4e3a\u5b83\u4eec\u4e5f\u4f9d\u8d56\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u3002 \u4e3a\u4e86\u786e\u4fdd\u91cd\u65b0\u521b\u5efa\u76f8\u5173\u7684\u5bf9\u8c61\u4e4b\u524d\uff0c\u8001\u7248\u672c\u7684\u5bf9\u8c61\u88ab\u7cfb\u7edf\u6b63\u786e\u56de\u6536\u6e05\u7406\uff0c\u6211\u4eec\u9700\u8981\u79fb\u52a8\u4e00\u4e9bcleanup\u4ee3\u7801\u5230\u4e0d\u540c\u7684\u51fd\u6570\u4e2d\uff0c\u8fd9\u6837\u53ef\u4ee5\u5728 recreateSwapChain \u51fd\u6570\u8c03\u7528\u3002\u8be5\u51fd\u6570\u5b9a\u4e49\u4e3a cleanupSwapChain : void cleanupSwapChain() { } void recreateSwapChain() { vkDeviceWaitIdle(device); cleanupSwapChain() createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers(); } \u6211\u4eec\u4ece cleanup \u4e2d\u5c06\u9700\u8981\u88ab\u91cd\u65b0\u521b\u5efa\u7684\u5bf9\u8c61\u6240\u5bf9\u5e94\u7684\u6e05\u7406\u4ee3\u7801\u79fb\u52a8\u5230 cleanupSwapChain \u4e2d: void cleanupSwapChain() { for (size_t i = 0; i < swapChainFramebuffers.size(); i++) { vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); } vkFreeCommandBuffers(device, commandPool, static_cast<uint32_t>(commandBuffers.size()), commandBuffers.data()); vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); for (size_t i = 0; i < swapChainImageViews.size(); i++) { vkDestroyImageView(device, swapChainImageViews[i], nullptr); } vkDestroySwapchainKHR(device, swapChain, nullptr); } void cleanup() { cleanupSwapChain(); vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); vkDestroyCommandPool(device, commandPool, nullptr); vkDestroyDevice(device, nullptr); DestroyDebugReportCallbackEXT(instance, callback, nullptr); vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate(); } \u6211\u4eec\u91cd\u5934\u521b\u5efa\u547d\u4ee4\u5bf9\u8c61\u6c60 command pool \uff0c\u4f46\u662f\u6bd4\u8f83\u6d6a\u8d39\u770b\u8d77\u6765\u3002\u76f8\u53cd\u7684\uff0c\u6211\u4eec\u9009\u62e9\u501f\u52a9 vkFreeCommandBuffers \u51fd\u6570\u6e05\u7406\u5df2\u7ecf\u5b58\u5728\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002\u8fd9\u79cd\u65b9\u5f0f\u53ef\u4ee5\u91cd\u7528\u5bf9\u8c61\u6c60\u4e2d\u5df2\u7ecf\u5206\u914d\u7684\u547d\u4ee4\u7f13\u51b2\u533a\u3002 \u4ee5\u4e0a\u90e8\u5206\u5c31\u662f\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u7684\u5de5\u4f5c\uff01\u7136\u800c\u8fd9\u6837\u505a\u7684\u7f3a\u70b9\u5c31\u662f\u5728\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u5b8c\u6bd5\u4e4b\u524d\uff0c\u4f1a\u9020\u6210\u6e32\u67d3\u505c\u6b62\u3002\u521b\u5efa\u65b0\u4ea4\u6362\u94fe\u7684\u540c\u65f6\u5141\u8bb8\u5728\u65e7\u7684\u4ea4\u6362\u94fe\u7684\u56fe\u50cf\u4e0a\u7ee7\u7eed\u7ed8\u5236\u547d\u4ee4\u3002\u9700\u8981\u5c06\u4e4b\u524d\u7684\u4ea4\u6362\u94fe\u4f20\u9012\u5230 VkSwapchainCreateInfoKHR \u7ed3\u6784\u4f53\u4e2d\u7684 oldSwapChain \u5b57\u6bb5\uff0c\u5e76\u5728\u4f7f\u7528\u4e4b\u540e\u7acb\u5373\u9500\u6bc1\u3002","title":"\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_57","text":"\u73b0\u5728\u6211\u4eec\u9700\u8981\u641e\u6e05\u695a\u54ea\u4e9b\u60c5\u51b5\u4e0b\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u662f\u5fc5\u8981\u7684\uff0c\u5e76\u8c03\u7528 recreateSwapChain \u51fd\u6570\u3002\u4e00\u4e2a\u901a\u5e38\u7684\u6761\u4ef6\u662f\u7a97\u4f53\u7684\u5927\u5c0f\u53d8\u5316\u3002\u8ba9\u6211\u4eec\u8c03\u6574\u7a97\u4f53\u7684\u5927\u5c0f\uff0c\u5e76\u89c2\u5bdf\u6355\u6349\u5230\u7684\u4e8b\u4ef6\u3002\u4fee\u6539 initWindow \u51fd\u6570\u4e0d\u518d\u5305\u542b GLFW_RESIZABLE \u884c\uff0c\u6216\u8005\u5c06\u5176\u53c2\u6570\u4ece GLFW_FALSE \u4fee\u6539\u4e3a GLFW_TRUE \u3002 void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr); glfwSetWindowUserPointer(window, this); glfwSetWindowSizeCallback(window, HelloTriangleApplication::onWindowResized); } ... static void onWindowResized(GLFWwindow* window, int width, int height) { if (width == 0 || height == 0) return; HelloTriangleApplication* app = reinterpret_cast<HelloTriangleApplication*>(glfwGetWindowUserPointer(window)); app->recreateSwapChain(); } C++ glfwSetWindowSizeCallback \u51fd\u6570\u4f1a\u5728\u7a97\u4f53\u53d1\u751f\u5927\u5c0f\u53d8\u5316\u7684\u65f6\u5019\u88ab\u4e8b\u4ef6\u56de\u8c03\u3002\u9057\u61be\u7684\u662f\uff0c\u5b83\u53ea\u80fd\u63a5\u53d7\u4e00\u4e2a\u6307\u9488\u4f5c\u4e3a\u53c2\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u76f4\u63a5\u4f7f\u7528\u6210\u5458\u51fd\u6570\u3002\u4f46\u5e78\u8fd0\u7684\u662f\uff0cGLFW\u5141\u8bb8\u6211\u4eec\u4f7f\u7528 glfwSetWindowUserPointer \u5c06\u4efb\u610f\u6307\u9488\u5b58\u50a8\u5728\u7a97\u4f53\u5bf9\u8c61\u4e2d\uff0c\u56e0\u6b64\u53ef\u4ee5\u6307\u5b9a\u9759\u6001\u7c7b\u6210\u5458\u8c03\u7528 glfwGetWindowUserPointer \u8fd4\u56de\u539f\u59cb\u7684\u5b9e\u4f8b\u5bf9\u8c61\u3002\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528 recreateSwapChain \uff0c\u8fd9\u79cd\u60c5\u51b5\u901a\u5e38\u53d1\u751f\u5728\uff0c\u7a97\u4f53\u6700\u5c0f\u5316\u5e76\u4e14\u5bfc\u81f4\u4ea4\u6362\u94fe\u521b\u5efa\u5931\u8d25\u65f6. chooseSwapExtent \u51fd\u6570\u5e94\u8be5\u589e\u52a0\u66f4\u65b0\u903b\u8f91\uff0c\u4f7f\u7528\u7a97\u4f53\u6700\u65b0\u7684 width \u548c height \u4ee3\u66ff\u6700\u521d\u7684 WIDTH \u548c HEIGHT : int width, height; glfwGetWindowSize(window, &width, &height); VkExtent2D actualExtent = {width, height}; C++","title":"\u7a97\u53e3\u5927\u5c0f\u8c03\u6574"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_58","text":"\u6709\u4e9b\u65f6\u5019 Vulkan \u53ef\u80fd\u544a\u8bc9\u6211\u4eec\u5f53\u524d\u7684\u4ea4\u6362\u94fe\u5728 presentation \u65f6\u4e0d\u518d\u517c\u5bb9\u3002 vkAcquireNextImageKHR \u548c vkQueuePresentKHR \u51fd\u6570\u53ef\u4ee5\u8fd4\u56de\u5177\u4f53\u7684\u503c\u660e\u786e\u3002 VK_ERROR_OUT_DATE_KHR : \u4ea4\u6362\u94fe\u4e0esurface\u4e0d\u518d\u517c\u5bb9\uff0c\u4e0d\u53ef\u8fdb\u884c\u6e32\u67d3 VK_SUBOPTIMAL_KHR : \u4ea4\u6362\u94fe\u4ecd\u7136\u53ef\u4ee5\u5411surface\u63d0\u4ea4\u56fe\u50cf\uff0c\u4f46\u662fsurface\u7684\u5c5e\u6027\u4e0d\u518d\u5339\u914d\u51c6\u786e\u3002\u6bd4\u5982\u5e73\u53f0\u53ef\u80fd\u91cd\u65b0\u8c03\u6574\u56fe\u50cf\u7684\u5c3a\u5bf8\u9002\u5e94\u7a97\u4f53\u5927\u5c0f\u3002 VkResult result = vkAcquireNextImageKHR(device, swapChain, std::numeric_limits<uint64_t>::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex); if (result == VK_ERROR_OUT_OF_DATE_KHR) { recreateSwapChain(); return; } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) { throw std::runtime_error(\"failed to acquire swap chain image!\"); } C++ \u5982\u679c\u4ea4\u6362\u94fe\u83b7\u53d6\u56fe\u50cf timeout \uff0c\u8868\u660e\u4e0d\u518d\u53ef\u7528\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u7acb\u5373\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\uff0c\u5e76\u5728\u4e0b\u4e00\u6b21 drawFrame \u8c03\u7528\u4e2d\u5c1d\u8bd5\u83b7\u53d6\u3002 \u4f60\u4e5f\u53ef\u4ee5\u9009\u62e9\u5728\u4ea4\u6362\u94fe\u4e0d\u662f\u6700\u4f73\u72b6\u6001\u7684\u65f6\u5019\uff0c\u9009\u62e9\u91cd\u65b0\u521b\u5efa\uff0c\u6bd4\u5982\u521a\u624d\u8bf4\u7684\u5927\u5c0f\u4e0d\u5339\u914d\u95ee\u9898\u3002\u5728\u8fd9\u91cc\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u83b7\u5f97\u4e86\u4e00\u4e2a\u56fe\u50cf\uff0c\u6240\u4ee5\u7ee7\u7eed\u8fdb\u884c\u3002 VK_SUCCESS \u548c VK_SUBOPTIMAL_KHR \u90fd\u88ab\u8ba4\u4e3a\u662f\u201c\u6210\u529f\u201d\u8fd4\u56de\u7801\u3002 result = vkQueuePresentKHR(presentQueue, &presentInfo); if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) { recreateSwapChain(); } else if (result != VK_SUCCESS) { throw std::runtime_error(\"failed to present swap chain image!\"); } vkQueueWaitIdle(presentQueue); vkQueuePresentKHR \u51fd\u6570\u8fd4\u56de\u540c\u6837\u7684\u503c\u3002\u5728\u6211\u4eec\u7684\u6848\u4f8b\u4e2d\u6211\u4eec\uff0c\u5982\u679c\u662f\u975e\u6700\u4f73\u72b6\u6001\uff0c\u4e5f\u9009\u62e9\u91cd\u65b0\u521b\u5efa\u4ea4\u6362\u94fe\u3002\u56e0\u4e3a\u6211\u4eec\u9700\u8981\u6700\u597d\u7684\u6548\u679c\u3002\u5c1d\u8bd5\u8c03\u6574\u7a97\u4f53\u7684\u5927\u5c0f\uff0c\u5e27\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u53d8\u5316\u4e0e\u7a97\u4f53\u5339\u914d\u3002 Congratulations \uff0c\u6211\u4eec\u5b8c\u7ed3\u4e86\u7b2c\u4e00\u4e2a\u8fd0\u884c\u6bd4\u8f83\u5b8c\u6574\u7684 Vulkan \u7a0b\u5e8f\uff0c\u5728\u4e0b\u9762\u7684\u7ae0\u8282\u4e2d\u6211\u4eec\u5c1d\u8bd5\u6446\u8131\u4e4b\u524d\u7684\u786c\u7f16\u7801\uff0c\u4f7f\u7528\u9876\u70b9\u7f13\u51b2\u533a\u4ee3\u66ff vertex shader \u4e2d\u5199\u6b7b\u9876\u70b9\u6570\u636e\u3002","title":"\u6b21\u4f18\u6216\u8fc7\u671f\u7684\u4ea4\u6362\u94fe"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#_59","text":"","title":"\u7b2c\u4e8c\u7ae0"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_15","text":"","title":"Vulkan \u9876\u70b9\u8f93\u5165"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_16","text":"","title":"Vulkan \u521b\u5efa\u9876\u70b9\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_17","text":"","title":"Vulkan \u4e34\u65f6\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_18","text":"","title":"Vulkan \u7d22\u5f15\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_19","text":"","title":"Vulkan \u63cf\u8ff0\u7b26\u5e03\u5c40\u548c\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_20","text":"","title":"Vulkan \u63cf\u8ff0\u7b26\u6c60\u548c\u96c6\u5408"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan-images","text":"","title":"Vulkan \u56fe\u50cf(Images)"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_21","text":"","title":"Vulkan \u56fe\u50cf\u89c6\u56fe\u548c\u91c7\u6837\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_22","text":"","title":"Vulkan \u7ec4\u5408\u56fe\u50cf\u53d6\u6837\u5668"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_23","text":"","title":"Vulkan \u6df1\u5ea6\u7f13\u51b2\u533a"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan_24","text":"","title":"Vulkan \u52a0\u8f7d\u6a21\u578b"},{"location":"Vulkan/Vulkan%E6%95%99%E7%A8%8B/#vulkan-mipmap","text":"","title":"Vulkan \u751f\u6210\u8d34\u56fe(mipmap)"}]}
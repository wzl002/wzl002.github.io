<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Pipeline - Wesley的轨迹</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Wesley的轨迹</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../../index.md" class="nav-link">首页</a>
                            </li>
                            <li class="navitem">
                                <a href="../../GLES/Framebuffer%20Object/" class="nav-link">OpenGL(ES)</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Vulkan <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../0.1.%20Vulkan%20%E6%89%A9%E5%B1%95/" class="dropdown-item">0.1. Vulkan 扩展</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#pipeline" class="nav-link">Pipeline</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="pipeline">Pipeline</h1>
<p>在 Vulkan 中, 渲染管线需要手动创建.  Vulkan中创建对象的过程大多都通过使用 VkXXXCreateInfo 结构体, 为结构体各属性赋值后调用 vk API创建.</p>
<p>对应Pipeline的创建结构体为 <code>VkGraphicsPipelineCreateInfo</code>,  其除了所有结构体的共有属性(sType, pNext)外, 还包括了 10个子结构体属性, 分别对应渲染管线的十个固定流程. 以及 3个对象: PipelineLayout, RenderPass, subpass</p>
<p>Pipeline Fixed Functions:</p>
<ol>
<li>VkPipeline   Shader               StageCreateInfo*       pStages;</li>
<li>VkPipeline   VertexInput       StateCreateInfo*       pVertexInputState;</li>
<li>VkPipeline   InputAssembly  StateCreateInfo*       pInputAssemblyState;</li>
<li>VkPipeline   Tessellation       StateCreateInfo*       pTessellationState;</li>
<li>VkPipeline   Viewport            StateCreateInfo*       pViewportState;</li>
<li>VkPipeline   Rasterization     StateCreateInfo*       pRasterizationState;</li>
<li>VkPipeline   Multisample      StateCreateInfo*       pMultisampleState;</li>
<li>VkPipeline   DepthStencil     StateCreateInfo*       pDepthStencilState;</li>
<li>VkPipeline   ColorBlend        StateCreateInfo*       pColorBlendState;</li>
<li>VkPipeline   Dynamic            StateCreateInfo*       pDynamicState;</li>
</ol>
<p>Objects:</p>
<ol>
<li>PipelineLayout   layout;</li>
<li>RenderPass        renderPass;</li>
<li>int                        subpass;<pre><code>// Shader Stages &lt;-- Shader Modules
VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
vertShaderStageInfo.module = vertShaderModule;
vertShaderStageInfo.pName = "main";

VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
fragShaderStageInfo.module = fragShaderModule;
fragShaderStageInfo.pName = "main";

VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

// Vertex Input State
VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
vertexInputInfo.vertexBindingDescriptionCount = 0;
vertexInputInfo.vertexAttributeDescriptionCount = 0;

// Input Assembly State
VkPipelineInputAssemblyStateCreateInfo inputAssembly{};
inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
inputAssembly.primitiveRestartEnable = VK_FALSE;

VkViewport viewport{};
viewport.x = 0.0f;
viewport.y = 0.0f;
viewport.width = (float)swapChainExtent.width;
viewport.height = (float)swapChainExtent.height;
viewport.minDepth = 0.0f;
viewport.maxDepth = 1.0f;

VkRect2D scissor{};
scissor.offset = { 0, 0 };
scissor.extent = VkExtent2D;

// Viewport State &lt;-- viewport extent, scissor extent
VkPipelineViewportStateCreateInfo viewportState{};
viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
viewportState.viewportCount = 1;
viewportState.pViewports = &amp;viewport;
viewportState.scissorCount = 1;
viewportState.pScissors = &amp;scissor;

// Rasterization State
VkPipelineRasterizationStateCreateInfo rasterizer{};
rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
rasterizer.depthClampEnable = VK_FALSE;
rasterizer.rasterizerDiscardEnable = VK_FALSE;
rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
rasterizer.lineWidth = 1.0f;
rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
rasterizer.depthBiasEnable = VK_FALSE;

// Multisample State 
VkPipelineMultisampleStateCreateInfo multisampling{};
multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
multisampling.sampleShadingEnable = VK_FALSE;
multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

// Color Blend Attachment State
VkPipelineColorBlendAttachmentState colorBlendAttachment{};
colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
colorBlendAttachment.blendEnable = VK_FALSE;

VkPipelineColorBlendStateCreateInfo colorBlending{};
colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
colorBlending.logicOpEnable = VK_FALSE;
colorBlending.logicOp = VK_LOGIC_OP_COPY;
colorBlending.attachmentCount = 1;
colorBlending.pAttachments = &amp;colorBlendAttachment;
colorBlending.blendConstants[0] = 0.0f;
colorBlending.blendConstants[1] = 0.0f;
colorBlending.blendConstants[2] = 0.0f;
colorBlending.blendConstants[3] = 0.0f;

// Pipeline Layout
VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
pipelineLayoutInfo.setLayoutCount = 0;
pipelineLayoutInfo.pushConstantRangeCount = 0;

if (vkCreatePipelineLayout(mDevice, &amp;pipelineLayoutInfo, nullptr, &amp;pipelineLayout) != VK_SUCCESS) {
    throw std::runtime_error("failed to create pipeline layout!");
}

//------ Pipeline Layout &amp; Render Pass are ready, setup finish
// ----- Create Graphics Pipeline ----------
VkGraphicsPipelineCreateInfo pipelineInfo{};
pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
pipelineInfo.stageCount = 2;
pipelineInfo.pStages = shaderStages; // shaders
pipelineInfo.pVertexInputState = &amp;vertexInputInfo; // vertex input
pipelineInfo.pInputAssemblyState = &amp;inputAssembly; // input assembly
pipelineInfo.pViewportState = &amp;viewportState; // viewport
pipelineInfo.pRasterizationState = &amp;rasterizer; // rasterizer
pipelineInfo.pMultisampleState = &amp;multisampling; // multisampling
pipelineInfo.pColorBlendState = &amp;colorBlending; // colorBlending
pipelineInfo.layout = pipelineLayout;
pipelineInfo.renderPass = renderPass; // render pass
pipelineInfo.subpass = 0;
pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;
</code></pre>
</li>
</ol>
<p>Pipeline  Fixed Function Properties: </p>
<pre><code class="language-json">// 省略了所有 CreateInfo 的 sType, pNext, 和 xxxxflags

Graphics_Pipeline {
    stageCount = 2;

    // create infos
    pStages = [ // shader modules
        vertShaderStageInfo = {         
            stage = VK_SHADER_STAGE_VERTEX_BIT;
            module = vertShaderModule; // VkShaderModule
            pName = &quot;main&quot;;
            // const VkSpecializationInfo*         pSpecializationInfo;
        }
        fragShaderStageInfo = {
            stage = VK_SHADER_STAGE_FRAGMENT_BIT;
            module = fragShaderModule; // VkShaderModule
            pName = &quot;main&quot;;
            // const VkSpecializationInfo*         pSpecializationInfo;
        }
    ], 

    pVertexInputState = Vertex_Input_State { // vertex input
        vertexBindingDescriptionCount = 0;
        pVertexBindingDescriptions = null;
        vertexAttributeDescriptionCount = 0;
        pVertexAttributeDescriptions = null;
    }; 

    pInputAssemblyState = {  // input assembly
        topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
        primitiveRestartEnable = VK_FALSE;
    };

    pTessellationState = null; // Tessellation

    pViewportState = {  // Viewport
        viewportCount = 1;
        pViewports = {
            x = 0.0f;
            y = 0.0f;
            width = (float)swapChainExtent.width; // VkExtent2D
            height = (float)swapChainExtent.height;
            minDepth = 0.0f;
            maxDepth = 1.0f;
        };
        scissorCount = 1;
        pScissors = {
            offset: { 0, 0 };
            extent = swapChainExtent; // VkExtent2D
        }; 
    };

    pRasterizationState = { // Rasterizer
            depthClampEnable = VK_FALSE;
            rasterizerDiscardEnable = VK_FALSE;
            polygonMode = VK_POLYGON_MODE_FILL;
            lineWidth = 1.0f;
            cullMode = VK_CULL_MODE_BACK_BIT;
            frontFace = VK_FRONT_FACE_CLOCKWISE;
            depthBiasEnable = VK_FALSE;
            //float                                      depthBiasConstantFactor;
            //float                                      depthBiasClamp;
            //float                                      depthBiasSlopeFactor;
    }; 

    pMultisampleState = { // multisampling
        sampleShadingEnable = VK_FALSE;
        rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
        // float                                    minSampleShading;
        // const VkSampleMask*                      pSampleMask;
        // VkBool32                                 alphaToCoverageEnable;
        // VkBool32                                 alphaToOneEnable;
    };

    pDepthStencilState : null,

    pColorBlendState = { // colorBlending
        logicOpEnable = VK_FALSE;
        logicOp = VK_LOGIC_OP_COPY;
        attachmentCount = 1;
        pAttachments = &amp;colorBlendAttachment;
        blendConstants[0] = 0.0f;
        blendConstants[1] = 0.0f;
        blendConstants[2] = 0.0f;
        blendConstants[3] = 0.0f;
    }; 

    pDynamicState : null,

    // vars
    layout = {
        setLayoutCount = 0;
        // const VkDescriptorSetLayout*    pSetLayouts;
        pushConstantRangeCount = 0;
        //const VkPushConstantRange*      pPushConstantRanges;
    };

    renderPass = renderPass; // render pass
    subpass = 0;
    basePipelineHandle = VK_NULL_HANDLE;
    basePipelineIndex = 0,
}
</code></pre>
<p>Render Pass</p>
<pre><code class="language-c++">VkAttachmentDescription colorAttachment{};
colorAttachment.format = swapChainImageFormat;
colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

VkAttachmentReference colorAttachmentRef{};
colorAttachmentRef.attachment = 0;
colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

VkSubpassDescription subpass{};
subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
subpass.colorAttachmentCount = 1;
subpass.pColorAttachments = &amp;colorAttachmentRef;

// 后加的??
VkSubpassDependency dependency{};
dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
dependency.dstSubpass = 0;
dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
dependency.srcAccessMask = 0;
dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

VkRenderPassCreateInfo renderPassInfo{};
renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
renderPassInfo.attachmentCount = 1;
renderPassInfo.pAttachments = &amp;colorAttachment;
renderPassInfo.subpassCount = 1;
renderPassInfo.pSubpasses = &amp;subpass;
renderPassInfo.dependencyCount = 1;
renderPassInfo.pDependencies = &amp;dependency;

if (vkCreateRenderPass(mDevice, &amp;renderPassInfo, nullptr, &amp;renderPass) != VK_SUCCESS) {
throw std::runtime_error(&quot;failed to create render pass!&quot;);
}
</code></pre>
<p>Json</p>
<pre><code class="language-json">RenderPass {
    attachmentCount = 1;
    pAttachments = {  // VkAttachmentDescription
        colorAttachment.format = swapChainImageFormat;
        colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
        colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
        colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
        colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
        colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
        colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
    };
    subpassCount = 1;
    pSubpasses = {  // VkSubpassDescription
        pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
        colorAttachmentCount = 1;
        pColorAttachments = { // VkAttachmentReference
            colorAttachmentRef.attachment = 0;
            colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
        };
        // uint32_t                        inputAttachmentCount;
        // const VkAttachmentReference*    pInputAttachments;
        // const VkAttachmentReference*    pResolveAttachments;
        // const VkAttachmentReference*    pDepthStencilAttachment;
        // uint32_t                        preserveAttachmentCount;
        // const uint32_t*                 pPreserveAttachments;
    };
    dependencyCount = 1;
    pDependencies = {
        srcSubpass = VK_SUBPASS_EXTERNAL;
        dstSubpass = 0;
        srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        srcAccessMask = 0;
        dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
    }; // VkSubpassDependency
}

</code></pre>
<p>&nbsp;</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
